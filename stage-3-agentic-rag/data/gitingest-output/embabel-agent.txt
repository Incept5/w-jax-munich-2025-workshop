Directory structure:
└── embabel-embabel-agent/
    ├── README.md
    ├── CLAUDE.md
    ├── CODE_OF_CONDUCT.md
    ├── flake.lock
    ├── flake.nix
    ├── LICENSE
    ├── pom.xml
    ├── README-appendix.md
    ├── .sonarcloud.properties
    ├── embabel-agent-a2a/
    │   ├── pom.xml
    │   └── src/
    │       ├── main/
    │       │   ├── kotlin/
    │       │   │   └── com/
    │       │   │       └── embabel/
    │       │   │           └── agent/
    │       │   │               └── a2a/
    │       │   │                   └── server/
    │       │   │                       ├── A2ARequestHandler.kt
    │       │   │                       ├── AgentCardHandler.kt
    │       │   │                       ├── AgentSkillFactory.kt
    │       │   │                       ├── events.kt
    │       │   │                       ├── config/
    │       │   │                       │   └── A2AConfiguration.kt
    │       │   │                       └── support/
    │       │   │                           ├── A2AEndpointRegistrar.kt
    │       │   │                           ├── A2AStreamingHandler.kt
    │       │   │                           ├── AutonomyA2ARequestHandler.kt
    │       │   │                           ├── EmbabelServerGoalsAgentCardHandler.kt
    │       │   │                           └── FromGoalsAgentSkillFactory.kt
    │       │   └── resources/
    │       │       └── .gitkeep
    │       └── test/
    │           ├── kotlin/
    │           │   └── com/
    │           │       └── embabel/
    │           │           └── agent/
    │           │               └── a2a/
    │           │                   ├── .gitkeep
    │           │                   ├── example/
    │           │                   │   └── simple/
    │           │                   │       └── horoscope/
    │           │                   │           ├── TestHoroscopeService.kt
    │           │                   │           └── kotlin/
    │           │                   │               └── TestStarNewsFinder.kt
    │           │                   └── server/
    │           │                       ├── A2AWebIntegrationTest.kt
    │           │                       └── config/
    │           │                           ├── FakeAiConfiguration.kt
    │           │                           └── FakeRankerConfiguration.kt
    │           └── resources/
    │               ├── application-test.properties
    │               └── .gitkeep
    ├── embabel-agent-api/
    │   ├── README.md
    │   ├── docker-compose.yml
    │   ├── Dockerfile.a2a
    │   ├── embabel_planning_system.dot
    │   ├── mvnw
    │   ├── mvnw.cmd
    │   ├── pom.xml
    │   ├── src/
    │   │   ├── main/
    │   │   │   ├── java/
    │   │   │   │   └── com/
    │   │   │   │       └── embabel/
    │   │   │   │           └── agent/
    │   │   │   │               └── api/
    │   │   │   │                   └── annotation/
    │   │   │   │                       ├── README.md
    │   │   │   │                       ├── AchievesGoal.java
    │   │   │   │                       ├── Export.java
    │   │   │   │                       └── WaitFor.java
    │   │   │   ├── kotlin/
    │   │   │   │   └── com/
    │   │   │   │       └── embabel/
    │   │   │   │           ├── agent/
    │   │   │   │           │   ├── README.md
    │   │   │   │           │   ├── api/
    │   │   │   │           │   │   ├── README.md
    │   │   │   │           │   │   ├── annotation/
    │   │   │   │           │   │   │   ├── README.md
    │   │   │   │           │   │   │   ├── annotations.kt
    │   │   │   │           │   │   │   ├── wait.kt
    │   │   │   │           │   │   │   └── support/
    │   │   │   │           │   │   │       ├── ActionMethodArgumentResolver.kt
    │   │   │   │           │   │   │       ├── ActionMethodManager.kt
    │   │   │   │           │   │   │       ├── AgentMetadataReader.kt
    │   │   │   │           │   │   │       ├── DefaultActionMethodManager.kt
    │   │   │   │           │   │   │       ├── DuplicateParameterType.kt
    │   │   │   │           │   │   │       ├── DuplicateParameterTypeException.kt
    │   │   │   │           │   │   │       ├── MethodDefinedOperationNameGenerator.kt
    │   │   │   │           │   │   │       ├── MultiTransformationAction.kt
    │   │   │   │           │   │   │       └── utils.kt
    │   │   │   │           │   │   ├── common/
    │   │   │   │           │   │   │   ├── README.md
    │   │   │   │           │   │   │   ├── ActionContext.kt
    │   │   │   │           │   │   │   ├── AgentPlatformTypedOps.kt
    │   │   │   │           │   │   │   ├── Ai.kt
    │   │   │   │           │   │   │   ├── Asyncer.kt
    │   │   │   │           │   │   │   ├── composites.kt
    │   │   │   │           │   │   │   ├── InteractionId.kt
    │   │   │   │           │   │   │   ├── LlmReference.kt
    │   │   │   │           │   │   │   ├── ObjectCreator.kt
    │   │   │   │           │   │   │   ├── OperationContext.kt
    │   │   │   │           │   │   │   ├── PlannerType.kt
    │   │   │   │           │   │   │   ├── PlatformServices.kt
    │   │   │   │           │   │   │   ├── PromptRunner.kt
    │   │   │   │           │   │   │   ├── PromptRunnerOperations.kt
    │   │   │   │           │   │   │   ├── StuckHandler.kt
    │   │   │   │           │   │   │   ├── TemplateOperations.kt
    │   │   │   │           │   │   │   ├── ToolObject.kt
    │   │   │   │           │   │   │   ├── ToolsStats.kt
    │   │   │   │           │   │   │   ├── Transformation.kt
    │   │   │   │           │   │   │   ├── TypedOps.kt
    │   │   │   │           │   │   │   ├── autonomy/
    │   │   │   │           │   │   │   │   ├── AgentInvocation.kt
    │   │   │   │           │   │   │   │   ├── AgentProcessExecution.kt
    │   │   │   │           │   │   │   │   ├── Autonomy.kt
    │   │   │   │           │   │   │   │   ├── DefaultPlanLister.kt
    │   │   │   │           │   │   │   │   ├── GoalChoiceApprover.kt
    │   │   │   │           │   │   │   │   └── PlanLister.kt
    │   │   │   │           │   │   │   ├── support/
    │   │   │   │           │   │   │   │   ├── bindFieldsToBlackboard.kt
    │   │   │   │           │   │   │   │   ├── BranchingAction.kt
    │   │   │   │           │   │   │   │   ├── ConsumerAction.kt
    │   │   │   │           │   │   │   │   ├── MultiTransformationAction.kt
    │   │   │   │           │   │   │   │   ├── OperationContextPromptRunner.kt
    │   │   │   │           │   │   │   │   ├── SelfToolCallbackPublisher.kt
    │   │   │   │           │   │   │   │   ├── SupplierAction.kt
    │   │   │   │           │   │   │   │   └── TransformationAction.kt
    │   │   │   │           │   │   │   └── workflow/
    │   │   │   │           │   │   │       ├── WorkflowBuilder.kt
    │   │   │   │           │   │   │       ├── control/
    │   │   │   │           │   │   │       │   ├── ScatterGather.kt
    │   │   │   │           │   │   │       │   ├── ScatterGatherBuilder.kt
    │   │   │   │           │   │   │       │   └── SimpleAgentBuilder.kt
    │   │   │   │           │   │   │       ├── loop/
    │   │   │   │           │   │   │       │   ├── Feedback.kt
    │   │   │   │           │   │   │       │   ├── RepeatUntil.kt
    │   │   │   │           │   │   │       │   ├── RepeatUntilAcceptable.kt
    │   │   │   │           │   │   │       │   ├── RepeatUntilAcceptableBuilder.kt
    │   │   │   │           │   │   │       │   └── RepeatUntilBuilder.kt
    │   │   │   │           │   │   │       └── multimodel/
    │   │   │   │           │   │   │           └── ConsensusBuilder.kt
    │   │   │   │           │   │   ├── dsl/
    │   │   │   │           │   │   │   ├── README.md
    │   │   │   │           │   │   │   ├── agent.kt
    │   │   │   │           │   │   │   ├── AgentBuilder.kt
    │   │   │   │           │   │   │   ├── AgentScopeBuilder.kt
    │   │   │   │           │   │   │   ├── mapper.kt
    │   │   │   │           │   │   │   └── support/
    │   │   │   │           │   │   │       └── promptTransformer.kt
    │   │   │   │           │   │   └── models/
    │   │   │   │           │   │       ├── AnthropicModels.kt
    │   │   │   │           │   │       ├── DeepSeekModels.kt
    │   │   │   │           │   │       ├── DockerLocalModels.kt
    │   │   │   │           │   │       ├── FallbackChatModel.kt
    │   │   │   │           │   │       ├── OllamaModels.kt
    │   │   │   │           │   │       ├── OpenAiCompatibleModelFactory.kt
    │   │   │   │           │   │       └── OpenAiModels.kt
    │   │   │   │           │   ├── channel/
    │   │   │   │           │   │   └── OutputChannel.kt
    │   │   │   │           │   ├── common/
    │   │   │   │           │   │   ├── Constants.kt
    │   │   │   │           │   │   └── RetryProperties.kt
    │   │   │   │           │   ├── core/
    │   │   │   │           │   │   ├── README.md
    │   │   │   │           │   │   ├── Action.kt
    │   │   │   │           │   │   ├── ActionQos.kt
    │   │   │   │           │   │   ├── ActionRunner.kt
    │   │   │   │           │   │   ├── Agent.kt
    │   │   │   │           │   │   ├── AgentPlatform.kt
    │   │   │   │           │   │   ├── AgentProcess.kt
    │   │   │   │           │   │   ├── AgentProcessCallback.kt
    │   │   │   │           │   │   ├── AgentScope.kt
    │   │   │   │           │   │   ├── Blackboard.kt
    │   │   │   │           │   │   ├── Condition.kt
    │   │   │   │           │   │   ├── Context.kt
    │   │   │   │           │   │   ├── ContextId.kt
    │   │   │   │           │   │   ├── CoreToolGroups.kt
    │   │   │   │           │   │   ├── CreationPermitted.kt
    │   │   │   │           │   │   ├── DataDictionary.kt
    │   │   │   │           │   │   ├── DomainType.kt
    │   │   │   │           │   │   ├── DynamicType.kt
    │   │   │   │           │   │   ├── EarlyTerminationPolicy.kt
    │   │   │   │           │   │   ├── Goal.kt
    │   │   │   │           │   │   ├── InProcess.kt
    │   │   │   │           │   │   ├── IoBinding.kt
    │   │   │   │           │   │   ├── JvmType.kt
    │   │   │   │           │   │   ├── LlmInvocation.kt
    │   │   │   │           │   │   ├── Operation.kt
    │   │   │   │           │   │   ├── OperationStatus.kt
    │   │   │   │           │   │   ├── ProcessContext.kt
    │   │   │   │           │   │   ├── ProcessOptions.kt
    │   │   │   │           │   │   ├── ToolConsumer.kt
    │   │   │   │           │   │   ├── deployment/
    │   │   │   │           │   │   │   ├── AgentPublisher.kt
    │   │   │   │           │   │   │   └── AgentScanningProperties.kt
    │   │   │   │           │   │   ├── hitl/
    │   │   │   │           │   │   │   ├── README.md
    │   │   │   │           │   │   │   ├── Awaitable.kt
    │   │   │   │           │   │   │   ├── ConfirmationRequest.kt
    │   │   │   │           │   │   │   └── FormBindingRequest.kt
    │   │   │   │           │   │   └── support/
    │   │   │   │           │   │       ├── AbstractAction.kt
    │   │   │   │           │   │       ├── AbstractAgentProcess.kt
    │   │   │   │           │   │       ├── AbstractLlmOperations.kt
    │   │   │   │           │   │       ├── BlackboardWorldStateDeterminer.kt
    │   │   │   │           │   │       ├── ConcurrentAgentProcess.kt
    │   │   │   │           │   │       ├── DefaultAgentPlatform.kt
    │   │   │   │           │   │       ├── InMemoryBlackboard.kt
    │   │   │   │           │   │       ├── SimpleAgentProcess.kt
    │   │   │   │           │   │       └── springAiUtils.kt
    │   │   │   │           │   ├── domain/
    │   │   │   │           │   │   ├── README.md
    │   │   │   │           │   │   ├── InMemoryCrudRepository.kt
    │   │   │   │           │   │   ├── io/
    │   │   │   │           │   │   │   ├── SystemOutput.kt
    │   │   │   │           │   │   │   └── UserInput.kt
    │   │   │   │           │   │   └── library/
    │   │   │   │           │   │       ├── Content.kt
    │   │   │   │           │   │       ├── InternetResources.kt
    │   │   │   │           │   │       ├── NewsStory.kt
    │   │   │   │           │   │       ├── Person.kt
    │   │   │   │           │   │       ├── Research.kt
    │   │   │   │           │   │       └── Summary.kt
    │   │   │   │           │   ├── event/
    │   │   │   │           │   │   ├── AgenticEvent.kt
    │   │   │   │           │   │   ├── AgenticEventListener.kt
    │   │   │   │           │   │   ├── AgentPlatformEvent.kt
    │   │   │   │           │   │   ├── AgentProcessEvent.kt
    │   │   │   │           │   │   ├── RagEvent.kt
    │   │   │   │           │   │   ├── logging/
    │   │   │   │           │   │   │   ├── README.md
    │   │   │   │           │   │   │   ├── LoggingAgenticEventListener.kt
    │   │   │   │           │   │   │   └── personality/
    │   │   │   │           │   │   │       ├── ColorPalette.kt
    │   │   │   │           │   │   │       ├── formatUtils.kt
    │   │   │   │           │   │   │       ├── colossus/
    │   │   │   │           │   │   │       │   ├── ColossusColorPalette.kt
    │   │   │   │           │   │   │       │   └── ColossusLoggingAgenticEventListener.kt
    │   │   │   │           │   │   │       ├── hitchhiker/
    │   │   │   │           │   │   │       │   ├── HitchhikerColorPalette.kt
    │   │   │   │           │   │   │       │   ├── HitchhikerLoggingAgenticEventListener.kt
    │   │   │   │           │   │   │       │   └── HitchhikerUtils.kt
    │   │   │   │           │   │   │       ├── montypython/
    │   │   │   │           │   │   │       │   ├── MontyPythonColorPalette.kt
    │   │   │   │           │   │   │       │   └── MontyPythonLoggingAgenticEventListener.kt
    │   │   │   │           │   │   │       ├── severance/
    │   │   │   │           │   │   │       │   ├── LumonColorPalette.kt
    │   │   │   │           │   │   │       │   ├── SeveranceLoggingAgenticEventListener.kt
    │   │   │   │           │   │   │       │   └── SeveranceUtils.kt
    │   │   │   │           │   │   │       └── starwars/
    │   │   │   │           │   │   │           ├── StarWarsColorPalette.kt
    │   │   │   │           │   │   │           └── StarWarsLoggingAgenticEventListener.kt
    │   │   │   │           │   │   └── progress/
    │   │   │   │           │   │       └── OutputChannelHighlightingEventListener.kt
    │   │   │   │           │   ├── experimental/
    │   │   │   │           │   │   ├── README.md
    │   │   │   │           │   │   ├── primitive/
    │   │   │   │           │   │   │   └── PromptCondition.kt
    │   │   │   │           │   │   └── util/
    │   │   │   │           │   │       ├── InjectionUtils.kt
    │   │   │   │           │   │       └── Injector.kt
    │   │   │   │           │   ├── identity/
    │   │   │   │           │   │   ├── User.kt
    │   │   │   │           │   │   └── UserService.kt
    │   │   │   │           │   ├── prompt/
    │   │   │   │           │   │   ├── README.md
    │   │   │   │           │   │   ├── PromptUtils.kt
    │   │   │   │           │   │   ├── ResponseFormat.kt
    │   │   │   │           │   │   ├── element/
    │   │   │   │           │   │   │   ├── DynamicPromptContributor.kt
    │   │   │   │           │   │   │   └── ToolCallControl.kt
    │   │   │   │           │   │   └── persona/
    │   │   │   │           │   │       ├── Actor.kt
    │   │   │   │           │   │       ├── CoStar.kt
    │   │   │   │           │   │       ├── Instruction.kt
    │   │   │   │           │   │       ├── Persona.kt
    │   │   │   │           │   │       └── RoleGoalBackstory.kt
    │   │   │   │           │   ├── rag/
    │   │   │   │           │   │   ├── README.md
    │   │   │   │           │   │   ├── AbstractWritableContentElementRepository.kt
    │   │   │   │           │   │   ├── Cluster.kt
    │   │   │   │           │   │   ├── ContextualTool.kt
    │   │   │   │           │   │   ├── EntityData.kt
    │   │   │   │           │   │   ├── HierarchicalContentElement.kt
    │   │   │   │           │   │   ├── NamedEntityData.kt
    │   │   │   │           │   │   ├── NavigableRagService.kt
    │   │   │   │           │   │   ├── RagRequest.kt
    │   │   │   │           │   │   ├── RagResponse.kt
    │   │   │   │           │   │   ├── RagResponseEnhancer.kt
    │   │   │   │           │   │   ├── RagResponseFormatter.kt
    │   │   │   │           │   │   ├── RagResponseSummarizer.kt
    │   │   │   │           │   │   ├── RagService.kt
    │   │   │   │           │   │   ├── RagServiceEnhancer.kt
    │   │   │   │           │   │   ├── RagServiceEnhancerProperties.kt
    │   │   │   │           │   │   ├── Retrievable.kt
    │   │   │   │           │   │   ├── Source.kt
    │   │   │   │           │   │   ├── WritableContentElementRepository.kt
    │   │   │   │           │   │   ├── WritableStore.kt
    │   │   │   │           │   │   ├── ingestion/
    │   │   │   │           │   │   │   ├── ContentChunker.kt
    │   │   │   │           │   │   │   ├── ContentElementRepository.kt
    │   │   │   │           │   │   │   ├── Ingester.kt
    │   │   │   │           │   │   │   ├── MaterializedDocument.kt
    │   │   │   │           │   │   │   └── MultiIngester.kt
    │   │   │   │           │   │   ├── support/
    │   │   │   │           │   │   │   ├── FacetedRagService.kt
    │   │   │   │           │   │   │   ├── RagFacet.kt
    │   │   │   │           │   │   │   └── SpringVectorStoreRagService.kt
    │   │   │   │           │   │   └── tools/
    │   │   │   │           │   │       ├── DualShotRagServiceSearchTools.kt
    │   │   │   │           │   │       ├── RagOptions.kt
    │   │   │   │           │   │       ├── RagReference.kt
    │   │   │   │           │   │       └── SingleShotRagServiceSearchTools.kt
    │   │   │   │           │   ├── spi/
    │   │   │   │           │   │   ├── README.md
    │   │   │   │           │   │   ├── AgentProcessIdGenerator.kt
    │   │   │   │           │   │   ├── AgentProcessRepository.kt
    │   │   │   │           │   │   ├── AutoLlmSelectionCriteriaResolver.kt
    │   │   │   │           │   │   ├── ContextRepository.kt
    │   │   │   │           │   │   ├── LlmOperations.kt
    │   │   │   │           │   │   ├── OperationScheduler.kt
    │   │   │   │           │   │   ├── PlannerFactory.kt
    │   │   │   │           │   │   ├── Ranker.kt
    │   │   │   │           │   │   ├── ToolDecorator.kt
    │   │   │   │           │   │   ├── ToolGroupResolver.kt
    │   │   │   │           │   │   ├── config/
    │   │   │   │           │   │   │   └── spring/
    │   │   │   │           │   │   │       ├── AgentPlatformConfiguration.kt
    │   │   │   │           │   │   │       ├── AgentPlatformProperties.kt
    │   │   │   │           │   │   │       ├── AgentPlatformPropertiesLoader.kt
    │   │   │   │           │   │   │       ├── AsyncConfiguration.kt
    │   │   │   │           │   │   │       ├── ContextRepositoryProperties.kt
    │   │   │   │           │   │   │       ├── InfrastructureInjectionConfiguration.kt
    │   │   │   │           │   │   │       ├── ProcessRepositoryProperties.kt
    │   │   │   │           │   │   │       ├── ToolGroupsConfiguration.kt
    │   │   │   │           │   │   │       ├── ValidationConfiguration.kt
    │   │   │   │           │   │   │       └── migration/
    │   │   │   │           │   │   │           ├── DeprecatedPropertyScanner.kt
    │   │   │   │           │   │   │           ├── DeprecatedPropertyScanningConfig.kt
    │   │   │   │           │   │   │           ├── DeprecatedPropertyWarningConfig.kt
    │   │   │   │           │   │   │           └── SimpleDeprecatedConfigWarner.kt
    │   │   │   │           │   │   ├── support/
    │   │   │   │           │   │   │   ├── AgenticEventListenerToolsStats.kt
    │   │   │   │           │   │   │   ├── AutoRegistration.kt
    │   │   │   │           │   │   │   ├── DefaultAgentProcessIdGenerator.kt
    │   │   │   │           │   │   │   ├── ExecutorAsyncer.kt
    │   │   │   │           │   │   │   ├── GoapPlannerFactory.kt
    │   │   │   │           │   │   │   ├── InMemoryAgentProcessRepository.kt
    │   │   │   │           │   │   │   ├── InMemoryContextRepository.kt
    │   │   │   │           │   │   │   ├── LlmDataBindingProperties.kt
    │   │   │   │           │   │   │   ├── LlmOperationsPromptsProperties.kt
    │   │   │   │           │   │   │   ├── LlmRanker.kt
    │   │   │   │           │   │   │   ├── ObservabilityToolCallback.kt
    │   │   │   │           │   │   │   ├── OutputTransformingToolCallback.kt
    │   │   │   │           │   │   │   ├── ProcessOptionsOperationScheduler.kt
    │   │   │   │           │   │   │   ├── RegistryToolGroupResolver.kt
    │   │   │   │           │   │   │   ├── SimpleContext.kt
    │   │   │   │           │   │   │   ├── SpringContextPlatformServices.kt
    │   │   │   │           │   │   │   └── springai/
    │   │   │   │           │   │   │       ├── AgentProcessBindingToolCallback.kt
    │   │   │   │           │   │   │       ├── ChatClientLlmOperations.kt
    │   │   │   │           │   │   │       ├── ChatModelCallEvent.kt
    │   │   │   │           │   │   │       ├── converter.kt
    │   │   │   │           │   │   │       ├── DefaultToolDecorator.kt
    │   │   │   │           │   │   │       ├── EventPublishingToolCallback.kt
    │   │   │   │           │   │   │       ├── ExceptionWrappingConverter.kt
    │   │   │   │           │   │   │       ├── FilteringJacksonOutputConverter.kt
    │   │   │   │           │   │   │       ├── JacksonOutputConverter.kt
    │   │   │   │           │   │   │       ├── MetadataEnrichedToolCallback.kt
    │   │   │   │           │   │   │       ├── SuppressThinkingConverter.kt
    │   │   │   │           │   │   │       └── WithExampleConverter.kt
    │   │   │   │           │   │   └── validation/
    │   │   │   │           │   │       ├── DefaultValidationPromptGenerator.kt
    │   │   │   │           │   │       └── ValidationPromptGenerator.kt
    │   │   │   │           │   ├── testing/
    │   │   │   │           │   │   ├── README.md
    │   │   │   │           │   │   ├── common/
    │   │   │   │           │   │   │   └── EventSavingAgenticEventListener.kt
    │   │   │   │           │   │   ├── integration/
    │   │   │   │           │   │   │   ├── AgentPlatformTestExtensions.kt
    │   │   │   │           │   │   │   ├── DummyObjectCreatingLlmOperations.kt
    │   │   │   │           │   │   │   ├── IntegrationTestUtils.kt
    │   │   │   │           │   │   │   └── RandomRanker.kt
    │   │   │   │           │   │   └── unit/
    │   │   │   │           │   │       ├── FakeAction.kt
    │   │   │   │           │   │       ├── FakeOperationContext.kt
    │   │   │   │           │   │       ├── FakePromptRunner.kt
    │   │   │   │           │   │       └── UnitTestUtils.kt
    │   │   │   │           │   ├── tools/
    │   │   │   │           │   │   ├── DirectoryBased.kt
    │   │   │   │           │   │   ├── agent/
    │   │   │   │           │   │   │   ├── README.md
    │   │   │   │           │   │   │   ├── AchievableGoalsToolGroupFactory.kt
    │   │   │   │           │   │   │   ├── AgentToolCallback.kt
    │   │   │   │           │   │   │   ├── DefaultProcessCallbackTools.kt
    │   │   │   │           │   │   │   ├── GoalToolCallback.kt
    │   │   │   │           │   │   │   ├── GoalToolNamingStrategy.kt
    │   │   │   │           │   │   │   ├── Handoffs.kt
    │   │   │   │           │   │   │   ├── PerGoalToolCallbackFactory.kt
    │   │   │   │           │   │   │   ├── PromptedTextCommunicator.kt
    │   │   │   │           │   │   │   └── TypeWrappingToolDefinition.kt
    │   │   │   │           │   │   ├── file/
    │   │   │   │           │   │   │   ├── FileChangeLog.kt
    │   │   │   │           │   │   │   ├── FileReadLog.kt
    │   │   │   │           │   │   │   ├── FileTools.kt
    │   │   │   │           │   │   │   ├── LocalDirectory.kt
    │   │   │   │           │   │   │   ├── PatternSearch.kt
    │   │   │   │           │   │   │   └── WellKnownFileContentTransformers.kt
    │   │   │   │           │   │   ├── math/
    │   │   │   │           │   │   │   └── MathTools.kt
    │   │   │   │           │   │   ├── mcp/
    │   │   │   │           │   │   │   └── McpToolGroup.kt
    │   │   │   │           │   │   └── osx/
    │   │   │   │           │   │       └── AppleScriptTools.kt
    │   │   │   │           │   ├── validation/
    │   │   │   │           │   │   ├── AgentStructureValidator.kt
    │   │   │   │           │   │   ├── AgentValidationManager.kt
    │   │   │   │           │   │   ├── AgentValidator.kt
    │   │   │   │           │   │   ├── DefaultAgentValidationManager.kt
    │   │   │   │           │   │   ├── DetailedValidationResult.kt
    │   │   │   │           │   │   └── GoapPathToCompletionValidator.kt
    │   │   │   │           │   └── web/
    │   │   │   │           │       ├── rest/
    │   │   │   │           │       │   ├── README.md
    │   │   │   │           │       │   ├── AgentProcessController.kt
    │   │   │   │           │       │   ├── CustomErrorController.kt
    │   │   │   │           │       │   └── PlatformInfoController.kt
    │   │   │   │           │       └── sse/
    │   │   │   │           │           └── SseController.kt
    │   │   │   │           ├── chat/
    │   │   │   │           │   ├── Chatbot.kt
    │   │   │   │           │   ├── ChatSession.kt
    │   │   │   │           │   ├── Conversation.kt
    │   │   │   │           │   ├── ConversationFormatter.kt
    │   │   │   │           │   ├── agent/
    │   │   │   │           │   │   ├── AgentProcessChatbot.kt
    │   │   │   │           │   │   ├── BlackboardFormatter.kt
    │   │   │   │           │   │   ├── ConversationStatus.kt
    │   │   │   │           │   │   ├── DefaultChatAgentBuilder.kt
    │   │   │   │           │   │   └── Personas.kt
    │   │   │   │           │   └── support/
    │   │   │   │           │       ├── InMemoryConversation.kt
    │   │   │   │           │       └── console/
    │   │   │   │           │           ├── ChatConsole.kt
    │   │   │   │           │           └── ConsoleOutputChannel.kt
    │   │   │   │           ├── common/
    │   │   │   │           │   └── util/
    │   │   │   │           │       └── StringTransformer.kt
    │   │   │   │           ├── plan/
    │   │   │   │           │   ├── README.md
    │   │   │   │           │   ├── Plan.kt
    │   │   │   │           │   ├── Planner.kt
    │   │   │   │           │   └── goap/
    │   │   │   │           │       ├── AStarGoapPlanner.kt
    │   │   │   │           │       ├── Goap.kt
    │   │   │   │           │       ├── GoapWorldState.kt
    │   │   │   │           │       └── OptimizingGoapPlanner.kt
    │   │   │   │           └── ux/
    │   │   │   │               └── form/
    │   │   │   │                   ├── README.md
    │   │   │   │                   ├── DefaultFormProcessor.kt
    │   │   │   │                   ├── Form.kt
    │   │   │   │                   ├── FormBinder.kt
    │   │   │   │                   ├── FormGenerator.kt
    │   │   │   │                   ├── FormSubmissionResult.kt
    │   │   │   │                   └── SimpleFormGenerator.kt
    │   │   │   └── resources/
    │   │   │       ├── agent-application.properties
    │   │   │       ├── agent-platform.properties
    │   │   │       ├── application-docker-ce.yml
    │   │   │       ├── application-docker-desktop.yml
    │   │   │       ├── application-neo.yml.unused
    │   │   │       ├── application-test.yml
    │   │   │       ├── application.yml.unused
    │   │   │       ├── banner.txt
    │   │   │       ├── logback-spring.xml
    │   │   │       ├── logging/
    │   │   │       │   ├── colossus.txt
    │   │   │       │   ├── hitchhiker.txt
    │   │   │       │   ├── montypython.txt
    │   │   │       │   ├── severance.txt
    │   │   │       │   └── starwars.txt
    │   │   │       └── prompts/
    │   │   │           ├── maybe_prompt_contribution.jinja
    │   │   │           └── chat/
    │   │   │               └── default_chat.jinja
    │   │   └── test/
    │   │       ├── java/
    │   │       │   └── com/
    │   │       │       └── embabel/
    │   │       │           ├── agent/
    │   │       │           │   ├── api/
    │   │       │           │   │   ├── annotation/
    │   │       │           │   │   │   └── support/
    │   │       │           │   │   │       ├── AgentMetadataReaderNullableParameterJavaTest.java
    │   │       │           │   │   │       ├── OneTransformerActionWithNullableParameterJavaSpring.java
    │   │       │           │   │   │       └── PackageVisibleTests.java
    │   │       │           │   │   └── common/
    │   │       │           │   │       ├── JavaAsyncerTest.java
    │   │       │           │   │       ├── autonomy/
    │   │       │           │   │       │   ├── AgentInvocationJavaTest.java
    │   │       │           │   │       │   └── MultiGoal.java
    │   │       │           │   │       └── workflow/
    │   │       │           │   │           ├── RepeatUntilAcceptableBuilderTest.java
    │   │       │           │   │           ├── RepeatUntilBuilderTest.java
    │   │       │           │   │           ├── control/
    │   │       │           │   │           │   ├── ScatterGatherBuilderTest.java
    │   │       │           │   │           │   └── SimpleAgentBuilderTest.java
    │   │       │           │   │           └── multimodel/
    │   │       │           │   │               └── ConsensusBuilderTest.java
    │   │       │           │   ├── core/
    │   │       │           │   │   ├── BudgetBuilderTest.java
    │   │       │           │   │   ├── ProcessOptionsBuilderTest.java
    │   │       │           │   │   ├── ToolGroupDescriptionFromJavaTest.java
    │   │       │           │   │   └── VerbosityBuilderTest.java
    │   │       │           │   └── rag/
    │   │       │           │       └── SimpleRagRagResponseFormatterTest.kt
    │   │       │           ├── example/
    │   │       │           │   └── simple/
    │   │       │           │       └── horoscope/
    │   │       │           │           └── java/
    │   │       │           │               ├── Horoscope.java
    │   │       │           │               ├── StarPerson.java
    │   │       │           │               ├── Starry.java
    │   │       │           │               ├── TestStarNewsFinder.java
    │   │       │           │               └── Writeup.java
    │   │       │           └── ux/
    │   │       │               └── form/
    │   │       │                   ├── JavaPersonImmutable.java
    │   │       │                   ├── JavaPersonRecord.java
    │   │       │                   └── JavaPersonRecordWithControlId.java
    │   │       ├── kotlin/
    │   │       │   └── com/
    │   │       │       └── embabel/
    │   │       │           ├── agent/
    │   │       │           │   ├── AgentApiTestApplication.kt
    │   │       │           │   ├── api/
    │   │       │           │   │   ├── annotation/
    │   │       │           │   │   │   └── support/
    │   │       │           │   │   │       ├── ActionMethodArgumentResolverTest.kt
    │   │       │           │   │   │       ├── AgentMetadataReaderActionTest.kt
    │   │       │           │   │   │       ├── AgentMetadataReaderConditionsTest.kt
    │   │       │           │   │   │       ├── AgentMetadataReaderImportTest.kt
    │   │       │           │   │   │       ├── AgentMetadataReaderMetadataTest.kt
    │   │       │           │   │   │       ├── FromClassAndMethodMethodDefinedOperationNameGeneratorTest.kt
    │   │       │           │   │   │       ├── IntentReceptionAgent.kt
    │   │       │           │   │   │       ├── RequireNonAmbiguousParametersTest.kt
    │   │       │           │   │   │       ├── RoutingViaSubclassTest.kt
    │   │       │           │   │   │       ├── testTypes.kt
    │   │       │           │   │   │       └── typesWithInheritance.kt
    │   │       │           │   │   ├── common/
    │   │       │           │   │   │   ├── MulticastStuckHandlerTest.kt
    │   │       │           │   │   │   ├── OperationContextAiTest.kt
    │   │       │           │   │   │   ├── OperationContextPromptRunnerTest.kt
    │   │       │           │   │   │   ├── SubagentTest.kt
    │   │       │           │   │   │   ├── ToolGroupExposerKtTest.kt
    │   │       │           │   │   │   ├── autonomy/
    │   │       │           │   │   │   │   ├── AgentDeployerTest.kt
    │   │       │           │   │   │   │   ├── AgentInvocationKotlinTest.kt
    │   │       │           │   │   │   │   ├── AutonomyActionLeakageTest.kt
    │   │       │           │   │   │   │   ├── AutonomyAgentSelectionTest.kt
    │   │       │           │   │   │   │   ├── AutonomyGoalSelectionTest.kt
    │   │       │           │   │   │   │   └── PlanListerTest.kt
    │   │       │           │   │   │   └── support/
    │   │       │           │   │   │       ├── BindFieldsToBlackboardTest.kt
    │   │       │           │   │   │       └── MultiTransformationActionTest.kt
    │   │       │           │   │   └── dsl/
    │   │       │           │   │       ├── AgentBuilderTest.kt
    │   │       │           │   │       ├── AgentScopeBuilderTest.kt
    │   │       │           │   │       ├── dslAgents.kt
    │   │       │           │   │       ├── MapperParallelTest.kt
    │   │       │           │   │       ├── MapperTest.kt
    │   │       │           │   │       ├── ParallelizationTest.kt
    │   │       │           │   │       └── support/
    │   │       │           │   │           └── PromptTransformerKtTest.kt
    │   │       │           │   ├── channel/
    │   │       │           │   │   └── OutputChannelTest.kt
    │   │       │           │   ├── config/
    │   │       │           │   │   ├── AgentPlatformPropertiesIntegrationTest.kt
    │   │       │           │   │   ├── migration/
    │   │       │           │   │   │   ├── DeprecatedPropertyScannerTest.kt
    │   │       │           │   │   │   ├── DeprecatedPropertyScanningConfigIntegrationTest.kt
    │   │       │           │   │   │   ├── PlatformPropertiesMigrationIntegrationTest.kt
    │   │       │           │   │   │   └── SimpleDeprecatedConfigWarnerTest.kt
    │   │       │           │   │   └── models/
    │   │       │           │   │       ├── FallbackChatModelTest.kt
    │   │       │           │   │       └── OpenAiCompatibleModelFactoryTest.kt
    │   │       │           │   ├── core/
    │   │       │           │   │   ├── ConditionTest.kt
    │   │       │           │   │   ├── DataDictionaryTest.kt
    │   │       │           │   │   ├── DomainTypeAssignabilityTest.kt
    │   │       │           │   │   ├── DomainTypeSerializationTest.kt
    │   │       │           │   │   ├── EarlyTerminationPolicyTest.kt
    │   │       │           │   │   ├── ExtendedConditionTest.kt
    │   │       │           │   │   ├── IoBindingTest.kt
    │   │       │           │   │   ├── JvmTypeTest.kt
    │   │       │           │   │   ├── ProcessContextTest.kt
    │   │       │           │   │   ├── hitl/
    │   │       │           │   │   │   └── FormBindingRequestTest.kt
    │   │       │           │   │   └── support/
    │   │       │           │   │       ├── ConcurrentAgentProcessTest.kt
    │   │       │           │   │       ├── DefaultAgentPlatformTest.kt
    │   │       │           │   │       ├── SimpleAgentProcessTest.kt
    │   │       │           │   │       └── SpringAiUtilsKtTest.kt
    │   │       │           │   ├── domain/
    │   │       │           │   │   ├── InMemoryCrudRepositoryTest.kt
    │   │       │           │   │   └── io/
    │   │       │           │   │       └── UserInputSerializationTest.kt
    │   │       │           │   ├── e2e/
    │   │       │           │   │   ├── AgentPlatformIntegrationTest.kt
    │   │       │           │   │   ├── AiInjectionIntegrationTest.kt
    │   │       │           │   │   └── OperationContextInjectionIntegrationTest.kt
    │   │       │           │   ├── event/
    │   │       │           │   │   ├── AgenticEventListenerTest.kt
    │   │       │           │   │   └── AgenticEventSerializationTest.kt
    │   │       │           │   ├── experimental/
    │   │       │           │   │   └── InjectionUtilsTest.kt
    │   │       │           │   ├── model/
    │   │       │           │   │   └── TestModels.kt
    │   │       │           │   ├── prompt/
    │   │       │           │   │   └── persona/
    │   │       │           │   │       ├── CoStarTest.kt
    │   │       │           │   │       ├── PersonaTest.kt
    │   │       │           │   │       └── RoleGoalBackstoryTest.kt
    │   │       │           │   ├── rag/
    │   │       │           │   │   ├── ContentElementPropertiesToPersistTest.kt
    │   │       │           │   │   ├── FakeRagService.kt
    │   │       │           │   │   ├── ingestion/
    │   │       │           │   │   │   ├── ContentChunkerTest.kt
    │   │       │           │   │   │   └── MultiIngesterTest.kt
    │   │       │           │   │   └── tools/
    │   │       │           │   │       └── RagServiceSearchToolsTest.kt
    │   │       │           │   ├── spi/
    │   │       │           │   │   ├── support/
    │   │       │           │   │   │   ├── AgenticEventListenerToolsStatsTest.kt
    │   │       │           │   │   │   ├── ChatClientLlmOperationsTest.kt
    │   │       │           │   │   │   ├── ChatClientLlmTransformerTest.kt
    │   │       │           │   │   │   ├── CustomValidationAnnotationTest.kt
    │   │       │           │   │   │   ├── DefaultToolDecoratorTest.kt
    │   │       │           │   │   │   ├── InMemoryAgentProcessRepositoryTest.kt
    │   │       │           │   │   │   ├── InMemoryContextRepositoryTest.kt
    │   │       │           │   │   │   ├── LlmRankerTest.kt
    │   │       │           │   │   │   ├── ObservabilityToolCallbackTest.kt
    │   │       │           │   │   │   ├── ToolDecoratorsKtTest.kt
    │   │       │           │   │   │   ├── WithExampleConverterTest.kt
    │   │       │           │   │   │   └── springai/
    │   │       │           │   │   │       ├── ChatClientLlmOperationsIT.kt
    │   │       │           │   │   │       ├── FilteringJacksonOutputConverterTest.kt
    │   │       │           │   │   │       └── SuppressThinkingConverterTest.kt
    │   │       │           │   │   └── validation/
    │   │       │           │   │       └── DefaultValidationPromptGeneratorTest.kt
    │   │       │           │   ├── support/
    │   │       │           │   │   ├── AbstractBlackboardTest.kt
    │   │       │           │   │   ├── BlackboardTest.kt
    │   │       │           │   │   ├── BlackboardWorldStateDeterminerTest.kt
    │   │       │           │   │   ├── DefaultProcessIdGeneratorTest.kt
    │   │       │           │   │   └── LlmInvocationHistoryTest.kt
    │   │       │           │   ├── testing/
    │   │       │           │   │   └── unit/
    │   │       │           │   │       └── OperationContextTest.kt
    │   │       │           │   ├── tools/
    │   │       │           │   │   ├── agent/
    │   │       │           │   │   │   └── PerGoalToolFactoryTest.kt
    │   │       │           │   │   ├── file/
    │   │       │           │   │   │   ├── FileReadToolsTest.kt
    │   │       │           │   │   │   ├── FileWriteToolsTest.kt
    │   │       │           │   │   │   ├── PatternSearchTest.kt
    │   │       │           │   │   │   └── WellKnownFileContentTransformersTest.kt
    │   │       │           │   │   ├── math/
    │   │       │           │   │   │   └── MathToolsTest.kt
    │   │       │           │   │   └── osx/
    │   │       │           │   │       └── AppleScriptToolsTest.kt
    │   │       │           │   ├── validation/
    │   │       │           │   │   ├── AgentStructureValidatorTest.kt
    │   │       │           │   │   └── DefaultAgentValidationManagerTest.kt
    │   │       │           │   └── web/
    │   │       │           │       ├── rest/
    │   │       │           │       │   ├── AgentProcessControllerIntegrationTest.kt
    │   │       │           │       │   └── PlatformInfoControllerIntegrationTest.kt
    │   │       │           │       └── sse/
    │   │       │           │           └── SseControllerTest.kt
    │   │       │           ├── chat/
    │   │       │           │   ├── WindowingConversationFormatterTest.kt
    │   │       │           │   └── agent/
    │   │       │           │       └── DefaultChatAgentBuilderTest.kt
    │   │       │           ├── example/
    │   │       │           │   ├── README.md
    │   │       │           │   ├── common/
    │   │       │           │   │   ├── README.md
    │   │       │           │   │   └── InMemoryCrudRepository.kt
    │   │       │           │   ├── dogfood/
    │   │       │           │   │   └── factchecker/
    │   │       │           │   │       └── factChecker.kt
    │   │       │           │   └── simple/
    │   │       │           │       ├── horoscope/
    │   │       │           │       │   ├── TestHoroscopeService.kt
    │   │       │           │       │   └── kotlin/
    │   │       │           │       │       └── TestStarNewsFinder.kt
    │   │       │           │       └── movie/
    │   │       │           │           └── InMemoryCrudRepository.kt
    │   │       │           ├── plan/
    │   │       │           │   ├── PlanTest.kt
    │   │       │           │   └── goap/
    │   │       │           │       ├── AStarGoapPlannerTest.kt
    │   │       │           │       ├── GoapPlannerTest.kt
    │   │       │           │       ├── GoapPlanningSystemTest.kt
    │   │       │           │       ├── IrrelevantActionsTest.kt
    │   │       │           │       ├── OptimizingGoapPlannerTest.kt
    │   │       │           │       └── WorldStateTest.kt
    │   │       │           └── ux/
    │   │       │               └── form/
    │   │       │                   ├── DefaultFormProcessorTest.kt
    │   │       │                   ├── FormBinderTest.kt
    │   │       │                   └── SimpleFormGeneratorTest.kt
    │   │       └── resources/
    │   │           ├── application-shell.yml
    │   │           ├── application-test.properties
    │   │           ├── application.properties
    │   │           └── examples/
    │   │               └── movie/
    │   │                   └── rod_ratings.tsv
    │   ├── .embabel/
    │   │   └── coding-style.md
    │   ├── .github/
    │   │   └── workflows/
    │   │       └── maven.yml
    │   └── .mvn/
    │       └── wrapper/
    │           └── maven-wrapper.properties
    ├── embabel-agent-autoconfigure/
    │   ├── README.md
    │   ├── pom.xml
    │   ├── embabel-agent-platform-autoconfigure/
    │   │   ├── README.md
    │   │   ├── pom.xml
    │   │   └── src/
    │   │       ├── main/
    │   │       │   ├── java/
    │   │       │   │   └── com/
    │   │       │   │       └── embabel/
    │   │       │   │           └── agent/
    │   │       │   │               ├── autoconfigure/
    │   │       │   │               │   └── platform/
    │   │       │   │               │       ├── AgentPlatformAutoConfiguration.java
    │   │       │   │               │       └── ScanConfiguration.java
    │   │       │   │               └── config/
    │   │       │   │                   └── annotation/
    │   │       │   │                       ├── AgentPlatform.java
    │   │       │   │                       ├── EnableAgentMcpServer.java
    │   │       │   │                       ├── EnableAgents.java
    │   │       │   │                       ├── EnableAgentShell.java
    │   │       │   │                       ├── LocalModels.java
    │   │       │   │                       ├── LoggingThemes.java
    │   │       │   │                       ├── McpServers.java
    │   │       │   │                       ├── StartupMode.java
    │   │       │   │                       └── spi/
    │   │       │   │                           └── EnvironmentPostProcessor.java
    │   │       │   └── resources/
    │   │       │       └── META-INF/
    │   │       │           ├── spring.factories
    │   │       │           └── spring/
    │   │       │               └── org.springframework.boot.autoconfigure.AutoConfiguration.imports
    │   │       └── test/
    │   │           └── java/
    │   │               └── com/
    │   │                   └── embabel/
    │   │                       └── agent/
    │   │                           ├── autoconfigure/
    │   │                           │   └── platform/
    │   │                           │       └── AgentPlatformAutoConfigurationIT.java
    │   │                           └── config/
    │   │                               └── annotation/
    │   │                                   ├── EnableAgentsAnnotationIT.java
    │   │                                   └── spi/
    │   │                                       └── EnvironmentPostProcessorTest.java
    │   └── models/
    │       ├── embabel-agent-anthropic-autoconfigure/
    │       │   ├── pom.xml
    │       │   └── src/
    │       │       ├── main/
    │       │       │   ├── java/
    │       │       │   │   └── com/
    │       │       │   │       └── embabel/
    │       │       │   │           └── agent/
    │       │       │   │               └── autoconfigure/
    │       │       │   │                   └── models/
    │       │       │   │                       └── anthropic/
    │       │       │   │                           └── AgentAnthropicAutoConfiguration.java
    │       │       │   ├── kotlin/
    │       │       │   │   └── com/
    │       │       │   │       └── embabel/
    │       │       │   │           └── agent/
    │       │       │   │               └── config/
    │       │       │   │                   └── models/
    │       │       │   │                       └── anthropic/
    │       │       │   │                           ├── AnthropicModelLoader.kt
    │       │       │   │                           └── AnthropicModelsConfig.kt
    │       │       │   └── resources/
    │       │       │       └── models/
    │       │       │           └── anthropic-models.yml
    │       │       └── test/
    │       │           └── kotlin/
    │       │               └── com/
    │       │                   └── embabel/
    │       │                       └── agent/
    │       │                           └── config/
    │       │                               └── models/
    │       │                                   └── anthropic/
    │       │                                       ├── AnthropicModelLoaderTest.kt
    │       │                                       └── AnthropicOptionsConverterTest.kt
    │       ├── embabel-agent-bedrock-autoconfigure/
    │       │   ├── pom.xml
    │       │   └── src/
    │       │       ├── main/
    │       │       │   ├── java/
    │       │       │   │   └── com/
    │       │       │   │       └── embabel/
    │       │       │   │           └── agent/
    │       │       │   │               ├── autoconfigure/
    │       │       │   │               │   └── models/
    │       │       │   │               │       └── bedrock/
    │       │       │   │               │           └── AgentBedrockAutoConfiguration.java
    │       │       │   │               └── config/
    │       │       │   │                   └── annotation/
    │       │       │   │                       └── bedrock/
    │       │       │   │                           └── EnableAgentBedrock.java
    │       │       │   ├── kotlin/
    │       │       │   │   └── com/
    │       │       │   │       └── embabel/
    │       │       │   │           └── agent/
    │       │       │   │               └── config/
    │       │       │   │                   └── models/
    │       │       │   │                       └── bedrock/
    │       │       │   │                           └── BedrockModels.kt
    │       │       │   └── resources/
    │       │       │       ├── application-bedrock.yml
    │       │       │       └── META-INF/
    │       │       │           ├── spring.factories
    │       │       │           └── spring/
    │       │       │               └── org.springframework.boot.autoconfigure.AutoConfiguration.imports
    │       │       └── test/
    │       │           ├── java/
    │       │           │   └── com/
    │       │           │       └── embabel/
    │       │           │           └── agent/
    │       │           │               └── autoconfigure/
    │       │           │                   └── models/
    │       │           │                       └── bedrock/
    │       │           │                           └── AgentBedrockAutoConfigurationIT.java
    │       │           └── kotlin/
    │       │               └── com/
    │       │                   └── embabel/
    │       │                       └── agent/
    │       │                           └── config/
    │       │                               └── models/
    │       │                                   └── bedrock/
    │       │                                       ├── BedrockModelsIntegrationTest.kt
    │       │                                       ├── BedrockOptionsConverterTest.kt
    │       │                                       └── EmbabelBedrockProxyChatModelBuilderTest.kt
    │       ├── embabel-agent-deepseek-autoconfigure/
    │       │   ├── pom.xml
    │       │   └── src/
    │       │       ├── main/
    │       │       │   ├── java/
    │       │       │   │   └── com/
    │       │       │   │       └── embabel/
    │       │       │   │           └── agent/
    │       │       │   │               └── autoconfigure/
    │       │       │   │                   └── models/
    │       │       │   │                       └── deepseek/
    │       │       │   │                           └── AgentDeepSeekAutoConfiguration.java
    │       │       │   └── kotlin/
    │       │       │       └── com/
    │       │       │           └── embabel/
    │       │       │               └── agent/
    │       │       │                   └── config/
    │       │       │                       └── models/
    │       │       │                           └── deepseek/
    │       │       │                               └── DeepSeekModelsConfig.kt
    │       │       └── test/
    │       │           └── kotlin/
    │       │               └── com/
    │       │                   └── embabel/
    │       │                       └── agent/
    │       │                           └── config/
    │       │                               └── models/
    │       │                                   └── deepseek/
    │       │                                       └── DeepSeekOptionsConverterTest.kt
    │       ├── embabel-agent-dockermodels-autoconfigure/
    │       │   ├── pom.xml
    │       │   └── src/
    │       │       └── main/
    │       │           ├── java/
    │       │           │   └── com/
    │       │           │       └── embabel/
    │       │           │           └── agent/
    │       │           │               └── autoconfigure/
    │       │           │                   └── models/
    │       │           │                       └── docker/
    │       │           │                           └── AgentDockerModelsAutoConfiguration.java
    │       │           ├── kotlin/
    │       │           │   └── com/
    │       │           │       └── embabel/
    │       │           │           └── agent/
    │       │           │               └── config/
    │       │           │                   └── models/
    │       │           │                       └── docker/
    │       │           │                           └── DockerLocalModelsConfig.kt
    │       │           └── resources/
    │       │               └── META-INF/
    │       │                   ├── spring.factories
    │       │                   └── spring/
    │       │                       └── org.springframework.boot.autoconfigure.AutoConfiguration.imports
    │       ├── embabel-agent-ollama-autoconfigure/
    │       │   ├── pom.xml
    │       │   └── src/
    │       │       ├── main/
    │       │       │   ├── java/
    │       │       │   │   └── com/
    │       │       │   │       └── embabel/
    │       │       │   │           └── agent/
    │       │       │   │               └── autoconfigure/
    │       │       │   │                   └── models/
    │       │       │   │                       └── ollama/
    │       │       │   │                           └── AgentOllamaAutoConfiguration.java
    │       │       │   ├── kotlin/
    │       │       │   │   └── com/
    │       │       │   │       └── embabel/
    │       │       │   │           └── agent/
    │       │       │   │               └── config/
    │       │       │   │                   └── models/
    │       │       │   │                       └── ollama/
    │       │       │   │                           └── OllamaModelsConfig.kt
    │       │       │   └── resources/
    │       │       │       └── META-INF/
    │       │       │           ├── spring.factories
    │       │       │           └── spring/
    │       │       │               └── org.springframework.boot.autoconfigure.AutoConfiguration.imports
    │       │       └── test/
    │       │           └── kotlin/
    │       │               └── com/
    │       │                   └── embabel/
    │       │                       └── agent/
    │       │                           └── config/
    │       │                               └── models/
    │       │                                   └── ollama/
    │       │                                       └── OllamaOptionsConverterTest.kt
    │       └── embabel-agent-openai-autoconfigure/
    │           ├── pom.xml
    │           └── src/
    │               ├── main/
    │               │   ├── java/
    │               │   │   └── com/
    │               │   │       └── embabel/
    │               │   │           └── agent/
    │               │   │               └── autoconfigure/
    │               │   │                   └── models/
    │               │   │                       └── openai/
    │               │   │                           └── AgentOpenAiAutoConfiguration.java
    │               │   └── kotlin/
    │               │       └── com/
    │               │           └── embabel/
    │               │               └── agent/
    │               │                   └── config/
    │               │                       └── models/
    │               │                           └── openai/
    │               │                               └── OpenAiModelsConfig.kt
    │               └── test/
    │                   └── kotlin/
    │                       └── com/
    │                           └── embabel/
    │                               └── agent/
    │                                   └── config/
    │                                       └── models/
    │                                           └── openai/
    │                                               ├── Gpt5ChatOptionsConverterTest.kt
    │                                               └── OpenAiOptionsConverterTest.kt
    ├── embabel-agent-code/
    │   ├── pom.xml
    │   └── src/
    │       ├── main/
    │       │   ├── kotlin/
    │       │   │   └── com/
    │       │   │       └── embabel/
    │       │   │           ├── agent/
    │       │   │           │   └── domain/
    │       │   │           │       └── library/
    │       │   │           │           └── code/
    │       │   │           │               ├── SoftwareProject.kt
    │       │   │           │               └── SymbolSearch.kt
    │       │   │           └── coding/
    │       │   │               └── tools/
    │       │   │                   ├── api/
    │       │   │                   │   ├── Api.kt
    │       │   │                   │   ├── ApiExtractor.kt
    │       │   │                   │   └── ApiReference.kt
    │       │   │                   ├── bash/
    │       │   │                   │   └── BashTools.kt
    │       │   │                   ├── ci/
    │       │   │                   │   ├── Ci.kt
    │       │   │                   │   └── CiTools.kt
    │       │   │                   ├── git/
    │       │   │                   │   ├── ClonedRepositoryReference.kt
    │       │   │                   │   ├── GitOperations.kt
    │       │   │                   │   └── RepositoryReferenceProvider.kt
    │       │   │                   └── jvm/
    │       │   │                       ├── ClassGraphApiReferenceExtractor.kt
    │       │   │                       ├── JavaParserApiExtractor.kt
    │       │   │                       └── MavenBuildSystemIntegration.kt
    │       │   └── resources/
    │       │       └── .gitkeep
    │       └── test/
    │           ├── kotlin/
    │           │   └── com/
    │           │       └── embabel/
    │           │           ├── agent/
    │           │           │   └── discord/
    │           │           │       └── .gitkeep
    │           │           └── coding/
    │           │               └── tools/
    │           │                   ├── GitReferenceTest.kt
    │           │                   ├── api/
    │           │                   │   ├── ApiExtractorTest.kt
    │           │                   │   └── ApiReferenceTest.kt
    │           │                   └── jvm/
    │           │                       ├── ClassGraphApiReferenceExtractorTest.kt
    │           │                       └── JavaParserApiExtractorTest.kt
    │           └── resources/
    │               └── .gitkeep
    ├── embabel-agent-dependencies/
    │   └── pom.xml
    ├── embabel-agent-discord/
    │   ├── pom.xml
    │   └── src/
    │       ├── main/
    │       │   ├── kotlin/
    │       │   │   └── com/
    │       │   │       └── embabel/
    │       │   │           └── agent/
    │       │   │               └── discord/
    │       │   │                   ├── ChannelRespondingOutputChannel.kt
    │       │   │                   ├── ChatbotSessionEventListener.kt
    │       │   │                   ├── DiscordConfiguration.kt
    │       │   │                   ├── DiscordMessageUtils.kt
    │       │   │                   ├── DiscordSessionService.kt
    │       │   │                   ├── DiscordUser.kt
    │       │   │                   └── .gitkeep
    │       │   └── resources/
    │       │       └── .gitkeep
    │       └── test/
    │           ├── kotlin/
    │           │   └── com/
    │           │       └── embabel/
    │           │           └── agent/
    │           │               └── discord/
    │           │                   ├── DiscordMessageUtilsTest.kt
    │           │                   └── .gitkeep
    │           └── resources/
    │               └── .gitkeep
    ├── embabel-agent-docs/
    │   ├── README.md
    │   ├── pom.xml
    │   ├── dot/
    │   │   └── process.dot
    │   ├── src/
    │   │   └── main/
    │   │       ├── asciidoc/
    │   │       │   ├── authors.adoc
    │   │       │   ├── docinfo-footer.html
    │   │       │   ├── docinfo-header.html
    │   │       │   ├── docinfo.html
    │   │       │   ├── index.adoc
    │   │       │   ├── tabs.js
    │   │       │   ├── user-guide.adoc
    │   │       │   ├── agent-design/
    │   │       │   │   └── page.adoc
    │   │       │   ├── appendix/
    │   │       │   │   └── page.adoc
    │   │       │   ├── contributing/
    │   │       │   │   └── page.adoc
    │   │       │   ├── eval/
    │   │       │   │   └── eval-guide.adoc
    │   │       │   ├── getting-started/
    │   │       │   │   ├── page.adoc
    │   │       │   │   ├── a-little-ai/
    │   │       │   │   │   └── page.adoc
    │   │       │   │   ├── first-agent/
    │   │       │   │   │   └── page.adoc
    │   │       │   │   ├── installing/
    │   │       │   │   │   └── page.adoc
    │   │       │   │   ├── quickstart/
    │   │       │   │   │   └── page.adoc
    │   │       │   │   └── running/
    │   │       │   │       └── page.adoc
    │   │       │   ├── guides/
    │   │       │   │   ├── page.adoc
    │   │       │   │   ├── horoscope/
    │   │       │   │   │   └── page.adoc
    │   │       │   │   └── movies/
    │   │       │   │       └── page.adoc
    │   │       │   ├── images/
    │   │       │   │   ├── agent-api/
    │   │       │   │   │   └── .gitkeep
    │   │       │   │   ├── architecture/
    │   │       │   │   │   └── .gitkeep
    │   │       │   │   ├── eval/
    │   │       │   │   │   └── .gitkeep
    │   │       │   │   └── shell/
    │   │       │   │       └── .gitkeep
    │   │       │   ├── overview/
    │   │       │   │   ├── agent-framework.adoc
    │   │       │   │   ├── concepts.adoc
    │   │       │   │   ├── glossary.adoc
    │   │       │   │   ├── page.adoc
    │   │       │   │   └── why-embabel.adoc
    │   │       │   ├── reference/
    │   │       │   │   ├── reference.adoc
    │   │       │   │   ├── agent-platform/
    │   │       │   │   │   └── page.adoc
    │   │       │   │   ├── agent-process/
    │   │       │   │   │   └── page.adoc
    │   │       │   │   ├── annotations/
    │   │       │   │   │   └── page.adoc
    │   │       │   │   ├── api-evolution/
    │   │       │   │   │   └── page.adoc
    │   │       │   │   ├── api-spi/
    │   │       │   │   │   └── page.adoc
    │   │       │   │   ├── architecture/
    │   │       │   │   │   └── page.adoc
    │   │       │   │   ├── configuration/
    │   │       │   │   │   └── page.adoc
    │   │       │   │   ├── customizing/
    │   │       │   │   │   └── page.adoc
    │   │       │   │   ├── domain/
    │   │       │   │   │   └── page.adoc
    │   │       │   │   ├── dsl/
    │   │       │   │   │   └── page.adoc
    │   │       │   │   ├── flow/
    │   │       │   │   │   └── page.adoc
    │   │       │   │   ├── integrations/
    │   │       │   │   │   └── page.adoc
    │   │       │   │   ├── invoking/
    │   │       │   │   │   └── page.adoc
    │   │       │   │   ├── llms/
    │   │       │   │   │   └── page.adoc
    │   │       │   │   ├── migrating/
    │   │       │   │   │   └── page.adoc
    │   │       │   │   ├── prompt-contributors/
    │   │       │   │   │   └── page.adoc
    │   │       │   │   ├── spring/
    │   │       │   │   │   └── page.adoc
    │   │       │   │   ├── steps/
    │   │       │   │   │   └── page.adoc
    │   │       │   │   ├── templates/
    │   │       │   │   │   └── page.adoc
    │   │       │   │   ├── testing/
    │   │       │   │   │   └── page.adoc
    │   │       │   │   ├── tools/
    │   │       │   │   │   └── page.adoc
    │   │       │   │   ├── troubleshooting/
    │   │       │   │   │   └── page.adoc
    │   │       │   │   └── types/
    │   │       │   │       └── page.adoc
    │   │       │   ├── resources/
    │   │       │   │   └── page.adoc
    │   │       │   ├── roadmap/
    │   │       │   │   └── roadmap.adoc
    │   │       │   └── shell/
    │   │       │       ├── commands.adoc
    │   │       │       ├── how-to.adoc
    │   │       │       └── shell-guide.adoc
    │   │       └── resources/
    │   │           └── themes/
    │   │               ├── embabel-agent-docs.css
    │   │               └── theme-extensions.css
    │   └── .embabel/
    │       └── log.jsonl
    ├── embabel-agent-eval/
    │   ├── pom.xml
    │   └── src/
    │       ├── main/
    │       │   ├── kotlin/
    │       │   │   └── com/
    │       │   │       └── embabel/
    │       │   │           └── agent/
    │       │   │               └── eval/
    │       │   │                   ├── AgentEvalApplication.kt
    │       │   │                   ├── assert/
    │       │   │                   │   ├── Assertion.kt
    │       │   │                   │   └── AssertionEvaluator.kt
    │       │   │                   ├── client/
    │       │   │                   │   ├── AgentChatClient.kt
    │       │   │                   │   ├── ChatRequest.kt
    │       │   │                   │   ├── GenerationEvent.kt
    │       │   │                   │   ├── ObjectContext.kt
    │       │   │                   │   └── OpenAiCompatibleMessage.kt
    │       │   │                   ├── config/
    │       │   │                   │   ├── Config.kt
    │       │   │                   │   └── ScriptEvaluationService.kt
    │       │   │                   ├── runner/
    │       │   │                   │   ├── DefaultEvaluationRunner.kt
    │       │   │                   │   └── EvalApplicationRunner.kt
    │       │   │                   └── support/
    │       │   │                       ├── Evaluation.kt
    │       │   │                       ├── EvaluationInProgress.kt
    │       │   │                       └── Setup.kt
    │       │   └── resources/
    │       │       ├── application.properties
    │       │       └── prompts/
    │       │           └── eval/
    │       │               ├── score.jinja
    │       │               └── socrates.jinja
    │       └── test/
    │           └── kotlin/
    │               └── com/
    │                   └── embabel/
    │                       └── agent/
    │                           └── eval/
    │                               ├── AgentEvalApplicationTests.kt
    │                               └── config/
    │                                   └── ScriptEvaluationServiceTest.kt
    ├── embabel-agent-mcpserver/
    │   ├── pom.xml
    │   └── src/
    │       ├── main/
    │       │   └── kotlin/
    │       │       └── com/
    │       │           └── embabel/
    │       │               └── agent/
    │       │                   └── mcpserver/
    │       │                       ├── AbstractMcpServerConfiguration.kt
    │       │                       ├── McpServerStrategy.kt
    │       │                       ├── McpToolExportCallbackPublisher.kt
    │       │                       ├── ToolRegistry.kt
    │       │                       ├── async/
    │       │                       │   ├── AsyncToolRegistry.kt
    │       │                       │   ├── McpAsyncPromptFactory.kt
    │       │                       │   ├── McpAsyncPromptPublisher.kt
    │       │                       │   ├── McpAsyncResourcePublisher.kt
    │       │                       │   ├── McpAsyncServerStrategy.kt
    │       │                       │   ├── config/
    │       │                       │   │   └── McpAsyncServerConfiguration.kt
    │       │                       │   └── support/
    │       │                       │       ├── PerGoalAsyncMcpToolExportCallbackPublisher.kt
    │       │                       │       └── PerGoalStartingInputTypesPromptPublisher.kt
    │       │                       ├── domain/
    │       │                       │   └── Types.kt
    │       │                       ├── support/
    │       │                       │   ├── extensions.kt
    │       │                       │   └── promptUtils.kt
    │       │                       └── sync/
    │       │                           ├── McpPromptFactory.kt
    │       │                           ├── McpPromptPublisher.kt
    │       │                           ├── McpResourcePublisher.kt
    │       │                           ├── McpServerStrategy.kt
    │       │                           ├── SyncResourceSpecificationFactory.kt
    │       │                           ├── SyncToolRegistry.kt
    │       │                           ├── config/
    │       │                           │   └── McpSyncServerConfiguration.kt
    │       │                           └── support/
    │       │                               ├── PerGoalMcpToolExportCallbackPublisher.kt
    │       │                               └── PerGoalStartingInputTypesPromptPublisher.kt
    │       └── test/
    │           └── kotlin/
    │               └── com/
    │                   └── embabel/
    │                       └── agent/
    │                           └── mcpserver/
    │                               ├── AbstractMcpServerConfigurationTest.kt
    │                               ├── ServerInfoFactoryAndUnifiedBannerToolTest.kt
    │                               ├── async/
    │                               │   ├── AsyncServerStrategyTest.kt
    │                               │   ├── AsyncToolRegistryTest.kt
    │                               │   └── McpAsyncPromptFactoryTest.kt
    │                               ├── config/
    │                               │   └── McpServerConditionsTest.kt
    │                               ├── domain/
    │                               │   └── TypesTest.kt
    │                               ├── support/
    │                               │   ├── ExtensionsTest.kt
    │                               │   └── PromptUtilsTest.kt
    │                               └── sync/
    │                                   ├── AsyncFactoriesTest.kt
    │                                   ├── McpPromptFactoryExtendedTest.kt
    │                                   ├── McpPromptFactoryTest.kt
    │                                   ├── SyncServerStrategyTest.kt
    │                                   └── SyncToolRegistryTest.kt
    ├── embabel-agent-rag/
    │   ├── pom.xml
    │   ├── embabel-agent-rag-lucene/
    │   │   ├── pom.xml
    │   │   └── src/
    │   │       ├── main/
    │   │       │   └── kotlin/
    │   │       │       └── com/
    │   │       │           └── embabel/
    │   │       │               └── agent/
    │   │       │                   └── rag/
    │   │       │                       └── lucene/
    │   │       │                           └── LuceneRagFacetProvider.kt
    │   │       └── test/
    │   │           ├── kotlin/
    │   │           │   └── com/
    │   │           │       └── embabel/
    │   │           │           └── agent/
    │   │           │               └── rag/
    │   │           │                   ├── .gitkeep
    │   │           │                   └── lucene/
    │   │           │                       └── LuceneRagFacetProviderTest.kt
    │   │           └── resources/
    │   │               └── application-test.properties
    │   ├── embabel-agent-rag-neo/
    │   │   ├── pom.xml
    │   │   └── src/
    │   │       ├── main/
    │   │       │   ├── kotlin/
    │   │       │   │   └── com/
    │   │       │   │       └── embabel/
    │   │       │   │           └── agent/
    │   │       │   │               └── rag/
    │   │       │   │                   ├── neo/
    │   │       │   │                   │   ├── common/
    │   │       │   │                   │   │   ├── CypherRagQueryGenerator.kt
    │   │       │   │                   │   │   ├── CypherSearch.kt
    │   │       │   │                   │   │   └── LogicalQueryResolver.kt
    │   │       │   │                   │   └── ogm/
    │   │       │   │                   │       ├── NeoOgmConfig.kt
    │   │       │   │                   │       ├── NeoRagServiceProperties.kt
    │   │       │   │                   │       ├── OgmCypherSearch.kt
    │   │       │   │                   │       ├── OgmMappedEntity.kt
    │   │       │   │                   │       ├── OgmMetadataSchemaResolver.kt
    │   │       │   │                   │       ├── OgmRagFacetProvider.kt
    │   │       │   │                   │       └── SchemaDrivenCypherRagQueryGenerator.kt
    │   │       │   │                   └── schema/
    │   │       │   │                       └── SchemaResolver.kt
    │   │       │   └── resources/
    │   │       │       └── cypher/
    │   │       │           ├── chunk_fulltext_search.cypher
    │   │       │           ├── chunk_vector_search.cypher
    │   │       │           ├── create_content_element_relationships.cypher
    │   │       │           ├── create_entity.cypher
    │   │       │           ├── entity_fulltext_search.cypher
    │   │       │           ├── entity_vector_search.cypher
    │   │       │           ├── find_all.cypher
    │   │       │           ├── save_content_element.cypher
    │   │       │           └── vector_cluster.cypher
    │   │       └── test/
    │   │           ├── kotlin/
    │   │           │   └── com/
    │   │           │       └── embabel/
    │   │           │           └── agent/
    │   │           │               └── rag/
    │   │           │                   ├── .gitkeep
    │   │           │                   ├── neo/
    │   │           │                   │   ├── NeoTestApplication.kt
    │   │           │                   │   ├── NeoTestContainerTest.kt
    │   │           │                   │   ├── config/
    │   │           │                   │   │   └── NeoFakeAiConfiguration.kt
    │   │           │                   │   ├── ogm/
    │   │           │                   │   │   └── OgmRagServiceTest.kt
    │   │           │                   │   └── support/
    │   │           │                   │       ├── Neo4jTestContainer.kt
    │   │           │                   │       ├── NeoIntegrationTest.kt
    │   │           │                   │       └── NeoIntegrationTestSupport.kt
    │   │           │                   └── ogm/
    │   │           │                       └── OgmCypherSearchTest.kt
    │   │           └── resources/
    │   │               ├── application-test.properties
    │   │               ├── create_indexes.cypher
    │   │               ├── reference-data.cypher
    │   │               └── .gitkeep
    │   ├── embabel-agent-rag-pipeline/
    │   │   ├── pom.xml
    │   │   └── src/
    │   │       └── main/
    │   │           └── kotlin/
    │   │               └── com/
    │   │                   └── embabel/
    │   │                       └── agent/
    │   │                           └── rag/
    │   │                               ├── RagPipelineConfiguration.kt
    │   │                               └── pipeline/
    │   │                                   ├── AdaptivePipelineRagResponseEnhancer.kt
    │   │                                   ├── DeduplicatingEnhancer.kt
    │   │                                   ├── FilterEnhancer.kt
    │   │                                   ├── PipelinedRagServiceEnhancer.kt
    │   │                                   ├── PromptedContextualCompressionEnhancer.kt
    │   │                                   ├── RerankingEnhancer.kt
    │   │                                   └── event/
    │   │                                       └── PipelineRagEvents.kt
    │   └── embabel-agent-rag-tika/
    │       ├── pom.xml
    │       └── src/
    │           ├── main/
    │           │   └── kotlin/
    │           │       └── com/
    │           │           └── embabel/
    │           │               └── agent/
    │           │                   └── rag/
    │           │                       └── ingestion/
    │           │                           └── HierarchicalContentReader.kt
    │           └── test/
    │               ├── kotlin/
    │               │   └── com/
    │               │       └── embabel/
    │               │           └── agent/
    │               │               └── rag/
    │               │                   ├── .gitkeep
    │               │                   └── ingestion/
    │               │                       └── HierarchicalContentReaderTest.kt
    │               └── resources/
    │                   └── application-test.properties
    ├── embabel-agent-shell/
    │   ├── README.md
    │   ├── pom.xml
    │   └── src/
    │       └── main/
    │           └── kotlin/
    │               └── com/
    │                   └── embabel/
    │                       └── agent/
    │                           └── shell/
    │                               ├── DefaultPromptProvider.kt
    │                               ├── formatProcessOutput.kt
    │                               ├── markdown.kt
    │                               ├── MessageGeneratorPromptProvider.kt
    │                               ├── ShellCommands.kt
    │                               ├── TerminalServices.kt
    │                               ├── config/
    │                               │   ├── ShellConfiguration.kt
    │                               │   └── ShellProperties.kt
    │                               └── personality/
    │                                   ├── colossus/
    │                                   │   └── ColossusPromptProvider.kt
    │                                   ├── hitchhiker/
    │                                   │   └── HitchhikerPromptProvider.kt
    │                                   ├── montypython/
    │                                   │   └── MontyPythonPromptProvider.kt
    │                                   ├── severance/
    │                                   │   └── SeverancePromptProvider.kt
    │                                   └── starwars/
    │                                       └── StarwarsPromptProvider.kt
    ├── embabel-agent-starters/
    │   ├── pom.xml
    │   ├── .gitkeep
    │   ├── embabel-agent-starter/
    │   │   └── pom.xml
    │   ├── embabel-agent-starter-anthropic/
    │   │   └── pom.xml
    │   ├── embabel-agent-starter-bedrock/
    │   │   ├── pom.xml
    │   │   └── src/
    │   │       ├── main/
    │   │       │   ├── java/
    │   │       │   │   └── com/
    │   │       │   │       └── embabel/
    │   │       │   │           └── agent/
    │   │       │   │               └── starter/
    │   │       │   │                   └── bedrock/
    │   │       │   │                       └── spi/
    │   │       │   │                           └── BedrockEnvironmentPostProcessor.java
    │   │       │   └── resources/
    │   │       │       └── META-INF/
    │   │       │           └── spring.factories
    │   │       └── test/
    │   │           └── java/
    │   │               └── com/
    │   │                   └── embabel/
    │   │                       └── agent/
    │   │                           └── starter/
    │   │                               └── bedrock/
    │   │                                   └── spi/
    │   │                                       └── BedrockEnvironmentPostProcessorTest.java
    │   ├── embabel-agent-starter-deepseek/
    │   │   └── pom.xml
    │   ├── embabel-agent-starter-dockermodels/
    │   │   └── pom.xml
    │   ├── embabel-agent-starter-mcpserver/
    │   │   └── pom.xml
    │   ├── embabel-agent-starter-ollama/
    │   │   └── pom.xml
    │   ├── embabel-agent-starter-openai/
    │   │   └── pom.xml
    │   ├── embabel-agent-starter-platform/
    │   │   └── pom.xml
    │   └── embabel-agent-starter-shell/
    │       ├── README.md
    │       ├── pom.xml
    │       └── src/
    │           ├── main/
    │           │   ├── java/
    │           │   │   └── com/
    │           │   │       └── embabel/
    │           │   │           └── agent/
    │           │   │               └── starter/
    │           │   │                   └── shell/
    │           │   │                       ├── AgentShellStarterProperties.java
    │           │   │                       └── spi/
    │           │   │                           └── ShellEnvironmentPostProcessor.java
    │           │   └── resources/
    │           │       └── META-INF/
    │           │           └── spring.factories
    │           └── test/
    │               └── java/
    │                   └── com/
    │                       └── embabel/
    │                           └── agent/
    │                               └── starter/
    │                                   └── shell/
    │                                       ├── AgentShellStarterPropertiesTest.java
    │                                       └── spi/
    │                                           └── ShellEnvironmentPostProcessorTest.java
    ├── embabel-agent-test-support/
    │   ├── pom.xml
    │   ├── embabel-agent-test/
    │   │   ├── pom.xml
    │   │   └── src/
    │   │       └── main/
    │   │           └── java/
    │   │               └── com/
    │   │                   └── embabel/
    │   │                       └── agent/
    │   │                           └── testing/
    │   │                               └── integration/
    │   │                                   └── EmbabelMockitoIntegrationTest.java
    │   └── embabel-agent-test-internal/
    │       ├── pom.xml
    │       └── src/
    │           └── main/
    │               └── kotlin/
    │                   └── com/
    │                       └── embabel/
    │                           └── agent/
    │                               ├── AgentTestApplication.kt
    │                               └── test/
    │                                   ├── domain/
    │                                   │   ├── gardenOfEden.kt
    │                                   │   └── simplyMagic.kt
    │                                   ├── dsl/
    │                                   │   ├── agentBuilderUtils.kt
    │                                   │   └── dslAgents.kt
    │                                   ├── models/
    │                                   │   ├── OptionsConverterTestSupport.kt
    │                                   │   └── optionsConverterTestUtils.kt
    │                                   └── type/
    │                                       └── testTypes.kt
    ├── embabel-agent-ux/
    │   ├── pom.xml
    │   └── src/
    │       ├── main/
    │       │   ├── kotlin/
    │       │   │   └── com/
    │       │   │       └── embabel/
    │       │   │           └── agent/
    │       │   │               └── discord/
    │       │   │                   └── .gitkeep
    │       │   └── resources/
    │       │       └── .gitkeep
    │       └── test/
    │           ├── kotlin/
    │           │   └── com/
    │           │       └── embabel/
    │           │           └── agent/
    │           │               └── discord/
    │           │                   └── .gitkeep
    │           └── resources/
    │               └── .gitkeep
    └── .github/
        ├── dco.yml
        ├── scripts/
        │   └── dependabot-group-alerts.sh
        └── workflows/
            ├── dependabot-insights.yml
            ├── deploy-docs.yml
            ├── deploy-snapshots.yml
            └── maven.yml

================================================
FILE: README.md
================================================
# Embabel Agent Framework

<img align="left" src="https://github.com/embabel/embabel-agent/blob/main/embabel-agent-api/images/315px-Meister_der_Weltenchronik_001.jpg?raw=true" width="180">

[![Docs](https://img.shields.io/badge/docs-live-brightgreen)](https://docs.embabel.com/embabel-agent/guide/0.1.2-SNAPSHOT/)
![Build](https://github.com/embabel/embabel-agent/actions/workflows/maven.yml/badge.svg)
[![YourKit](https://img.shields.io/badge/Profiling-YourKit-blue)](https://www.yourkit.com/)
[![JProfiler](https://img.shields.io/badge/Profiled%20with-JProfiler-blue)](https://www.ej-technologies.com/products/jprofiler/overview.html)
[![Quality Gate Status](https://sonarcloud.io/api/project_badges/measure?project=embabel_embabel-agent&metric=alert_status)](https://sonarcloud.io/summary/new_code?id=embabel_embabel-agent)
[![Discord](https://img.shields.io/discord/1277751399261798401?logo=discord)](https://discord.gg/t6bjkyj93q)

[//]: # ([![Quality Gate Status]&#40;https://sonarcloud.io/api/project_badges/measure?project=embabel_embabel-agent&metric=alert_status&token=d275d89d09961c114b8317a4796f84faf509691c&#41;]&#40;https://sonarcloud.io/summary/new_code?id=embabel_embabel-agent&#41;)

[//]: # ([![Bugs]&#40;https://sonarcloud.io/api/project_badges/measure?project=embabel_embabel-agent&metric=bugs&#41;]&#40;https://sonarcloud.io/summary/new_code?id=embabel_embabel-agent&#41;)
![Kotlin](https://img.shields.io/badge/kotlin-%237F52FF.svg?style=for-the-badge&logo=kotlin&logoColor=white)
![Java](https://img.shields.io/badge/java-%23ED8B00.svg?style=for-the-badge&logo=openjdk&logoColor=white)
![Spring](https://img.shields.io/badge/spring-%236DB33F.svg?style=for-the-badge&logo=spring&logoColor=white)
![Spring Boot](https://img.shields.io/badge/Spring%20Boot-6DB33F.svg?style=for-the-badge&logo=Spring-Boot&logoColor=white)
![Apache Tomcat](https://img.shields.io/badge/apache%20tomcat-%23F8DC75.svg?style=for-the-badge&logo=apache-tomcat&logoColor=black)
![Apache Maven](https://img.shields.io/badge/Apache%20Maven-C71A36?style=for-the-badge&logo=Apache%20Maven&logoColor=white)
![JUnit](https://img.shields.io/badge/JUnit5-25A162.svg?style=for-the-badge&logo=JUnit5&logoColor=white)
![ChatGPT](https://img.shields.io/badge/chatGPT-74aa9c?style=for-the-badge&logo=openai&logoColor=white)
![Jinja](https://img.shields.io/badge/jinja-white.svg?style=for-the-badge&logo=jinja&logoColor=black)
![JSON](https://img.shields.io/badge/JSON-000?logo=json&logoColor=fff)
![GitHub Actions](https://img.shields.io/badge/github%20actions-%232671E5.svg?style=for-the-badge&logo=githubactions&logoColor=white)
![SonarQube](https://img.shields.io/badge/SonarQube-black?style=for-the-badge&logo=sonarqube&logoColor=4E9BCD)
![Docker](https://img.shields.io/badge/docker-%230db7ed.svg?style=for-the-badge&logo=docker&logoColor=white)
![IntelliJ IDEA](https://img.shields.io/badge/IntelliJIDEA-000000.svg?style=for-the-badge&logo=intellij-idea&logoColor=white)
[![License](https://img.shields.io/github/license/embabel/embabel-agent?style=for-the-badge&logo=apache&color=brightgreen)](https://www.apache.org/licenses/LICENSE-2.0)
[![Commits](https://img.shields.io/github/commit-activity/m/embabel/embabel-agent.svg?label=commits&style=for-the-badge&logo=git&logoColor=white)](https://github.com/embabel/embabel-agent/pulse)

&nbsp;&nbsp;&nbsp;&nbsp;

Embabel (Em-BAY-bel) is a framework for authoring agentic flows on the JVM that seamlessly mix LLM-prompted interactions
with code and domain models. Supports
intelligent path finding towards goals. Written in Kotlin
but offers a natural usage
model from Java.
From the creator of Spring.

&nbsp;

## Key Concepts

Models agentic flows in terms of:

- **Actions**: Steps an agent takes
- **Goals**: What an agent is trying to achieve
- **Conditions**: Conditions to assess before executing an action or determining that a goal has been achieved.
  Conditions are reassessed after each action is executed.
- **Domain model**: Objects underpinning the flow and informing Actions, Goals and Conditions.
- **Plan**: A sequence of actions to achieve a goal. Plans are dynamically formulated by the system, not the programmer.
  The
  system replans after the completion of each action, allowing it to adapt to new information as well as observe the
  effects of the previous action.
  This is effectively an [OODA loop](https://en.wikipedia.org/wiki/OODA_loop).

> Application developers don't usually have to deal with these concepts directly,
> as most conditions result from data flow defined in code, allowing the system to infer
> pre and post conditions.

These concepts underpin these differentiators versus other agent frameworks:

- **Sophisticated planning.** Goes beyond a finite state machine or sequential execution
  with nesting by introducing a true planning step, using a
  non-LLM AI algorithm. This enables the system to perform tasks it wasn’t programmed to do by combining known
  steps in
  a novel order, as well as make decisions about parallelization and other runtime behavior.
- **Superior extensibility and reuse**: Because of dynamic planning, adding more domain objects, actions, goals and
  conditions
  can extend the capability of the system, _without editing FSM definitions_ or existing code.
- **Strong typing and the benefits of object orientation**: Actions, goals and conditions are informed by a domain
  model, which can
  include behavior. Everything is strongly typed and prompts and
  manually authored code interact cleanly. No more magic maps. Enjoy full refactoring support.

Other benefits:

- **Platform abstraction**: Clean separation between programming model and platform internals allows running locally
  while
  potentially offering higher QoS in production without changing application code.
- **Designed for LLM mixing**: It is easy to build applications that mix LLMs, ensuring the most cost-effective yet
  capable solution.
  This enables the system to leverage the strengths of different models for different tasks. In particular, it
  facilitates
  the use of local models for point tasks. This can be important for cost and privacy.
- **Built on Spring and the JVM,** making it easy to access existing enterprise functionality and capabilities.
  For example:
    - Spring can inject and manage agents, including using Spring AOP to decorate functions.
    - Robust persistence and transaction management solutions are available.
- **Designed for testability** from the ground up. Both unit testing and agent end to end testing are easy.

Flows can be authored in one of two ways:

- An annotation-based model similar to Spring MVC, with types annotated with the Spring stereotype `@Agent`, using
  `@Goal`, `@Condition` and
  `@Action` methods.
- Idiomatic Kotlin DSL with `agent {` and `action {` blocks.

Either way, flows are backed by a domain model of objects that can have rich behavior.

> We are working toward allowing natural language actions and goals to be deployed.

The planning step is pluggable.

The default planning approach is
[Goal Oriented Action Planning](https://medium.com/@vedantchaudhari/goal-oriented-action-planning-34035ed40d0b).
GOAP is a popular AI planning algorithm used in gaming. It allows for dynamic decision-making and action selection based
on the current state of the world and the goals of the agent.

Goals, actions and plans are independent of GOAP. Future planning options include:

- Plans created by a reasoning model such as OpenAI o1 or DeepSeek R1.

The framework executes via an `AgentPlatform` implementation.

An agent platform supports the following modes of execution:

- **Focused**, where user code requests particular functionality: User code calls a method to run a particular agent,
  passing in input. This is ideal for code-driven flows such as a flow invoked in response to an incoming event.
- **Closed**, where user intent (or another incoming event) is classified to choose an agent. The platform tries to
  find a
  suitable agent among all the agents it knows about.
  Agent choice is dynamic, but only actions defined within the particular agent
  will run.
- **Open**, where the user's intent is assessed and the platform uses _all_ its resources to try to achieve it. The
  platform tries to find a
  suitable goal among all the goals it knows about and builds a custom agent to achieve it from the start state,
  including relevant actions and conditions. The platform will not proceed if it is unconvinced as to the applicability
  of any goal. The `GoalChoiceApprover` interface provides developers a way to limit goal choice further.

Open mode is the most powerful, but least deterministic.
> In open mode, the platform is capable of finding novel paths that were not envisioned by developers, and even
> combining functionality from multiple providers.

Even in open mode, the platform will only perform individual steps
that have been specified. (Of course, steps may themselves be LLM
transforms, in which case the prompts are controlled by user code but the
results are still non-deterministic.)

Possible future modes:

- **Evolving** mode: Where the platform can work with multiple goals in the same process and modify a running process to
  add further goals and agents.
  For example, an action can realize that it has become important to achieve additional goals.

Embabel agent systems will also support federation, both with other Embabel systems (allowing planning to incorporate
remote actions and goals) and third party agent frameworks.

## Quick Start

Get an agent running in under 5 minutes.

Create your own agent repo from our [Java](https://github.com/embabel/java-agent-template)
or [Kotlin](https://github.com/embabel/kotlin-agent-template) GitHub template by clicking the "Use this template"
button.

You can also create your own Embabel agent project locally with our quick start tool:

```
uvx --from git+https://github.com/embabel/project-creator.git project-creator
```

Choose Java or Kotlin and specify your project name and package name and you'll have an agent running in under a minute,
if you already have an `OPENAI_API_KEY` and have Maven installed.

**📚 For examples and tutorials**, see
the [Embabel Agent Examples Repository](https://github.com/embabel/embabel-agent-examples)

**🚗 For a realistic example application**, see the [Tripper travel planner agent](https://github.com/embabel/tripper)

<img src="images/tripper_output1.jpg" alt="Travel Planner Output" width="600"/>

*AI-generated travel itinerary with detailed recommendations*

<img src="images/tripper_map.jpg" alt="Interactive map" width="600"/>

*Map link included in output*

## Why Is Embabel Needed?

TL;DR Because the evolution of agent frameworks is early and there's a lot of room for improvement; because an agent
framework on the JVM will deliver great business value.

- _Why do we need an agent framework at all_? We can write code without higher level abstractions, directly invoking
  LLMs and controlling flow directly in code. However, a higher level agent framework offers compelling benefits. For
  example:
    - Breaking up LLM interactions, making them simpler and more focused. This maximizes reuse and minimizes cost and
      errors. It often allows us to use cheaper models for point interactions.
    - Facilitating both unit and integration testing, which remain as important with agentic systems as with any other
      software systems.
    - Increasing composability where subflows and individual actions can be reused
    - Making applications more manageable and robust, enabling a workflow manager to control their execution and retry
      operations while maintaining previous state
    - Enhancing safety through the ability to apply guardrails in many places
- _Why do we need an agent framework for the JVM when solutions exist in Python?_: While this space is presently
  better developed in Python (or even TypeScript), it's early and there's plenty of room for novel and potentially
  superior
  approaches. The key adjacency is often not the LLM--which is a simple HTTP call away--but existing code and
  infrastructure
  assets that are more likely on the JVM than in Python.
- _Why not use just Spring AI?_ Spring AI is great. We build on it, and embrace the Spring component model. However, we
  believe that most applications should work with higher
  level APIs. An analogy: Spring AI exists at the level of the Servlet API, while Embabel is more like Spring MVC.
  Complex requirements are much easier to express and test in Embabel than with direct use of Spring AI.
- _Why not attempt to contribute this project to Spring?_ This project requires different governance
  from Spring, where most projects exist in stable environments and dependability and stability outweighs rapid
  innovation. Second, the
  concepts are not JVM-specific. We hope that Embabel will become the leading agent framework across platforms. While
  the Spring brand is valuable in Java, it is not in TypeScript or Python.

## Show Me The Code

In Java or Kotlin, agent implementation code is intuitive and easy to test.

<details open>
<summary>Java</summary>

```java

@Agent(description = "Find news based on a person's star sign")
public class StarNewsFinder {

    private final HoroscopeService horoscopeService;
    private final int storyCount;

    // Services are injected by Spring
    public StarNewsFinder(
            HoroscopeService horoscopeService,
            @Value("${star-news-finder.story.count:5}") int storyCount) {
        this.horoscopeService = horoscopeService;
        this.storyCount = storyCount;
    }

    @Action
    public StarPerson extractStarPerson(UserInput userInput, OperationContext context) {
        return context.ai()
                .withLlm(OpenAiModels.GPT_41)
                .createObjectIfPossible(
                        """
                                Create a person from this user input, extracting their name and star sign:
                                %s""".formatted(userInput.getContent()),
                        StarPerson.class
                );
    }

    @Action
    public Horoscope retrieveHoroscope(StarPerson starPerson) {
        return new Horoscope(horoscopeService.dailyHoroscope(starPerson.sign()));
    }

    // toolGroups specifies tools that are required for this action to run
    @Action(toolGroups = {CoreToolGroups.WEB})
    public RelevantNewsStories findNewsStories(
            StarPerson person,
            Horoscope horoscope,
            OperationContext context) {
        var prompt = """
                %s is an astrology believer with the sign %s.
                Their horoscope for today is:
                    <horoscope>%s</horoscope>
                Given this, use web tools and generate search queries
                to find %d relevant news stories summarize them in a few sentences.
                Include the URL for each story.
                Do not look for another horoscope reading or return results directly about astrology;
                find stories relevant to the reading above.
                
                For example:
                - If the horoscope says that they may
                want to work on relationships, you could find news stories about
                novel gifts
                - If the horoscope says that they may want to work on their career,
                find news stories about training courses.""".formatted(
                person.name(), person.sign(), horoscope.summary(), storyCount);
        return context.ai()
                .withDefaultLlm()
                .createObject(prompt, RelevantNewsStories.class);
    }

    // The @AchievesGoal annotation indicates that completing this action
    // achieves the given goal, so the agent can be complete
    @AchievesGoal(
            description = "Write an amusing writeup for the target person based on their horoscope and current news stories",
            export = @Export(
                    remote = true,
                    name = "starNewsWriteupJava",
                    startingInputTypes = {StarPerson.class, UserInput.class})
    )
    @Action
    public Writeup writeup(
            StarPerson person,
            RelevantNewsStories relevantNewsStories,
            Horoscope horoscope,
            OperationContext context) {
        var llm = LlmOptions
                .withModel(OpenAiModels.GPT_41_MINI)
                // High temperature for creativity
                .withTemperature(0.9);

        var newsItems = relevantNewsStories.getItems().stream()
                .map(item -> "- " + item.getUrl() + ": " + item.getSummary())
                .collect(Collectors.joining("\n"));

        var prompt = """
                Take the following news stories and write up something
                amusing for the target person.
                
                Begin by summarizing their horoscope in a concise, amusing way, then
                talk about the news. End with a surprising signoff.
                
                %s is an astrology believer with the sign %s.
                Their horoscope for today is:
                    <horoscope>%s</horoscope>
                Relevant news stories are:
                %s
                
                Format it as Markdown with links.""".formatted(
                person.name(), person.sign(), horoscope.summary(), newsItems);
        return context.ai()
                .withLlm(llm)
                .createObject(prompt, Writeup.class);
    }
}
```

</details>

<details>
<summary>Kotlin</summary>

```kotlin
@Agent(description = "Find news based on a person's star sign")
class StarNewsFinder(
    // Services such as Horoscope are injected by Spring
    private val horoscopeService: HoroscopeService,
    // Potentially externalized by Spring
    @param:Value("\${star-news-finder.story.count:5}")
    private val storyCount: Int = 5,
) {

    @Action
    fun extractPerson(
        userInput: UserInput,
        context: OperationContext
    ): StarPerson =
        // All prompts are typesafe
        context.ai().withDefaultLlm()
            .createObject("Create a person from this user input, extracting their name and star sign: $userInput")

    // This action doesn't use an LLM
    // Embabel makes it easy to mix LLM use with regular code
    @Action
    fun retrieveHoroscope(starPerson: StarPerson) =
        Horoscope(horoscopeService.dailyHoroscope(starPerson.sign))

    // This action uses tools
    // "toolGroups" specifies tools that are required for this action to run
    @Action(toolGroups = [ToolGroup.WEB])
    fun findNewsStories(
        person: StarPerson,
        horoscope: Horoscope,
        context: OperationContext
    ): RelevantNewsStories =
        context.ai().withDefaultLlm().createObject(
            """
            ${person.name} is an astrology believer with the sign ${person.sign}.
            Their horoscope for today is:
                <horoscope>${horoscope.summary}</horoscope>
            Given this, use web tools and generate search queries
            to find $storyCount relevant news stories summarize them in a few sentences.
            Include the URL for each story.
            Do not look for another horoscope reading or return results directly about astrology;
            find stories relevant to the reading above.

            For example:
            - If the horoscope says that they may
            want to work on relationships, you could find news stories about
            novel gifts
            - If the horoscope says that they may want to work on their career,
            find news stories about training courses.
        """.trimIndent()
        )

    // The @AchievesGoal annotation indicates that completing this action
    // achieves the given goal, so the agent run will be complete
    @AchievesGoal(
        description = "Write an amusing writeup for the target person based on their horoscope and current news stories",
    )
    @Action
    fun writeup(
        person: StarPerson,
        relevantNewsStories: RelevantNewsStories,
        horoscope: Horoscope,
        context: OperationContext,
    ): Writeup =
        context.ai()
            .withLlm(
                LlmOptions
                    .withModel(model)
                    .withTemperature(0.9)
            )
            .createObject(
                """
            Take the following news stories and write up something
            amusing for the target person.

            Begin by summarizing their horoscope in a concise, amusing way, then
            talk about the news. End with a surprising signoff.

            ${person.name} is an astrology believer with the sign ${person.sign}.
            Their horoscope for today is:
                <horoscope>${horoscope.summary}</horoscope>
            Relevant news stories are:
            ${relevantNewsStories.items.joinToString("\n") { "- ${it.url}: ${it.summary}" }}

            Format it as Markdown with links.
        """.trimIndent()
            )

}
```

</details>


The following domain classes ensure type safety:

<details open>
<summary>Java</summary>

```java

@JsonClassDescription("Person with astrology details")
@JsonDeserialize(as = StarPerson.class)
public record StarPerson(
        String name,
        @JsonPropertyDescription("Star sign") String sign
) implements Person {

    @JsonCreator
    public StarPerson(
            @JsonProperty("name") String name,
            @JsonProperty("sign") String sign
    ) {
        this.name = name;
        this.sign = sign;
    }

    @Override
    public String getName() {
        return name;
    }
}

public record Horoscope(String summary) {
}

@JsonClassDescription("Writeup relating to a person's horoscope and relevant news")
public record Writeup(String text) implements HasContent {

    @JsonCreator
    public Writeup(@JsonProperty("text") String text) {
        this.text = text;
    }

    @Override
    public String getContent() {
        return text;
    }
}

```

</details>

<details>
<summary>Kotlin</summary>

```kotlin
data class RelevantNewsStories(
    val items: List<NewsStory>
)

data class NewsStory(
    val url: String,

    val summary: String,
)

data class Subject(
    val name: String,
    val sign: String,
)

data class Horoscope(
    val summary: String,
)

data class FunnyWriteup(
    override val text: String,
) : HasContent
```

</details>

It's easy to unit test your agents to ensure that they correctly execute logic
and pass the correct prompts and hyperparameters to LLMs. For example:

```java
public class StarNewsFinderTest {

    @Test
    void writeupPromptMustContainKeyData() {
        HoroscopeService horoscopeService = mock(HoroscopeService.class);
        StarNewsFinder starNewsFinder = new StarNewsFinder(horoscopeService, 5);
        var context = new FakeOperationContext();
        context.expectResponse(new com.embabel.example.horoscope.Writeup("Gonna be a good day"));

        NewsStory cockatoos = new NewsStory(
                "https://fake.com.au",
                "Cockatoo behavior",
                "Cockatoos are eating cabbages"
        );

        NewsStory emus = new NewsStory(
                "https://morefake.com.au",
                "Emu movements",
                "Emus are massing"
        );

        StarPerson starPerson = new StarPerson("Lynda", "Scorpio");
        RelevantNewsStories relevantNewsStories = new RelevantNewsStories(Arrays.asList(cockatoos, emus));
        Horoscope horoscope = new Horoscope("This is a good day for you");

        starNewsFinder.writeup(starPerson, relevantNewsStories, horoscope, context);

        var prompt = context.getLlmInvocations().getFirst().getPrompt();
        var toolGroups = context.getLlmInvocations().getFirst().getInteraction().getToolGroups();


        assertTrue(prompt.contains(starPerson.getName()));
        assertTrue(prompt.contains(starPerson.sign()));
        assertTrue(prompt.contains(cockatoos.getSummary()));
        assertTrue(prompt.contains(emus.getSummary()));

        assertTrue(toolGroups.isEmpty(), "The LLM should not have been given any tool groups");
    }
}
```

## Dog Food Policy

We believe that all aspects of software development and business can and should
be greatly accelerated through the use of AI agents. The ultimate decision
makers remain human, but they can and should be greatly augmented.

> This project practices extreme dogfooding.

<!-- TODO photo of Duke with kibble -->

Our key principles:

1. **We will use AI agents to help every aspect of the project:** coding, documentation, community management, producing
   marketing copy etc.
   Any
   human performing a task should ask why it cannot be automated, and strive toward maximum automation.
2. **Developers retain ultimate control.** Developers are responsible for guiding agents toward the solution and
   iterating
   as necessary. A developer who commits or merges an agent contribution
   is responsible for ensuring that it meets the project coding standards, which are
   independent of the use of agents. For example, code must be human-readable.
3. **We will favour open source agents built on the Embabel platform,** and contribute improvements. While
   commercial agents
   may be more advanced in some areas, we believe that our
   platform is the best general solution for automation and by dogfooding we will improve it fastest.
   By open sourcing agents used on our open source projects, we will maximize benefit to the community.
4. **We will prioritize agents that help accelerate our progress.** Per the flight safety advice to fit your own mask
   before helping others, we will prioritize
   agents that help us accelerate our own progress. This will not only produce useful examples, but increase overall
   project velocity.

Developers must carefully read all code they commit and improve generated code if possible.

> Coding agents are a special case. While the `embabel-agent-code` submodule offers support for project modification
> that is useful for project bootstrapping, coding agents are the most mature of commercial agents, and their vendors
> are
> heavily subsidising their users, making it economically irrational to insist on our own platform.

## Getting Started

- Get the bits
- Set up your environment
- Run the application

### Getting the bits

Choose one of the following:

- Clone the repository via `git clone https://github.com/embabel/embabel-agent`
- Create a new Spring Boot project and add the necessary dependencies (see "Using Embabel Agent Framework in Your
  Project" below)

### Environment variables

> Environment variables are consistent with common usage, rather than Spring AI.
> For example, we prefer `OPENAI_API_KEY` to `SPRING_AI_OPENAI_API_KEY`.

Required:

- `OPENAI_API_KEY`: For the OpenAI API

Optional:

- `ANTHROPIC_API_KEY`: For the Anthropic API. Necessary for the coding agent.

> We strongly recommend providing both an OpenAI and Anthropic key, as some examples require both. And it's important to
> try to find the best LLM for a given task, rather than automatically choose a familiar provider.

### Services

You will need a Docker Desktop version [`>4.43.2`](https://docs.docker.com/desktop/release-notes/).
Be sure to activate the following MCP tools from the catalog:

- Brave Search
- Fetch
- Puppeteer
- Wikipedia

> You can also set up your own MCP tools using Spring AI conventions. See the `application-docker-desktop.yml` file for
> an example.

If you're running Ollama locally, set the `ollama` profile and Embabel will automatically connect to your Ollama
endpoint and make all models available.

### Running

Create your own agent project with

```
uvx --from git+https://github.com/embabel/project-creator.git project-creator
```

### Example Agents

> **📚 For examples and tutorials**, see
> the [Embabel Agent Examples Repository](https://github.com/embabel/embabel-agent-examples)

```bash
# Clone and run examples
git clone https://github.com/embabel/embabel-agent-examples
cd embabel-agent-examples/scripts/kotlin
./shell.sh
```

#### Shell Commands

Spring Shell is an easy way to interact with the Embabel agent framework, especially during development.

Type `help` to see available commands. Use `execute` or `x` to run an agent:

```
execute "Lynda is a Scorpio, find news for her" -p -r
```

This will look for an agent, choose the star finder agent and
run the flow. `-p` will log prompts `-r` will log LLM responses.
Omit these for less verbose logging.

Options:

- `-p` logs prompts
- `-r` logs LLM responses

Use the `chat` command to enter an interactive chat with the agent.
It will attempt to run the most appropriate
agent for each command.

> Spring Shell supports history. Type `!!` to repeat the last command.
> This will survive restarts, so is handy when iterating on an agent.

#### Further examples

Example commands within the shell:

```
# Perplexity style deep research
# Requires both OpenAI and Anthropic keys and Docker Desktop with the MCP extension (or your own web tools)
execute "research the recent australian federal election. what is the position of the greens party?"

# x is a shortcut for execute
x "fact check the following: holden cars are still made in australia; the koel is a bird native only to australia; fidel castro is justin trudeau's father"

```

### Bringing in additional LLMs

#### Local models with well-known providers

The Embabel Agent Framework supports local models from:

- Ollama: Simply set the `ollama` profile and your local Ollama endpoint will be queries. All local models will be
  available.
- Docker: Set the `docker` profile and your local Docker endpoint will be queried. All local models will be available.

#### Custom LLMs

You can define an LLM for any provider for which a Spring AI `ChatModel` is available.

Simply define Spring beans of type `Llm`.
See the `OpenAiConfiguration` class as an example.

Remember:

- Provide the knowledge cutoff date if you know it
- Make the configuration class conditional on any required API key.

## Roadmap

This project is in its early stages, but we have big plans.
The milestones and issues in this repository are a good reference.
Our key goals:

- **Become the natural way to Gen AI-enable Java applications**, and especially those built on Spring.
- **Prove the power of the approach**. Demonstrate that this approach is the best way to build safe, dependable, Gen AI
  applications.
  In particular:
    - Demonstrate the power of extensibility without modification, by adding goals and actions
    - Demonstrate the potential to become the PaaS for natural language
    - Demonstrate the potential of agent federation within the GOAP model
    - Demonstrate budget-aware agents, such as "Research the following topic, spending up to 20c if you are still
      learning"
    - Integrate with data stores and demonstrate the power of surfacing existing functionality inside an organization
- **Take the model to other platforms**: The conceptual framework is not JVM specific. Once established, we intend to
  create TypeScript
  and Python projects.

There is a lot to do, and you are awesome. We look forward to your contribution!

## Application Design

### Domain objects

Applications center around domain objects. These can be instantiated by LLMs or user
code, and manipulated by user code.

Use Jackson annotations to help LLMs with descriptions as well as mark fields to ignore.
For example:

```kotlin
@JsonClassDescription("Person with astrology details")
data class StarPerson(
    override val name: String,
    @get:JsonPropertyDescription("Star sign")
    val sign: String,
) : Person
```

See [Java Json Schema Generation - Module Jackson](https://github.com/victools/jsonschema-generator/tree/main/jsonschema-module-jackson)
for documentation of the library used.

Domain objects can have behaviors that are automatically exposed to LLMs when they are in scope. Simply annotate methods
with the Spring AI `@Tool` annotation.

> When exposing `@Tool` methods on domain objects, be sure that the tool is safe to invoke. Even the best LLMs can get
> trigger-happy. For example, be careful about methods that can mutate or delete data. This is likely better modeled via
> an explicit call to a non-tool method on the same domain class, in a code action.

## Using Embabel as an MCP server

You can use the Embabel agent platform as an MCP server from a
UI like Claude Desktop. The Embabel MCP server is available over SSE.

Configure Claude Desktop as follows in your `claude_desktop_config.yml`:

```json
{
  "mcpServers": {
    "embabel": {
      "command": "npx",
      "args": [
        "-y",
        "mcp-remote",
        "http://localhost:8080/sse"
      ]
    }
  }
}

```

See [MCP Quickstart for Claude Desktop Users](https://modelcontextprotocol.io/quickstart/user) for how to configure
Claude Desktop.

The [MCP Inspector](https://github.com/modelcontextprotocol/inspector) is a helpful tool for interacting with your
Embabel
SSE server, manually invoking tools and checking the exposed prompts and resources.

Start the MCP Inspector with:

```bash
npx @modelcontextprotocol/inspector
```

## Consuming MCP Servers

The Embabel Agent Framework provides built-in support for consuming Model Context Protocol (MCP) servers, allowing you
to extend your applications with powerful AI capabilities through standardized interfaces.

### What is MCP?

Model Context Protocol (MCP) is an open protocol that standardizes how applications provide context and extra
functionality to large language models. Introduced by Anthropic, MCP has emerged as the de facto standard for connecting
AI agents to tools, functioning as a client-server protocol where:

- **Clients** (like Embabel Agent) send requests to servers
- **Servers** process those requests to deliver necessary context to the AI model

MCP simplifies integration between AI applications and external tools, transforming an "M×N problem" into an "M+N
problem" through standardization - similar to what USB did for hardware peripherals.

### Configuring MCP in Embabel Agent

To configure MCP servers in your Embabel Agent application, add the following to your `application.yml`:

```yaml
spring:
  ai:
    mcp:
      client:
        enabled: true
        name: embabel
        version: 1.0.0
        request-timeout: 30s
        type: SYNC
        stdio:
          connections:
            docker-mcp:
              command: docker
              args:
                - run
                - -i
                - --rm
                - alpine/socat
                - STDIO
                - TCP:host.docker.internal:8811
```

This configuration sets up an MCP client that connects to a Docker-based MCP server. The connection uses STDIO transport
through Docker's socat utility to connect to a TCP endpoint.

### Docker Desktop MCP Integration

Docker has embraced MCP with their Docker MCP Catalog and Toolkit, which provides:

1. **Centralized Discovery** - A trusted hub for discovering MCP tools integrated into Docker Hub
2. **Containerized Deployment** - Run MCP servers as containers without complex setup
3. **Secure Credential Management** - Centralized, encrypted credential handling
4. **Built-in Security** - Sandbox isolation and permissions management

The Docker MCP ecosystem includes over 100 verified tools from partners like Stripe, Elastic, Neo4j, and more, all
accessible through Docker's infrastructure.

### Learn More

- [Docker MCP Documentation](https://docs.docker.com/desktop/features/gordon/mcp/)
- [Docker MCP Servers Repository](https://github.com/docker/mcp-servers)
- [Introducing Docker MCP Catalog and Toolkit](https://www.docker.com/blog/introducing-docker-mcp-catalog-and-toolkit/)
- [MCP Introduction and Overview](https://www.philschmid.de/mcp-introduction)

## A2A

Embabel integrates with the [A2A](https://github.com/google-a2a/A2A) protocol, allowing you to connect to other
A2A-enabled agents and
services.

Enable the `a2a` Spring profile to start the A2A server.

You'll need the following environment variable:

- `GOOGLE_STUDIO_API_KEY`: Your Google Studio API key, which is used for Gemini.

Start the Google A2A web interface using the `a2a` Docker profile:

```bash
docker compose --profile a2a up
```

Go to the web interface running within the container at `http://localhost:12000/`.

Connect to your agent at `host.docker.internal:8080/a2a`. Note that `localhost:8080/a2a` won't work as the server
cannot access it when running in a Docker container.

## Running Tests

Run the tests via Maven.

```bash
mvn test
```

This will run both unit and integration tests
but will not require an internet connection or any external services.

## Spring profiles

Spring profiles are used to configure the application for different environments and behaviors.

Interaction profiles:

- `shell`: Runs agent in interactive shell. Does not start web process.

Model profiles:

- `ollama`: Looks for Ollama models. You will need to have Ollama installed locally and the relevant models pulled.
- `docker-desktop`: Looks for Docker-managed local models when running outside Docker but talking to Docker Desktop with
  the MCP extension. **This is recommended for the best experience, with Docker-provided web tools.**
- `docker`: Looks for Docker-managed local models when running in a Docker container.

Logging profiles:

- `severance`: [Severance](https://www.youtube.com/watch?v=xEQP4VVuyrY&ab_channel=AppleTV) specific logging. Praise
  Kier!
- `starwars`: Star Wars specific logging. Feel the force
- `colossus`: Colossus specific logging. The Forbin Project.

## Testing

A key goal of this framework is ease of testing.
Just as Spring eased testing of early enterprise Java applications,
this framework facilitates testing of AI applications.

Types of testing:

- Unit tests: All agents are unit testable, like any Spring-managed beans. Construct them with mock objects; call
  individual action methods. The testing library facilitates testing prompts.
- Integration tests: tbd

## Logging

All logging in this project is either debug logging in the relevant
class itself, or results from the stream of events of type `AgentEvent`.

Edit `application.yml` if you want to see debug logging from the relevant classes and packages.

Available logging experiences:

- `severance`: Severance logging. Praise Kier
- `starwars`: Star Wars logging. Feel the force. The default as it's understood throughout the galaxy.
- `colossus`: Colossus logging. The Forbin Project.
- `montypython`: Monty Python logging. No one expects it.
- `hh`: Hitchhiker's Guide to the Galaxy logging. The answer is 42.

If none of these profiles is chosen, Embabel will use vanilla logging.
This makes me sad.

## Adding Embabel Agent Framework to Your Project

### Maven

The easiest way is to add the Embabel Spring Boot starter dependency to your `pom.xml`:

```xml

<dependency>
    <groupId>com.embabel.agent</groupId>
    <artifactId>embabel-agent-starter</artifactId>
    <version>${embabel-agent.version}</version>
</dependency>
```

### Gradle (Kotlin DSL)

Add the required repositories to your `build.gradle.kts`:

```kotlin
repositories {
    mavenCentral()
    maven {
        name = "embabel-releases"
        url = uri("https://repo.embabel.com/artifactory/libs-release")
        mavenContent {
            releasesOnly()
        }
    }
    maven {
        name = "embabel-snapshots"
        url = uri("https://repo.embabel.com/artifactory/libs-snapshot")
        mavenContent {
            snapshotsOnly()
        }
    }
    maven {
        name = "Spring Milestones"
        url = uri("https://repo.spring.io/milestone")
    }
}
```

Add the Embabel Agent starter:

```kotlin
dependencies {
    implementation('com.embabel.agent:embabel-agent-starter:${embabel-agent.version}')
}
```

### Gradle (Groovy DSL)

Add the required repositories to your `build.gradle`:

```groovy
repositories {
    mavenCentral()
    maven {
        name = 'embabel-snapshots'
        url = 'https://repo.embabel.com/artifactory/libs-snapshot'
        mavenContent {
            snapshotsOnly()
        }
    }
    maven {
        name = 'Spring Milestones'
        url = 'https://repo.spring.io/milestone'
    }
}
```

Add the Embabel Agent starter:

```groovy
dependencies {
    implementation 'com.embabel.agent:embabel-agent-starter:0.1.0-SNAPSHOT'
}
```

> **Note:** The Spring Milestones repository is required because the Embabel BOM (`embabel-agent-dependencies`) has
> transitive dependencies on experimental Spring components, specifically the `mcp-bom`. This BOM is not available on
> Maven Central and is only published to the Spring milestone repository. Unlike Maven, Gradle does not inherit
> repository
> configurations declared in parent POMs or BOMs. Therefore, it is necessary to explicitly declare the Spring milestone
> repository in your repositories block to ensure proper resolution of all transitive dependencies.

## Repository

Binary Packages are located in Embabel Maven Repository.
You would need to add Embabel Snapshot Repository to your pom.xml or configure in settings.xml

```xml

<repositories>
    <repository>
        <id>embabel-releases</id>
        <url>https://repo.embabel.com/artifactory/libs-release</url>
        <releases>
            <enabled>true</enabled>
        </releases>
        <snapshots>
            <enabled>false</enabled>
        </snapshots>
    </repository>
    <repository>
        <id>embabel-snapshots</id>
        <url>https://repo.embabel.com/artifactory/libs-snapshot</url>
        <releases>
            <enabled>false</enabled>
        </releases>
        <snapshots>
            <enabled>true</enabled>
        </snapshots>
    </repository>
</repositories>
```

## Contributing

We welcome contributions to the Embabel Agent Framework.

Look at the [coding style guide](embabel-agent-api/.embabel/coding-style.md) for style guidelines.
This file also informs coding agent behavior.

## Miscellaneous

- _Why the name Embabel?_
  The "babel" part is ultimately inspired by the story of the Tower of Babel, perhaps via Douglas
  Adams' [babelfish](https://www.youtube.com/watch?v=iuumnjJWFO4&ab_channel=BBCStudios).
  Per @lasuac:
  _While Adams' fish in the ear enabled universal translation between species, Embabel aims at translating human intent
  to JVM code, AI models, and enterprise systems._
  "embabel" also sounds like "enable."
- Milestone names are Australian animals. Mythical animals such as "bunyip" and "yowie" are used for futures that may or
  not be implemented.
- README badges come from [here](https://github.com/Ileriayo/markdown-badges)
  and [here](https://home.aveek.io/GitHub-Profile-Badges/).
- Don't forget to join [Discord](https://discord.gg/t6bjkyj93q) to collaborate with the Embabel community. It is a good
  place to receive support, showcase your work, discuss ideas and connect with like-minded people.

## Star history

[![Star History Chart](https://api.star-history.com/svg?repos=embabel/embabel-agent&type=Date)](https://star-history.com/#embabel/embabel-agent&Date)

## Contributors

[![Embabel contributors](https://contrib.rocks/image?repo=embabel/embabel-agent)](https://github.com/embabel/embabel-agent/graphs/contributors)



--------------------
(c) Embabel Software Inc 2024-2025.



================================================
FILE: CLAUDE.md
================================================
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Important

- ALL instructions within this document MUST BE FOLLOWED, these are not optional unless explicitly stated.
- ASK FOR CLARIFICATION If you are uncertain of anything within the document.
- DO NOT edit more code than you have to.
- DO NOT WASTE TOKENS, be succinct and concise.

## Coding Style

IMPORTANT: Adhere to coding style in `.embabel/coding-style.md` for coding style guidance.

## Working Approach

You should work test first.

IMPORTANT: You should build the most relevant project (closest pom.xml) with Maven before
presenting finished changes. Run the individual tests you have changed
or that are most relevant.

## Advice for Documentation in embabel-agent-docs

When working on documentation in the `embabel-agent-docs` module, follow these guidelines:

Use Asciidoctor syntax for writing documentation.

When asked to edit a particular .adoc file, look for a parallel file with a name prefixed with a . for instructions.

For example, if you are asked to edit `tools.adoc`, look for `.tools.adoc` for specific instructions about how to go
about it.
Thus you will be given a combination of user instructions such as ("edit tools.adoc to cover the FooBar tool in
FooBar.kt").
You will follow the user instruction but bear in mind the instructions in any .tools.adoc file.
If there is no .<filename>.adoc file, follow the general instructions in this document.

When writing documentation, ensure that you cover the following general instructions:

NEVER make up code unless asked. Code examples must come from the following repositories:

- This repository
- The `embabel-agent-examples` repository at https://github.com/embabel/embabel-agent-examples/
- The `java-agent-template` repository at https://github.com/embabel/java-agent-template/
- Other repositories the user specifically asks you to use.






================================================
FILE: CODE_OF_CONDUCT.md
================================================
# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
  advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
  address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
community@embabel.com.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.0, available at
https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.

Community Impact Guidelines were inspired by [Mozilla's code of conduct
enforcement ladder](https://github.com/mozilla/diversity).

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see the FAQ at
https://www.contributor-covenant.org/faq. Translations are available at
https://www.contributor-covenant.org/translations.



================================================
FILE: flake.lock
================================================
{
  "nodes": {
    "flake-utils": {
      "inputs": {
        "systems": "systems"
      },
      "locked": {
        "lastModified": 1731533236,
        "owner": "numtide",
        "repo": "flake-utils",
        "rev": "11707dc2f618dd54ca8739b309ec4fc024de578b",
        "type": "github"
      },
      "original": {
        "owner": "numtide",
        "repo": "flake-utils",
        "type": "github"
      }
    },
    "nixpkgs": {
      "locked": {
        "lastModified": 1750741721,
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "4b1164c3215f018c4442463a27689d973cffd750",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "flake-utils": "flake-utils",
        "nixpkgs": "nixpkgs"
      }
    },
    "systems": {
      "locked": {
        "lastModified": 1681028828,
        "narHash": "sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=",
        "owner": "nix-systems",
        "repo": "default",
        "rev": "da67096a3b9bf56a91d16901293e51ba5b49a27e",
        "type": "github"
      },
      "original": {
        "owner": "nix-systems",
        "repo": "default",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}



================================================
FILE: flake.nix
================================================
{
  description = "Embabel Agent Framework - JVM-based AI agent framework";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, nixpkgs, flake-utils, ... }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.${system};
        
        jdk = pkgs.jdk21; # Spring Boot 3.x requires JDK 17+, JDK 21 is LTS
        
        # Build the project
        embabel-agent = pkgs.stdenv.mkDerivation {
          pname = "embabel-agent";
          version = "0.1.0-SNAPSHOT";
          
          src = ./.;
          
          nativeBuildInputs = [ pkgs.makeWrapper ];
          buildInputs = [ jdk pkgs.maven ];
          
          buildPhase = ''
            export JAVA_HOME=${jdk}
            mvn clean package -DskipTests
          '';
          
          installPhase = ''
            mkdir -p $out/lib $out/bin
            cp embabel-agent-shell/target/*.jar $out/lib/
            
            makeWrapper ${jdk}/bin/java $out/bin/embabel-agent \
              --add-flags "-jar $out/lib/embabel-agent-shell-*.jar" \
              --set JAVA_HOME ${jdk}
          '';
        };
        
      in
      {
        packages = {
          default = embabel-agent;
          inherit embabel-agent;
        };
        
        devShells.default = pkgs.mkShell {
          buildInputs = with pkgs; [
            # Java/Kotlin development
            jdk
            maven
            kotlin
            gradle # Alternative build tool
            
            # Development tools
            jdt-language-server # Java LSP
            kotlin-language-server
            
            # Database tools (for testing)
            postgresql
            redis
            
            # Container tools
            docker
            docker-compose
            
            # Additional tools
            git
            jq
            httpie
            curl
            
            # IDE support
            jetbrains.idea-community
          ];
          
          shellHook = ''
            export JAVA_HOME=${jdk}
            export PATH=$JAVA_HOME/bin:$PATH
            
            echo "Embabel Agent Development Environment"
            echo "====================================="
            echo "Java version: $(java -version 2>&1 | head -n 1)"
            echo "Maven version: $(mvn -version | head -n 1)"
            echo "Kotlin version: $(kotlin -version 2>&1)"
            echo ""
            echo "Common commands:"
            echo "  mvn clean install       - Build entire project"
            echo "  mvn test               - Run tests"
            echo "  mvn spring-boot:run    - Run application"
            echo ""
            echo "Run with shell profile:"
            echo "  mvn spring-boot:run -Dspring.profiles.active=shell"
            echo ""
            echo "Environment variables needed:"
            echo "  export OPENAI_API_KEY=your-key"
            echo "  export ANTHROPIC_API_KEY=your-key (optional)"
          '';
        };
        
        # Additional specialized shells
        devShells = {
          # Minimal shell for CI/CD
          ci = pkgs.mkShell {
            buildInputs = with pkgs; [
              jdk
              maven
            ];
            
            shellHook = ''
              export JAVA_HOME=${jdk}
            '';
          };
          
          # Shell with documentation tools
          docs = pkgs.mkShell {
            buildInputs = with pkgs; [
              jdk
              maven
              asciidoctor
              graphviz # For dot files
              pandoc
            ];
            
            shellHook = ''
              export JAVA_HOME=${jdk}
              echo "Documentation shell - includes AsciiDoc tools"
              echo "Build docs with: mvn clean install -Pembabel-agent-docs"
            '';
          };
        };
        
        # Provide a simple app runner
        apps.default = flake-utils.lib.mkApp {
          drv = embabel-agent;
        };
      });
}


================================================
FILE: LICENSE
================================================
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.



================================================
FILE: pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.build</groupId>
        <artifactId>embabel-build-parent</artifactId>
        <version>0.1.6-SNAPSHOT</version>
    </parent>
    <groupId>com.embabel.agent</groupId>
    <artifactId>embabel-agent-parent</artifactId>
    <version>0.2.0-SNAPSHOT</version>
    <packaging>pom</packaging>
    <name>Embabel Agent Parent</name>
    <description>Parent POM for Embabel Agent Modules</description>

    <properties>
        <embabel-common.version>0.1.5-SNAPSHOT</embabel-common.version>
        <!-- Netty version for security vulnerability fixes - duplicate from build-dependencies -->
        <netty.version>4.1.125.Final</netty.version>
    </properties>

    <modules>
        <module>embabel-agent-api</module>
        <module>embabel-agent-a2a</module>
        <module>embabel-agent-autoconfigure</module>
        <module>embabel-agent-code</module>
        <module>embabel-agent-dependencies</module>
        <module>embabel-agent-eval</module>
        <module>embabel-agent-mcpserver</module>
        <module>embabel-agent-rag</module>
        <module>embabel-agent-shell</module>
        <module>embabel-agent-starters</module>
        <module>embabel-agent-test-support</module>
        <module>embabel-agent-ux</module>
        <module>embabel-agent-discord</module>
    </modules>

    <scm>
        <url>https://github.com/embabel/embabel-agent</url>
        <connection>scm:git:https://github.com/embabel/embabel-agent.git</connection>
        <developerConnection>scm:git:https://github.com/embabel/embabel-agent.git</developerConnection>
        <tag>HEAD</tag>
    </scm>

    <!-- Embabel Common BOM -->
    <dependencyManagement>
        <dependencies>
            <!-- Embabel Agent BOM -->
            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-dependencies</artifactId>
                <version>${project.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <!-- Embabel Common BOM -->
            <dependency>
                <groupId>com.embabel.common</groupId>
                <artifactId>embabel-common-dependencies</artifactId>
                <version>${embabel-common.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <!-- Embabel Common BOM -->
            <dependency>
                <groupId>com.embabel.common</groupId>
                <artifactId>embabel-common-test-dependencies</artifactId>
                <version>${embabel-common.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <!-- Netty Version Upgrades - Security Vulnerability Fixes -->
            <!-- 
              Force safe netty versions to fix multiple CVEs:
              - CVE-2025-58057 (GHSA-3p8m-j85q-pgmj): DoS via zip bomb in netty-codec
              - CVE-2025-58056 (GHSA-fghv-69vj-qj49): Request smuggling in netty-codec-http  
              - CVE-2025-59340 (GHSA-prj3-ccx8-p6x4): MadeYouReset HTTP/2 DDoS in netty-codec-http2
              
              Added to common parent to override all transitive netty dependencies across all modules.
            -->
            <dependency>
                <groupId>io.netty</groupId>
                <artifactId>netty-bom</artifactId>
                <version>${netty.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <dependencies>

        <!-- Unit and Integration Testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!--
        https://mvnrepository.com/artifact/org.jetbrains/annotations
        For Experimental annotation
        -->
        <dependency>
            <groupId>org.jetbrains</groupId>
            <artifactId>annotations</artifactId>
            <version>26.0.2</version>
            <scope>provided</scope>
        </dependency>

        <!-- Consider kotlin-test-junit5 for enhanced JUnit 5 integration (test discovery, parameterized tests) -->
        <dependency>
            <groupId>org.jetbrains.kotlin</groupId>
            <artifactId>kotlin-test</artifactId>
            <version>${kotlin.version}</version>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-testcontainers</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>junit-jupiter</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>com.ninja-squad</groupId>
            <artifactId>springmockk</artifactId>
            <scope>test</scope>
        </dependency>

    </dependencies>


    <build>
        <plugins>
            <plugin>
                <groupId>pl.project13.maven</groupId>
                <artifactId>git-commit-id-plugin</artifactId>
            </plugin>
            <plugin>
                <groupId>org.codehaus.mojo</groupId>
                <artifactId>build-helper-maven-plugin</artifactId>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-source-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

    <profiles>
        <!-- Build Embabel Agent Documentation -->
        <profile>
            <id>embabel-agent-docs</id>
            <activation>
                <activeByDefault>false</activeByDefault>
            </activation>
            <modules>
                <module>embabel-agent-docs</module>
            </modules>
        </profile>
    </profiles>


    <repositories>
        <repository>
            <id>embabel-releases</id>
            <url>https://repo.embabel.com/artifactory/libs-release</url>
            <snapshots>
                <enabled>false</enabled>
            </snapshots>
        </repository>
        <repository>
            <id>embabel-snapshots</id>
            <url>https://repo.embabel.com/artifactory/libs-snapshot</url>
            <releases>
                <enabled>false</enabled>
            </releases>
            <snapshots>
                <enabled>true</enabled>
            </snapshots>
        </repository>
    </repositories>


</project>



================================================
FILE: README-appendix.md
================================================
# Embabel Agent Goal Planning System

## Key Components and Their Relationships

### Action
- Core executable unit that performs a specific task
- Implements `GoapAction` interface and the `ActionRunner` interface
- Has preconditions (what must be true before it can run)
- Has effects (what becomes true after it runs)
- Contains inputs and outputs defined as `IoBinding` objects
- Can consume tools via the `ToolConsumer` interface
- Has a cost (computational expense) and value (benefit of execution)
- References transitions that define how action affects the system state

### Condition
- Represents a named predicate that can be evaluated
- Can be TRUE, FALSE, or UNKNOWN (via `ConditionDetermination`)
- Has a cost associated with evaluation
- Can be combined using logical operators (AND, OR, NOT)
- Used to define preconditions for Actions and Goals
- Evaluated against the current world state via `ProcessContext`

### Blackboard
- Shared memory system for maintaining context
- Implements `Bindable` interface for variable binding
- Stores objects in an ordered list accessible by name or type
- Can spawn independent child blackboards
- Can track condition values explicitly
- Acts as the repository for all data and objects in the system
- Used by the World State Determiner to derive current conditions

### WorldState
- Represents current state of the system as a map of conditions
- Key component in GOAP (Goal-Oriented Action Planning)
- Used to determine which actions are achievable
- Can generate variants with different condition values
- Foundation for planning algorithms

### Plan
- Sequence of Actions to achieve a Goal
- Has associated cost and value metrics
- Created by Planners (like `AStarGoapPlanner`)
- Represents the path from current state to goal state

### GoapPlanningSystem
- Collection of available Actions and Goals
- Tracks known preconditions and effects
- Used by planners to construct valid plans

## How They Work Together

### 1. Planning Process
- The `WorldStateDeterminer` reads the `Blackboard` to determine current conditions
- The `AStarGoapPlanner` uses A* algorithm to find optimal sequence of Actions
- Each Action's preconditions are checked against `WorldState`
- The planner constructs a `Plan` with lowest cost path to satisfy Goal conditions

### 2. Execution Flow
- Actions read inputs from and write outputs to the `Blackboard`
- Actions can only execute when their preconditions are satisfied
- When executed, Actions update the `WorldState` through their effects
- The system re-evaluates Conditions after each Action

### 3. State Management
- `Blackboard` maintains the actual objects and data
- `WorldState` maintains boolean conditions derived from `Blackboard`
- Conditions provide the evaluation logic to determine truth values
- Plans are re-assessed after each Action executes

This architecture implements Goal-Oriented Action Planning (GOAP), allowing the system to dynamically determine sequences of actions to achieve goals based on current conditions.

## Visualization

To review key components visually:
- Open Graphviz online: https://dreampuf.github.io/GraphvizOnline
- Paste the content of `embabel_planning_system.dot` in the left pane


================================================
FILE: .sonarcloud.properties
================================================
# Path to sources
#sonar.sources=.
#sonar.exclusions=
#sonar.inclusions=

# Path to tests
#sonar.tests=
#sonar.test.exclusions=
#sonar.test.inclusions=

# Source encoding
#sonar.sourceEncoding=UTF-8

# Exclusions for copy-paste detection
sonar.cpd.exclusions=**/embabel-agent-shell/**


================================================
FILE: embabel-agent-a2a/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-parent</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-a2a</artifactId>
    <packaging>jar</packaging>
    <name>Embabel A2A</name>
    <description>Embabel Agent To Agent Protocol</description>

    <dependencies>
        <!-- Main Dependencies -->
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-api</artifactId>
        </dependency>
        
   
        <!-- SLF4J for logging -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
        </dependency>
        
        <!-- Test Dependencies -->
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-test-internal</artifactId>
            <scope>test</scope>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.jetbrains.kotlin</groupId>
                <artifactId>kotlin-maven-plugin</artifactId>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
            </plugin>

        </plugins>
    </build>

</project>


================================================
FILE: embabel-agent-a2a/src/main/kotlin/com/embabel/agent/a2a/server/A2ARequestHandler.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.a2a.server

import io.a2a.spec.JSONRPCResponse
import io.a2a.spec.NonStreamingJSONRPCRequest
import io.a2a.spec.StreamingJSONRPCRequest
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter

/**
 * Handles JSON-RPC requests according to the A2A protocol.
 */
interface A2ARequestHandler {

    /**
     * Handle a JSON-RPC request according to the A2A protocol.
     * @param request the JSON-RPC request
     * @return the JSON-RPC response
     */
    fun handleJsonRpc(request: NonStreamingJSONRPCRequest<*>): JSONRPCResponse<*>

    /**
     * Handles a streaming JSON-RPC request using Server-Sent Events (SSE).
     * This method is called when a client requests a streaming response for methods like "message/stream".
     *
     * The default implementation throws [UnsupportedOperationException] as streaming is not supported.
     * Override this method in implementations that support streaming responses.
     *
     * @param request The JSON-RPC request containing the method name, parameters, and request ID
     * @return An [SseEmitter] that will be used to send streaming events to the client
     * @throws UnsupportedOperationException if streaming is not supported by this implementation
     * @see SseEmitter
     * @see StreamingJSONRPCRequest
     */
    fun handleJsonRpcStream(request: StreamingJSONRPCRequest<*>): SseEmitter {
        throw UnsupportedOperationException("Streaming not supported by this implementation")
    }
}



================================================
FILE: embabel-agent-a2a/src/main/kotlin/com/embabel/agent/a2a/server/AgentCardHandler.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.a2a.server

import com.embabel.common.core.types.HasInfoString
import io.a2a.spec.AgentCard

/**
 * Exposes an A2A AgentCard and handles JSON-RPC requests routed to its path
 */
interface AgentCardHandler : A2ARequestHandler, HasInfoString {

    /**
     * Relative path below root
     */
    val path: String

    /**
     * Returns the agent card for the A2A server.
     * We need to provide the scheme, host, and port so that the agent card
     * can compute the correct URL for its POST endpoint.
     */
    fun agentCard(scheme: String, host: String, port: Int): AgentCard

}



================================================
FILE: embabel-agent-a2a/src/main/kotlin/com/embabel/agent/a2a/server/AgentSkillFactory.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.a2a.server

import io.a2a.spec.AgentSkill

interface AgentSkillFactory {

    /**
     * Create a skill instance by its ID.
     */
    fun skills(namespace: String): List<AgentSkill>
}



================================================
FILE: embabel-agent-a2a/src/main/kotlin/com/embabel/agent/a2a/server/events.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.a2a.server

import com.embabel.agent.core.AgentPlatform
import com.embabel.agent.event.AgentPlatformEvent
import io.a2a.spec.JSONRPCRequest
import io.a2a.spec.JSONRPCResponse
import java.time.Instant

data class A2ARequestEvent(
    override val agentPlatform: AgentPlatform,
    val request: JSONRPCRequest<*>,
) : AgentPlatformEvent {
    override val timestamp: Instant = Instant.now()
}

data class A2AResponseEvent(
    override val agentPlatform: AgentPlatform,
    val response: JSONRPCResponse<*>,
) : AgentPlatformEvent {
    override val timestamp: Instant = Instant.now()
}



================================================
FILE: embabel-agent-a2a/src/main/kotlin/com/embabel/agent/a2a/server/config/A2AConfiguration.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.a2a.server.config

import com.embabel.agent.a2a.server.AgentCardHandler
import com.embabel.agent.a2a.server.support.AutonomyA2ARequestHandler
import com.embabel.agent.a2a.server.support.EmbabelServerGoalsAgentCardHandler
import com.embabel.agent.core.AgentPlatform
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.context.annotation.Profile

/**
 * Expose AgentCardHandler objects.
 * Each will be exposed as an A2A endpoint with the path "a2a".
 */
@Configuration
@Profile("a2a")
class A2AConfiguration {

    @Bean
    fun defaultAgentCardHandler(
        agentPlatform: AgentPlatform,
        a2aMessageHandler: AutonomyA2ARequestHandler,
    ): AgentCardHandler {
        return EmbabelServerGoalsAgentCardHandler(
            path = "a2a",
            agentPlatform = agentPlatform,
            a2ARequestHandler = a2aMessageHandler,
            goalFilter = { true },
        )
    }
}



================================================
FILE: embabel-agent-a2a/src/main/kotlin/com/embabel/agent/a2a/server/support/A2AEndpointRegistrar.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.a2a.server.support

import com.embabel.agent.a2a.server.AgentCardHandler
import com.fasterxml.jackson.databind.ObjectMapper
import io.a2a.spec.AgentCard
import io.a2a.spec.CancelTaskRequest
import io.a2a.spec.GetTaskRequest
import io.a2a.spec.JSONRPCError
import io.a2a.spec.JSONRPCErrorResponse
import io.a2a.spec.SendMessageRequest
import io.a2a.spec.SendStreamingMessageRequest
import jakarta.servlet.ServletRequest
import org.slf4j.LoggerFactory
import org.springframework.boot.context.event.ApplicationReadyEvent
import org.springframework.context.annotation.Profile
import org.springframework.context.event.EventListener
import org.springframework.http.MediaType
import org.springframework.http.ResponseEntity
import org.springframework.stereotype.Component
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMethod
import org.springframework.web.bind.annotation.ResponseBody
import org.springframework.web.servlet.mvc.method.RequestMappingInfo
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping

/**
 * Registers A2A endpoints for the agent-to-agent communication protocol.
 * Each AgentCardHandler passed in results in the creation of
 * a distinct endpoint with its own agent card.
 */
@Component
@Profile("a2a")
class A2AEndpointRegistrar(
    private val agentCardHandlers: List<AgentCardHandler>,
    private val requestMappingHandlerMapping: RequestMappingHandlerMapping,
    private val objectMapper: ObjectMapper,
) {

    private val logger = LoggerFactory.getLogger(A2AEndpointRegistrar::class.java)

    @EventListener
    fun onApplicationReady(event: ApplicationReadyEvent) {
        logger.info("Registering ${agentCardHandlers.size} A2A endpoints")
        agentCardHandlers.forEach { endpoint ->
            registerWebEndpoints(endpoint)
        }
    }

    private fun registerWebEndpoints(agentCardHandler: AgentCardHandler) {
        val endpointPath = "/${agentCardHandler.path}/.well-known/agent.json"
        logger.info(
            "Registering web endpoint under {} for {}",
            endpointPath,
            agentCardHandler.infoString(verbose = true),
        )
        val agentCardGetMapping = RequestMappingInfo.paths(endpointPath)
            .methods(RequestMethod.GET)
            .produces(MediaType.APPLICATION_JSON_VALUE)
            .build()
        val achwf = AgentCardHandlerWebFacade(
            agentCardHandler,
            objectMapper,
        )
        requestMappingHandlerMapping.registerMapping(
            agentCardGetMapping,
            achwf,
            achwf::class.java.getMethod("agentCard", ServletRequest::class.java),
        )

        val jsonRpcPostMethod = achwf.javaClass.getMethod(
            "handleJsonRpc",
            Map::class.java,
        )
        val jsonRpcPostMapping = RequestMappingInfo.paths(agentCardHandler.path)
            .methods(RequestMethod.POST)
            .consumes(MediaType.APPLICATION_JSON_VALUE)
            .produces(MediaType.APPLICATION_JSON_VALUE, MediaType.TEXT_EVENT_STREAM_VALUE)
            .build()
        requestMappingHandlerMapping.registerMapping(
            jsonRpcPostMapping,
            achwf,
            jsonRpcPostMethod,
        )
    }
}

private class AgentCardHandlerWebFacade(
    val agentCardHandler: AgentCardHandler,
    val objectMapper: ObjectMapper,
) {
    private val logger = LoggerFactory.getLogger(AgentCardHandlerWebFacade::class.java)

    @ResponseBody
    fun agentCard(servletRequest: ServletRequest): ResponseEntity<AgentCard> {
        val agentCard = agentCardHandler.agentCard(
            scheme = servletRequest.scheme,
            host = servletRequest.serverName,
            port = servletRequest.serverPort,
        )
        return ResponseEntity.ok()
            .contentType(MediaType.APPLICATION_JSON)
            .body(agentCard)
    }

    @ResponseBody
    fun handleJsonRpc(@RequestBody requestMap: Map<String, Any>): Any {
        return try {
            logger.debug("Received JSON-RPC request: {}", requestMap)
            val method = requestMap["method"] as? String

            return when (method) {
                SendStreamingMessageRequest.METHOD -> {
                    // For streaming requests, return the SseEmitter directly without wrapping
                    val request = objectMapper.convertValue(requestMap, SendStreamingMessageRequest::class.java)
                    agentCardHandler.handleJsonRpcStream(request)
                }
                else -> {
                    val request = when (method) {
                        SendMessageRequest.METHOD -> objectMapper.convertValue(requestMap, SendMessageRequest::class.java)
                        GetTaskRequest.METHOD -> objectMapper.convertValue(requestMap, GetTaskRequest::class.java)
                        CancelTaskRequest.METHOD -> objectMapper.convertValue(requestMap, CancelTaskRequest::class.java)
                        else -> {
                            throw UnsupportedOperationException("Method ${method} is not supported")
                        }
                    }
                    // Regular JSON-RPC handling
                    ResponseEntity.ok()
                        .contentType(MediaType.APPLICATION_JSON)
                        .body(agentCardHandler.handleJsonRpc(request))
                }
            }
        } catch (e: Exception) {
            val requestId = requestMap["id"]
            ResponseEntity.status(500)
                .contentType(MediaType.APPLICATION_JSON)
                .body(
                    JSONRPCErrorResponse(
                        requestId,
                        JSONRPCError(
                            500,
                            "Internal server error: ${e.message}",
                            null
                        )
                    )
                )
        }
    }
}



================================================
FILE: embabel-agent-a2a/src/main/kotlin/com/embabel/agent/a2a/server/support/A2AStreamingHandler.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.a2a.server.support

import com.fasterxml.jackson.databind.ObjectMapper
import io.a2a.spec.Message
import io.a2a.spec.SendStreamingMessageResponse
import io.a2a.spec.StreamingEventKind
import io.a2a.spec.Task
import io.a2a.spec.TaskArtifactUpdateEvent
import io.a2a.spec.TaskStatusUpdateEvent
import org.slf4j.LoggerFactory
import org.springframework.context.annotation.Profile
import org.springframework.http.MediaType
import org.springframework.stereotype.Service
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.Executors
import java.util.concurrent.ScheduledExecutorService
import java.util.concurrent.TimeUnit

/**
 * Handles streaming functionality for A2A messages
 */
@Service
@Profile("a2a")
class A2AStreamingHandler(
    private val objectMapper: ObjectMapper
) {
    private val logger = LoggerFactory.getLogger(A2AStreamingHandler::class.java)
    private val activeStreams = ConcurrentHashMap<String, SseEmitter>()
    private val scheduler: ScheduledExecutorService = Executors.newScheduledThreadPool(1)

    /**
     * Creates a new SSE stream for the given stream ID
     */
    fun createStream(streamId: String): SseEmitter {
        logger.info("Creating SSE stream for streamId: {}", streamId)

        val emitter = SseEmitter(Long.MAX_VALUE)
        activeStreams[streamId] = emitter

        emitter.onCompletion {
            logger.info("Stream completed for streamId: {}", streamId)
            activeStreams.remove(streamId)
        }

        emitter.onTimeout {
            logger.info("Stream timed out for streamId: {}", streamId)
            activeStreams.remove(streamId)
        }

        // Send initial connection established event
        try {
            emitter.send(SseEmitter.event()
                .name("connected")
                .data(mapOf("streamId" to streamId))
            )
        } catch (e: Exception) {
            logger.error("Error sending initial event", e)
            emitter.completeWithError(e)
        }

        return emitter
    }

    /**
     * Sends a streaming event to the specified stream
     */
    fun sendStreamEvent(streamId: String, event: StreamingEventKind) {
        val emitter = activeStreams[streamId] ?: run {
            logger.warn("No active stream found for streamId: {}", streamId)
            return
        }

        try {
            val eventData = when (event) {
                is Message -> {
                    SseEmitter.event()
                        .name("message")
                        .data(objectMapper.writeValueAsString(event), MediaType.APPLICATION_JSON)
                }
                is Task -> {
                    SseEmitter.event()
                        .name("task")
                        .data(objectMapper.writeValueAsString(event), MediaType.APPLICATION_JSON)
                }
                is TaskStatusUpdateEvent -> {
                    SseEmitter.event()
                        .name("task-update")
                        .data(
                            objectMapper.writeValueAsString(
                                SendStreamingMessageResponse(
                                    "2.0",
                                    streamId,
                                    event,
                                    null
                                )
                            ), MediaType.APPLICATION_JSON
                        )
                }
                is TaskArtifactUpdateEvent -> {
                    SseEmitter.event()
                        .name("task-update")
                        .data(
                            objectMapper.writeValueAsString(
                                SendStreamingMessageResponse(
                                    "2.0",
                                    streamId,
                                    event,
                                    null
                                )
                            ), MediaType.APPLICATION_JSON
                        )
                }
            }
            emitter.send(eventData)
        } catch (e: Exception) {
            logger.error("Error sending stream event", e)
            emitter.completeWithError(e)
        }
    }

    /**
     * Closes the specified stream
     */
    fun closeStream(streamId: String) {
        val emitter = activeStreams.remove(streamId)
        emitter?.complete()
    }

    /**
     * Shuts down the streaming handler
     */
    fun shutdown() {
        scheduler.shutdown()
        try {
            if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {
                scheduler.shutdownNow()
            }
        } catch (e: InterruptedException) {
            scheduler.shutdownNow()
        }
    }
}



================================================
FILE: embabel-agent-a2a/src/main/kotlin/com/embabel/agent/a2a/server/support/AutonomyA2ARequestHandler.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.a2a.server.support

import com.embabel.agent.a2a.server.A2ARequestEvent
import com.embabel.agent.a2a.server.A2ARequestHandler
import com.embabel.agent.a2a.server.A2AResponseEvent
import com.embabel.agent.api.common.autonomy.AgentProcessExecution
import com.embabel.agent.api.common.autonomy.Autonomy
import com.embabel.agent.core.ProcessOptions
import com.embabel.agent.event.AgenticEventListener
import io.a2a.spec.Artifact
import io.a2a.spec.CancelTaskRequest
import io.a2a.spec.CancelTaskResponse
import io.a2a.spec.DataPart
import io.a2a.spec.EventKind
import io.a2a.spec.GetTaskRequest
import io.a2a.spec.GetTaskResponse
import io.a2a.spec.JSONRPCErrorResponse
import io.a2a.spec.JSONRPCResponse
import io.a2a.spec.Message
import io.a2a.spec.MessageSendParams
import io.a2a.spec.NonStreamingJSONRPCRequest
import io.a2a.spec.SendMessageRequest
import io.a2a.spec.SendMessageResponse
import io.a2a.spec.SendStreamingMessageRequest
import io.a2a.spec.StreamingJSONRPCRequest
import io.a2a.spec.Task
import io.a2a.spec.TaskIdParams
import io.a2a.spec.TaskNotFoundError
import io.a2a.spec.TaskQueryParams
import io.a2a.spec.TaskState
import io.a2a.spec.TaskStatus
import io.a2a.spec.TaskStatusUpdateEvent
import io.a2a.spec.TextPart
import org.slf4j.LoggerFactory
import org.springframework.context.annotation.Profile
import org.springframework.stereotype.Service
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter
import java.time.LocalDateTime
import java.util.UUID

/**
 * Handle A2A messages according to the A2A protocol.
 * Doesn't dictate mapping to URLs: a router or controller
 * in front of this class must handle that.
 */
@Service
@Profile("a2a")
class AutonomyA2ARequestHandler(
    private val autonomy: Autonomy,
    private val agenticEventListener: AgenticEventListener,
    private val streamingHandler: A2AStreamingHandler,
) : A2ARequestHandler {

    private val logger = LoggerFactory.getLogger(A2ARequestHandler::class.java)

    override fun handleJsonRpcStream(request: StreamingJSONRPCRequest<*>): SseEmitter {
        return when (request) {
            is SendStreamingMessageRequest -> handleMessageStream(request)
            else -> throw UnsupportedOperationException("Method ${request.method} is not supported for streaming")
        }
    }

    override fun handleJsonRpc(
        request: NonStreamingJSONRPCRequest<*>
    ): JSONRPCResponse<*> {
        logger.info("Received JSONRPC message {}: {}", request.method, request::class.java.name)
        agenticEventListener.onPlatformEvent(
            A2ARequestEvent(
                agentPlatform = autonomy.agentPlatform,
                request = request,
            )
        )
        val result = when (request) {
            is SendMessageRequest -> {
                val messageSendParams = request.params
                handleMessageSend(request, messageSendParams)
            }

            is GetTaskRequest -> {
                val tqp = request.params
                handleTasksGet(request, tqp)
            }

            is CancelTaskRequest -> {
                val tip = request.params
                handleCancelTask(request, tip)
            }

            else -> {
                logger.warn("Unsupported method: {}", request.method)
                throw UnsupportedOperationException("Method ${request.method} is not supported")
            }
        }
        agenticEventListener.onPlatformEvent(
            A2AResponseEvent(
                agentPlatform = autonomy.agentPlatform,
                response = result,
            )
        )
        return result
    }

    private fun handleMessageSend(
        request: SendMessageRequest,
        params: MessageSendParams,
    ): JSONRPCResponse<*> {
        // TODO handle other message parts and handle errors
        val intent = params.message.parts.filterIsInstance<TextPart>().single().text
        logger.info("Handling message send request with intent: '{}'", intent)
        try {
            val result = autonomy.chooseAndRunAgent(
                intent = intent,
                processOptions = ProcessOptions(),
            )

            val task = Task.Builder()
                .id(ensureTaskId(params.message.taskId))
                .contextId(ensureContextId(params.message.contextId))
                .status(TaskStatus(TaskState.COMPLETED))
                .history(listOfNotNull(params.message))
                .artifacts(
                    listOf(
                        createResultArtifact(result, params.configuration?.acceptedOutputModes)
                    )
                )
                .build()

            val jSONRPCResponse = request.successResponseWith(result = task)
            logger.info("Handled message send request, response={}", jSONRPCResponse)
            return jSONRPCResponse
        } catch (e: Exception) {
            logger.error("Error handling message send request", e)
            // TODO other kinds of errors
            return JSONRPCErrorResponse(
                ensureTaskId(params.message.taskId),
                TaskNotFoundError(
                    null,
                   "Internal error: ${e.message}",
                    e.stackTraceToString()
                )
            )
        }
    }

    fun handleMessageStream(request: SendStreamingMessageRequest): SseEmitter {
        val params = request.params
        val streamId = request.id?.toString() ?: UUID.randomUUID().toString()
        val emitter = streamingHandler.createStream(streamId)

        Thread.startVirtualThread {
            try {
                // Send initial status event
                streamingHandler.sendStreamEvent(
                    streamId, TaskStatusUpdateEvent.Builder()
                        .taskId(params.message.taskId)
                        .contextId(params.message.contextId)
                        .status(createWorkingTaskStatus(params, "Task started..."))
                        .build()
                )

                // Send the received message, if any
                params.message?.let { userMsg ->
                    streamingHandler.sendStreamEvent(streamId, userMsg)
                }

                val intent = params.message?.parts?.filterIsInstance<TextPart>()?.firstOrNull()?.text
                    ?: "Task ${params.message.taskId}"

                // Execute the task using autonomy service
                val result = autonomy.chooseAndRunAgent(
                    intent = intent,
                    processOptions = ProcessOptions()
                )
                logger.debug("Task execution result: {}", result)

                // Send intermediate status updates
                streamingHandler.sendStreamEvent(
                    streamId, TaskStatusUpdateEvent.Builder()
                        .taskId(params.message.taskId)
                        .contextId(ensureContextId(params.message.contextId))
                        .status(createWorkingTaskStatus(params, "Processing task..."))
                        .build()
                )

                // Send result
                val taskResult = Task.Builder()
                    .id(params.message.taskId)
                    .contextId("ctx_${UUID.randomUUID()}")
                    .status(createCompletedTaskStatus(params))
                    .history(listOfNotNull(params.message))
                    .artifacts(
                        listOf(
                            createResultArtifact(result, params.configuration?.acceptedOutputModes)
                        )
                    )
                    .metadata(null)
                    .build()
                streamingHandler.sendStreamEvent(streamId, taskResult)
            } catch (e: Exception) {
                logger.error("Streaming error", e)
                try {
                    streamingHandler.sendStreamEvent(
                        streamId, TaskStatusUpdateEvent.Builder()
                            .taskId(params.message.taskId)
                            .contextId(ensureContextId(params.message.contextId))
                            .status(createFailedTaskStatus(params, e))
                            .build()
                    )
                } catch (sendError: Exception) {
                    logger.error("Error sending error event", sendError)
                }
            } finally {
                streamingHandler.closeStream(streamId)
            }
        }

        return emitter
    }

    private fun handleTasksGet(
        request: GetTaskRequest,
        params: TaskQueryParams,
    ): GetTaskResponse {
        TODO()
    }

    private fun handleCancelTask(
        request: CancelTaskRequest,
        tip: TaskIdParams,
    ): CancelTaskResponse {
        TODO()
    }

    private fun createFailedTaskStatus(params: MessageSendParams, e: Exception): TaskStatus = TaskStatus(
        TaskState.FAILED,
        Message.Builder()
            .messageId(UUID.randomUUID().toString())
            .role(Message.Role.AGENT)
            .parts(listOf(TextPart("Error: ${e.message}")))
            .contextId(params.message.contextId)
            .taskId(params.message.taskId)
            .build(),
        LocalDateTime.now()
    )

    private fun createCompletedTaskStatus(
        params: MessageSendParams,
        textPart: String = "Task completed successfully"
    ): TaskStatus = TaskStatus(
        TaskState.COMPLETED,
        Message.Builder()
            .messageId(UUID.randomUUID().toString())
            .role(Message.Role.AGENT)
            .parts(listOf(TextPart(textPart)))
            .contextId(params.message.contextId)
            .taskId(params.message.taskId)
            .build(),
        LocalDateTime.now()
    )

    private fun createWorkingTaskStatus(
        params: MessageSendParams,
        textPart: String = "Working..."
    ): TaskStatus = TaskStatus(
        TaskState.WORKING,
        Message.Builder()
            .messageId(UUID.randomUUID().toString())
            .role(Message.Role.AGENT)
            .parts(listOf(TextPart(textPart)))
            .contextId(params.message.contextId)
            .taskId(params.message.taskId)
            .build(),
        LocalDateTime.now()
    )

    private fun ensureContextId(providedContextId: String?): String {
        return providedContextId ?: ("ctx_" + UUID.randomUUID().toString())
    }

    private fun ensureTaskId(providedTaskId: String?): String {
        return providedTaskId ?: UUID.randomUUID().toString()
    }

    private fun createResultArtifact(
        result: AgentProcessExecution,
        acceptedOutputModes: List<String>? = emptyList()
    ): Artifact {
        // TODO result should be based on the outputMode received in the "params.configuration.acceptedOutputModes"
        return Artifact.Builder()
            .artifactId(UUID.randomUUID().toString())
            .parts(
                listOf(
                    DataPart(mapOf("output" to result.output))
                )
            )
            .build()
    }
}

fun SendMessageRequest.successResponseWith(result: EventKind): SendMessageResponse {
    return SendMessageResponse(
        this.id,
        result,
    )
}



================================================
FILE: embabel-agent-a2a/src/main/kotlin/com/embabel/agent/a2a/server/support/EmbabelServerGoalsAgentCardHandler.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.a2a.server.support

import com.embabel.agent.a2a.server.A2ARequestHandler
import com.embabel.agent.a2a.server.AgentCardHandler
import com.embabel.agent.core.AgentPlatform
import com.embabel.agent.core.Goal
import com.embabel.common.core.types.Semver
import com.embabel.common.util.indent
import io.a2a.spec.AgentCapabilities
import io.a2a.spec.AgentCard
import io.a2a.spec.AgentProvider
import org.slf4j.LoggerFactory

typealias GoalFilter = (Goal) -> Boolean

const val DEFAULT_A2A_PATH = "a2a"

/**
 * Expose one agent card for the whole server.
 * @param path Relative path of the endpoint (under the root)
 */
class EmbabelServerGoalsAgentCardHandler(
    override val path: String = DEFAULT_A2A_PATH,
    private val agentPlatform: AgentPlatform,
    private val a2ARequestHandler: A2ARequestHandler,
    private val goalFilter: GoalFilter,
) : AgentCardHandler, A2ARequestHandler by a2ARequestHandler {

    private val logger = LoggerFactory.getLogger(EmbabelServerGoalsAgentCardHandler::class.java)

    override fun agentCard(
        scheme: String,
        host: String,
        port: Int,
    ): AgentCard {
        val hostingUrl = "$scheme://$host:$port/$path"
        val agentCard = AgentCard.Builder()
            .name(agentPlatform.name)
            .description(agentPlatform.description)
            .url(hostingUrl)
            .provider(AgentProvider("Embabel", "https://embabel.com"))
            .version(Semver.DEFAULT_VERSION)
            .documentationUrl("https://embabel.com/docs")
            .capabilities(
                AgentCapabilities.Builder()
                    .streaming(false) // TODO are they planning to support streaming?
                    .pushNotifications(false)
                    .stateTransitionHistory(false)
                    .extensions(emptyList())
                    .build()
            )
            .defaultInputModes(listOf("application/json", "text/plain"))
            .defaultOutputModes(listOf("application/json", "text/plain"))
            .skills(
                FromGoalsAgentSkillFactory(
                    goals = agentPlatform.goals.filter { goalFilter.invoke(it) }.toSet(),
                ).skills(agentPlatform.name)
            )
            .supportsAuthenticatedExtendedCard(false)
            .protocolVersion("0.2.5")
            .build()
        logger.info("Returning agent card: {}", agentCard)
        return agentCard
    }

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String = "${javaClass.simpleName}(path='$path', agentPlatform=${agentPlatform.name})".indent(indent)
}



================================================
FILE: embabel-agent-a2a/src/main/kotlin/com/embabel/agent/a2a/server/support/FromGoalsAgentSkillFactory.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.a2a.server.support

import com.embabel.agent.a2a.server.AgentSkillFactory
import com.embabel.agent.core.Goal
import io.a2a.spec.AgentSkill

/**
 * Expose a skill for every goal defined in the agent platform.
 */
class FromGoalsAgentSkillFactory(
    private val goals: Set<Goal>,
) : AgentSkillFactory {

    override fun skills(namespace: String): List<AgentSkill> {
        return goals
            .map { goal ->
                AgentSkill(
                    "${namespace}_goal_${goal.name}",
                    goal.name,
                    goal.description,
                    goal.tags.toList(),
                    goal.examples.toList(),
                    listOf("application/json"),
                    listOf("application/json"),
                )
            }
    }
}



================================================
FILE: embabel-agent-a2a/src/main/resources/.gitkeep
================================================
ECHO is on.



================================================
FILE: embabel-agent-a2a/src/test/kotlin/com/embabel/agent/a2a/.gitkeep
================================================
ECHO is on.



================================================
FILE: embabel-agent-a2a/src/test/kotlin/com/embabel/agent/a2a/example/simple/horoscope/TestHoroscopeService.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.a2a.example.simple.horoscope

fun interface TestHoroscopeService {

    fun dailyHoroscope(sign: String): String
}



================================================
FILE: embabel-agent-a2a/src/test/kotlin/com/embabel/agent/a2a/example/simple/horoscope/kotlin/TestStarNewsFinder.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.a2a.example.simple.horoscope.kotlin

import com.embabel.agent.a2a.example.simple.horoscope.TestHoroscopeService
import com.embabel.agent.api.annotation.AchievesGoal
import com.embabel.agent.api.annotation.Action
import com.embabel.agent.api.annotation.Agent
import com.embabel.agent.api.annotation.fromForm
import com.embabel.agent.api.common.OperationContext
import com.embabel.agent.api.common.createObject
import com.embabel.agent.api.common.createObjectIfPossible
import com.embabel.agent.core.CoreToolGroups
import com.embabel.agent.domain.io.UserInput
import com.embabel.agent.domain.library.HasContent
import com.embabel.agent.domain.library.Person
import com.embabel.agent.domain.library.RelevantNewsStories
import com.embabel.common.ai.model.LlmOptions
import com.embabel.common.ai.model.ModelSelectionCriteria.Companion.Auto
import com.embabel.ux.form.Text
import com.fasterxml.jackson.annotation.JsonClassDescription
import com.fasterxml.jackson.annotation.JsonPropertyDescription
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import org.springframework.beans.factory.annotation.Value

/**
 * Data class representing astrological details for a person.
 * Used to capture star sign information through a form interface.
 */
@JsonClassDescription("Astrological details for a person")
data class Starry(
    @Text(label = "Star sign")
    val sign: String,
)

/**
 * Data class representing a person with their astrological details.
 * Implements the Person interface to maintain compatibility with the agent framework's
 * person-related operations.
 */
@JsonClassDescription("Person with astrology details")
@JsonDeserialize(`as` = StarPerson::class)
data class StarPerson(
    override val name: String,
    @get:JsonPropertyDescription("Star sign")
    val sign: String,
) : Person

/**
 * Data class containing a person's horoscope summary.
 * Acts as a container for the horoscope text retrieved from the HoroscopeService.
 */
data class Horoscope(
    val summary: String,
)

/**
 * Data class representing the final output of the agent's workflow.
 * Implements HasContent interface to provide standardized access to the text content.
 */
data class Writeup(
    override val content: String,
) : HasContent

/**
 * An agent that finds personalized news stories based on a person's star sign.
 */
@Agent(
    description = "Find news based on a person's star sign",
    scan = true,
    beanName = "KotlinStarNewsFinder",
)
class TestStarNewsFinder(
    private val horoscopeService: TestHoroscopeService,
    @param:Value("\${star-news-finder.story.count:5}")
    private val storyCount: Int,
    @param:Value("\${star-news-finder.word.count:100}")
    private val wordCount: Int,
) {

    @Action
    fun extractPerson(
        userInput: UserInput,
        context: OperationContext,
    ): Person? =
        // All prompts are typesafe
        context.ai().withDefaultLlm().createObjectIfPossible(
            """
            Create a person from this user input, extracting their name:
            ${userInput.content}
            """.trimIndent()
        )

    /**
     * Collects astrological details for a person through a form interface.
     *
     * This method is marked with a high cost (100.0) to indicate that it should
     * only be used when no other path is available in the agent's planning process.
     * The high cost discourages the agent from asking for user input unless necessary.
     *
     * @param person The person for whom to collect star sign information
     * @return A Starry object containing the person's star sign
     */
    @Action(cost = 100.0) // Make it costly so it won't be used in a plan unless there's no other path
    internal fun makeStarry(
        person: Person,
    ): Starry =
        fromForm("Let's get some astrological details for ${person.name}")

    /**
     * Combines a person and their astrological details into a StarPerson object.
     *
     * This method serves as a data transformation step in the agent workflow,
     * creating a specialized person object that includes star sign information.
     *
     * @param person The basic person information
     * @param starry The astrological details
     * @return A StarPerson object combining both sets of information
     */
    @Action
    fun assembleStarPerson(
        person: Person,
        starry: Starry,
    ): StarPerson {
        return StarPerson(
            name = person.name,
            sign = starry.sign,
        )
    }

    /**
     * Extracts both person information and star sign directly from user input.
     *
     * This method provides an alternative entry point to the agent workflow,
     * allowing the extraction of both name and star sign in a single step when
     * that information is present in the user's input.
     *
     * @param userInput The user's text input
     * @return A StarPerson object if extraction is successful, null otherwise
     */
    @Action
    fun extractStarPerson(
        userInput: UserInput,
        context: OperationContext,
    ): StarPerson? =
        context.ai().withAutoLlm().createObjectIfPossible(
            """
            Create a person from this user input, extracting their name and star sign:
            ${userInput.content}
            """.trimIndent()
        )

    /**
     * Retrieves a daily horoscope for a person based on their star sign.
     *
     * This method calls the injected HoroscopeService to get the actual horoscope text,
     * wrapping it in a Horoscope data class for use in subsequent steps.
     *
     * @param starPerson The person with their star sign information
     * @return A Horoscope object containing the daily horoscope text
     */
    @Action
    fun retrieveHoroscope(starPerson: StarPerson) =
        Horoscope(horoscopeService.dailyHoroscope(starPerson.sign))

    /**
     * Finds news stories relevant to a person's horoscope using web search tools.
     *
     * This method requires web tools (specified by toolGroups) to search for and
     * summarize news stories that relate to themes in the person's horoscope.
     * It uses the LLM to interpret the horoscope, generate appropriate search
     * queries, and summarize the results.
     *
     * @param person The person with their star sign
     * @param horoscope The person's daily horoscope
     * @return A collection of relevant news stories with summaries and URLs
     */
    // toolGroups specifies tools that are required for this action to run
    @Action(toolGroups = [CoreToolGroups.WEB, CoreToolGroups.BROWSER_AUTOMATION])
    internal fun findNewsStories(
        person: StarPerson,
        horoscope: Horoscope,
        context: OperationContext,
    ): RelevantNewsStories =
        context.ai().withDefaultLlm() createObject (
                """
            ${person.name} is an astrology believer with the sign ${person.sign}.
            Their horoscope for today is:
                <horoscope>${horoscope.summary}</horoscope>
            Given this, use web tools and generate search queries
            to find $storyCount relevant news stories summarize them in a few sentences.
            Include the URL for each story.
            Do not look for another horoscope reading or return results directly about astrology;
            find stories relevant to the reading above.

            For example:
            - If the horoscope says that they may
            want to work on relationships, you could find news stories about
            novel gifts
            - If the horoscope says that they may want to work on their career,
            find news stories about training courses.
            """.trimIndent()
                )

    /**
     * Creates a personalized writeup combining the horoscope and relevant news stories.
     *
     * This method is the final step in the agent's workflow, marked with @AchievesGoal
     * to indicate that it fulfills the agent's primary purpose. It uses the LLM with
     * increased temperature (0.9) to generate creative content that combines the
     * horoscope interpretation with the found news stories in an amusing way.
     *
     * @param person The person with their star sign
     * @param relevantNewsStories The collection of news stories found
     * @param horoscope The person's daily horoscope
     * @return A Writeup containing the formatted text combining horoscope and news
     */
    // The @AchievesGoal annotation indicates that completing this action
    // achieves the given goal, so the agent flow can be complete
    @AchievesGoal(
        description = "Create an amusing writeup for the target person based on their horoscope and current news stories",
    )
    @Action
    fun starNewsWriteup(
        person: StarPerson,
        relevantNewsStories: RelevantNewsStories,
        horoscope: Horoscope,
        context: OperationContext,
    ): Writeup = context.ai().withLlm(
        LlmOptions(Auto).withTemperature(.9)
    ).createObject<Writeup>(
        """
        Take the following news stories and write up something
        amusing for the target person in $wordCount words.

        Begin by summarizing their horoscope in a concise, amusing way, then
        talk about the news. End with a surprising signoff.

        ${person.name} is an astrology believer with the sign ${person.sign}.
        Their horoscope for today is:
            <horoscope>${horoscope.summary}</horoscope>
        Relevant news stories are:
        ${relevantNewsStories.items.joinToString("\n") { "- ${it.url}: ${it.summary}" }}

        Format it as Markdown with links.
        """.trimIndent()
    )

}



================================================
FILE: embabel-agent-a2a/src/test/kotlin/com/embabel/agent/a2a/server/A2AWebIntegrationTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.a2a.server

import com.embabel.agent.api.annotation.support.AgentMetadataReader
import com.embabel.agent.core.AgentPlatform
import com.embabel.agent.a2a.server.config.FakeAiConfiguration
import com.embabel.agent.a2a.server.config.FakeRankerConfiguration
import com.embabel.agent.a2a.example.simple.horoscope.TestHoroscopeService
import com.embabel.agent.a2a.example.simple.horoscope.kotlin.TestStarNewsFinder
import com.embabel.common.core.types.Semver.Companion.DEFAULT_VERSION
import com.fasterxml.jackson.databind.ObjectMapper
import io.a2a.spec.AgentCard
import io.a2a.spec.CancelTaskResponse
import io.a2a.spec.GetTaskPushNotificationConfigResponse
import io.a2a.spec.GetTaskResponse
import io.a2a.spec.JSONRPCRequest
import io.a2a.spec.Message
import io.a2a.spec.MessageSendParams
import io.a2a.spec.PushNotificationAuthenticationInfo
import io.a2a.spec.PushNotificationConfig
import io.a2a.spec.SendMessageRequest
import io.a2a.spec.SendMessageResponse
import io.a2a.spec.SetTaskPushNotificationConfigResponse
import io.a2a.spec.Task
import io.a2a.spec.TaskIdParams
import io.a2a.spec.TaskPushNotificationConfig
import io.a2a.spec.TaskQueryParams
import io.a2a.spec.TaskState
import io.a2a.spec.TextPart
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Disabled
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.autoconfigure.EnableAutoConfiguration
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.context.annotation.Import
import org.springframework.http.MediaType
import org.springframework.test.context.ActiveProfiles
import org.springframework.test.web.servlet.MockMvc
import org.springframework.test.web.servlet.get
import org.springframework.test.web.servlet.post
import org.springframework.test.web.servlet.result.MockMvcResultMatchers.status
import kotlin.test.assertEquals
import kotlin.test.assertNotNull
import kotlin.test.assertTrue

@SpringBootTest
@ActiveProfiles(value = ["test", "a2a"])
@AutoConfigureMockMvc(addFilters = false)
@EnableAutoConfiguration
@Import(
    value = [
        FakeAiConfiguration::class,
        FakeRankerConfiguration::class,
    ]
)
class A2AWebIntegrationTest(
    @Autowired
    private val mockMvc: MockMvc,
    @Autowired
    private val agentPlatform: AgentPlatform,
    @Autowired
    private val objectMapper: ObjectMapper,
    @Autowired
    private val horoscopeService: TestHoroscopeService,
) {

    @BeforeEach
    fun setup() {
        AgentMetadataReader().createAgentScopes(
            TestStarNewsFinder(
                horoscopeService = horoscopeService,
                wordCount = 100,
                storyCount = 5,
            ),
        ).forEach { agentPlatform.deploy(it) }
    }

    @Nested
    inner class AgentCardTests {
        @Test
        fun `should return agent card`() {
            val result = mockMvc.get("/a2a/.well-known/agent.json")
                .andExpect {
                    status().isOk()
                    content { contentType(MediaType.APPLICATION_JSON) }
                }.andReturn()

            val content = result.response.contentAsString
            val agentCard = objectMapper.readValue(content, AgentCard::class.java)

            assertNotNull(agentCard)
            assertNotNull(agentCard.name)
            assertNotNull(agentCard.description)
            assertTrue(
                agentCard.url.contains("localhost"),
                "Agent card url should expose localhost: '${agentCard.url}'"
            )
            assertTrue(agentCard.url.contains(":"), "Agent card url should expose port: '${agentCard.url}'")
            assertEquals("Embabel", agentCard.provider?.organization)
            assertEquals("https://embabel.com", agentCard.provider?.url)
            assertEquals(DEFAULT_VERSION, agentCard.version)
            assertEquals("https://embabel.com/docs", agentCard.documentationUrl)
            assertEquals(false, agentCard.capabilities.streaming)
            assertEquals(false, agentCard.capabilities.pushNotifications)
            assertEquals(false, agentCard.capabilities.stateTransitionHistory)
            assertEquals(listOf("application/json", "text/plain"), agentCard.defaultInputModes)
            assertEquals(listOf("application/json", "text/plain"), agentCard.defaultOutputModes)
//            assertTrue(agentCard.skills.isNotEmpty(), "Must have some skills")
//            assertEquals("echo", agentCard.skills[0].id)
//            assertEquals("Echo", agentCard.skills[0].name)
//            assertEquals("Echoes messages.", agentCard.skills[0].description)
//            assertEquals(listOf("test"), agentCard.skills[0].tags)
//            assertEquals(listOf("Say hello!"), agentCard.skills[0].examples)
            assertEquals(false, agentCard.supportsAuthenticatedExtendedCard)
        }
    }

    @Nested
    inner class MessageTests {
        @Test
        fun `should handle message send`() {
            val message = Message.Builder()
                .role(Message.Role.USER)
                .parts(listOf(TextPart("Hello, agent!")))
                .messageId("msg-123")
                .taskId("task-123")
                .contextId("ctx-123")
                .build()
            val params =  MessageSendParams.Builder().message(message).build()
            val request = SendMessageRequest.Builder()
                .jsonrpc(JSONRPCRequest.JSONRPC_VERSION)
                .method(SendMessageRequest.METHOD)
                .id("msg-123")
                .params(params)
                .build()

            val result = mockMvc.post("/a2a") {
                contentType = MediaType.APPLICATION_JSON
                content = objectMapper.writeValueAsString(request)
            }
                .andExpect {
                    status().isOk()
                    content { contentType(MediaType.APPLICATION_JSON) }
                }.andReturn()

            val content = result.response.contentAsString
            val response = objectMapper.readValue(content, SendMessageResponse::class.java)

            assertNotNull(response)
            assertEquals("msg-123", response.id)

            val task = objectMapper.convertValue(response.result, Task::class.java)
            assertEquals("task-123", task.id)
            assertEquals("ctx-123", task.contextId)
            assertEquals(TaskState.COMPLETED, task.status.state)
            assertTrue(task.history?.isNotEmpty() ?: false)
            assertEquals("Hello, agent!", (task.history.get(0)?.parts?.get(0) as? TextPart)?.text)
        }

        @Test
        fun `should handle message stream`() {
            val message = Message.Builder()
                .role(Message.Role.USER)
                .parts(listOf(TextPart("Hello, agent!")))
                .messageId("msg-123")
                .taskId("task-123")
                .contextId("ctx-123")
                .build()
            val params = MessageSendParams.Builder().message(message).build()

            // Note: We can't fully test SSE with MockMvc in a standard way
            // This test just verifies the endpoint doesn't throw an error
            mockMvc.post("/a2a/message/stream") {
                contentType = MediaType.APPLICATION_JSON
                content = objectMapper.writeValueAsString(params)
            }
                .andExpect {
                    status().isOk()
                }
        }
    }

    @Nested
    @Disabled
    inner class TaskTests {
        @Test
        fun `should get task`() {
            val params = TaskQueryParams("task-123")

            val result = mockMvc.post("/a2a/tasks/get") {
                contentType = MediaType.APPLICATION_JSON
                content = objectMapper.writeValueAsString(params)
            }
                .andExpect {
                    status().isOk()
                    content { contentType(MediaType.APPLICATION_JSON) }
                }.andReturn()

            val content = result.response.contentAsString
            val response = objectMapper.readValue(content, GetTaskResponse::class.java)

            assertNotNull(response)
            assertEquals("task-123", response.id)

            val task = objectMapper.convertValue(response.result, Task::class.java)
            assertEquals("task-123", task.id)
            assertEquals("ctx-1", task.contextId)
            assertEquals(TaskState.COMPLETED, task.status.state)
        }

        @Test
        fun `should cancel task`() {
            val params = TaskIdParams("task-123")

            val result = mockMvc.post("/a2a/tasks/cancel") {
                contentType = MediaType.APPLICATION_JSON
                content = objectMapper.writeValueAsString(params)
            }
                .andExpect {
                    status().isOk()
                    content { contentType(MediaType.APPLICATION_JSON) }
                }.andReturn()

            val content = result.response.contentAsString
            val response = objectMapper.readValue(content, CancelTaskResponse::class.java)

            assertNotNull(response)
            assertEquals("task-123", response.id)

            val task = objectMapper.convertValue(response.result, Task::class.java)
            assertEquals("task-123", task.id)
            assertEquals("ctx-1", task.contextId)
            assertEquals(TaskState.CANCELED, task.status.state)
        }
    }

    @Nested
    @Disabled
    inner class PushNotificationTests {
        @Test
        fun `should set push notification config`() {
            val config = PushNotificationConfig(
                "https://client/notify",
                "test-token",
                PushNotificationAuthenticationInfo(
                    listOf("Bearer"),
                    "test-secret"
                ),
                null
            )
            val params = TaskPushNotificationConfig(
                "task-123",
                config
            )

            val result = mockMvc.post("/a2a/tasks/pushNotificationConfig/set") {
                contentType = MediaType.APPLICATION_JSON
                content = objectMapper.writeValueAsString(params)
            }
                .andExpect {
                    status().isOk()
                    content { contentType(MediaType.APPLICATION_JSON) }
                }.andReturn()

            val content = result.response.contentAsString
            val response = objectMapper.readValue(content, SetTaskPushNotificationConfigResponse::class.java)

            assertNotNull(response)
            assertEquals("task-123", response.id)

            val resultConfig = objectMapper.convertValue(response.result, TaskPushNotificationConfig::class.java)
            assertEquals("task-123", resultConfig.taskId)
            assertEquals("https://client/notify", resultConfig.pushNotificationConfig.url)
            assertEquals("test-token", resultConfig.pushNotificationConfig.token)
            assertEquals(listOf("Bearer"), resultConfig.pushNotificationConfig.authentication?.schemes)
            assertEquals("test-secret", resultConfig.pushNotificationConfig.authentication?.credentials)
        }

        @Test
        fun `should get push notification config`() {
            val params = TaskIdParams("task-123")

            val result = mockMvc.post("/a2a/tasks/pushNotificationConfig/get") {
                contentType = MediaType.APPLICATION_JSON
                content = objectMapper.writeValueAsString(params)
            }
                .andExpect {
                    status().isOk()
                    content { contentType(MediaType.APPLICATION_JSON) }
                }.andReturn()

            val content = result.response.contentAsString
            val response = objectMapper.readValue(content, GetTaskPushNotificationConfigResponse::class.java)

            assertNotNull(response)
            assertEquals("task-123", response.id)

            val config = objectMapper.convertValue(response.result, TaskPushNotificationConfig::class.java)
            assertEquals("task-123", config.taskId)
            assertEquals("https://client/notify", config.pushNotificationConfig.url)
            assertEquals("demo-token", config.pushNotificationConfig.token)
            assertEquals(listOf("Bearer"), config.pushNotificationConfig.authentication?.schemes)
            assertEquals("secret", config.pushNotificationConfig.authentication?.credentials)
        }
    }
}



================================================
FILE: embabel-agent-a2a/src/test/kotlin/com/embabel/agent/a2a/server/config/FakeAiConfiguration.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.a2a.server.config

import com.embabel.agent.spi.LlmOperations
import com.embabel.agent.testing.integration.DummyObjectCreatingLlmOperations
import com.embabel.common.ai.model.DefaultOptionsConverter
import com.embabel.common.ai.model.EmbeddingService
import com.embabel.common.ai.model.Llm
import org.mockito.Mockito.mock
import org.slf4j.LoggerFactory
import org.springframework.ai.chat.model.ChatModel
import org.springframework.ai.embedding.EmbeddingModel
import org.springframework.boot.test.context.TestConfiguration
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Primary
import org.springframework.context.annotation.Profile


@Profile(value = ["test", "a2a"])
@TestConfiguration
class FakeAiConfiguration {

    private val logger = LoggerFactory.getLogger(FakeAiConfiguration::class.java)

    init {
        logger.info("Using fake AI configuration for A2A.")
    }

    /**
     * Mock LLM operations bean for testing purposes.
     */
    @Bean
    @Primary
    fun llmOperations(): LlmOperations = DummyObjectCreatingLlmOperations.LoremIpsum

    /**
     * Mock bean to satisfy the dependency requirement for bedrockModels
     */
    @Bean(name = ["bedrockModels"])
    fun bedrockModels(): Any = Any()

    /**
     * Test LLM bean that matches the default-llm configuration
     */
    @Bean(name = ["test-llm"])
    fun testLlm(): Llm = Llm(
        name = "test-llm",
        model = mock(ChatModel::class.java),
        provider = "test",
        optionsConverter = DefaultOptionsConverter
    )

    /**
     * Test embedding service that matches the default-embedding-model configuration
     */
    @Bean(name = ["test-embedding"])
    fun testEmbedding(): EmbeddingService = EmbeddingService(
        name = "test-embedding",
        model = mock(EmbeddingModel::class.java),
        provider = "test"
    )

    /**
     * Additional test embedding model for the 'best' role
     */
    @Bean(name = ["test"])
    fun test(): EmbeddingService = EmbeddingService(
        name = "test",
        model = mock(EmbeddingModel::class.java),
        provider = "test"
    )
}



================================================
FILE: embabel-agent-a2a/src/test/kotlin/com/embabel/agent/a2a/server/config/FakeRankerConfiguration.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.a2a.server.config

import com.embabel.agent.a2a.example.simple.horoscope.TestHoroscopeService
import com.embabel.agent.spi.Ranking
import com.embabel.agent.spi.Rankings
import com.embabel.agent.testing.integration.FakeRanker
import com.embabel.common.core.types.Described
import com.embabel.common.core.types.Named
import org.junit.jupiter.api.Assertions.fail
import org.springframework.boot.test.context.TestConfiguration
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Primary
import org.slf4j.LoggerFactory
import org.springframework.context.annotation.Profile


@Profile("test", "a2a")
@TestConfiguration
class FakeRankerConfiguration {

    private val logger = LoggerFactory.getLogger(FakeRankerConfiguration::class.java)

    init {
        logger.info("Using fake Ranker configuration for A2A.")
    }

    /**
     * Mock horoscope service for testing purposes.
     * Provides predictable horoscope responses without requiring external services.
     */
    @Bean
    @Primary
    fun fakeHoroscopeService() = TestHoroscopeService {
        """
            |On Monday, try to avoid being eaten by wolves            .
        """.trimMargin()
    }

    /**
     * Mock ranker implementation for testing purposes.
     * Provides deterministic ranking behavior for agents and goals:
     */
    @Bean
    @Primary
    fun fakeRanker() = object : FakeRanker {

        override fun <T> rank(
            description: String,
            userInput: String,
            rankables: Collection<T>,
        ): Rankings<T> where T : Named, T : Described {
            when (description) {
                "agent" -> {
                    val a = rankables.firstOrNull { it.name.contains("Star") } ?: fail { "No agent with Star found" }
                    return Rankings(
                        rankings = listOf(Ranking(a, 0.9))
                    )
                }

                "goal" -> {
                    val g =
                        rankables.firstOrNull { it.description.contains("horoscope") } ?: fail("No goal with horoscope")
                    return Rankings(
                        rankings = listOf(Ranking(g, 0.9))
                    )
                }

                else -> throw IllegalArgumentException("Unknown description $description")
            }
        }
    }
}



================================================
FILE: embabel-agent-a2a/src/test/resources/application-test.properties
================================================
# Spring Boot Application Properties
spring.application.name=agent-a2a
spring.output.ansi.enabled=ALWAYS

# Embabel Agent Platform - minimal configuration for tests
embabel.agent-platform.scanning.annotation=true
embabel.agent-platform.scanning.bean=true

# Models - Use simple names that can be satisfied by test infrastructure
embabel.models.default-llm=test-llm
embabel.models.default-embedding-model=test-embedding

# Logging - minimal pattern for test output
logging.pattern.console=%clr(%d{HH:mm:ss.SSS}){faint} %clr(%-5level) %clr(%logger{0}){cyan} %clr(-){faint} %msg%n



================================================
FILE: embabel-agent-a2a/src/test/resources/.gitkeep
================================================
ECHO is on.



================================================
FILE: embabel-agent-api/README.md
================================================
# Embabel Agent Framework

Core library for building intelligent agent applications with Spring Boot integration.

## Overview

The Embabel Agent Framework provides a library-centric approach to agent development, supporting multiple configuration methods and seamless integration with existing Spring Boot applications.

## Strategic Direction: Enhanced Configurability

The framework is undergoing transformation from profile-based to property-based configuration for enhanced library usability and developer experience.

## Configuration Architecture

### **Property Segregation Principle**

The framework separates configuration into two distinct categories based on **who controls** and **how often** properties change:

#### **Platform Properties (`embabel.agent.platform.*`)**
**Definition:** Internal framework behavior that library controls

| Criteria | Platform Properties | Example |
|----------|-------------------|---------|
| **Ownership** | Library manages defaults | `embabel.agent.platform.scanning.annotation=true` |
| **Change Frequency** | Rarely customized | `embabel.agent.platform.ranking.max-attempts=5` |
| **Purpose** | How framework works internally | `embabel.agent.platform.llm-operations.backoff-millis=5000` |
| **Risk Level** | Can break platform assumptions | `embabel.agent.platform.models.anthropic.retry-multiplier=2.0` |
| **Defaults** | Shipped with library | In `agent-platform.properties` |

#### **Application Properties (`embabel.agent.*`)**  
**Definition:** Business decisions and deployment choices that developer controls

| Criteria | Application Properties | Example |
|----------|----------------------|---------|
| **Ownership** | Developer customizes | `embabel.agent.models.provider=openai` |
| **Change Frequency** | Expected to be modified | `embabel.agent.logging.personality=starwars` |
| **Purpose** | What application wants to do | `embabel.agent.infrastructure.neo4j.enabled=true` |
| **Risk Level** | Safe to change | `embabel.agent.models.openai.model=gpt-4` |
| **Defaults** | In developer's `application.yml` | User-specific values |

### Platform Internal Properties (`embabel.agent.platform.*`)
**File:** `agent-platform.properties`  
**Purpose:** Platform internals managed by the library

```properties
# Platform capabilities and behavior  
embabel.agent.platform.scanning.annotation=true
embabel.agent.platform.scanning.bean=true
embabel.agent.platform.llm-operations.data-binding.max-attempts=10
embabel.agent.platform.llm-operations.prompts.generate-examples-by-default=true
embabel.agent.platform.process-id-generation.include-version=false
embabel.agent.platform.ranking.max-attempts=5
embabel.agent.platform.ranking.backoff-millis=100
embabel.agent.platform.autonomy.agent-confidence-cut-off=0.6
embabel.agent.platform.sse.max-buffer-size=100
embabel.agent.platform.models.anthropic.max-attempts=10
embabel.agent.platform.test.mock-mode=true
```

**Characteristics:**
- ✅ **Sensible defaults** - rarely need changing
- ✅ **Platform behavior** - internal operations  
- ✅ **Library-managed** - shipped with library
- ⚠️ **Override with caution** - can break platform assumptions

### Application Properties (`embabel.agent.*`)
**File:** Developer's `application.yml`  
**Purpose:** Business logic and deployment choices

```yaml
embabel:
  agent:
    # UI/UX choices
    logging:
      personality: starwars
      verbosity: debug
    
    # Model provider choices
    models:
      provider: openai
      openai:
        apiKey: ${OPENAI_API_KEY}
        model: gpt-4
    
    # Infrastructure choices
    infrastructure:
      observability:
        enabled: true
        zipkinEndpoint: ${ZIPKIN_ENDPOINT}
        tracingEnabled: true
      neo4j:
        enabled: true
        uri: ${NEO4J_URI}
        authentication:
          username: ${NEO4J_USERNAME}
          password: ${NEO4J_PASSWORD}
      mcp:
        enabled: true
        servers:
          github:
            command: docker
            args: ["run", "-i", "--rm", "-e", "GITHUB_PERSONAL_ACCESS_TOKEN", "mcp/github"]
            env:
              GITHUB_PERSONAL_ACCESS_TOKEN: ${GITHUB_PERSONAL_ACCESS_TOKEN}
```

**Characteristics:**
- ✅ **Developer-controlled** - expected to be customized
- ✅ **Environment-specific** - different per deployment
- ✅ **Business decisions** - model choices, thresholds, services
- ✅ **Infrastructure bindings** - endpoints, credentials, features

## Strategic Migration from Profiles

### Current Challenge
```yaml
# ❌ Profile-based (being phased out)
spring:
  profiles:
    active: bedrock,shell,observability

# Multiple application-{profile}.yml files to maintain
application-bedrock.yml     # Mixed framework + app concerns
application-shell.yml       # Framework behavior
application-observability.yml  # Infrastructure setup
```

### Target Architecture
```yaml
# ✅ Property-based (target)
embabel:
  agent:
    platform:
      # Platform internals (library defaults)
      scanning:
        annotation: true
      test:
        mockMode: false
    
    # Application choices (developer config)
    models:
      provider: bedrock
      bedrock:
        region: us-east-1
    infrastructure:
      observability:
        enabled: true
```

### Migration Benefits
- **🎯 Explicit configuration** - clear what features are enabled
- **🔧 Enhanced configurability** - granular control over behavior  
- **📚 Better IDE support** - auto-completion and validation
- **🏗️ Library-centric design** - suitable for embedded usage
- **🔄 Environment flexibility** - easy override with env vars
- **📖 Self-documenting** - configuration structure shows capabilities

## Property Precedence

Configuration follows Spring Boot precedence (highest to lowest):

1. **Programmatic Properties** (Highest)
   - `@TestPropertySource(properties = [...])`
   - System properties (`-Dembabel.framework.test.mockMode=false`)
   - Environment variables (`EMBABEL_FRAMEWORK_TEST_MOCKMODE=false`)

2. **Application Properties Files**
   - `application.properties`
   - `application.yml`

3. **Platform Default Files** (Lowest)
   - `agent-platform.properties`
   - Code defaults in `AgentPlatformProperties.kt`

## Spring Boot Integration

```kotlin
@SpringBootApplication
@EnableConfigurationProperties(AgentPlatformProperties::class)
class MyAgentApplication

fun main(args: Array<String>) {
    runApplication<MyAgentApplication>(*args)
}
```

## Module Independence

### Core Framework (`embabel-agent-api`)
- **Prefix:** `embabel.agent.platform.*` and `embabel.agent.*`
- **Scope:** Core agent capabilities, model providers, business logic
- **Independence:** Works standalone without shell module

### Shell Module (`embabel-agent-shell`)  
- **Prefix:** `embabel.shell.*`
- **Scope:** Interactive CLI interface and terminal services
- **Independence:** Optional dependency with separate configuration

### Autoconfigure Module (`embabel-agent-autoconfigure`)
- **Annotation-driven:** `@EnableAgentBedrock`, `@EnableAgentShell`
- **Profile activation:** Maintains profiles for annotation convenience
- **Consumer choice:** Developers choose activation method

## Configuration Examples & Templates

The framework provides **granular, composable templates** in `src/main/resources/application-templates/`:

### Template Structure
```
application-templates/
├── base/                        # Granular building blocks
│   ├── platform-defaults.yml   # Platform internal settings
│   ├── logging-starwars.yml     # StarWars personality configuration
│   ├── models-openai.yml        # OpenAI model configuration
│   └── infrastructure-neo4j.yml # Neo4j infrastructure configuration
├── environments/               # Environment-specific overrides
│   ├── development-overrides.yml
│   └── production-overrides.yml
└── composed/                   # Example compositions using imports
    ├── application-development.yml
    ├── application-production.yml
    └── application-minimal.yml
```

### Import-Based Composition
Templates are designed for **composition using Spring Boot imports**, not copy-paste.

### Development Environment Example
```yaml
# application.yml.unused - Import-based composition
spring:
  config:
    import:
      - classpath:application-templates/base/platform-defaults.yml
      - classpath:application-templates/base/logging-starwars.yml
      - classpath:application-templates/base/models-openai.yml
      - classpath:application-templates/base/infrastructure-neo4j.yml
      - classpath:application-templates/environments/development-overrides.yml

# Application-specific configuration
server:
  port: 8080
```

### Production Environment Example
```yaml
# application.yml.unused - Import-based composition
spring:
  config:
    import:
      - classpath:application-templates/base/platform-defaults.yml
      - classpath:application-templates/base/logging-severance.yml
      - classpath:application-templates/base/models-bedrock.yml
      - classpath:application-templates/base/infrastructure-neo4j.yml
      - classpath:application-templates/base/infrastructure-observability.yml
      - classpath:application-templates/environments/production-overrides.yml

# Application-specific configuration
server:
  port: 8443
```

### Custom Composition Example
```yaml
# application.yml.unused - Mix and match as needed
spring:
  config:
    import:
      - classpath:application-templates/base/logging-starwars.yml
      - classpath:application-templates/base/models-anthropic.yml  # Custom mix
      - classpath:shell-templates/base/shell-enabled.yml          # From shell module

# Your application configuration
myapp:
  custom:
    setting: value
```

**Usage:** Compose exactly what you need using Spring Boot's `spring.config.import` feature.

## Property Migration (v1.x → v2.0)

### **Platform Property Namespace Consolidation**

The framework consolidates internal platform properties under unified namespaces for better organization and clarity:

| Old Property Namespace | New Property Namespace | Purpose |
|------------------------|------------------------|---------|
| `embabel.agent-platform.*` | `embabel.agent.platform.*` | Agent scanning, ranking settings |
| `embabel.autonomy.*` | `embabel.agent.platform.autonomy.*` | Autonomy confidence thresholds |
| `embabel.process-id-generation.*` | `embabel.agent.platform.process-id-generation.*` | Process ID generation settings |
| `embabel.llm-operations.*` | `embabel.agent.platform.llm-operations.*` | LLM operation retry and prompt settings |
| `embabel.sse.*` | `embabel.agent.platform.sse.*` | Server-sent events configuration |
| `embabel.anthropic.*` | `embabel.agent.platform.models.anthropic.*` | Anthropic provider retry settings |

### **Action Required**

**If you customized any platform properties**, update your `application.yml`:

```yaml
# OLD - Will be ignored
embabel:
  agent-platform:
    ranking:
      max-attempts: 10
  autonomy:
    agent-confidence-cut-off: 0.8

# NEW - Required  
embabel:
  agent:
    platform:
      ranking:
        max-attempts: 10
      autonomy:
        agent-confidence-cut-off: 0.8
```

### **Migration Detection**

The framework provides automatic detection of deprecated property usage with production-safe defaults:

```yaml
# Migration system is DISABLED by default for zero production impact
# Enable only when you need migration guidance:
embabel:
  agent:
    platform:
      migration:
        scanning:
          enabled: true                    # Activates comprehensive migration detection
          include-packages:
            - "com.yourcompany"            # Scan your packages for deprecated usage
            - "com.yourthirdparty"         # Include third-party integration packages
        warnings:
          enabled: true                    # Automatically enabled when scanning is on
          individual-logging: true         # Log each deprecated property individually
```

**Key Features:**
- ✅ **Production Safe**: Completely disabled by default (zero overhead)
- ✅ **Comprehensive**: Detects both `@ConditionalOnProperty` and `@ConfigurationProperties` deprecated usage
- ✅ **Environment Variables**: Automatically detects deprecated properties from any source
- ✅ **Verbose Feedback**: Individual warnings plus aggregated summary

**Full Migration Guide**: [PROFILES_MIGRATION_GUIDE.md - Property Namespace Migration](PROFILES_MIGRATION_GUIDE.md#phase-0-platform-property-consolidation)

### **Spring Boot + Kotlin Configuration Patterns**

The framework implements production-validated Spring Boot + Kotlin configuration patterns:

#### **Val vs Var Decision Matrix:**
| Configuration Pattern | Property Type | Recommendation | Reason |
|----------------------|--------------|----------------|--------|
| **Pure `@ConfigurationProperties`** | Scalar (String, Boolean, Int) | ✅ `val` | Constructor binding works perfectly |
| **`@Configuration` + `@ConfigurationProperties`** | Scalar | ⚠️ `var` | CGLIB proxy requires setters |
| **Any Pattern** | Complex (List, Map) | ✅ `var` | Environment variable binding needs setters |

#### **Production Lesson Learned:**
```kotlin
@Configuration  // 🚨 This annotation forces var usage
@ConfigurationProperties("app.config")
data class MyConfig(
    var enabled: Boolean = false,     // ✅ var required for CGLIB proxying
    var servers: List<String> = emptyList()  // ✅ var required for complex types
)

// vs.

@ConfigurationProperties("app.simple") // 🎯 No @Configuration
data class SimpleConfig(
    val enabled: Boolean = false      // ✅ val works with constructor binding
)
```

**Reference**: See comprehensive analysis in `AgentPlatformPropertiesIntegrationTest`

## Phase 1: Library-Centric Transformation

Current transformation status:

- ✅ **Property Segregation** - Platform vs application concerns clearly defined
- 🔄 **Profile Migration** - Moving from profile-based to property-based activation  
- ✅ **Shell Independence** - Complete separation achieved
- 🔄 **Enhanced Configurability** - Granular property control
- 📋 **Annotation Support** - Maintained for developer convenience

### Personality Plugin Infrastructure (In Progress)

**Current State**: Profile-based personality activation
```yaml
# Current (being migrated away from)
spring:
  profiles:
    active: starwars
```

**Target State**: Property-based with plugin architecture
```yaml
# Target library-centric approach
embabel:
  agent:
    logging:
      personality: starwars
      verbosity: debug
      enableRuntimeSwitching: true
```

**Plugin Architecture Features**:
- ✅ **Property-based activation** - No Spring profile dependencies
- 🔄 **Dynamic discovery** - Auto-find personality providers
- 🔄 **Runtime switching** - Change personalities without restart
- 🔄 **Plugin interface** - Clean provider contract for extensions

**Implementation**: 
- **Detailed Steps**: [ITERATIVE_PLAN.md](ITERATIVE_PLAN.md) 
- **Profile-Specific Changes**: [PROFILES_MIGRATION_GUIDE.md - Personality Profiles](PROFILES_MIGRATION_GUIDE.md#0-personality-profiles-migration)

## Migration from Profiles

For detailed migration instructions from profile-based configuration (`application-{profile}.yml`) to property-based configuration, see [PROFILES_MIGRATION_GUIDE.md](PROFILES_MIGRATION_GUIDE.md).

### Next Phase Goals
- **Complete profile departure** from core framework configuration
- **Plugin architecture expansion** for personalities and model providers
- **Enhanced property dynamism** matching profile flexibility
- **Developer experience improvements** with better IDE support

--------------------
(c) Embabel Software Inc 2024-2025.


================================================
FILE: embabel-agent-api/docker-compose.yml
================================================
services:
  llama3.2:
    image: ollama/ollama:latest
    ports:
      - "11434:11434"
    environment:
      - OLLAMA_MODELS=llama3.2
  qwen3:
    image: ollama/ollama:latest
    ports:
      - "11435:11434"
    environment:
      - OLLAMA_MODELS=qwen2.5

  zipkin:
    image: 'openzipkin/zipkin:latest'
    ports:
      - "9411:9411"

  a2a-ui:
    build:
      context: .
      dockerfile: Dockerfile.a2a
    ports:
      - "12000:12000"
    profiles:
      - a2a



================================================
FILE: embabel-agent-api/Dockerfile.a2a
================================================
FROM python:3.11-slim

# Install system dependencies
RUN apt-get update && apt-get install -y \
    git \
    && rm -rf /var/lib/apt/lists/*

# Install uv
RUN pip install uv

# Set working directory
WORKDIR /workspace

# Clone the repository
RUN git clone --depth 1 https://github.com/google-a2a/a2a-samples .

# Create virtual environment and install dependencies
RUN uv venv .venv
RUN . .venv/bin/activate && cd demo/ui && uv sync

# Set the working directory to demo/ui
WORKDIR /workspace/demo/ui

# Activate virtual environment in subsequent commands
ENV PATH="/workspace/.venv/bin:$PATH"

# Expose port
EXPOSE 12000

# Default command
CMD ["uv", "run", "main.py"]



================================================
FILE: embabel-agent-api/embabel_planning_system.dot
================================================
digraph PlanningSystem {
    // Node styling
    node [shape=box, style="filled,rounded", fontname="Arial", margin=0.2];
    edge [fontname="Arial", fontsize=10];
    
    // Key components
    Action [fillcolor=lightblue, label="Action\n(Core executable unit)"];
    Condition [fillcolor=lightgreen, label="Condition\n(Named predicate)"];
    Blackboard [fillcolor=lightyellow, label="Blackboard\n(Shared memory system)"];
    WorldState [fillcolor=lightcoral, label="WorldState\n(System conditions map)"];
    Plan [fillcolor=lightgrey, label="Plan\n(Sequence of Actions)"];
    Goal [fillcolor=pink, label="Goal\n(Desired end state)"];
    Planner [fillcolor=lightcyan, label="AStarGoapPlanner\n(Planning algorithm)"];
    GoapPlanningSystem [fillcolor=lavender, label="GoapPlanningSystem\n(Actions + Goals)"];
    IoBinding [fillcolor=lightpink, label="IoBinding\n(Input/output binding)"];
    
    // Relationships
    Action -> Condition [label="has preconditions"];
    Action -> WorldState [label="produces effects on"];
    Action -> Blackboard [label="reads from/writes to"];
    Action -> IoBinding [label="defines inputs/outputs via"];
    
    Condition -> WorldState [label="evaluated against"];
    
    Goal -> Condition [label="defined by"];
    
    Blackboard -> WorldState [label="determines"];
    
    WorldState -> Planner [label="informs"];
    
    Planner -> Plan [label="creates"];
    Planner -> Action [label="selects"];
    Planner -> Goal [label="satisfies"];
    
    Plan -> Action [label="contains sequence of"];
    Plan -> Goal [label="achieves"];
    
    GoapPlanningSystem -> Action [label="contains available"];
    GoapPlanningSystem -> Goal [label="contains possible"];
    GoapPlanningSystem -> Planner [label="used by"];
    
    // Additional relationships
    Blackboard -> Condition [label="stores state for", style="dashed"];
    WorldState -> Action [label="determines achievability of", style="dashed"];
    Action -> Plan [label="executed according to", dir="back", style="dashed"];
}


================================================
FILE: embabel-agent-api/mvnw
================================================
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"



================================================
FILE: embabel-agent-api/mvnw.cmd
================================================
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.2
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" (%__MVNW_CMD__% %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace '^.*'+$MVNW_REPO_PATTERN,'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''
$MAVEN_HOME_PARENT = "$HOME/.m2/wrapper/dists/$distributionUrlNameMain"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_HOME_PARENT = "$env:MAVEN_USER_HOME/wrapper/dists/$distributionUrlNameMain"
}
$MAVEN_HOME_NAME = ([System.Security.Cryptography.MD5]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"



================================================
FILE: embabel-agent-api/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-parent</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-api</artifactId>
    <version>0.2.0-SNAPSHOT</version>
    <packaging>jar</packaging>
    <name>Embabel Agent API</name>
    <description>Fluent DSL and Kotlin DSL for Agentic Flows</description>

    <dependencies>

        <!--
        We want to be able to work with Repository conventions
        but don't want heavyweight dependencies here like JPA
        -->
        <dependency>
            <groupId>org.springframework.data</groupId>
            <artifactId>spring-data-commons</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
        </dependency>

        <dependency>
            <groupId>jakarta.servlet</groupId>
            <artifactId>jakarta.servlet-api</artifactId>
        </dependency>

        <dependency>
            <groupId>com.embabel.common</groupId>
            <artifactId>embabel-common-core</artifactId>
        </dependency>

        <dependency>
            <groupId>com.embabel.common</groupId>
            <artifactId>embabel-common-util</artifactId>
        </dependency>

        <dependency>
            <groupId>com.embabel.common</groupId>
            <artifactId>embabel-common-ai</artifactId>
        </dependency>

        <dependency>
            <groupId>com.embabel.common</groupId>
            <artifactId>embabel-common-textio</artifactId>
        </dependency>

        <!-- Apache Commons -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-text</artifactId>
        </dependency>

        <!-- Kotlin Dependencies -->
        <dependency>
            <groupId>org.jetbrains.kotlin</groupId>
            <artifactId>kotlin-stdlib</artifactId>
        </dependency>

        <dependency>
            <groupId>org.jetbrains.kotlin</groupId>
            <artifactId>kotlin-reflect</artifactId>
        </dependency>

        <dependency>
            <groupId>org.jetbrains.kotlinx</groupId>
            <artifactId>kotlinx-coroutines-core</artifactId>
        </dependency>

        <!-- Spring Boot Dependencies -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-starter-mcp-client</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-logging</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-client-chat</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-vector-store</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-openai</artifactId>
        </dependency>

        <dependency>
            <groupId>com.fasterxml.jackson.module</groupId>
            <artifactId>jackson-module-kotlin</artifactId>
        </dependency>

        <dependency>
            <groupId>info.schnatterer.moby-names-generator</groupId>
            <artifactId>moby-names-generator</artifactId>
        </dependency>

        <dependency>
            <groupId>io.github.a2asdk</groupId>
            <artifactId>a2a-java-sdk-spec</artifactId>
            <version>0.2.5</version>
        </dependency>

        <!-- Unit and Integration Testing -->
        <!-- Most common testing dependencies are in the embabel-agent-parent -->
        <!-- If something is missing, add it here -->
        <dependency>
            <groupId>com.embabel.common</groupId>
            <artifactId>embabel-common-test-ai</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.mockito</groupId>
            <artifactId>mockito-core</artifactId>
            <scope>test</scope>
        </dependency>

    </dependencies>


    <build>
        <plugins>
            <!-- Production Build Plugins -->
            <plugin>
                <groupId>org.jetbrains.kotlin</groupId>
                <artifactId>kotlin-maven-plugin</artifactId>
                <executions>
                    <execution>
                        <id>compile</id>
                        <phase>compile</phase>
                        <goals>
                            <goal>compile</goal>
                        </goals>
                        <configuration>
                            <sourceDirs>
                                <source>src/main/java</source>
                                <source>src/main/kotlin</source>
                                <source>target/generated-sources/annotations</source>
                            </sourceDirs>
                        </configuration>
                    </execution>
                    <execution>
                        <id>test-compile</id>
                        <phase>test-compile</phase>
                        <goals>
                            <goal>test-compile</goal>
                        </goals>
                        <configuration>
                            <sourceDirs>
                                <source>src/test/java</source>
                                <source>src/test/kotlin</source>
                                <source>target/generated-test-sources/test-annotations</source>
                            </sourceDirs>
                        </configuration>
                    </execution>
                    <execution>
                        <id>kapt</id>
                        <goals>
                            <goal>kapt</goal>
                        </goals>
                        <configuration>
                            <annotationProcessorPaths>
                                <path>
                                    <groupId>org.springframework.boot</groupId>
                                    <artifactId>spring-boot-configuration-processor</artifactId>
                                    <version>${spring-boot.version}</version>
                                </path>
                            </annotationProcessorPaths>
                        </configuration>
                    </execution>
                </executions>
            </plugin>

            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>${spring-boot.version}</version>
            </plugin>

            <!-- Testing and Quality Build Plugins -->
            <plugin>
                <groupId>org.jacoco</groupId>
                <artifactId>jacoco-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>com/embabel/agent/testing/**</exclude>
                        <exclude>com/embabel/agent/experimental/**</exclude>
                        <exclude>com/embabel/agent/event/logging/personality/**</exclude>
                    </excludes>
                    <rules>
                        <rule>
                            <element>CLASS</element>
                            <excludes>
                                <exclude>*ApiStatus.Experimental*</exclude>
                            </excludes>
                        </rule>
                    </rules>
                </configuration>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <configuration>
                    <failOnFlakeCount>1</failOnFlakeCount>
                    <rerunFailingTestsCount>1</rerunFailingTestsCount>
                    <excludes>
                        <exclude>**/*IT.java</exclude>
                        <exclude>**/*IT.kt</exclude>
                    </excludes>
                </configuration>
            </plugin>

        </plugins>
    </build>

</project>



================================================
FILE: embabel-agent-api/src/main/java/com/embabel/agent/api/annotation/README.md
================================================
# Java syntax sugar

Thin layer over Embabel annotation programming model allowing for
idiomatic use in Java without showing any Kt annotations.


================================================
FILE: embabel-agent-api/src/main/java/com/embabel/agent/api/annotation/AchievesGoal.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation;

import java.lang.annotation.*;

/**
 * Annotation that can be added to an @Action method
 * to indicate that its execution achieves a goal
 * See {@link com.embabel.agent.core.Goal} for more details.
 * A Goal object will be created for each method annotated with this annotation.
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface AchievesGoal {

    /**
     * Description of the goal.
     * Take care in writing this description as it will be used
     * to choose a goal based on user input.
     */
    String description();

    /**
     * Value of achieving the goal
     */
    double value() default 0.0;

    /**
     * Set of tags describing classes or capabilities for this goal.
     * Example: ["cooking", "customer support", "billing"]
     */
    String[] tags() default {};

    /**
     * Set of example scenarios that the goal can achieve.
     * Example: ["I need a recipe for bread", "I want to support a customer with a billing issue"]
     */
    String[] examples() default {};

    /**
     * How the goal should be exported as a tool
     * Tools will not be exposed remotely by default
     */
    Export export() default @Export();
}




================================================
FILE: embabel-agent-api/src/main/java/com/embabel/agent/api/annotation/Export.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation;

/**
 * How a goal should be exposed
 */
public @interface Export {

    /**
     * Set to override the name of the goal when it is exported.
     */
    String name() default "";

    boolean remote() default false;

    boolean local() default true;

    /**
     * Any starting input types for the goal we might want to prompt for
     */
    // This annotation is implemented in Java because the following is impossible in Kotlin:
    Class<?>[] startingInputTypes() default {};

}



================================================
FILE: embabel-agent-api/src/main/java/com/embabel/agent/api/annotation/WaitFor.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation;

import com.embabel.agent.core.hitl.Awaitable;
import org.springframework.lang.NonNull;

/**
 * Java syntax sugar for HITL
 *
 * @see com.embabel.agent.api.annotation.WaitKt
 */
public class WaitFor {

    private WaitFor() {
        // Prevent instantiation
    }

    /**
     * @see com.embabel.agent.api.annotation.WaitKt#fromForm(String, Class)
     */
    @NonNull
    public static <T> T formSubmission(@NonNull String title, @NonNull Class<T> clazz) {
        return WaitKt.fromForm(title, clazz);
    }

    @NonNull
    public static <P> P confirmation(@NonNull P what, @NonNull String description) {
        return WaitKt.confirm(what, description);
    }

    @NonNull
    public static <P> P awaitable(@NonNull Awaitable<P, ?> awaitable) {
        return com.embabel.agent.api.annotation.WaitKt.waitFor(awaitable);
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/README.md
================================================
# Embabel Agent API

Root package for Embabel Agent API.

Subpackages:

- `api`: Public API. Your apps should primarily use this package. The two key subpackages are fully interoperable:
    - `annotation`: Spring-style annotations defining agents and actions.
    - `dsl`: Kotlin DSL for defining agents and actions.
    - `common`: Common classes used in both annotation and DSL idioms.
- `core`: Core classes of the Agent API. These will appear in the public API
  but some are lower level than the public API.
- `domain`: Data dictionary of com
- `spi`: Defines types primarily used by platform providers. Not intended for user use.
- `testing`: Testing support classes. Intended to make it easy for application developers to unit and integration test
  their agents.


================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/README.md
================================================
# Public API

API to use when building agentic applications.


================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/annotation/README.md
================================================
# Annotation-driven programming model

Annotation-driven programming model built on Spring
and inspired by Spring MVC.

Intended for use from Java, offering a familiar
model for Spring developers.

## Annotations

Classes can be annotated with `@Agentic`. This indicates the class contains agentic functions.

Functions can be annotated with the `@Action` or `@Condition` interfaces.

Agentic classes may choose to implement the `GoalContributor` interface.
Goals are immutable. The `goals` getter will be called once only.

### @Action methods

Signature choices:

- Transformer with regular Java or Kotlin implementation
- Prompt transformer
- Can have multiple arguments

TODO
Document `Prompt` and `PromptRunner`

### @Condition methods

TODO should support additional signatures such
as operations on a type or all of a type

### Tool callback methods

These follow the conventions of Spring AI and are annotated with `@Tool`.
They have access to instance state.

Tool methods are scoped to this type.
They will not be used on prompts outside it.



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/annotation/annotations.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation

import com.embabel.agent.api.common.PlannerType
import com.embabel.agent.core.IoBinding
import com.embabel.common.core.types.Semver.Companion.DEFAULT_VERSION
import com.embabel.common.core.types.ZeroToOne
import org.springframework.core.annotation.AliasFor
import org.springframework.stereotype.Component


/**
 * Indicates that this class exposes actions, goals and conditions that may be used
 * by agents, but is not an agent in itself.
 * This is a Spring stereotype annotation, so annotated classes will be picked up on the classpath and injected
 * @param scan Whether to find this agent in the classpath. If false, it will not be found by classpath scanning.
 * This is useful for testing
 * [com.embabel.agent.api.annotation.support.AgentMetadataReader] will still process it if asked directly.
 */
@Retention(AnnotationRetention.RUNTIME)
@Target(
    AnnotationTarget.CLASS,
)
@Component
annotation class AgentCapabilities(
    val scan: Boolean = true,
)

/**
 * Indicates that this class is an agent.
 * It doesn't just contribute actions, goals and conditions:
 * it is an agent in itself.
 * This is a Spring stereotype annotation, so annotated classes will be picked up on the classpath and injected
 * Either @Agent or @AgentCapabilities should be used: not both
 * @param name Name of the agent. If not provided, the name will be the class simple name
 * @param provider provider of the agent. If not provided, will default to the package this annotation is used in
 * @param description Description of the agent. Required. This is used for documentation purposes and to choose an agent
 * @param version Version of the agent
 * @param planner The type of planning this agent uses. Defaults to GOAP (Goal Oriented Action Planning).
 * @param scan Whether to find this agent in the classpath. If false, it will not be found by the agent manager. Defaults to true
 * @param beanName The value may indicate a suggestion for a logical component name,
 * to be turned into a Spring bean in case of an autodetected component. Use only if there's the likelihood of
 * conflict with the default bean name.
 * @param opaque Whether to hide the agent's actions and conditions
 */
@Retention(AnnotationRetention.RUNTIME)
@Target(
    AnnotationTarget.CLASS,
)
@Component
annotation class Agent(
    val name: String = "",
    val provider: String = "",
    val description: String,
    val version: String = DEFAULT_VERSION,
    val planner: PlannerType = PlannerType.GOAP,
    val scan: Boolean = true,
    @get:AliasFor(annotation = Component::class, attribute = "value")
    val beanName: String = "",
    val opaque: Boolean = false,
)

/**
 * Annotates a method that evaluates a condition.
 * This will have access to the processContext and also
 * can use any other state.
 * @param name Name of the condition. If not provided, the name will be the method name
 * Useful if we want to avoid magic strings by sharing a constant
 * @param cost Cost of evaluating the condition, between 0 and 1.
 * 0 is cheap; 1 is the most expensive. The platform can use this
 * information for optimization.
 */
@Target(AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
@MustBeDocumented
annotation class Condition(
    val name: String = "",
    val cost: ZeroToOne = 0.0,
)

@Retention(AnnotationRetention.RUNTIME)
@MustBeDocumented
annotation class ToolGroup(
    val role: String,
)

/**
 * Annotation to indicate a method implementing an Action.
 * Methods can have any number of parameters, which represent
 * necessary input types.
 * Methods can return any type. The return type will become
 * an effect.
 * @param description Description of the action. Less important than for
 * goals as a planner chooses actions based on preconditions
 * and effects rather than by description. The description property is
 * used for documentation purposes, having the advantage over comments
 * that it can appear in logs. Description defaults to name
 * @param pre Preconditions for the action
 * @param outputBinding Output binding for the action.
 * Only required for a custom binding.
 * @param cost Cost of executing the action
 * @param value Value of performing the action
 * @param toolGroups Tool groups that this action requires. These are well known tools from the server.
 * @param toolGroupRequirements Tool groups required, with explicit metadata such as QoS requirements.
 * @Tool methods on the @Agentic class are automatically added.
 */
@Target(AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
@MustBeDocumented
annotation class Action(
    val description: String = "",
    val pre: Array<String> = [],
    val post: Array<String> = [],
    val canRerun: Boolean = false,
    val outputBinding: String = IoBinding.DEFAULT_BINDING,
    val cost: ZeroToOne = 0.0,
    val value: ZeroToOne = 0.0,
    val toolGroups: Array<String> = [],
    val toolGroupRequirements: Array<ToolGroup> = [],
)


/**
 * Annotation that can added to parameters of an @Action method
 * to indicate that the parameter name must match the input binding.
 * Otherwise, it can match the latest ("it") value.
 * Must be combined with the outputBinding method on Action for the action
 * producing the input
 * @param value The name of the input binding that this parameter should match; "" indicates using the parameter name.
 * @see Action
 * @see IoBinding
 */
@Target(AnnotationTarget.VALUE_PARAMETER)
@Retention(AnnotationRetention.RUNTIME)
@MustBeDocumented
annotation class RequireNameMatch(
    val value: String = "",
)



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/annotation/wait.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation

import com.embabel.agent.core.hitl.Awaitable
import com.embabel.agent.core.hitl.ConfirmationRequest
import com.embabel.ux.form.SimpleFormGenerator
import com.embabel.agent.core.hitl.FormBindingRequest

/**
 * Call when the current AgentProcess should
 * wait for a response from the user.
 */
fun <P : Any> waitFor(
    awaitable: Awaitable<P, *>,
): P {
    throw AwaitableResponseException(
        awaitable = awaitable,
    )
}

fun <P : Any> confirm(
    what: P,
    description: String,
): P = waitFor(ConfirmationRequest(what, description))

inline fun <reified P : Any> fromForm(
    title: String,
): P = fromForm(
    title = title,
    dataClass = P::class.java,
)

/**
 * Bind input to the data class
 */
fun <P : Any> fromForm(
    title: String? = null,
    dataClass: Class<P>,
): P {
    val form =
        SimpleFormGenerator.generateForm(dataClass = dataClass, title = title ?: "Bind to ${dataClass.simpleName}")
    val formBindingRequest = FormBindingRequest(
        form = form,
        outputClass = dataClass,
        persistent = false,
    )
    throw AwaitableResponseException(
        awaitable = formBindingRequest,
    )
}


/**
 * Not an error, but gets special treatment in the platform.
 */
class AwaitableResponseException(
    val awaitable: Awaitable<*, *>,
) : RuntimeException("Awaitable response exception") {
    override fun toString(): String {
        return "AwaitableResponseException(awaitable=$awaitable)"
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/annotation/support/ActionMethodArgumentResolver.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation.support

import com.embabel.agent.api.annotation.RequireNameMatch
import com.embabel.agent.api.common.Ai
import com.embabel.agent.api.common.OperationContext
import com.embabel.agent.api.common.support.expandInputBindings
import com.embabel.agent.core.IoBinding
import com.embabel.agent.core.ProcessContext
import java.lang.reflect.Parameter
import kotlin.reflect.KClass
import kotlin.reflect.KParameter
import kotlin.reflect.full.findAnnotation

/**
 * Strategy interface for resolving action method parameters into argument values and input bindings.
 *
 * @see DefaultActionMethodManager
 */
interface ActionMethodArgumentResolver {

    /**
     * Whether the given method parameter is supported by this resolver.
     * @param javaParameter the Java method parameter to check
     * @param kotlinParameter the Kotlin method parameter to check. Can be `null` if `kotlin-reflect` is unavailable.
     * @param operationContext the current operation context when invoked before [resolveArgument];
     * `null` when invoked before [resolveInputBinding]
     * @return `true` if this resolver supports the supplied parameter; `false` otherwise
     */
    fun supportsParameter(
        javaParameter: Parameter,
        kotlinParameter: KParameter?,
        operationContext: OperationContext?,
    ): Boolean

    /**
     * @param javaParameter the Java method parameter to check. This parameter must have previously been passed to
     * [supportsParameter] which must have returned `true`.
     * @param kotlinParameter the Kotlin method parameter to check. Can be `null` if `kotlin-reflect` is unavailable.
     * @return a set of bindings. Returns an empty set by default.
     */
    fun resolveInputBinding(
        javaParameter: Parameter,
        kotlinParameter: KParameter?,
    ): Set<IoBinding> = emptySet()

    /**
     * Resolve an action method parameter into an argument value. An `OperationContext` provides access to the
     * context of the current action.
     * @param javaParameter the Java method parameter to check. This parameter must have previously been passed to
     * [supportsParameter] which must have returned `true`.
     * @param kotlinParameter the Kotlin method parameter to check. Can be `null` if `kotlin-reflect` is unavailable.
     * @param operationContext the current operation context
     */
    fun resolveArgument(
        javaParameter: Parameter,
        kotlinParameter: KParameter?,
        operationContext: OperationContext,
    ): Any?

}

/**
 * Resolves [ProcessContext] arguments.
 */
class ProcessContextArgumentResolver : ActionMethodArgumentResolver {

    override fun supportsParameter(
        javaParameter: Parameter,
        kotlinParameter: KParameter?,
        operationContext: OperationContext?,
    ): Boolean {
        return ProcessContext::class.java.isAssignableFrom(javaParameter.type)
    }

    override fun resolveArgument(
        javaParameter: Parameter,
        kotlinParameter: KParameter?,
        operationContext: OperationContext,
    ): Any {
        return operationContext.processContext
    }
}

/**
 * Resolves [OperationContext] arguments.
 */
class OperationContextArgumentResolver : ActionMethodArgumentResolver {

    override fun supportsParameter(
        javaParameter: Parameter,
        kotlinParameter: KParameter?,
        operationContext: OperationContext?,
    ): Boolean {
        return OperationContext::class.java.isAssignableFrom(javaParameter.type)
    }

    override fun resolveArgument(
        javaParameter: Parameter,
        kotlinParameter: KParameter?,
        operationContext: OperationContext,
    ): Any {
        return operationContext
    }
}

/**
 * Resolves [Ai] arguments.
 */
class AiArgumentResolver : ActionMethodArgumentResolver {

    override fun supportsParameter(
        javaParameter: Parameter,
        kotlinParameter: KParameter?,
        operationContext: OperationContext?,
    ): Boolean {
        return Ai::class.java.isAssignableFrom(javaParameter.type)
    }

    override fun resolveArgument(
        javaParameter: Parameter,
        kotlinParameter: KParameter?,
        operationContext: OperationContext,
    ): Any {
        return operationContext.ai()
    }
}

private const val PARAMETER_NAME_SHOULD_BE_AVAILABLE = "Parameter name should be available"

/**
 * Resolves arguments that can be found on the [com.embabel.agent.core.Blackboard]
 */
class BlackboardArgumentResolver : ActionMethodArgumentResolver {

    override fun supportsParameter(
        javaParameter: Parameter,
        kotlinParameter: KParameter?,
        operationContext: OperationContext?,
    ): Boolean {
        if (kotlinParameter != null) {
            val classifier = kotlinParameter.type.classifier
            if (classifier is KClass<*>) {
                if (operationContext == null) {
                    return true
                }
                val annotation = kotlinParameter.findAnnotation<RequireNameMatch>()
                val name = getBindingParameterName(kotlinParameter.name, annotation)
                    ?: error(PARAMETER_NAME_SHOULD_BE_AVAILABLE)
                return operationContext.hasValue(
                    variable = name,
                    type = classifier.java.name,
                    dataDictionary = operationContext.processContext.agentProcess.agent,
                )
            } else {
                return false
            }
        } else if (operationContext != null) {
            val annotation = javaParameter.getAnnotation(RequireNameMatch::class.java)
            val name = getBindingParameterName(javaParameter.name, annotation)
                ?: error(PARAMETER_NAME_SHOULD_BE_AVAILABLE)
            return operationContext.hasValue(
                variable = name,
                type = javaParameter.type.name,
                dataDictionary = operationContext.processContext.agentProcess.agent,
            )
        } else {
            return true
        }
    }

    override fun resolveInputBinding(
        javaParameter: Parameter,
        kotlinParameter: KParameter?,
    ): Set<IoBinding> {
        if (kotlinParameter != null) {
            if (kotlinParameter.type.isMarkedNullable) {
                return emptySet()
            }
            val nullableAnnotation = kotlinParameter.annotations.find {
                it.annotationClass.simpleName == "Nullable"
            }
            if (nullableAnnotation != null) {
                return emptySet()
            }

            val requireNameMatchAnnotation = kotlinParameter.findAnnotation<RequireNameMatch>()
            val name = getBindingParameterName(kotlinParameter.name, requireNameMatchAnnotation)
                ?: throw IllegalArgumentException(
                    "Name for argument of type [${kotlinParameter.type}] not specified, and parameter name information not " +
                            "available via reflection. Ensure that the compiler uses the '-parameters' flag."
                )

            return expandInputBindings(
                name,
                (kotlinParameter.type.classifier as KClass<*>).java
            )
        } else {
            val annotation = javaParameter.getAnnotation(RequireNameMatch::class.java)
            val parameterName = if (javaParameter.isNamePresent) javaParameter.name else null
            val name =
                getBindingParameterName(parameterName, annotation) ?: throw IllegalArgumentException(
                    "Name for argument of type [${javaParameter.type}] not specified, and parameter name information not " +
                            "available via reflection. Ensure that the kotlinc compiler uses the '-java-parameters' flag, " +
                            "and that the javac compiler uses the '-parameters' flag."
                )

            return expandInputBindings(
                name,
                javaParameter.type
            )
        }
    }

    override fun resolveArgument(
        javaParameter: Parameter,
        kotlinParameter: KParameter?,
        operationContext: OperationContext,
    ): Any? {
        if (kotlinParameter != null) {
            val classifier = kotlinParameter.type.classifier
            if (classifier is KClass<*>) {
                val annotation = kotlinParameter.findAnnotation<RequireNameMatch>()
                val name = getBindingParameterName(kotlinParameter.name, annotation)
                    ?: error(PARAMETER_NAME_SHOULD_BE_AVAILABLE)
                val arg = operationContext.getValue(
                    variable = name,
                    type = classifier.java.name,
                    dataDictionary = operationContext.processContext.agentProcess.agent,
                )
                if (arg == null) {
                    val isNullable = kotlinParameter.isOptional || kotlinParameter.type.isMarkedNullable
                    if (!isNullable) {
                        error("Operation ${operationContext.operation.name}: Internal error. No value found in blackboard for non-nullable parameter ${kotlinParameter.name}:${classifier.java.name}")
                    }
                }
                return arg
            }
        }
        val annotation = javaParameter.getAnnotation(RequireNameMatch::class.java)
        val name = getBindingParameterName(javaParameter.name, annotation)
            ?: error(PARAMETER_NAME_SHOULD_BE_AVAILABLE)
        return operationContext.getValue(
            variable = name,
            type = javaParameter.type.name,
            dataDictionary = operationContext.processContext.agentProcess.agent,
        )

    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/annotation/support/ActionMethodManager.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation.support

import com.embabel.agent.api.common.TransformationActionContext
import com.embabel.agent.core.Action
import org.springframework.ai.tool.ToolCallback
import java.lang.reflect.Method

/**
 * Creates and invokes actions from annotated methods.
 */
interface ActionMethodManager {

    /**
     * Create an Action from a method
     * @param method the method to create an action from
     * @param instance instance of Agent or AgentCapabilities-annotated class
     * @param toolCallbacksOnInstance tool callbacks to use from instance level
     */
    fun createAction(
        method: Method,
        instance: Any,
        toolCallbacksOnInstance: List<ToolCallback>,
    ): Action

    /**
     * Invoke the action method on the given instance.
     */
    fun <O> invokeActionMethod(
        method: Method,
        instance: Any,
        actionContext: TransformationActionContext<List<Any>, O>,
    ): O
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/annotation/support/AgentMetadataReader.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation.support

import com.embabel.agent.api.annotation.*
import com.embabel.agent.api.annotation.Action
import com.embabel.agent.api.annotation.Agent
import com.embabel.agent.api.annotation.Condition
import com.embabel.agent.api.common.OperationContext
import com.embabel.agent.api.common.StuckHandler
import com.embabel.agent.api.common.ToolObject
import com.embabel.agent.core.*
import com.embabel.agent.core.Export
import com.embabel.agent.core.support.Rerun
import com.embabel.agent.core.support.safelyGetToolCallbacksFrom
import com.embabel.agent.validation.AgentStructureValidator
import com.embabel.agent.validation.AgentValidationManager
import com.embabel.agent.validation.DefaultAgentValidationManager
import com.embabel.agent.validation.GoapPathToCompletionValidator
import com.embabel.common.core.types.Semver
import com.embabel.common.util.NameUtils
import com.embabel.common.util.loggerFor
import com.fasterxml.jackson.annotation.JsonTypeInfo
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import org.slf4j.LoggerFactory
import org.springframework.cglib.proxy.Enhancer
import org.springframework.context.support.StaticApplicationContext
import org.springframework.stereotype.Service
import org.springframework.util.ClassUtils
import org.springframework.util.ReflectionUtils
import java.lang.reflect.Method
import java.lang.reflect.Proxy
import com.embabel.agent.core.Action as CoreAction
import com.embabel.agent.core.Agent as CoreAgent
import com.embabel.agent.core.Condition as CoreCondition
import com.embabel.agent.core.Goal as AgentCoreGoal

/**
 * Agentic info about a type
 */
data class AgenticInfo(
    val type: Class<*>,
) {

    // Unwrap proxy to get target class for annotation lookups
    private val targetType: Class<*> = if (Enhancer.isEnhanced(type) ||
        Proxy.isProxyClass(type)
    ) {
        ClassUtils.getUserClass(type)
    } else {
        type
    }

    val agentCapabilitiesAnnotation: AgentCapabilities? = targetType.getAnnotation(AgentCapabilities::class.java)
    val agentAnnotation: Agent? = targetType.getAnnotation(Agent::class.java)

    /**
     * Is this type agentic at all?
     */
    fun agentic() = agentCapabilitiesAnnotation != null || agentAnnotation != null

    fun validationErrors(): Collection<String> {
        val errors = mutableListOf<String>()
        if (agentCapabilitiesAnnotation != null && agentAnnotation != null) {
            errors += "Both @Agentic and @Agent annotations found on ${targetType.name}. Treating class as Agent, but both should not be used"
        }
        if (agentAnnotation != null && agentAnnotation.description.isBlank()) {
            errors + "No description provided for @${Agent::class.java.simpleName} on ${targetType.name}"
        }
        return errors
    }

    fun noAutoScan() = agentCapabilitiesAnnotation?.scan == false || agentAnnotation?.scan == false

    /**
     * Name for this agent. Valid only if agentic() is true.
     */
    fun agentName(): String = (agentAnnotation?.name ?: "").ifBlank { targetType.simpleName }

    /**
     * Gets the target class, unwrapping proxies for method discovery.
     */
    fun getTargetType(): Class<*> = targetType
}

/**
 * Read AgentMetadata from annotated classes.
 * Looks for @Agentic, @Condition and @Action annotations
 * and properties of type Goal.
 * Warn on invalid or missing annotations but never throw an exception
 * as this could affect application startup.
 */
@Service
class AgentMetadataReader(
    private val actionMethodManager: ActionMethodManager = DefaultActionMethodManager(),
    private val nameGenerator: MethodDefinedOperationNameGenerator = MethodDefinedOperationNameGenerator(),
    agentStructureValidator: AgentStructureValidator,
    goapPathToCompletionValidator: GoapPathToCompletionValidator,
) {
    // test-friendly constructor
    constructor() : this(
        DefaultActionMethodManager(),
        MethodDefinedOperationNameGenerator(),
        AgentStructureValidator(StaticApplicationContext()),
        GoapPathToCompletionValidator()
    )

    private val logger = LoggerFactory.getLogger(AgentMetadataReader::class.java)

    private val agentValidationManager: AgentValidationManager = DefaultAgentValidationManager(
        listOf(
            agentStructureValidator,
            goapPathToCompletionValidator
        )
    )

    fun createAgentScopes(vararg instances: Any): List<AgentScope> =
        instances.mapNotNull { createAgentMetadata(it) }

    /**
     * Given this configured instance, find all the methods annotated with @Action and @Condition
     * The instance will have been injected by Spring if it's Spring-managed.
     * @return null if the class doesn't satisfy the requirements of @Agentic
     * or doesn't have the annotation at all.
     * @return an Agent if the class has the @Agent annotation,
     * otherwise the AgentMetadata superinterface
     */
    fun createAgentMetadata(instance: Any): AgentScope? {
        if (instance is Class<*>) {
            logger.warn(
                "❓Call to createAgentMetadata with class {}. Pass an instance",
                instance.name,
            )
            return null
        }

        val agenticInfo = AgenticInfo(instance.javaClass)
        val targetType = agenticInfo.getTargetType()

        if (!agenticInfo.agentic()) {
            logger.debug(
                "No @{} or @{} annotation found on {}",
                AgentCapabilities::class.simpleName,
                Agent::class.simpleName,
                targetType.name,
            )
            return null
        }

        if (agenticInfo.validationErrors().isNotEmpty()) {
            logger.warn(
                agenticInfo.validationErrors().joinToString("\n"),
                AgentCapabilities::class.simpleName,
                Agent::class.simpleName,
                targetType.name,
            )
            return null
        }
        val getterGoals = findGoalGetters(targetType).map { getGoal(it, instance) }
        val actionMethods = findActionMethods(targetType)
        val conditionMethods = findConditionMethods(targetType)

        val toolCallbacksOnInstance = safelyGetToolCallbacksFrom(ToolObject.from(instance))

        val conditions = conditionMethods.map { createCondition(it, instance) }.toSet()
        val (actions, actionGoals) = actionMethods.map { actionMethod ->
            val action = actionMethodManager.createAction(actionMethod, instance, toolCallbacksOnInstance)
            Pair(action, createGoalFromActionMethod(actionMethod, action, instance))
        }.unzip()

        val goals = getterGoals + actionGoals.filterNotNull()

        if (actionMethods.isEmpty() && goals.isEmpty() && conditionMethods.isEmpty()) {
            logger.warn(
                "❓No methods annotated with @{} or @{} and no goals defined on {}",
                Action::class.simpleName,
                Condition::class.simpleName,
                targetType.name,
            )
            return null
        }

        val agent = if (agenticInfo.agentAnnotation != null) {
            CoreAgent(
                name = agenticInfo.agentName(),
                provider = agenticInfo.agentAnnotation.provider.ifBlank {
                    instance.javaClass.`package`.name
                },
                description = agenticInfo.agentAnnotation.description,
                version = Semver(agenticInfo.agentAnnotation.version),
                conditions = conditions,
                actions = actions,
                goals = goals.toSet(),
                stuckHandler = instance as? StuckHandler,
                opaque = agenticInfo.agentAnnotation.opaque,
            )
        } else {
            AgentScope(
                name = agenticInfo.type.name,
                conditions = conditions,
                actions = actions,
                goals = goals.toSet(),
            )
        }

        val validationResult = agentValidationManager.validate(agent)
        if (!validationResult.isValid) {
            logger.warn("Agent validation failed:\n${validationResult.errors.joinToString("\n")}")
            // TODO: Uncomment to strengthen validation and refactor the test if needed. Because some tests might fail.
            // return null
        }

        return agent
    }

    private fun findConditionMethods(type: Class<*>): List<Method> {
        val conditionMethods = mutableListOf<Method>()
        ReflectionUtils.doWithMethods(
            type,
            { method -> conditionMethods.add(method) },
            { method ->
                isConditionMethod(method, type)
            })
        return conditionMethods
    }

    private fun findActionMethods(type: Class<*>): List<Method> {
        val actionMethods = mutableListOf<Method>()
        ReflectionUtils.doWithMethods(
            type,
            { method -> actionMethods.add(method) },
            // Get annotated methods from this type and interfaces
            { method -> isActionMethod(method, type) })
        if (actionMethods.isEmpty()) {
            logger.debug("No methods annotated with @{} found in {}", Action::class.simpleName, type)
        }
        return actionMethods
    }

    private fun isActionMethod(
        method: Method,
        type: Class<*>,
    ): Boolean {
        return method.isAnnotationPresent(Action::class.java) &&
                (type.declaredMethods.contains(method) || isMethodFromSupertype(method, type)) &&
                (!method.returnType.isInterface || hasRequiredJsonDeserializeAnnotationOnInterfaceReturnType(
                    method
                ))
    }

    private fun isConditionMethod(
        method: Method,
        type: Class<*>,
    ): Boolean {
        return method.isAnnotationPresent(Condition::class.java) &&
                (type.declaredMethods.contains(method) || isMethodFromSupertype(method, type))
    }

    private fun isMethodFromSupertype(
        method: Method,
        type: Class<*>,
    ): Boolean {
        // Check interfaces
        if (type.interfaces.any { interfaceType ->
                interfaceType.declaredMethods.any { interfaceMethod ->
                    methodSignaturesMatch(method, interfaceMethod)
                }
            }) {
            return true
        }

        // Check superclasses
        var superclass = type.superclass
        while (superclass != null && superclass != Any::class.java) {
            if (superclass.declaredMethods.any { superMethod ->
                    methodSignaturesMatch(method, superMethod)
                }) {
                return true
            }
            superclass = superclass.superclass
        }

        return false
    }

    private fun methodSignaturesMatch(
        method1: Method,
        method2: Method,
    ): Boolean {
        return method1.name == method2.name &&
                method1.parameterTypes.contentEquals(method2.parameterTypes) &&
                method1.returnType == method2.returnType
    }

    private fun findGoalGetters(type: Class<*>): List<Method> {
        val goalGetters = mutableListOf<Method>()
        type.declaredMethods.forEach { method ->
            if (method.parameterCount == 0 &&
                method.returnType != Void.TYPE
            ) {
                if (AgentCoreGoal::class.java.isAssignableFrom(method.returnType)) {
                    goalGetters.add(method)
                }
            }
        }
        if (goalGetters.isEmpty()) {
            logger.debug("No goal getters found in {}", type)
        }
        return goalGetters
    }

    private fun getGoal(
        method: Method,
        instance: Any,
    ): AgentCoreGoal {
        // We need to change the name to be the property name
        val rawGoal = ReflectionUtils.invokeMethod(method, instance) as AgentCoreGoal
        return rawGoal.copy(
            name = nameGenerator.generateName(
                instance,
                NameUtils.beanMethodToPropertyName(method.name)
            )
        )
    }

    private fun createCondition(
        method: Method,
        instance: Any,
    ): ComputedBooleanCondition {
        requireNonAmbiguousParameters(method)
        val conditionAnnotation = method.getAnnotation(Condition::class.java)
        return ComputedBooleanCondition(
            name = conditionAnnotation.name.ifBlank {
                nameGenerator.generateName(instance, method.name)
            },
            cost = conditionAnnotation.cost,
        )
        { context, condition ->
            invokeConditionMethod(
                method = method,
                instance = instance,
                context = context,
                condition = condition,
            )
        }
    }

    private fun invokeConditionMethod(
        method: Method,
        instance: Any,
        condition: CoreCondition,
        context: OperationContext,
    ): Boolean {
        logger.debug("Invoking condition method {} on {}", method.name, instance.javaClass.name)
        val args = mutableListOf<Any>()

        for (parameter in method.parameters) {
            when {
                OperationContext::class.java.isAssignableFrom(parameter.type) -> {
                    args += context
                }

                else -> {
                    val requireNameMatch = parameter.getAnnotation(RequireNameMatch::class.java)
                    val domainTypes = context.agentProcess.agent.jvmTypes.map { it.clazz }
                    val variable = getBindingParameterName(parameter.name, requireNameMatch)
                        ?: error("Parameter name should be available")
                    args += context.getValue(
                        variable = variable,
                        type = parameter.type.name,
                        context.agentProcess.agent,
                    )
                        ?: return run {
                            // TODO assignable?
                            if (domainTypes.contains(parameter.type)) {
                                // This is not an error condition
                                logger.debug(
                                    "Condition method {}.{} has no value for parameter {} of known type {}: Returning false",
                                    instance.javaClass.name,
                                    method.name,
                                    variable,
                                    parameter.type,
                                )
                            } else {
                                logger.warn(
                                    "Condition method {}.{} has unsupported argument {}. Unknown type {}",
                                    instance.javaClass.name,
                                    method.name,
                                    variable,
                                    parameter.type,
                                )
                            }
                            false
                        }
                }
            }
        }
        return try {
            method.trySetAccessible()
            val evaluationResult = ReflectionUtils.invokeMethod(method, instance, *args.toTypedArray()) as Boolean
            logger.debug(
                "Condition evaluated to {}, calling {} on {} using args {}",
                evaluationResult,
                method.name,
                instance.javaClass.name,
                args,
            )
            evaluationResult
        } catch (t: Throwable) {
            logger.warn("Error invoking condition method ${method.name} with args $args", t)
            false
        }
    }

    /**
     * If the @Action method also has an @AchievesGoal annotation,
     * create a goal from it.
     */
    private fun createGoalFromActionMethod(
        method: Method,
        action: CoreAction,
        instance: Any,
    ): AgentCoreGoal? {
        val actionAnnotation = method.getAnnotation(Action::class.java)
        val goalAnnotation = method.getAnnotation(AchievesGoal::class.java) ?: return null
        val inputBinding = IoBinding(
            name = actionAnnotation.outputBinding,
            type = method.returnType.name,
        )
        return AgentCoreGoal(
            name = nameGenerator.generateName(instance, method.name),
            description = goalAnnotation.description,
            inputs = setOf(inputBinding),
            outputType = JvmType(method.returnType),
            value = goalAnnotation.value,
            // Add precondition of the action having run
            pre = setOf(Rerun.hasRunCondition(action)) + action.preconditions.keys.toSet(),
            export = Export(
                local = goalAnnotation.export.local,
                remote = goalAnnotation.export.remote,
                name = goalAnnotation.export.name.ifBlank { null },
                startingInputTypes = goalAnnotation.export.startingInputTypes.map { it.java }.toSet(),
            )
        )
    }
}

/**
 * Checks if a method returning an interface returns a type with a @JsonDeserialize annotation.
 * @param method The Java method to check.
 * @return true if the return type has a @JsonDeserialize annotation, false otherwise
 */
private fun hasRequiredJsonDeserializeAnnotationOnInterfaceReturnType(method: Method): Boolean {
    val hasRequiredAnnotation = method.returnType.isAnnotationPresent(JsonDeserialize::class.java) ||
            method.returnType.isAnnotationPresent(JsonTypeInfo::class.java)
    if (!hasRequiredAnnotation) {
        loggerFor<AgentMetadataReader>().warn(
            "❓Interface {} used as return type of {}.{} must have @JsonDeserialize or @JsoonTypeInfo annotation",
            method.returnType,
            method.declaringClass,
            method.name,
        )
    }
    return hasRequiredAnnotation
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/annotation/support/DefaultActionMethodManager.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation.support

import com.embabel.agent.api.annotation.AwaitableResponseException
import com.embabel.agent.api.common.TransformationActionContext
import com.embabel.agent.api.common.support.MultiTransformationAction
import com.embabel.agent.core.Action
import com.embabel.agent.core.IoBinding
import com.embabel.agent.core.ToolGroupRequirement
import org.slf4j.LoggerFactory
import org.springframework.ai.tool.ToolCallback
import org.springframework.core.KotlinDetector
import org.springframework.stereotype.Component
import org.springframework.util.ReflectionUtils
import java.lang.reflect.InvocationTargetException
import java.lang.reflect.Method
import kotlin.reflect.KClass
import kotlin.reflect.KFunction
import kotlin.reflect.full.valueParameters
import kotlin.reflect.jvm.isAccessible
import kotlin.reflect.jvm.kotlinFunction

/**
 * Implementation that creates dummy instances of domain objects to discover tools,
 * before re-reading the tool callbacks from the actual domain object instances at invocation time.
 */
@Component
internal class DefaultActionMethodManager(
    val nameGenerator: MethodDefinedOperationNameGenerator = MethodDefinedOperationNameGenerator(),
    val argumentResolvers: List<ActionMethodArgumentResolver> = listOf(
        ProcessContextArgumentResolver(),
        OperationContextArgumentResolver(),
        AiArgumentResolver(),
        BlackboardArgumentResolver(),
    ),
) : ActionMethodManager {

    private val logger = LoggerFactory.getLogger(DefaultActionMethodManager::class.java)

    @Suppress("UNCHECKED_CAST")
    override fun createAction(
        method: Method,
        instance: Any,
        toolCallbacksOnInstance: List<ToolCallback>,
    ): Action {
        requireNonAmbiguousParameters(method)
        val actionAnnotation = method.getAnnotation(com.embabel.agent.api.annotation.Action::class.java)
        val inputClasses = method.parameters
            .map { it.type }
        val inputs = resolveInputBindings(method)

        require(method.returnType != null) { "Action method ${method.name} must have a return type" }

        return MultiTransformationAction(
            name = nameGenerator.generateName(instance, method.name),
            description = actionAnnotation.description.ifBlank { method.name },
            cost = actionAnnotation.cost,
            inputs = inputs.toSet(),
            canRerun = actionAnnotation.canRerun,
            pre = actionAnnotation.pre.toList(),
            post = actionAnnotation.post.toList(),
            inputClasses = inputClasses,
            outputClass = method.returnType,
            outputVarName = actionAnnotation.outputBinding,
            toolGroups = (actionAnnotation.toolGroupRequirements.map { ToolGroupRequirement(it.role) } + actionAnnotation.toolGroups.map {
                ToolGroupRequirement(
                    it
                )
            }).toSet(),
        ) { context ->
            invokeActionMethod(
                method = method,
                instance = instance,
                actionContext = context,
            )
        }
    }

    private fun resolveInputBindings(
        javaMethod: Method,
    ): Set<IoBinding> {
        val result = mutableSetOf<IoBinding>()
        val kotlinFunction = if (KotlinDetector.isKotlinReflectPresent()) javaMethod.kotlinFunction else null
        for (i in javaMethod.parameters.indices) {
            val javaParameter = javaMethod.parameters[i]
            val kotlinParameter = kotlinFunction?.valueParameters?.getOrNull(i)
            for (argumentResolver in argumentResolvers) {
                if (argumentResolver.supportsParameter(javaParameter, kotlinParameter, null)) {
                    result += argumentResolver.resolveInputBinding(javaParameter, kotlinParameter)
                    break
                }
            }
        }
        return result
    }

    override fun <O> invokeActionMethod(
        method: Method,
        instance: Any,
        actionContext: TransformationActionContext<List<Any>, O>,
    ): O {
        logger.debug("Invoking action method {} with payload {}", method.name, actionContext.input)
        val result = if (KotlinDetector.isKotlinReflectPresent()) {
            val kFunction = method.kotlinFunction
            if (kFunction != null) invokeActionMethodKotlinReflect(method, kFunction, instance, actionContext)
            else invokeActionMethodJavaReflect(method, instance, actionContext)
        } else {
            invokeActionMethodJavaReflect(method, instance, actionContext)
        }
        logger.debug(
            "Result of invoking action method {} was {}: payload {}",
            method.name,
            result,
            actionContext.input
        )
        return result
    }

    private fun <O> invokeActionMethodKotlinReflect(
        method: Method,
        kFunction: KFunction<*>,
        instance: Any,
        actionContext: TransformationActionContext<List<Any>, O>,
    ): O {
        val args = arrayOfNulls<Any?>(method.parameters.size + 1)
        args[0] = instance
        for (i in method.parameters.indices) {
            val javaParameter = method.parameters[i]
            val kotlinParameter = kFunction.valueParameters.getOrNull(i)
            val classifier = kotlinParameter?.type?.classifier
            if (classifier is KClass<*>) {
                for (argumentResolver in argumentResolvers) {
                    if (argumentResolver.supportsParameter(javaParameter, kotlinParameter, actionContext)) {
                        val arg = argumentResolver.resolveArgument(javaParameter, kotlinParameter, actionContext)
                        if (arg == null) {
                            val isNullable = kotlinParameter.isOptional || kotlinParameter.type.isMarkedNullable
                            if (!isNullable) {
                                error("Action ${actionContext.action.name}: Internal error. No value found in blackboard for non-nullable parameter ${kotlinParameter.name}:${classifier.java.name}")
                            }
                        }
                        args[i + 1] = arg
                    }
                }
            }
        }

        val result = try {
            try {
                kFunction.isAccessible = true
                kFunction.call(*args)
            } catch (ite: InvocationTargetException) {
                ReflectionUtils.handleInvocationTargetException(ite)
            }
        } catch (awe: AwaitableResponseException) {
            handleAwaitableResponseException(instance.javaClass.name, kFunction.name, awe)
        } catch (t: Throwable) {
            handleThrowable(instance.javaClass.name, kFunction.name, t)
        }
        return result as O
    }

    private fun <O> invokeActionMethodJavaReflect(
        method: Method,
        instance: Any,
        actionContext: TransformationActionContext<List<Any>, O>,
    ): O {
        val args = arrayOfNulls<Any?>(method.parameters.size)
        for (i in method.parameters.indices) {
            val parameter = method.parameters[i]
            for (argumentResolver in argumentResolvers) {
                if (argumentResolver.supportsParameter(parameter, null, actionContext)) {
                    val arg = argumentResolver.resolveArgument(parameter, null, actionContext)
                    args[i] = arg
                }
            }
        }

        val result = try {
            method.trySetAccessible()
            ReflectionUtils.invokeMethod(method, instance, *args)
        } catch (awe: AwaitableResponseException) {
            handleAwaitableResponseException(instance.javaClass.name, method.name, awe)
        } catch (t: Throwable) {
            handleThrowable(instance.javaClass.name, method.name, t)
        }
        return result as O
    }

    private fun handleAwaitableResponseException(
        instanceName: String,
        methodName: String,
        awe: AwaitableResponseException,
    ) {
        // This is not a failure, but will drive transition to a wait state
        logger.info(
            "Action method {}.{} entering wait state: {}",
            instanceName,
            methodName,
            awe.message,
        )
        throw awe
    }

    private fun handleThrowable(
        instanceName: String,
        methodName: String,
        t: Throwable,
    ) {
        logger.warn(
            "Error invoking action method {}.{}: {}",
            instanceName,
            methodName,
            t.message,
        )
        throw t
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/annotation/support/DuplicateParameterType.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation.support

import java.lang.reflect.Method
import java.lang.reflect.Parameter

/**
 * A class representing a method with multiple parameters of the same type that have not been annotated with
 * [com.embabel.agent.api.annotation.RequireNameMatch].
 */
class DuplicateParameterType(
    /** The method with multiple parameters of the same type which require @RequireNameMatch annotation */
    val method: Method,
    /** The type of the parameter that is ambiguous. */
    val conflictingClassType: Class<*>,
    /** The parameters that are ambiguous. */
    val conflictingParameters: List<Parameter>,
)



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/annotation/support/DuplicateParameterTypeException.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation.support

import com.embabel.agent.api.annotation.RequireNameMatch
import java.lang.reflect.Method
import java.lang.reflect.Parameter

/**
 * A class representing a method with multiple parameters of the same type that have not been annotated with
 * [com.embabel.agent.api.annotation.RequireNameMatch].
 */
class DuplicateParameterTypeException(
    val method: Method,
    val duplicates: List<DuplicateParameterType>,
) : RuntimeException(buildDuplicateParameterTypeMessage(method, duplicates))

/**
 * Checks if a method has multiple parameters with the same type, but no @RequireNameMatch annotation.
 * This prevents any issue when the developer forgets to add @RequireNameMatch when parameters have the same type and
 * the system is unable to determine the correct parameter order.
 *
 * @param method The method to check.
 * @throws DuplicateParameterTypeException If the method has multiple parameters with the same type.
 */
fun requireNonAmbiguousParameters(method: Method) {
    val parameterMap: Map<Class<*>, List<Parameter>> = method.parameters.groupBy { it.type }

    // For any class type with more than one parameter, flag as duplicate only when
    // ALL of those parameters are NOT annotated with @RequireNameMatch
    val duplicates = parameterMap
        .asSequence()
        .filter { (_, params) -> params.size > 1 }
        .filter { (_, params) -> isNotProperlyAnnotated(params) }
        .map { (clazz, params) ->
            DuplicateParameterType(
                method = method,
                conflictingClassType = clazz,
                conflictingParameters = params
            )
        }
        .toList()

    if (duplicates.isNotEmpty()) {
        throw DuplicateParameterTypeException(method = method, duplicates)
    }
}

internal fun isNotProperlyAnnotated(params: List<Parameter>): Boolean =
    !params.all { it.isAnnotationPresent(RequireNameMatch::class.java) } &&
            !params.none { it.isAnnotationPresent(RequireNameMatch::class.java) }

/**
 * Builds a detailed error message for the [DuplicateParameterTypeException] that instructs the developer on how to
 * resolve the issue.
 *
 * @param method The method with duplicate parameter types.
 * @param duplicates The list of duplicate parameter types found in the method.
 * @return A formatted error message describing the issue and how to resolve it.
 */
internal fun buildDuplicateParameterTypeMessage(
    method: Method,
    duplicates: List<DuplicateParameterType>,
): String {
    val declaring = method.declaringClass.name
    val params = method.parameters
    fun positionOf(p: Parameter) = params.indexOf(p)
    val details = duplicates.joinToString(separator = "; ") { d ->
        val positions = d.conflictingParameters.joinToString(
            prefix = "(",
            postfix = ")",
            separator = ", "
        ) { p ->
            val idx = positionOf(p)
            val name = p.name
            "#$idx(name='$name')"
        }
        "${d.conflictingClassType.name} at $positions"
    }

    return """
        Ambiguous parameters in $declaring.${method.name}(): multiple parameters share the same type without @RequireNameMatch.
        Conflicts: $details.
        How to fix: annotate each parameter of the duplicated type with @RequireNameMatch so values are bound by parameter name, or make the parameter types unique.
        """
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/annotation/support/MethodDefinedOperationNameGenerator.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation.support

import org.springframework.stereotype.Component

/**
 * Define names for operations defined in methods.
 */
fun interface MethodDefinedOperationNameGenerator {
    /**
     * Generate a qualified name to avoid name clashes.
     * @param instance The instance of the class we are reading
     * @param name The name of the method or property for which we should generate a method
     */
    fun generateName(instance: Any, name: String): String

    companion object {
        @JvmStatic
        operator fun invoke(): MethodDefinedOperationNameGenerator =
            FromClassAndMethodMethodDefinedOperationNameGenerator
    }
}

@Component
internal object FromClassAndMethodMethodDefinedOperationNameGenerator : MethodDefinedOperationNameGenerator {
    override fun generateName(instance: Any, name: String): String {
        // Strip the $ suffix from Kotlin internal methods
        return "${instance.javaClass.name}.${stripDollarSign(name)}"
    }

    private fun stripDollarSign(input: String): String {
        val dollarIndex = input.indexOf('$')
        return if (dollarIndex >= 0) {
            input.substring(0, dollarIndex)
        } else {
            input
        }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/annotation/support/MultiTransformationAction.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation.support



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/annotation/support/utils.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation.support

import com.embabel.agent.api.annotation.RequireNameMatch
import com.embabel.agent.core.AgentPlatform
import com.embabel.agent.core.IoBinding

/**
 * Convenient method to deploy instances to an agent platform
 */
fun AgentPlatform.deployAnnotatedInstances(
    agentMetadataReader: AgentMetadataReader,
    vararg instances: Any,
) {
    instances
        .mapNotNull { agentMetadataReader.createAgentMetadata(it) }
        .forEach { deploy(it) }
}

/**
 * Returns the name of the parameter based on the provided [RequireNameMatch].
 */
fun getBindingParameterName(
    parameterName: String?,
    requireNameMatch: RequireNameMatch?
): String? {
    if (requireNameMatch == null) {
        return IoBinding.DEFAULT_BINDING
    }

    return requireNameMatch.value.ifBlank { parameterName }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/README.md
================================================
# Common APIs

Types common to all API usages, whether annotation model, Kotlin DSL
or any other.


================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/ActionContext.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common

import com.embabel.agent.api.common.support.OperationContextPromptRunner
import com.embabel.agent.api.dsl.AgentScopeBuilder
import com.embabel.agent.channel.MessageOutputChannelEvent
import com.embabel.agent.channel.OutputChannelEvent
import com.embabel.agent.channel.ProgressOutputChannelEvent
import com.embabel.agent.core.*
import com.embabel.agent.prompt.element.ContextualPromptElement
import com.embabel.chat.Message
import com.embabel.common.ai.model.LlmOptions
import com.embabel.common.ai.prompt.CurrentDate
import com.embabel.common.ai.prompt.PromptContributor

/**
 * OperationContext that execute actions.
 * An ExecutingOperationContext can execute agents as sub-processes.
 */
interface ExecutingOperationContext : OperationContext {

    /**
     * Convenience method to send a message to the output channel of the process.
     */
    fun sendMessage(message: Message) {
        processContext.outputChannel.send(
            MessageOutputChannelEvent(agentProcess.id, message)
        )
    }

    fun updateProgress(message: String) {
        sendOutputChannelEvent(ProgressOutputChannelEvent(agentProcess.id, message))
    }

    fun sendOutputChannelEvent(event: OutputChannelEvent) {
        processContext.outputChannel.send(
            event
        )
    }

    /**
     * Run the given agent as a sub-process of this operation context.
     * @param outputClass the class of the output of the agent
     * @param agentScopeBuilder the builder for the agent scope to run
     */
    fun <O : Any> asSubProcess(
        outputClass: Class<O>,
        agentScopeBuilder: AgentScopeBuilder<O>,
    ): O {
        val agent = agentScopeBuilder.build().createAgent(
            name = agentScopeBuilder.name,
            provider = agentScopeBuilder.provider,
            description = agentScopeBuilder.name,
        )
        return asSubProcess(
            outputClass = outputClass,
            agent = agent,
        )
    }

    /**
     * Run the given agent as a sub-process of this operation context.
     */
    fun <O : Any> asSubProcess(
        outputClass: Class<O>,
        agent: Agent,
    ): O {
        val singleAction = agentTransformer(
            agent = agent,
            inputClass = Unit::class.java,
            outputClass = outputClass,
        )

        singleAction.execute(
            processContext = this.processContext,
        )
        return last(outputClass) ?: throw IllegalStateException(
            "No output of type ${outputClass.name} found in context"
        )
    }

    companion object {

        /**
         * Create an ExecutingOperationContext for the given process context and operation.
         */
        operator fun invoke(
            name: String,
            agentProcess: AgentProcess,
        ): ExecutingOperationContext =
            ExecutingOperationContextImpl(
                processContext = agentProcess.processContext,
                operation = InjectedType.named(name),
                toolGroups = emptySet(),
            )
    }

}

private class ExecutingOperationContextImpl(
    override val processContext: ProcessContext,
    override val operation: Operation,
    override val toolGroups: Set<ToolGroupRequirement>,
) : ExecutingOperationContext, Blackboard by processContext.agentProcess {
    override fun toString(): String {
        return "${javaClass.simpleName}(processContext=$processContext, operation=${operation.name})"
    }
}

/**
 * Context for actions
 * @param processContext the process context
 * @param action the action being executed, if one is executing.
 * This is useful for getting tools etc.
 */
interface ActionContext : ExecutingOperationContext {
    override val processContext: ProcessContext
    val action: Action?

    override fun promptRunner(
        llm: LlmOptions,
        toolGroups: Set<ToolGroupRequirement>,
        toolObjects: List<ToolObject>,
        promptContributors: List<PromptContributor>,
        contextualPromptContributors: List<ContextualPromptElement>,
        generateExamples: Boolean,
    ): PromptRunner {
        val promptContributorsToUse = (promptContributors + CurrentDate()).distinctBy { it.promptContribution().role }

        val doi = domainObjectInstances()
        return OperationContextPromptRunner(
            this,
            llm = llm,
            toolGroups = this.toolGroups + toolGroups,
            toolObjects = (toolObjects + doi.map { ToolObject(it) }).distinct(),
            promptContributors = promptContributorsToUse,
            contextualPromptContributors = contextualPromptContributors,
            generateExamples = generateExamples,
        )
    }

    /**
     * Return the domain object instances that are relevant for this action context.
     * They may expose tools.
     */
    fun domainObjectInstances(): List<Any>

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/AgentPlatformTypedOps.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common

import com.embabel.agent.common.Constants
import com.embabel.agent.core.*
import org.slf4j.LoggerFactory

class NoSuchAgentException(
    val agentName: String,
    val knownAgents: String
) : IllegalArgumentException("No such agent: '$agentName'. Known agents: $knownAgents")


/**
 * Typed operations over an agent platform
 */
class AgentPlatformTypedOps(
    private val agentPlatform: AgentPlatform
) : TypedOps {

    private val logger = LoggerFactory.getLogger(javaClass)

    override fun <I : Any, O> asFunction(
        outputClass: Class<O>,
    ): AgentFunction<I, O> =
        AgentPlatformBackedAgentFunction(
            outputClass = outputClass,
            agentPlatform = agentPlatform,
        )

    override fun <I : Any, O> asFunction(
        outputClass: Class<O>,
        agentName: String,
    ): AgentFunction<I, O> {
        val agent = agentPlatform.agents().firstOrNull { it.name == agentName }
            ?: throw NoSuchAgentException(agentName, agentPlatform.agents().joinToString { it.name })
        logger.info("Creating function for agent $agentName")
        return AgentBackedAgentFunction(
            outputClass = outputClass,
            agentPlatform = agentPlatform,
            agent = agent,
        )
    }
}

private class AgentPlatformBackedAgentFunction<I : Any, O>(
    override val outputClass: Class<O>,
    private val agentPlatform: AgentPlatform,
) : AgentFunction<I, O> {

    // TODO verify if it's impossible to get from I to O

    override val agentScope: AgentScope
        get() = agentPlatform

    override fun apply(input: I, processOptions: ProcessOptions): O {
        val goalAgent = agentPlatform.createAgent(
            name = "goal-${outputClass.simpleName}",
            provider = Constants.EMBABEL_PROVIDER,
            description = "Goal agent for ${outputClass.simpleName}",
        )
            .withSingleGoal(
                Goal(
                    name = "create-${outputClass.simpleName}",
                    description = "Create ${outputClass.simpleName}",
                    satisfiedBy = outputClass,
                )
            )

        val processStatus = agentPlatform.runAgentFrom(
            processOptions = processOptions,
            agent = goalAgent,
            bindings = mapOf(
                IoBinding.DEFAULT_BINDING to input,
            )
        )
        return processStatus.resultOfType(outputClass)
    }
}

private class AgentBackedAgentFunction<I : Any, O>(
    override val outputClass: Class<O>,
    private val agentPlatform: AgentPlatform,
    private val agent: Agent,
) : AgentFunction<I, O> {

    // TODO verify if it's impossible to get from I to O

    override val agentScope: AgentScope
        get() = agentPlatform

    override fun apply(input: I, processOptions: ProcessOptions): O {
        val processStatus = agentPlatform.runAgentFrom(
            processOptions = processOptions,
            agent = agent,
            bindings = mapOf(
                IoBinding.DEFAULT_BINDING to input,
            )
        )
        return processStatus.resultOfType(outputClass)
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/Ai.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common

import com.embabel.agent.core.LlmVerbosity
import com.embabel.agent.core.ProcessOptions
import com.embabel.common.ai.model.*
import org.springframework.ai.embedding.EmbeddingModel

typealias Embedding = FloatArray


/**
 * Gateway to AI functionality in the context of an operation.
 * This includes both LLM and embedding models.
 */
interface Ai {

    /**
     * Return an embedding model with the given name
     */
    fun withEmbeddingModel(model: String): EmbeddingModel =
        withEmbeddingModel(ModelSelectionCriteria.byName(model))

    /**
     * Return an embedding model matching the given criteria.
     */
    fun withEmbeddingModel(criteria: ModelSelectionCriteria): EmbeddingModel

    fun withDefaultEmbeddingModel(): EmbeddingModel =
        withEmbeddingModel(DefaultModelSelectionCriteria)

    /**
     * Get a configurable PromptRunner for this context using
     * the given LLM. Allows full control over LLM options.
     */
    fun withLlm(llm: LlmOptions): PromptRunner

    /**
     * Get a configurable PromptRunner for this context choosing
     * the given model by name and the default LLM options.
     * Does not allow for any other LLM options to be set.
     */
    fun withLlm(model: String): PromptRunner {
        return withLlm(LlmOptions(model = model))
    }

    /**
     * Get a configurable PromptRunner for this context choosing
     * the given model by role and the default LLM options.
     * Does not allow for any other LLM options to be set.
     * Users must configure roles, for example in application.properties.
     */
    fun withLlmByRole(role: String): PromptRunner {
        return withLlm(LlmOptions(criteria = ModelSelectionCriteria.byRole(role)))
    }

    /**
     * Get a configurable PromptRunner for this context using
     * automatic model selection criteria. This may consider prompt
     * and tools, so is not the same as default.
     */
    fun withAutoLlm(): PromptRunner {
        return withLlm(LlmOptions(criteria = AutoModelSelectionCriteria))
    }

    /**
     * Get a configurable PromptRunner for this context using
     * the default model selection criteria.
     */
    fun withDefaultLlm(): PromptRunner {
        return withLlm(LlmOptions(criteria = DefaultModelSelectionCriteria))
    }

    fun withFirstAvailableLlmOf(vararg llms: String): PromptRunner {
        return withLlm(LlmOptions(criteria = FallbackByNameModelSelectionCriteria(llms.toList())))
    }
}

/**
 * Builder that can be injected into components
 * to obtain Ai instances.
 * Use when you want custom configuration.
 */
interface AiBuilder : LlmVerbosity {

    /**
     * Build an Ai instance according to the configuration.
     */
    fun ai(): Ai

    fun withProcessOptions(options: ProcessOptions): AiBuilder

    fun withShowPrompts(show: Boolean): AiBuilder

    fun withShowLlmResponses(show: Boolean): AiBuilder
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/Asyncer.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common

import java.util.concurrent.CompletableFuture

/**
 * Simple Java-friendly async interface.
 */
interface Asyncer {

    fun <T> async(block: () -> T): CompletableFuture<T>

    fun <T, R> parallelMap(
        items: Collection<T>,
        maxConcurrency: Int,
        transform: (t: T) -> R,
    ): List<R>

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/composites.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common

import java.lang.reflect.Field
import java.lang.reflect.Modifier

/**
 * Tag interface to indicate that an implementing type should be built from the context from its bound fields.
 * Provides a strongly typed way to wait on combined results.
 * Makes a megazord!
 * An aggregation should have multiple non-nullable fields, each of which will be bound to the blackboard.
 * An aggregation is used as an input to the action.
 */
interface Aggregation

/**
 * Tag interface used as an action return type. Indicates that some of the fields will be bound to the blackboard.
 * Fields are usually nullable.
 */
interface SomeOf {

    companion object {

        /**
         * Fields of this SomeOf that are domain types and can be bound to the blackboard.
         */
        fun eligibleFields(
            outputClass: Class<*>,
        ): Set<Field> {
            return outputClass.declaredFields
                .filter { !it.isSynthetic && !Modifier.isStatic(it.modifiers) }
                .toSet()
        }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/InteractionId.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common

/**
 * All prompt interactions through the platform need a unique id
 * This allows LLM interactions to be optimized by an AgentPlatform
 */
@JvmInline
value class InteractionId(val value: String) {

    override fun toString(): String = value
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/LlmReference.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common

import com.embabel.common.ai.prompt.PromptContributor
import com.embabel.common.core.types.NamedAndDescribed

/**
 * An LLmReference exposes tools and is a prompt contributor.
 * The prompt contribution might describe how to use the tools
 * or can include relevant information directly.
 * Consider, for example, a reference to an API which is so small it's
 * included in the prompt, versus a large API which must be
 * accessed via tools.
 * The reference name is used in a strategy for tool naming, so should be fairly short.
 * Description may be more verbose.
 * If you want a custom naming strategy, use a ToolObject directly,
 * and add the PromptContributor separately.
 */
interface LlmReference : NamedAndDescribed, PromptContributor {

    /**
     * A safe prefix for LLM tools associated with this reference.
     * Defaults to the name lowercased with spaces replaced by underscores.
     * Subclasses can override it
     */
    fun toolPrefix(): String = name.replace(Regex("[^a-zA-Z0-9 ]"), "_").lowercase()

    /**
     * Create a tool object for this reference.
     */
    fun toolObject(): ToolObject = ToolObject(
        obj = toolInstance(),
        namingStrategy = { toolName -> "${toolPrefix()}_$toolName" },
    )

    /**
     * Return the instance of the tool object. Defaults to this
     */
    fun toolInstance(): Any = this

    override fun contribution(): String {
        return """|
            |Reference: $name
            |Description: $description
            |Tool prefix: ${toolPrefix()}
            |Notes: ${notes()}
        """.trimMargin()
    }

    /**
     * Notes about this reference, such as usage guidance.
     * Does not need to consider prompt prefix, name or description as
     * they will be added automatically.
     */
    fun notes(): String
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/ObjectCreator.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common

import com.embabel.chat.Message
import com.embabel.chat.UserMessage
import com.embabel.common.ai.prompt.PromptContributor
import com.fasterxml.jackson.databind.ObjectMapper

/**
 * Interface to create objects of the given type from a prompt or messages.
 * Allows setting strongly typed examples.
 */
interface ObjectCreator<T> {

    /**
     * Add an example of the desired output to the prompt.
     * This will be included in JSON.
     * It is possible to call this method multiple times.
     * This will override PromptRunner.withGenerateExamples
     */
    fun withExample(
        description: String,
        value: T,
    ): ObjectCreator<T>

    /**
     * Create an object of the desired type using the given prompt and LLM options from context
     * (process context or implementing class).
     * Prompts are typically created within the scope of an
     * @Action method that provides access to
     * domain object instances, offering type safety.
     */
    fun fromPrompt(
        prompt: String,
    ): T = fromMessages(
        messages = listOf(UserMessage(prompt)),
    )

    /**
     * Create an object of the desired typed from messages
     */
    fun fromMessages(
        messages: List<Message>,
    ): T

}

internal data class PromptRunnerObjectCreator<T>(
    internal val promptRunner: PromptRunner,
    internal val outputClass: Class<T>,
    private val objectMapper: ObjectMapper,
) : ObjectCreator<T> {

    override fun withExample(
        description: String,
        value: T,
    ): ObjectCreator<T> {
        return copy(
            promptRunner = promptRunner
                .withGenerateExamples(false)
                .withPromptContributor(
                    PromptContributor.Companion.fixed(
                        """
                        Example: $description
                        ${objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(value)}
                        """.trimIndent()
                    )
                )
        )
    }

    override fun fromMessages(
        messages: List<Message>,
    ): T {
        return promptRunner.createObject(
            messages = messages,
            outputClass = outputClass,
        )
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/OperationContext.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common

import com.embabel.agent.api.common.autonomy.AgentInvocation
import com.embabel.agent.api.common.support.OperationContextPromptRunner
import com.embabel.agent.api.dsl.AgentScopeBuilder
import com.embabel.agent.core.*
import com.embabel.agent.event.AgenticEventListener
import com.embabel.agent.identity.User
import com.embabel.agent.prompt.element.ContextualPromptElement
import com.embabel.common.ai.model.LlmOptions
import com.embabel.common.ai.model.ModelSelectionCriteria
import com.embabel.common.ai.prompt.CurrentDate
import com.embabel.common.ai.prompt.PromptContributor
import org.springframework.ai.embedding.EmbeddingModel
import java.util.concurrent.CompletableFuture

/**
 * Context for any operation. Exposes blackboard and process context.
 * @param processContext the process context
 */
interface OperationContext : Blackboard, ToolGroupConsumer {

    val processContext: ProcessContext

    val agentProcess: AgentProcess
        get() = processContext.agentProcess

    fun agentPlatform() = processContext.platformServices.agentPlatform

    /**
     * Convenient way to get the user on whose behalf this operation is being executed, if any.
     */
    fun user(): User? = processContext.processOptions.identities.forUser

    /**
     * Action or operation that is being executed.
     */
    val operation: Operation

    /**
     * Any agents known to the present platform that can handle the given object and return the given result type.
     * It is not an error if there are no such agents
     */
    fun <T : Any> fireAgent(
        obj: Any,
        resultType: Class<T>,
    ): CompletableFuture<T>? {
        val invocation = AgentInvocation.create(agentPlatform(), resultType)
        return invocation.invokeAsync(obj)
    }

    /**
     * Get AI functionality for this context
     */
    fun ai(): Ai = OperationContextAi(this)

    /**
     * Create a prompt runner for this context.
     * Application code should always go through this method to run LLM operations.
     * @param llm the LLM options to use
     * @param toolGroups extra local tool groups to use, in addition to those declared on the action if
     * we're in an action
     * @param promptContributors extra prompt contributors to use, in addition to those declared on the action if
     * we're in an action, or at agent level
     */
    fun promptRunner(
        llm: LlmOptions = LlmOptions(),
        toolGroups: Set<ToolGroupRequirement> = emptySet(),
        toolObjects: List<ToolObject> = emptyList(),
        promptContributors: List<PromptContributor> = emptyList(),
        contextualPromptContributors: List<ContextualPromptElement> = emptyList(),
        generateExamples: Boolean = false,
    ): PromptRunner {
        val promptContributorsToUse = (promptContributors + CurrentDate()).distinctBy { it.promptContribution().role }
        return OperationContextPromptRunner(
            context = this,
            llm = llm,
            toolGroups = toolGroups,
            toolObjects = toolObjects,
            promptContributors = promptContributorsToUse,
            contextualPromptContributors = contextualPromptContributors,
            generateExamples = generateExamples,
        )
    }

    /**
     * Create a prompt runner for this context
     * that can be customized later.
     * Principally for use from Java.
     */
    fun promptRunner(): PromptRunner = promptRunner(
        llm = LlmOptions(),
    )

    /**
     * Execute the operations in parallel.
     * @param items the collection of items to process
     * @param maxConcurrency the maximum number of concurrent operations to run
     * @param transform the transformation function to apply to each element
     */
    fun <T, R> parallelMap(
        items: Collection<T>,
        maxConcurrency: Int,
        transform: (t: T) -> R,
    ): List<R> = processContext.platformServices.asyncer.parallelMap(
        items = items,
        transform = transform,
        maxConcurrency = maxConcurrency,
    )


    companion object {
        operator fun invoke(
            processContext: ProcessContext,
            operation: Operation,
            toolGroups: Set<ToolGroupRequirement>,
        ): OperationContext =
            OperationContextImpl(
                processContext = processContext,
                operation = operation,
                toolGroups = toolGroups,
            )
    }
}

private class OperationContextImpl(
    override val processContext: ProcessContext,
    override val operation: Operation,
    override val toolGroups: Set<ToolGroupRequirement>,
) : OperationContext, Blackboard by processContext.agentProcess {
    override fun toString(): String {
        return "${javaClass.simpleName}(processContext=$processContext, operation=${operation.name})"
    }
}

/**
 * Run the given agent as a sub-process of this action context.
 */
inline fun <reified O : Any> ActionContext.asSubProcess(
    agentScopeBuilder: AgentScopeBuilder<O>,
): O = asSubProcess(
    outputClass = O::class.java,
    agentScopeBuilder = agentScopeBuilder,
)

/**
 * Run the given agent as a sub-process of this action context.
 * @param agent the agent to run
 */
inline fun <reified O : Any> ActionContext.asSubProcess(
    agent: Agent,
): O = asSubProcess(
    outputClass = O::class.java,
    agent = agent,
)

/**
 * ActionContext with multiple inputs
 */
interface InputsActionContext : ActionContext {
    val inputs: List<Any>

    override fun domainObjectInstances(): List<Any> = inputs.flatMap { input ->
        when (input) {
            is List<*> -> input.filterNotNull()
            else -> listOf(input)
        }.distinct()
    }
}

/**
 * ActionContext with a single input
 */
interface InputActionContext<I> : InputsActionContext {
    val input: I

    override val inputs: List<Any> get() = listOfNotNull(input)
}

data class TransformationActionContext<I, O>(
    override val input: I,
    override val processContext: ProcessContext,
    override val action: Action,
    val inputClass: Class<I>,
    val outputClass: Class<O>,
) : InputActionContext<I>, Blackboard by processContext.agentProcess,
    AgenticEventListener by processContext {

    override val toolGroups: Set<ToolGroupRequirement>
        get() = action.toolGroups

    override val operation = action
}

class SupplierActionContext<O>(
    override val processContext: ProcessContext,
    override val action: Action,
    val outputClass: Class<O>,
) : ActionContext, Blackboard by processContext.agentProcess,
    AgenticEventListener by processContext {

    override val toolGroups: Set<ToolGroupRequirement>
        get() = action.toolGroups

    override val operation = action

    val inputs: List<Any> get() = emptyList()

    override fun domainObjectInstances(): List<Any> = listOf(outputClass)

}

internal class OperationContextAi(
    private val context: OperationContext,
) : Ai {

    override fun withEmbeddingModel(criteria: ModelSelectionCriteria): EmbeddingModel {
        return context.processContext.platformServices.modelProvider().getEmbeddingService(
            criteria
        ).model
    }

    override fun withLlm(llm: LlmOptions): PromptRunner {
        return context.promptRunner().withLlm(llm)
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/PlannerType.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common

/**
 * Specifies the type of planner that an agent uses.
 */
enum class PlannerType {

    /**
     * Goal Oriented Action Planning.
     * This is the default planner.
     * It uses goals, actions and conditions to plan actions.
     */
    GOAP,
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/PlatformServices.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common

import com.embabel.agent.api.common.autonomy.Autonomy
import com.embabel.agent.channel.OutputChannel
import com.embabel.agent.core.AgentPlatform
import com.embabel.agent.event.AgenticEventListener
import com.embabel.agent.spi.LlmOperations
import com.embabel.agent.spi.OperationScheduler
import com.embabel.common.ai.model.ModelProvider
import com.embabel.common.textio.template.TemplateRenderer
import com.fasterxml.jackson.databind.ObjectMapper

/**
 * Services used by the platform and available to user-authored code.
 */
interface PlatformServices {

    /**
     * The agent platform executing this agent
     */
    val agentPlatform: AgentPlatform

    /**
     * Operations to use for LLMs
     */
    val llmOperations: LlmOperations

    /**
     * Event listener for agentic events
     */
    val eventListener: AgenticEventListener

    /**
     * Operation scheduler for scheduling operations
     */
    val operationScheduler: OperationScheduler

    /**
     * Asyncer for async operations
     */
    val asyncer: Asyncer


    val objectMapper: ObjectMapper

    val outputChannel: OutputChannel

    val templateRenderer: TemplateRenderer

    fun autonomy(): Autonomy

    fun modelProvider(): ModelProvider

    fun withEventListener(agenticEventListener: AgenticEventListener): PlatformServices
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/PromptRunner.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common

import com.embabel.agent.api.annotation.support.AgenticInfo
import com.embabel.agent.core.Agent
import com.embabel.agent.core.AgentPlatform
import com.embabel.agent.core.ToolGroup
import com.embabel.agent.core.ToolGroupRequirement
import com.embabel.agent.prompt.element.ContextualPromptElement
import com.embabel.agent.spi.LlmUse
import com.embabel.chat.AssistantMessage
import com.embabel.chat.Message
import com.embabel.common.ai.model.LlmOptions
import com.embabel.common.ai.prompt.PromptContributor
import com.embabel.common.ai.prompt.PromptElement
import com.embabel.common.util.loggerFor
import org.jetbrains.annotations.ApiStatus
import java.util.function.Predicate
import kotlin.reflect.KProperty

/**
 * Define a handoff to a subagent.

 */
class Subagent private constructor(
    private val agentRef: Any,
    val inputClass: Class<*>,
) {

    /**
     * Subagent that is an agent
     * @param agent the subagent to hand off to
     * @param inputClass the class of the input that the subagent expects
     */
    constructor(
        agent: Agent,
        inputClass: Class<*>,
    ) : this(
        agentRef = agent,
        inputClass = inputClass,
    )

    constructor(
        agentName: String,
        inputClass: Class<*>,
    ) : this(
        agentRef = agentName,
        inputClass = inputClass,
    )

    /**
     * Reference to an annotated agent class.
     */
    constructor(
        agentType: Class<*>,
        inputClass: Class<*>,
    ) : this(
        agentRef = agentType,
        inputClass = inputClass,
    )

    fun resolve(agentPlatform: AgentPlatform): Agent {
        return when (agentRef) {
            is Agent -> agentRef
            is String -> agentPlatform.agents().find { it.name == agentRef }
                ?: throw IllegalArgumentException(
                    "Subagent with name '$agentRef' not found in platform ${agentPlatform.name}. " +
                            "Available agents: ${agentPlatform.agents().map { it.name }}"
                )

            is Class<*> -> {
                val agenticInfo = AgenticInfo(agentRef)
                if (!agenticInfo.agentic()) {
                    throw IllegalArgumentException(
                        "Subagent must be an Agent or a String representing the agent name, but was: $agentRef"
                    )
                }
                agentPlatform.agents().find { it.name == agenticInfo.agentName() }
                    ?: throw IllegalArgumentException(
                        "Subagent of type $agentRef with name '$agentRef' not found in platform ${agentPlatform.name}. " +
                                "Available agents: ${agentPlatform.agents().map { it.name }}"
                    )
            }

            else -> throw IllegalArgumentException(
                "Subagent must be an Agent or a String representing the agent name, but was: $agentRef"
            )
        }
    }
}


/**
 * User code should always use this interface to execute prompts.
 * Typically obtained from an [OperationContext] or [ActionContext] parameter,
 * via [OperationContext.ai]
 * A PromptRunner is immutable once constructed, and has determined
 * LLM and hyperparameters. Use the "with" methods to evolve
 * the state to your desired configuration before executing createObject,
 * generateText or other LLM invocation methods.
 * Thus, a PromptRunner can be reused within an action implementation.
 * A contextual facade to LlmOperations.
 * @see com.embabel.agent.spi.LlmOperations
 */
interface PromptRunner : LlmUse, PromptRunnerOperations {

    /**
     * Additional objects with @Tool annotation for use in this PromptRunner
     */
    val toolObjects: List<ToolObject>

    /**
     * Messages added to this PromptRunner
     */
    val messages: List<Message>

    /**
     * Set an interaction id for this prompt runner.
     */
    fun withInteractionId(interactionId: InteractionId): PromptRunner

    /**
     * Set the interaction id for this prompt runner.
     */
    fun withId(id: String) = withInteractionId(InteractionId(id))

    /**
     * Specify an LLM for the PromptRunner
     */
    fun withLlm(llm: LlmOptions): PromptRunner

    /**
     * Add a message that will be included in the final prompt.
     */
    fun withMessage(message: Message): PromptRunner =
        withMessages(listOf(message))

    fun withMessages(messages: List<Message>): PromptRunner

    fun withMessages(vararg message: Message): PromptRunner =
        withMessages(message.toList())

    /**
     * Add a tool group to the PromptRunner
     * @param toolGroup name of the toolGroup we're requesting
     * @return PromptRunner instance with the added tool group
     */
    fun withToolGroup(toolGroup: String): PromptRunner =
        withToolGroup(ToolGroupRequirement(toolGroup))

    /**
     * Allows for dynamic tool groups to be added to the PromptRunner.
     */
    fun withToolGroup(toolGroup: ToolGroup): PromptRunner

    fun withToolGroups(toolGroups: Set<String>): PromptRunner =
        toolGroups.fold(this) { acc, toolGroup -> acc.withToolGroup(toolGroup) }

    /**
     * Add a set of tool groups to the PromptRunner
     * @param toolGroups the set of named tool groups to add
     */
    fun withTools(vararg toolGroups: String): PromptRunner =
        withToolGroups(toolGroups.toSet())

    fun withToolGroup(toolGroup: ToolGroupRequirement): PromptRunner

    /**
     * Add a tool object to the prompt runner.
     * @param toolObject the object to add. If it is null, nothing is done.
     * This is not an error
     * @return PromptRunner instance with the added tool object
     */
    fun withToolObject(toolObject: Any?): PromptRunner =
        if (toolObject == null) {
            this
        } else {
            withToolObject(ToolObject.from(toolObject))
        }

    /**
     * Add a tool object
     * @param toolObject the object to add.
     */
    fun withToolObject(
        toolObject: ToolObject,
    ): PromptRunner

    fun withToolObjects(vararg toolObjects: Any?): PromptRunner =
        toolObjects.fold(this) { acc, toolObject -> acc.withToolObject(toolObject) }

    /**
     * Add a reference which provides tools and prompt contribution.
     */
    fun withReference(reference: LlmReference): PromptRunner {
        return withToolObject(reference.toolObject())
            .withPromptContributor(reference)
    }

    /**
     * Add a list of references which provide tools and prompt contributions.
     */
    fun withReferences(references: List<LlmReference>): PromptRunner {
        return references.fold(this) { acc, reference -> acc.withReference(reference) }
    }

    /**
     * Add varargs of references which provide tools and prompt contributions.
     */
    fun withReferences(vararg references: LlmReference): PromptRunner =
        withReferences(references.toList())

    /**
     * Add a list of handoffs to agents on this platform
     * @param outputTypes the types of objects that can result from output flow
     */
    @ApiStatus.Experimental
    fun withHandoffs(
        vararg outputTypes: Class<*>,
    ): PromptRunner

    /**
     * Add a list of subagents to hand off to.
     */
    @ApiStatus.Experimental
    fun withSubagents(
        vararg subagents: Subagent,
    ): PromptRunner

    /**
     * Add a literal system prompt
     */
    fun withSystemPrompt(systemPrompt: String): PromptRunner =
        withPromptContributor(
            PromptContributor.fixed(systemPrompt)
        )

    /**
     * Add a prompt contributor that can add to the prompt.
     * Facilitates reuse of prompt elements.
     * @param promptContributor
     * @return PromptRunner instance with the added PromptContributor
     */
    fun withPromptContributor(promptContributor: PromptContributor): PromptRunner =
        withPromptContributors(listOf(promptContributor))

    fun withPromptContributors(promptContributors: List<PromptContributor>): PromptRunner

    /**
     * Add varargs of prompt contributors and contextual prompt elements.
     */
    fun withPromptElements(vararg elements: PromptElement): PromptRunner {
        val promptContributors = elements.filterIsInstance<PromptContributor>()
        val contextualPromptElements = elements.filterIsInstance<ContextualPromptElement>()
        val oddOnesOut = elements.filterNot { it is PromptContributor || it is ContextualPromptElement }
        if (oddOnesOut.isNotEmpty()) {
            loggerFor<PromptRunner>().warn(
                "{} arguments to withPromptElements were not prompt contributors or contextual prompt elements and will be ignored: {}",
                oddOnesOut.size,
                oddOnesOut.joinToString(
                    ", ", prefix = "[", postfix = "]"
                )
            )
        }
        return withPromptContributors(promptContributors)
            .withContextualPromptContributors(contextualPromptElements)
    }

    /**
     * Add a prompt contributor that can see context
     */
    fun withContextualPromptContributors(
        contextualPromptContributors: List<ContextualPromptElement>,
    ): PromptRunner

    fun withContextualPromptContributor(
        contextualPromptContributor: ContextualPromptElement,
    ): PromptRunner =
        withContextualPromptContributors(listOf(contextualPromptContributor))

    /**
     * Set whether to generate examples of the output in the prompt
     * on a per-PromptRunner basis. This overrides platform defaults.
     * Note that adding individual examples with [ObjectCreator.withExample]
     * will always override this.
     */
    fun withGenerateExamples(generateExamples: Boolean): PromptRunner

    /**
     * Adds a filter that determines which properties are to be included when creating an object.
     *
     * Note that each predicate is applied *in addition to* previously registered predicates, including
     * [withProperties] and [withoutProperties].
     * @param filter the property predicate to be added
     */
    fun withPropertyFilter(filter: Predicate<String>): PromptRunner

    /**
     * Includes the given properties when creating an object.
     *
     * Note that each predicate is applied *in addition to* previously registered predicates, including
     * [withPropertyFilter] and [withoutProperties].
     * @param properties the properties that are to be included
     */
    fun withProperties(vararg properties: String): PromptRunner = withPropertyFilter { properties.contains(it) }

    /**
     * Excludes the given properties when creating an object.
     *
     * Note that each predicate is applied *in addition to* previously registered predicates, including
     * [withPropertyFilter] and [withProperties].
     * @param properties the properties that are to be included
     */
    fun withoutProperties(vararg properties: String): PromptRunner = withPropertyFilter { !properties.contains(it) }

    /**
     * Create an object creator for the given output class.
     * Allows setting strongly typed examples.
     */
    fun <T> creating(outputClass: Class<T>): ObjectCreator<T>

    override fun respond(
        messages: List<Message>,
    ): AssistantMessage =
        AssistantMessage(
            createObject(
                messages = this.messages + messages,
                outputClass = String::class.java,
            )
        )

}

/**
 * Create an object of the given type
 */
inline infix fun <reified T> PromptRunner.createObject(prompt: String): T =
    createObject(prompt, T::class.java)

/**
 * Create an object of the given type.
 * Method overloading is evil
 **/
inline infix fun <reified T> PromptRunner.create(prompt: String): T =
    createObject(prompt, T::class.java)

inline fun <reified T> PromptRunner.createObjectIfPossible(prompt: String): T? =
    createObjectIfPossible(prompt, T::class.java)

inline fun <reified T> TemplateOperations.createObject(
    model: Map<String, Any>,
): T =
    createObject(outputClass = T::class.java, model = model)

fun PromptRunner.withProperties(
    vararg properties: KProperty<Any>,
): PromptRunner =
    withProperties(*properties.map { it.name }.toTypedArray())

fun PromptRunner.withoutProperties(
    vararg properties: KProperty<Any>,
): PromptRunner =
    withoutProperties(*properties.map { it.name }.toTypedArray())



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/PromptRunnerOperations.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common

import com.embabel.chat.AssistantMessage
import com.embabel.chat.Message
import com.embabel.chat.UserMessage
import com.embabel.common.core.types.ZeroToOne

/**
 * User-facing interface for executing prompts.
 * These are what are executed on a finally configured PromptRunner.
 */
interface PromptRunnerOperations {

    /**
     * Generate text
     */
    infix fun generateText(prompt: String): String =
        createObject(
            prompt = prompt,
            outputClass = String::class.java,
        )

    /**
     * Create an object of the given type using the given prompt and LLM options from context
     * (process context or implementing class).
     * Prompts are typically created within the scope of an
     * @Action method that provides access to
     * domain object instances, offering type safety.
     */
    fun <T> createObject(
        prompt: String,
        outputClass: Class<T>,
    ): T = createObject(
        messages = listOf(UserMessage(prompt)),
        outputClass = outputClass,
    )

    /**
     * Try to create an object of the given type using the given prompt and LLM options from context
     * (process context or implementing class).
     * Prompt is typically created within the scope of an
     * @Action method that provides access to
     * domain object instances, offering type safety.
     */
    fun <T> createObjectIfPossible(
        prompt: String,
        outputClass: Class<T>,
    ): T? = createObjectIfPossible(listOf(UserMessage(prompt)), outputClass)

    fun <T> createObjectIfPossible(
        messages: List<Message>,
        outputClass: Class<T>,
    ): T?

    /**
     * Create an object from messages
     */
    fun <T> createObject(
        messages: List<Message>,
        outputClass: Class<T>,
    ): T

    /**
     * Respond in a conversation
     */
    fun respond(
        messages: List<Message>,
    ): AssistantMessage

    /**
     * Use operations from a given template
     */
    fun withTemplate(templateName: String): TemplateOperations

    fun evaluateCondition(
        condition: String,
        context: String,
        confidenceThreshold: ZeroToOne = 0.8,
    ): Boolean

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/StuckHandler.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common

import com.embabel.agent.core.AgentProcess
import com.embabel.agent.event.AbstractAgentProcessEvent

enum class StuckHandlingResultCode {
    REPLAN,
    NO_RESOLUTION,
}

class StuckHandlerResult(
    val message: String,
    val handler: StuckHandler?,
    val code: StuckHandlingResultCode,
    agentProcess: AgentProcess,
) : AbstractAgentProcessEvent(agentProcess)

/**
 * Attempts to resolve stuck processes
 */
fun interface StuckHandler {

    /**
     * Attempt to resolve a stuck agent process
     * Resolution will occur via side effects on AgentProcess
     */
    fun handleStuck(
        agentProcess: AgentProcess,
    ): StuckHandlerResult

    companion object {

        operator fun invoke(
            vararg handlers: StuckHandler,
        ): StuckHandler = MulticastStuckHandler(handlers.toList())
    }
}

/**
 * Try to resolve a stuck agent process by trying all handlers in order
 */
class MulticastStuckHandler(
    private val stuckHandlers: List<StuckHandler>,
) : StuckHandler {

    override fun handleStuck(agentProcess: AgentProcess): StuckHandlerResult {
        for (handler in stuckHandlers) {
            val result = handler.handleStuck(agentProcess)
            if (result.code != StuckHandlingResultCode.NO_RESOLUTION) {
                return result
            }
        }
        return StuckHandlerResult(
            message = "No stuck handler could resolve the issue: Tried ${stuckHandlers.joinToString(", ") { it::class.java.name }}",
            code = StuckHandlingResultCode.NO_RESOLUTION,
            agentProcess = agentProcess,
            handler = null,
        )
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/TemplateOperations.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common

import com.embabel.chat.AssistantMessage
import com.embabel.chat.Conversation
import com.embabel.chat.SystemMessage
import com.embabel.common.textio.template.TemplateRenderer

/**
 * Llm operations based on a compiled template.
 * Similar to [PromptRunnerOperations], but taking a model instead of a template string.
 * Template names will be resolved by the [com.embabel.common.textio.template.TemplateRenderer] provided.
 */
class TemplateOperations(
    templateName: String,
    templateRenderer: TemplateRenderer,
    private val promptRunnerOperations: PromptRunnerOperations,
) {

    private val compiledTemplate = templateRenderer.compileLoadedTemplate(templateName)

    /**
     * Create an object of the given type using the given model to render the template
     * and LLM options from context
     */
    fun <T> createObject(
        outputClass: Class<T>,
        model: Map<String, Any>,
    ): T = promptRunnerOperations.createObject(
        prompt = compiledTemplate.render(model = model),
        outputClass = outputClass,
    )

    /**
     * Generate text using the given model to render the template
     * and LLM options from context
     */
    fun generateText(
        model: Map<String, Any>,
    ): String = promptRunnerOperations.generateText(
        prompt = compiledTemplate.render(model = model),
    )

    /**
     * Respond in the conversation using the rendered template as system prompt.
     * @param conversation the conversation so far
     * @param model the model to render the system prompt template with.
     * Defaults to the empty map (which is appropriate for static templates)
     */
    @JvmOverloads
    fun respondWithSystemPrompt(
        conversation: Conversation,
        model: Map<String, Any> = emptyMap(),
    ): AssistantMessage = promptRunnerOperations.respond(
        messages = listOf(
            SystemMessage(
                content = compiledTemplate.render(model = model)
            )
        ) + conversation.messages,
    )
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/ToolObject.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common

import com.embabel.common.util.StringTransformer

/**
 * Holds an annotated tool object.
 * Adds a naming strategy and a filter to the object.
 * @param obj the object the tool annotations are on
 * @param namingStrategy the naming strategy to use for the tool object's methods
 * @param filter a filter to apply to the tool object's methods
 */
data class ToolObject(
    val obj: Any,
    val namingStrategy: StringTransformer = StringTransformer.IDENTITY,
    val filter: (String) -> Boolean = { true },
) {

    init {
        if (obj is Iterable<*>) {
            throw IllegalArgumentException("Internal error: ToolObject cannot be an Iterable. Offending object: $obj")
        }
    }

    constructor (
        obj: Any,
    ) : this(
        obj = obj,
        namingStrategy = StringTransformer.IDENTITY,
        filter = { true },
    )

    fun withNamingStrategy(
        namingStrategy: StringTransformer,
    ): ToolObject = copy(namingStrategy = namingStrategy)

    fun withFilter(
        filter: (String) -> Boolean,
    ): ToolObject = copy(filter = filter)

    companion object {

        /**
         * Create a ToolObject from any object.
         * If the object is already a ToolObject, return it as is.
         */
        fun from(o: Any): ToolObject = o as? ToolObject
            ?: ToolObject(
                obj = o,
                namingStrategy = StringTransformer.IDENTITY,
                filter = { true },
            )

    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/ToolsStats.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common

import com.embabel.common.core.types.HasInfoString

/**
 * Stats around tool calls to a particular tool.
 * Open to allow implementations to extend if they wish
 * @param name The name of the tool.
 * @param calls The number of times the tool has been called.
 * @param averageResponseTime The average response time of the tool in milliseconds.
 * @param failures The number of times the tool has failed.
 */
open class ToolStats(
    val name: String,
    val calls: Int,
    val averageResponseTime: Long = 0L,
    val failures: Int = 0,
) : HasInfoString {

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String =
        "ToolStats(name=$name, calls=$calls, avgResponseTime=$averageResponseTime ms, failures=$failures)"

}

/**
 * Tool statistics, indexed by tool name.
 */
interface ToolsStats : HasInfoString {

    val toolsStats: Map<String, ToolStats>

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String {
        return toolsStats.entries.joinToString(
            prefix = "Tool usage:\n",
            separator = ",\n"
        ) { (_, toolStats) ->
            "\t${toolStats.infoString(verbose, 1)}"
        }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/Transformation.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common

import com.embabel.agent.api.common.support.TransformationAction
import com.embabel.agent.core.Action
import com.embabel.agent.core.Agent
import com.embabel.agent.core.resultOfType
import com.embabel.common.core.types.ZeroToOne

fun <I, O : Any> asTransformation(
    agent: Agent,
    outputClass: Class<O>,
) = Transformation<I, O> {
    val childAgentProcess = it.agentPlatform().createChildProcess(
        agent = agent,
        parentAgentProcess = it.agentProcess,
    )
    val childProcessResult = childAgentProcess.run()
    childProcessResult.resultOfType(outputClass)
}

/**
 * Creates a transformation action from an agent
 */
inline fun <reified I, reified O : Any> Agent.asTransformation() = Transformation<I, O> {
    val childAgentProcess = it.agentPlatform().createChildProcess(
        agent = this,
        parentAgentProcess = it.processContext.agentProcess,
    )
    val childProcessResult = childAgentProcess.run()
    childProcessResult.resultOfType()
}


/**
 * Expose this agent as an action of the given transformation type
 */
inline fun <reified I, reified O : Any> Agent.asAction(): Action =
    agentTransformer<I, O>(this)

/**
 * Expose the named agent as an action of the given transformation type
 */
fun <I, O : Any> asAction(
    agentName: String,
    inputClass: Class<I>,
    outputClass: Class<O>,
    pre: List<String> = emptyList(),
    post: List<String> = emptyList(),
    cost: ZeroToOne = 0.0,
    value: ZeroToOne = 0.0,
    canRerun: Boolean = false,
): Action {
    return TransformationAction(
        name = "@agent-${agentName}",
        description = "Agent $agentName",
        pre = pre,
        post = post,
        cost = cost,
        value = value,
        canRerun = canRerun,
        inputClass = inputClass,
        outputClass = outputClass,
        toolGroups = emptySet(),
    ) { transformationActionContext ->
        val agent: Agent =
            transformationActionContext.processContext.platformServices.agentPlatform.agents().singleOrNull() {
                it.name == agentName
            } ?: throw IllegalArgumentException(
                "Agent '$agentName' not found: Known agents:\n\t${
                    transformationActionContext.processContext.platformServices.agentPlatform.agents()
                        .joinToString("\n\t") { it.name }
                }"
            )
        asTransformation<I, O>(agent, outputClass).transform(transformationActionContext)
    }
}

inline fun <reified I, reified O : Any> asAction(agentName: String): Action =
    asAction(agentName, I::class.java, O::class.java)

inline fun <reified I, reified O : Any> agentTransformer(agent: Agent): Action =
    agentTransformer(agent = agent, inputClass = I::class.java, outputClass = O::class.java)

fun <I, O : Any> agentTransformer(
    agent: Agent,
    pre: List<String> = emptyList(),
    post: List<String> = emptyList(),
    cost: ZeroToOne = 0.0,
    value: ZeroToOne = 0.0,
    canRerun: Boolean = false,
    inputClass: Class<I>,
    outputClass: Class<O>,
): Action {
    return TransformationAction(
        name = "@action-${agent.name}",
        description = agent.description,
        pre = pre,
        post = post,
        cost = cost,
        value = value,
        canRerun = canRerun,
        inputClass = inputClass,
        outputClass = outputClass,
        toolGroups = emptySet(),
    ) {
        val tf: Transformation<I, O> = asTransformation(agent, outputClass)
        tf.transform(it)
    }
}


/**
 * Transformation function signature
 */
fun interface Transformation<I, O> {
    fun transform(context: TransformationActionContext<I, O>): O?
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/TypedOps.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common

import com.embabel.agent.core.AgentScope
import com.embabel.agent.core.ProcessOptions
import com.embabel.agent.domain.io.UserInput
import java.util.function.BiFunction


/**
 * Reusable AgentFunction.
 * Allows use of AgentPlatform as a function from I to O,
 * with different process options.
 */
interface AgentFunction<I, O> : BiFunction<I, ProcessOptions, O> {
    val agentScope: AgentScope
    val outputClass: Class<O>
}

/**
 * Enables typed operations using agentic systems
 */
interface TypedOps {

    /**
     * Transform between these two types if possible.
     */
    fun <I : Any, O> transform(
        input: I,
        outputClass: Class<O>,
        processOptions: ProcessOptions = ProcessOptions(),
    ): O = asFunction<I, O>(outputClass).apply(input, processOptions)

    /**
     * Return a reusable function that performs this transformation.
     * Validates whether it's possible and include metadata.
     */
    fun <I : Any, O> asFunction(
        outputClass: Class<O>,
    ): AgentFunction<I, O>

    @Throws(NoSuchAgentException::class)
    fun <I : Any, O> asFunction(
        outputClass: Class<O>,
        agentName: String,
    ): AgentFunction<I, O>

    /**
     * Transform user input into the target type
     */
    fun <O> handleUserInput(
        intent: String,
        outputClass: Class<O>,
        processOptions: ProcessOptions = ProcessOptions(),
    ): O {
        val input = UserInput(intent)
        return transform(input, outputClass, processOptions)
    }

}


/**
 * Perform the magic trick of getting from A to B
 */
inline fun <I : Any, reified O : Any> TypedOps.transform(
    input: I,
    processOptions: ProcessOptions = ProcessOptions(),
): O {
    return transform(
        input = input,
        outputClass = O::class.java,
        processOptions = processOptions,
    )
}

fun <I : Any, O : Any> TypedOps.transform(
    input: I,
    processOptions: ProcessOptions = ProcessOptions(),
    outputClass: Class<O>,
): O {
    return transform(
        input = input,
        outputClass = outputClass,
        processOptions = processOptions,
    )
}

/**
 * Turn user input into this type
 */
inline fun <reified O> TypedOps.handleUserInput(
    intent: String,
    processOptions: ProcessOptions = ProcessOptions(),
): O =
    handleUserInput(
        intent = intent,
        outputClass = O::class.java,
        processOptions = processOptions,
    )

inline fun <I : Any, reified O> TypedOps.asFunction(
): AgentFunction<I, O> = asFunction(O::class.java)



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/autonomy/AgentInvocation.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.autonomy

import com.embabel.agent.core.Agent
import com.embabel.agent.core.AgentPlatform
import com.embabel.agent.core.AgentProcess
import com.embabel.agent.core.ProcessOptions
import java.util.concurrent.CompletableFuture
import java.util.function.Consumer


/**
 * Defines the contract for invoking an agent.
 *
 * Default instances are created with [AgentInvocation.create];
 * [AgentInvocation.builder] allows for customization of the invocation
 * before creation.
 * Once created, [invoke] or [invokeAsync] is used to invoke the agent.
 *
 * @param T type of result returned by the invocation
 */
interface AgentInvocation<T> {

    /**
     * Invokes the agent with one or more arguments.
     *
     * @param obj the first (and possibly only) input value to be added to the blackboard
     * @param objs additional input values to add to the blackboard
     * @return the result of type [T] from the agent invocation
     */
    fun invoke(
        obj: Any,
        vararg objs: Any,
    ): T = invokeAsync(obj, *objs).get()

    /**
     * Invokes the agent with a map of named inputs.
     *
     * @param map A [Map] that initializes the blackboard
     * @return the result of type [T] from the agent invocation
     */
    fun invoke(map: Map<String, Any>): T = invokeAsync(map).get()

    /**
     * Invokes the agent asynchronously with one or more arguments.
     *
     * @param obj the first (and possibly only) input value to be added to the blackboard
     * @param objs additional input values to add to the blackboard
     * @return the result of type [T] from the agent invocation
     */
    fun invokeAsync(
        obj: Any,
        vararg objs: Any,
    ): CompletableFuture<T>

    /**
     * Invokes the agent asynchronously with a map of named inputs.
     *
     * @param map A [Map] that initializes the blackboard
     * @return the result of type [T] from the agent invocation
     */
    fun invokeAsync(map: Map<String, Any>): CompletableFuture<T>

    /**
     * Runs the agent with one or more arguments
     *
     * @param obj the first (and possibly only) input value to be added to the blackboard
     * @param objs additional input values to add to the blackboard
     * @return the agent process
     */
    fun run(
        obj: Any,
        vararg objs: Any,
    ): AgentProcess = runAsync(obj, *objs).get()

    /**
     * Runs the agent with a map of named inputs.
     *
     * @param map A [Map] that initializes the blackboard
     * @return the agent process
     */
    fun run(map: Map<String, Any>): AgentProcess = runAsync(map).get()

    /**
     * Runs the agent asynchronously with one or more arguments
     *
     * @param obj the first (and possibly only) input value to be added to the blackboard
     * @param objs additional input values to add to the blackboard
     * @return the future agent process
     */
    fun runAsync(
        obj: Any,
        vararg objs: Any,
    ): CompletableFuture<AgentProcess>

    /**
     * Runs the agent asynchronously with a map of named inputs.
     *
     * @param map A [Map] that initializes the blackboard
     * @return the future agent process
     */
    fun runAsync(map: Map<String, Any>): CompletableFuture<AgentProcess>

    companion object {

        /**
         * Create a new [AgentInvocation] for the given platform and explicit result type.
         *
         * @param agentPlatform the platform in which this agent will run
         * @param resultType the Java [Class] of the type of result the agent will return
         * @param T type of result returned by the invocation
         * @return a configured [AgentInvocation] that produces values of type [T]
         */
        @JvmStatic
        fun <T : Any> create(
            agentPlatform: AgentPlatform,
            resultType: Class<T>,
        ): AgentInvocation<T> {
            return builder(agentPlatform).build(resultType)
        }

        /**
         * Create a new [AgentInvocation] for the given platform, inferring the result type
         * from the reified type parameter.
         *
         * @param agentPlatform the platform or environment in which this agent will run
         * @param T type of result returned by the invocation
         * @return a configured [AgentInvocation] that produces values of type [T]
         */
        inline fun <reified T : Any> create(agentPlatform: AgentPlatform): AgentInvocation<T> {
            return builder(agentPlatform).build()
        }

        /**
         * Obtain a new [Builder] to customize agent settings before building.
         *
         * @param agentPlatform the platform or environment in which this agent will run
         * @return a builder through which you can set processing options
         */
        @JvmStatic
        fun builder(agentPlatform: AgentPlatform): Builder {
            return Builder(agentPlatform)
        }

    }

    /**
     * Builder for configuring and creating instances of [AgentInvocation].
     *
     * Use this builder to set process options such as context, blackboard,
     * verbosity, budget, and control policies before constructing the agent invocation.
     */
    class Builder internal constructor(
        private val agentPlatform: AgentPlatform,
    ) {

        private var processOptions = ProcessOptions.DEFAULT

        /**
         * Set the [ProcessOptions] to use for this invocation.
         * @param processOptions the process-level options
         * @return this builder instance for chaining
         */
        fun options(processOptions: ProcessOptions): Builder {
            this.processOptions = processOptions
            return this
        }

        /**
         * Begin configuring process options via a builder.
         * @return a [ProcessOptions.Builder] for fine-grained option setup
         */
        fun options(consumer: Consumer<ProcessOptions.Builder>): Builder {
            val builder = ProcessOptions.builder()
            consumer.accept(builder)
            this.processOptions = builder.build()
            return this
        }

        /**
         * Build the [AgentInvocation] with the given explicit result type.
         * @param resultType the Java [Class] of the result type [T]
         * @return a new [AgentInvocation] producing values of type [T]
         */
        fun <T : Any> build(resultType: Class<T>): AgentInvocation<T> {
            return DefaultAgentInvocation(
                agentPlatform = this.agentPlatform,
                processOptions = this.processOptions,
                resultType = resultType
            )
        }

    }
}


/**
 * Build the [AgentInvocation], inferring the result type from the reified type parameter.
 * @param T type of result returned by the invocation
 * @return a new [AgentInvocation] producing values of type [T]
 */
inline fun <reified T : Any> AgentInvocation.Builder.build(): AgentInvocation<T> {
    return build(T::class.java)
}

internal class DefaultAgentInvocation<T : Any>(
    private val agentPlatform: AgentPlatform,
    private val processOptions: ProcessOptions,
    private val resultType: Class<T>,
) : AgentInvocation<T> {

    override fun invokeAsync(
        obj: Any,
        vararg objs: Any,
    ): CompletableFuture<T> = runAsync(obj, *objs).thenApply { it.last(resultType) }

    override fun invokeAsync(map: Map<String, Any>): CompletableFuture<T> =
        runAsync(map).thenApply { it.last(resultType) }

    override fun runAsync(
        obj: Any,
        vararg objs: Any,
    ): CompletableFuture<AgentProcess> {
        val agent = findAgentByResultType() ?: error("No agent with outputClass $resultType found.")
        val args = arrayOf(obj, *objs)

        val agentProcess = agentPlatform.createAgentProcessFrom(
            agent = agent,
            processOptions = processOptions,
            objectsToAdd = args
        )
        return agentPlatform.start(agentProcess)
    }

    override fun runAsync(map: Map<String, Any>): CompletableFuture<AgentProcess> {
        val agent = findAgentByResultType() ?: error("No agent with outputClass $resultType found.")

        val agentProcess = agentPlatform.createAgentProcess(
            agent = agent,
            processOptions,
            bindings = map
        )
        return agentPlatform.start(agentProcess)
    }


    private fun findAgentByResultType(): Agent? =
        agentPlatform.agents().find { agent ->
            agent.goals.any { goal ->
                goal.outputType?.isAssignableTo(resultType) == true
            }
        }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/autonomy/AgentProcessExecution.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.autonomy

import com.embabel.agent.core.*
import com.embabel.agent.core.hitl.Awaitable
import com.embabel.agent.core.hitl.AwaitableResponse
import com.embabel.agent.event.AgentPlatformEvent
import com.embabel.agent.spi.Rankings
import com.embabel.common.core.types.HasInfoString
import java.time.Instant

/**
 * Successful result of directly trying to execute a goal.
 * Failure results in an exception being thrown.
 */
class AgentProcessExecution private constructor(

    /**
     * What triggered this result. Process input.
     */
    val basis: Any,

    /**
     * Output object
     */
    val output: Any,

    /**
     * Process that executed and is now complete
     */
    val agentProcess: AgentProcess,
) : HasInfoString {

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String =
        if (verbose == true)
            "${javaClass.simpleName}(basis=$basis, output=$output, agentProcess=${
                agentProcess.infoString(verbose, 1)
            })"
        else
            "${javaClass.simpleName}(basis=$basis, output=${output::class.simpleName}, agentProcess=${agentProcess.id})"

    override fun toString(): String = infoString(verbose = false)

    companion object {

        @Throws(
            ProcessExecutionException::class,
            ProcessExecutionStuckException::class,
            ProcessExecutionFailedException::class,
            ProcessWaitingException::class,
            ProcessExecutionTerminatedException::class,
        )
        @Suppress("UNCHECKED_CAST")
        fun fromProcessStatus(
            basis: Any,
            agentProcess: AgentProcess,
        ): AgentProcessExecution =
            when (agentProcess.status) {
                AgentProcessStatusCode.COMPLETED -> {
                    AgentProcessExecution(
                        basis = basis,
                        output = agentProcess.lastResult()!!,
                        agentProcess = agentProcess,
                    )
                }

                AgentProcessStatusCode.WAITING -> {
                    throw ProcessWaitingException(
                        agentProcess = agentProcess,
                        // TODO this is dirty
                        awaitable = agentProcess.lastResult() as Awaitable<*, AwaitableResponse>,
                    )
                }

                AgentProcessStatusCode.FAILED -> {
                    throw ProcessExecutionFailedException(
                        agentProcess = agentProcess,
                        detail = "Process ${agentProcess.id} failed: ${agentProcess.failureInfo}",
                    )
                }

                AgentProcessStatusCode.STUCK -> {
                    throw ProcessExecutionStuckException(
                        agentProcess = agentProcess,
                        detail = "Process ${agentProcess.id} stuck"
                    )
                }

                AgentProcessStatusCode.TERMINATED -> {
                    throw ProcessExecutionTerminatedException(
                        agentProcess = agentProcess,
                        detail = "Process ${agentProcess.id} was terminated: ${agentProcess.failureInfo}",
                    )
                }

                else -> {
                    error("Unexpected process status: ${agentProcess.status}")
                }
            }
    }
}

/**
 * Used for control flow
 */
sealed class ProcessExecutionException(
    open val agentProcess: AgentProcess?,
    message: String,
) : Exception(message)

class NoGoalFound(
    val basis: Any,
    val goalRankings: Rankings<Goal>,
) : ProcessExecutionException(null, "Goal not found: ${goalRankings.rankings().joinToString(",")}")

/**
 * The Ranker chose a goal, but it was rejected by the GoalApprover
 */
class GoalNotApproved(
    val basis: Any,
    val goalRankings: Rankings<Goal>,
    val reason: String,
    override val agentPlatform: AgentPlatform,
) : AgentPlatformEvent,
    ProcessExecutionException(null, "Goal not approved because $reason: ${goalRankings.rankings().joinToString(",")}") {

    override val timestamp: Instant = Instant.now()

}

class NoAgentFound(
    val basis: Any,
    val agentRankings: Rankings<Agent>,
) : ProcessExecutionException(null, "Agent not found: ${agentRankings.rankings().joinToString(",")}")

class ProcessExecutionFailedException(
    override val agentProcess: AgentProcess,
    val detail: String,
) : ProcessExecutionException(agentProcess, "Process ${agentProcess.id} failed: $detail")

class ProcessExecutionTerminatedException(
    override val agentProcess: AgentProcess,
    val detail: String,
) : ProcessExecutionException(agentProcess, "Process ${agentProcess.id} terminated: $detail")

class ProcessExecutionStuckException(
    override val agentProcess: AgentProcess,
    val detail: String,
) : ProcessExecutionException(agentProcess, "Process ${agentProcess.id} stuck: $detail")

class ProcessWaitingException(
    override val agentProcess: AgentProcess,
    val awaitable: Awaitable<*, AwaitableResponse>,
) : ProcessExecutionException(agentProcess, "Process ${agentProcess.id} is waiting for ${awaitable.infoString()}")



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/autonomy/Autonomy.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.autonomy

import com.embabel.agent.api.common.support.destructureAndBindIfNecessary
import com.embabel.agent.common.Constants
import com.embabel.agent.core.*
import com.embabel.agent.domain.io.UserInput
import com.embabel.agent.event.DynamicAgentCreationEvent
import com.embabel.agent.event.RankingChoiceRequestEvent
import com.embabel.agent.spi.Ranker
import com.embabel.agent.spi.Ranking
import com.embabel.agent.spi.Rankings
import com.embabel.agent.spi.config.spring.AgentPlatformProperties
import com.embabel.common.core.types.ZeroToOne
import com.embabel.common.util.indent
import com.embabel.common.util.loggerFor
import com.embabel.plan.goap.AStarGoapPlanner
import com.embabel.plan.goap.ConditionDetermination
import com.embabel.plan.goap.GoapPlanningSystem
import com.embabel.plan.goap.WorldStateDeterminer
import org.springframework.stereotype.Component
import org.springframework.stereotype.Service


/**
 * Autonomy properties
 * @param goalConfidenceCutOff Goal confidence cut-off, between 0 and 1, which is required
 * to have confidence in executing the most promising goal.
 * @param agentConfidenceCutOff Agent confidence cut-off, between 0 and 1, which is required
 * to have confidence in executing the most promising agent.
 */
// MIGRATED: @ConfigurationProperties("embabel.autonomy") → AgentPlatformProperties.autonomy
// Properties now sourced from embabel.agent.platform.autonomy.* in agent-platform.properties
@Component
class AutonomyProperties(platformProperties: AgentPlatformProperties) {
    val goalConfidenceCutOff: ZeroToOne = platformProperties.autonomy.goalConfidenceCutOff
    val agentConfidenceCutOff: ZeroToOne = platformProperties.autonomy.agentConfidenceCutOff
}

/**
 * Can override platform-wide AutonomyProperties
 * @param goalConfidenceCutOff Goal confidence cut-off, between 0 and 1 if we want to override the platform-wide setting.
 * @param agentConfidenceCutOff Agent confidence cut-off, between 0 and 1 if we want to override the platform-wide setting.
 * @param multiGoal Whether to allow multiple goals to be selected and accomplished.
 */
data class GoalSelectionOptions(
    val goalConfidenceCutOff: ZeroToOne? = null,
    val agentConfidenceCutOff: ZeroToOne? = null,
    val multiGoal: Boolean = false,
)

/**
 * Adds autonomy to an AgentPlatform, with the ability to choose
 * goals and agents dynamically, given user input.
 * Then calls the AgentPlatform to execute.
 */
@Service
class Autonomy(
    val agentPlatform: AgentPlatform,
    private val ranker: Ranker,
    val properties: AutonomyProperties,
) {

    private val logger = loggerFor<Autonomy>()

    private val eventListener = agentPlatform.platformServices.eventListener

    /**
     * Choose a goal based on the user input and try to achieve it.
     * Open execution model.
     * May bring in actions and conditions from multiple agents to help achieve the goal.
     * Doesn't need reified types because we don't know the type yet.
     * @param processOptions process options
     * @param goalChoiceApprover goal choice approver allowing goal choice to be rejected
     * @param agentScope scope to look for the agent
     * @param bindings any additional bindings to pass to the agent process
     * @param goalSelectionOptions options for goal selection, such as confidence cut-off and multi-goal selection,
     * if we want customization.
     */
    @Throws(ProcessExecutionException::class)
    fun chooseAndAccomplishGoal(
        processOptions: ProcessOptions = ProcessOptions(),
        goalChoiceApprover: GoalChoiceApprover,
        agentScope: AgentScope,
        bindings: Map<String, Any>,
        goalSelectionOptions: GoalSelectionOptions = GoalSelectionOptions(),
    ): AgentProcessExecution {
        val goalSeeker = createGoalSeeker(
            processOptions = processOptions,
            bindings = bindings,
            goalChoiceApprover = goalChoiceApprover,
            agentScope = agentScope,
            emitEvents = true,
            goalSelectionOptions = goalSelectionOptions,
        )
        val agentProcess = agentPlatform.createAgentProcess(
            processOptions = processOptions,
            agent = goalSeeker.agent,
            bindings = bindings,
        )
        agentProcess.run()

        return AgentProcessExecution.fromProcessStatus(
            basis = bindings,
            agentProcess = agentProcess,
        )
    }

    /**
     * Agent to seek a goal and the goal rankings that we used to choose the goal.
     */
    data class GoalSeeker(
        val agent: Agent,
        val rankings: Rankings<Goal>,
    )

    /**
     * Choose an agent based on the user input and run it.
     * Closed execution model:
     * Will never mix actions and goals from different agents.
     * Doesn't need reified types because we don't know the type yet.
     */
    @Throws(ProcessExecutionException::class)
    fun chooseAndRunAgent(
        intent: String,
        processOptions: ProcessOptions = ProcessOptions(),
    ): AgentProcessExecution {
        val userInput = UserInput(intent)

        val agentChoiceEvent = RankingChoiceRequestEvent(
            agentPlatform = agentPlatform,
            type = Agent::class.java,
            basis = userInput,
            choices = agentPlatform.agents(),
        )
        eventListener.onPlatformEvent(agentChoiceEvent)
        val agentRankings = ranker
            .rank(
                description = "agent",
                userInput = userInput.content,
                rankables = agentPlatform.agents()
            )
        val credibleAgents = agentRankings
            .rankings()
            .filter { it.score > properties.agentConfidenceCutOff }
        val agentChoice = credibleAgents.firstOrNull()
        if (agentChoice == null) {
            eventListener.onPlatformEvent(
                agentChoiceEvent.noDeterminationEvent(
                    rankings = agentRankings,
                    confidenceCutoff = properties.agentConfidenceCutOff
                )
            )
            throw NoAgentFound(agentRankings = agentRankings, basis = userInput)
        }

        logger.debug(
            "Agent choice {} with confidence {} for user intent {}: Choices were {}",
            agentChoice.match.name,
            agentChoice.score,
            intent,
            agentPlatform.agents().joinToString("\n") { it.name },
        )
        eventListener.onPlatformEvent(
            agentChoiceEvent.determinationEvent(
                choice = agentChoice,
                rankings = agentRankings,
            )
        )

        val agent = agentChoice.match
        eventListener.onPlatformEvent(
            DynamicAgentCreationEvent(
                agent = agentChoice.match,
                agentPlatform = agentPlatform,
                basis = userInput,
            )
        )
        return runAgent(userInput, processOptions, agent)
    }

    fun runAgent(
        inputObject: Any,
        processOptions: ProcessOptions,
        agent: Agent,
    ): AgentProcessExecution {
        val agentProcess = agentPlatform.createAgentProcess(
            processOptions = processOptions,
            agent = agent,
            bindings = mapOf(
                IoBinding.DEFAULT_BINDING to inputObject
            )
        )
        // We treat the inputObject specially, and destructure it if it's a SomeOf composite
        destructureAndBindIfNecessary(inputObject, "input", agentProcess, logger)
        agentProcess.run()
        return AgentProcessExecution.fromProcessStatus(
            basis = inputObject,
            agentProcess = agentProcess,
        )
    }

    /**
     * Indicate which goal we'd use for this intent, and what agent we'd create.
     * Dry run capability available externally.
     */
    fun createGoalSeeker(
        intent: String,
        goalChoiceApprover: GoalChoiceApprover,
        agentScope: AgentScope,
        goalSelectionOptions: GoalSelectionOptions,
    ): GoalSeeker = createGoalSeeker(
        bindings = mapOf(IoBinding.DEFAULT_BINDING to UserInput(intent)),
        processOptions = ProcessOptions(),
        goalChoiceApprover = goalChoiceApprover,
        emitEvents = false,
        agentScope = agentScope,
        goalSelectionOptions = goalSelectionOptions,
    )

    /**
     * Choose a goal, showing workings and create an agent.
     * @param emitEvents whether to emit events. If we're just
     * doing a dry run, we don't want to emit events
     */
    private fun createGoalSeeker(
        bindings: Map<String, Any>,
        processOptions: ProcessOptions,
        goalChoiceApprover: GoalChoiceApprover,
        emitEvents: Boolean,
        agentScope: AgentScope,
        goalSelectionOptions: GoalSelectionOptions,
    ): GoalSeeker {
        val userInput = bindings.values.firstOrNull { it is UserInput } as? UserInput
            ?: throw IllegalArgumentException("No UserInput found in bindings: $bindings")

        val goalChoiceEvent = RankingChoiceRequestEvent(
            agentPlatform = agentPlatform,
            type = Goal::class.java,
            basis = userInput,
            choices = agentScope.goals,
        )
        if (emitEvents) eventListener.onPlatformEvent(goalChoiceEvent)
        val goalRankings = ranker
            .rank(
                description = "goal",
                userInput = userInput.content,
                rankables = agentScope.goals
            )
        val credibleGoals = goalRankings
            .rankings()
            .filter { it.score > (goalSelectionOptions.goalConfidenceCutOff ?: properties.goalConfidenceCutOff) }
        val goalChoice = if (goalSelectionOptions.multiGoal) {
            // TODO need to refine this
            val ultimate = credibleGoals.firstOrNull()
            if (ultimate == null) {
                null
            } else {
                val multigoal =
                    ultimate.match.withGoalPreconditions(*credibleGoals.drop(1).map { it.match }.toTypedArray())
                logger.info(
                    "Creating composite of {} goals: {} from credible goals: {}",
                    credibleGoals.size,
                    multigoal,
                    credibleGoals,
                )
                Ranking(match = multigoal, ultimate.score)
            }
        } else {
            credibleGoals.firstOrNull()
        }
        if (goalChoice == null) {
            eventListener.onPlatformEvent(
                goalChoiceEvent.noDeterminationEvent(
                    rankings = goalRankings,
                    confidenceCutoff = properties.goalConfidenceCutOff,
                )
            )
            throw NoGoalFound(goalRankings = goalRankings, basis = userInput)
        }

        logger.debug(
            "Goal choice {} with confidence {} for user intent {}: Choices were {}",
            goalChoice.match.name,
            goalChoice.score,
            userInput.content,
            agentScope.goals.joinToString("\n") { it.name },
        )
        if (emitEvents) eventListener.onPlatformEvent(
            goalChoiceEvent.determinationEvent(
                choice = goalChoice,
                rankings = goalRankings,
            )
        )

        // Check if the goal is approved
        val approval =
            goalChoiceApprover.approve(
                GoalChoiceApprovalRequest(
                    goal = goalChoice.match,
                    intent = userInput.content,
                    rankings = goalRankings,
                )
            )
        if (approval is GoalChoiceNotApproved) {
            val goalNotApproved = GoalNotApproved(
                basis = userInput,
                goalRankings = goalRankings,
                reason = approval.reason,
                agentPlatform = agentPlatform,
            )
            if (emitEvents) eventListener.onPlatformEvent(goalNotApproved)
            throw goalNotApproved
        }

        val goalAgent = createGoalAgent(
            inputObject = userInput,
            agentScope = agentScope,
            goal = goalChoice.match,
            prune = processOptions.prune,
        )
        if (emitEvents) eventListener.onPlatformEvent(
            DynamicAgentCreationEvent(
                agent = goalAgent,
                agentPlatform = agentPlatform,
                basis = userInput,
            )
        )
        return GoalSeeker(agent = goalAgent, rankings = goalRankings)
    }

    /**
     * Open mode.
     * Create an agent to accomplish this goal from the given user input
     * @param inputObject any input object
     * @param agentScope scope to look for the agent
     * @param goal the goal to accomplish
     * @param prune whether to prune the agent to only relevant actions
     */
    fun createGoalAgent(
        inputObject: Any,
        agentScope: AgentScope,
        goal: Goal,
        prune: Boolean,
    ): Agent {
        val agent = agentScope.createAgent(
            name = "goal-${goal.name}",
            provider = Constants.EMBABEL_PROVIDER,
            description = goal.description,
        )
            .withSingleGoal(goal)

        return if (prune && inputObject is UserInput) {
            // TODO generalize this to any input type
            agent.prune(inputObject)
        } else {
            agent
        }
    }

    /**
     * Agent with only relevant actions
     */
    private fun Agent.prune(userInput: UserInput): Agent {
        val planningSystem = this.planningSystem
        if (planningSystem !is GoapPlanningSystem) {
            logger.warn("Pruning is only supported for GoapPlanningSystem. Skipping pruning.")
            return this
        }
        logger.debug(
            "Raw agent: {}",
            infoString(),
        )
        val map = mutableMapOf<String, ConditionDetermination>()
        for (condition in this.planningSystem.knownConditions()) {
            map[condition] = ConditionDetermination.FALSE
        }
        logger.info(
            "Pruning agent instance from:\n{}",
            map.map { it.key to "${it.key}: ${it.value}".indent(1) }
                .sortedBy { it.first }
                .joinToString("\n") { it.second }
        )
        map += ("it:${userInput::class.qualifiedName}" to ConditionDetermination.TRUE)

        val planner = AStarGoapPlanner(
            WorldStateDeterminer.fromMap(map),
        )

        val pruned = planner.prune(planningSystem)
        val prunedActions = planningSystem.actions.subtract(pruned.actions)
        logger.info(
            "Pruned planning system removed {} actions:\n{} \nPruned:\n{}",
            prunedActions.size,
            prunedActions.toList().sortedBy { it.name }.joinToString("\n") { it.name.indent(1) },
            pruned.infoString(true, 1),
        )
        return pruneTo(pruned)
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/autonomy/DefaultPlanLister.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.autonomy

import com.embabel.agent.core.AgentPlatform
import com.embabel.agent.core.ProcessOptions
import com.embabel.common.util.time
import com.embabel.plan.Plan
import com.embabel.plan.goap.GoapPlanner
import com.embabel.plan.goap.GoapPlanningSystem
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service

@Service
class DefaultPlanLister(
    private val agentPlatform: AgentPlatform,
) : PlanLister {

    private val logger = LoggerFactory.getLogger(javaClass)

    override fun achievablePlans(
        processOptions: ProcessOptions,
        bindings: Map<String, Any>,
    ): List<Plan> {
        // We'll never run this agent
        val uberAgent = agentPlatform.createAgent(
            name = "PlanLister",
            provider = "Embabel",
            description = "Won't even run, just lists plans",
        )
        // TODO this will get bound to the process repository, which we don't want
        val dummyAgentProcess = agentPlatform.createAgentProcess(
            processOptions = processOptions,
            agent = uberAgent,
            bindings = bindings,
        )
        val planner = dummyAgentProcess.planner as? GoapPlanner
            ?: TODO("Only GoapPlanners are presently supported: found ${dummyAgentProcess.planner::class.qualifiedName}")
        val planningSystem = planningSystem()
        val (plans, ms) = time {
            planner.plansToGoals(
                system = planningSystem,
            )
        }
        logger.info(
            "Achievable plans given {} actions and {} goals in {}ms from bindings {} : {}\n{}",
            planningSystem.actions.size,
            planningSystem.goals.size,
            ms,
            bindings,
            plans.joinToString("\n") { it.infoString(verbose = true, indent = 1) },
            planningSystem.infoString(verbose = true, indent = 1),
        )
        return plans
    }

    private fun planningSystem(): GoapPlanningSystem {
        return GoapPlanningSystem(
            actions = agentPlatform.actions.toSet(),
            goals = agentPlatform.goals,
        )
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/autonomy/GoalChoiceApprover.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.autonomy

import com.embabel.agent.core.Goal
import com.embabel.agent.spi.Rankings
import com.embabel.common.core.types.ZeroToOne

data class GoalChoiceApprovalRequest(
    val goal: Goal,
    val intent: String,
    val rankings: Rankings<Goal>,
)

sealed interface GoalChoiceApprovalResponse {
    val request: GoalChoiceApprovalRequest
    val approved: Boolean
}

data class GoalChoiceApproved(
    override val request: GoalChoiceApprovalRequest,
) : GoalChoiceApprovalResponse {
    override val approved: Boolean = true
}

data class GoalChoiceNotApproved(
    override val request: GoalChoiceApprovalRequest,
    val reason: String,
) : GoalChoiceApprovalResponse {
    override val approved: Boolean = false
}

/**
 * Implemented by objects that can veto goal choice
 */
fun interface GoalChoiceApprover {

    /**
     * Respond to a goal choice.
     */
    fun approve(
        goalChoiceApprovalRequest: GoalChoiceApprovalRequest,
    ): GoalChoiceApprovalResponse

    companion object {
        val APPROVE_ALL = GoalChoiceApprover { GoalChoiceApproved(it) }

        /**
         * Approve if the score is greater than this value
         */
        infix fun approveWithScoreOver(score: ZeroToOne) = GoalChoiceApprover { request ->
            if ((request.rankings.rankings().firstOrNull()?.score ?: 0.0) > score) {
                GoalChoiceApproved(request)
            } else {
                GoalChoiceNotApproved(
                    request = request,
                    reason = "Score ${request.rankings.rankings().firstOrNull()?.score} is not over $score",
                )
            }
        }
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/autonomy/PlanLister.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.autonomy

import com.embabel.agent.core.Goal
import com.embabel.agent.core.ProcessOptions
import com.embabel.plan.Plan

/**
 * Interface for listing achievable plans based on the current world state.
 */
interface PlanLister {

    /**
     * List achievable plans from the current world state.
     * @param processOptions process options
     * @param bindings bindings to use for planning
     */
    fun achievablePlans(
        processOptions: ProcessOptions,
        bindings: Map<String, Any>,
    ): List<Plan>

    fun achievableGoals(
        processOptions: ProcessOptions,
        bindings: Map<String, Any>,
    ): List<Goal> =
        achievablePlans(processOptions, bindings).mapNotNull { it.goal as? Goal }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/support/bindFieldsToBlackboard.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.support

import com.embabel.agent.api.common.SomeOf
import com.embabel.agent.core.Blackboard
import com.embabel.agent.core.IoBinding
import org.slf4j.Logger
import java.lang.reflect.Modifier

/**
 * Bind the fields of this object to the [Blackboard] if it is an instance of [SomeOf].
 */
fun destructureAndBindIfNecessary(
    obj: Any,
    name: String,
    blackboard: Blackboard,
    logger: Logger,
) {
    (obj as? SomeOf)?.bindFieldsToBlackboard(
        name = name,
        blackboard = blackboard,
        logger = logger
    )
}


private fun SomeOf.bindFieldsToBlackboard(
    name: String,
    blackboard: Blackboard,
    logger: Logger,
) {
    javaClass.declaredFields
        .filter { !it.isSynthetic && !Modifier.isStatic(it.modifiers) }
        .forEach { field ->
            field.setAccessible(true)
            val fieldValue = field.get(this)
            if (fieldValue != null) {
                val bindingName = IoBinding.DEFAULT_BINDING // field.name
                blackboard[bindingName] = fieldValue
                logger.info(
                    "Binding output element of composite action {}: {} to {}",
                    name,
                    bindingName,
                    fieldValue,
                )
            } else {
                logger.info(
                    "Field {} in output of composite action {} is null, not binding",
                    field.name,
                    name,
                )
            }
        }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/support/BranchingAction.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.support

import com.embabel.agent.api.common.Transformation
import com.embabel.agent.api.common.TransformationActionContext
import com.embabel.agent.core.*
import com.embabel.agent.core.support.AbstractAction
import com.embabel.common.core.types.ZeroToOne

/**
 * Return type to indicate that the action can return one of two types.
 * Facilitates branching
 */
data class Branch<B, C>(
    val left: B? = null,
    val right: C? = null,
) {

    init {
        if (left == null && right == null) {
            throw IllegalArgumentException("At least one of left or right must be non-null")
        }
    }

    fun get(): Any? {
        return left ?: right
    }
}

/**
 * Action that declares one of two types of output.
 * The code block must return a Branch object, which will be used to determine which output to use.
 */
open class BranchingAction<I, O1, O2>(
    name: String,
    description: String = name,
    pre: List<String> = emptyList(),
    post: List<String> = emptyList(),
    cost: ZeroToOne = 0.0,
    value: ZeroToOne = 0.0,
    canRerun: Boolean = false,
    qos: ActionQos = ActionQos(),
    private val inputClass: Class<I>,
    private val leftOutputClass: Class<O1>,
    private val rightOutputClass: Class<O2>,
    private val inputVarName: String = IoBinding.DEFAULT_BINDING,
    private val outputVarName: String? = IoBinding.DEFAULT_BINDING,
    private val referencedInputProperties: Set<String>? = null,
    toolGroups: Set<ToolGroupRequirement>,
    private val block: Transformation<I, Branch<O1, O2>>,
) : AbstractAction(
    name = name,
    description = description,
    pre = pre,
    post = post,
    cost = cost,
    value = value,
    inputs = expandInputBindings(inputVarName, inputClass),
    outputs = setOf(
        IoBinding(IoBinding.DEFAULT_BINDING, leftOutputClass.name),
        IoBinding(IoBinding.DEFAULT_BINDING, rightOutputClass.name)
    ),
    toolGroups = toolGroups,
    canRerun = canRerun,
    qos = qos,
) {

    override val domainTypes: Collection<DomainType>
        get() = setOf(inputClass, leftOutputClass, rightOutputClass)
            .map { JvmType(it) }

    @Suppress("UNCHECKED_CAST")
    override fun execute(
        processContext: ProcessContext,
    ): ActionStatus = ActionRunner.execute(processContext) {
        val input = processContext.getValue(inputVarName, inputClass.name) as I
        val branch = block.transform(
            context = TransformationActionContext(
                input = input,
                processContext = processContext,
                action = this,
                inputClass = inputClass,
                outputClass = Branch::class.java as Class<Branch<O1, O2>>,
            )
        )
        if (branch != null) {
            val output = branch.get()
            if (output != null) {
                if (outputVarName != null) {
                    processContext.blackboard[outputVarName] = output
                } else {
                    processContext.blackboard += output
                }
            }
        }
    }

    override fun referencedInputProperties(variable: String): Set<String> {
        return referencedInputProperties ?: run {
            val fields = inputClass.declaredFields.map { it.name }.toSet()
            fields
        }
    }

    override fun toString(): String =
        "${javaClass.simpleName}: name=$name, left=${leftOutputClass.simpleName}, right=${rightOutputClass.simpleName}"
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/support/ConsumerAction.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.support

import com.embabel.agent.api.common.Transformation
import com.embabel.agent.core.ActionQos
import com.embabel.agent.core.IoBinding
import com.embabel.agent.core.ToolGroupRequirement
import com.embabel.common.core.types.ZeroToOne

/**
 * Action that has input preconditions, but produces no output
 */
class ConsumerAction<I>(
    name: String,
    description: String = name,
    pre: List<String> = emptyList(),
    post: List<String> = emptyList(),
    cost: ZeroToOne = 0.0,
    value: ZeroToOne = 0.0,
    canRerun: Boolean = false,
    qos: ActionQos = ActionQos(),
    inputClass: Class<I>,
    outputVarName: String? = IoBinding.DEFAULT_BINDING,
    referencedInputProperties: Set<String>? = null,
    toolGroups: Set<ToolGroupRequirement>,
    block: Transformation<I, Unit>,
) : TransformationAction<I, Unit>(
    name = name,
    description = description,
    pre = pre,
    post = post,
    cost = cost,
    value = value,
    canRerun = canRerun,
    qos = qos,
    inputClass = inputClass,
    outputClass = Unit::class.java,
    outputVarName = outputVarName,
    referencedInputProperties = referencedInputProperties,
    toolGroups = toolGroups,
    block = block
)



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/support/MultiTransformationAction.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.support

import com.embabel.agent.api.common.SomeOf
import com.embabel.agent.api.common.Transformation
import com.embabel.agent.api.common.TransformationActionContext
import com.embabel.agent.core.*
import com.embabel.agent.core.support.AbstractAction
import com.embabel.common.core.types.ZeroToOne

/**
 * Transformer that can take multiple inputs.
 * The block takes a List<Any>.
 */
class MultiTransformationAction<O : Any>(
    name: String,
    description: String = name,
    pre: List<String> = emptyList(),
    post: List<String> = emptyList(),
    cost: ZeroToOne = 0.0,
    value: ZeroToOne = 0.0,
    canRerun: Boolean = false,
    qos: ActionQos = ActionQos(),
    inputs: Set<IoBinding>,
    private val inputClasses: List<Class<*>>,
    private val outputClass: Class<O>,
    private val outputVarName: String? = IoBinding.DEFAULT_BINDING,
    private val referencedInputProperties: Set<String>? = null,
    toolGroups: Set<ToolGroupRequirement>,
    private val block: Transformation<List<Any>, O>,
) : AbstractAction(
    name = name,
    description = description,
    pre = pre,
    post = post,
    cost = cost,
    value = value,
    inputs = inputs,
    outputs = calculateOutputs(outputVarName, outputClass),
    toolGroups = toolGroups,
    canRerun = canRerun,
    qos = qos,
) {

    override val domainTypes: Collection<JvmType>
        get() = JvmType.fromClasses(inputClasses + outputClass)

    override fun execute(
        processContext: ProcessContext,
    ): ActionStatus = ActionRunner.execute(processContext) {
        val inputValues: List<Any> = inputs.map {
            processContext.getValue(variable = it.name, type = it.type)
                ?: throw IllegalArgumentException("Input ${it.name} of type ${it.type} not found in process context")
        }
        logger.debug("Resolved action {} inputs {}", name, inputValues)
        val output = block.transform(
            TransformationActionContext(
                input = inputValues,
                processContext = processContext,
                inputClass = List::class.java as Class<List<Any>>,
                outputClass = outputClass,
                action = this,
            )
        )
        if (output != null) {
            bindOutput(processContext, output)
        }
    }

    private fun bindOutput(
        processContext: ProcessContext,
        output: O,
    ) {
        if (!outputClass.isInstance(output)) {
            throw IllegalArgumentException(
                """
                Output of action $name is not of type ${outputClass.name}.
                Return was $output
                """.trimIndent()
            )
        }
        destructureAndBindIfNecessary(
            obj = output,
            name = name,
            blackboard = processContext.blackboard,
            logger = logger
        )

        if (outputVarName != null) {
            logger.debug("Binding output of action {}: {} to {}", name, outputVarName, output)
            processContext.agentProcess[outputVarName] = output
        } else {
            logger.debug("Adding output of action {}: {}", name, output)
            processContext.agentProcess += output
        }
    }

    override fun referencedInputProperties(variable: String): Set<String> {
        return referencedInputProperties ?: run {
            val fields = inputClasses.map { it.declaredFields.map { it.name } }.flatten().toSet()
            fields
        }
    }

    override fun toString(): String {
        return "${javaClass.simpleName}: name=$name"
    }
}

private fun calculateOutputs(
    outputVarName: String?,
    outputClass: Class<*>,
): Set<IoBinding> {
    return if (outputVarName == null) {
        emptySet()
    } else {
        bindingsFrom(outputVarName, outputClass)
    }
}

private fun bindingsFrom(
    outputVarName: String?,
    outputClass: Class<*>,
): Set<IoBinding> {
    if (SomeOf::class.java.isAssignableFrom(outputClass)) {
        return SomeOf.eligibleFields(outputClass)
            .map { field ->
                IoBinding(
                    // TODO bind to name if requires match
                    name = IoBinding.DEFAULT_BINDING,//field.name,
                    type = field.type.name,
                )
            }
            .toSet()
    }

    return setOf(
        IoBinding(
            name = outputVarName,
            type = outputClass,
        )
    )
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/support/OperationContextPromptRunner.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.support

import com.embabel.agent.api.common.*
import com.embabel.agent.core.ProcessOptions
import com.embabel.agent.core.ToolGroup
import com.embabel.agent.core.ToolGroupRequirement
import com.embabel.agent.core.Verbosity
import com.embabel.agent.core.support.safelyGetToolCallbacks
import com.embabel.agent.experimental.primitive.Determination
import com.embabel.agent.prompt.element.ContextualPromptElement
import com.embabel.agent.spi.LlmInteraction
import com.embabel.agent.tools.agent.AgentToolCallback
import com.embabel.agent.tools.agent.Handoffs
import com.embabel.agent.tools.agent.PromptedTextCommunicator
import com.embabel.chat.Message
import com.embabel.common.ai.model.LlmOptions
import com.embabel.common.ai.prompt.PromptContributor
import com.embabel.common.core.types.ZeroToOne
import com.embabel.common.util.loggerFor
import org.springframework.ai.tool.ToolCallback
import java.util.function.Predicate

/**
 * Uses the platform's LlmOperations to execute the prompt.
 * All prompt running ends up through here.
 */
internal data class OperationContextPromptRunner(
    private val context: OperationContext,
    private val interactionId: InteractionId? = null,
    override val llm: LlmOptions,
    override val messages: List<Message> = emptyList(),
    override val toolGroups: Set<ToolGroupRequirement>,
    override val toolObjects: List<ToolObject>,
    override val promptContributors: List<PromptContributor>,
    private val contextualPromptContributors: List<ContextualPromptElement>,
    override val generateExamples: Boolean?,
    override val propertyFilter: Predicate<String> = Predicate { true },
    private val otherToolCallbacks: List<ToolCallback> = emptyList(),
) : PromptRunner {

    val action = (context as? ActionContext)?.action

    private fun idForPrompt(
        messages: List<Message>,
        outputClass: Class<*>,
    ): InteractionId {
        return InteractionId("${context.operation.name}-${outputClass.name}")
    }

    override fun withInteractionId(interactionId: InteractionId): PromptRunner =
        copy(interactionId = interactionId)

    override fun withMessages(messages: List<Message>): PromptRunner =
        copy(messages = this.messages + messages)

    override fun <T> createObject(
        messages: List<Message>,
        outputClass: Class<T>,
    ): T {
        val allPromptContributors = promptContributors + contextualPromptContributors.map {
            it.toPromptContributor(
                context
            )
        }
        return context.processContext.createObject(
            messages = this.messages + messages,
            interaction = LlmInteraction(
                llm = llm,
                toolGroups = this.toolGroups + toolGroups,
                toolCallbacks = safelyGetToolCallbacks(toolObjects) + otherToolCallbacks,
                promptContributors = allPromptContributors,
                id = interactionId ?: idForPrompt(messages, outputClass),
                generateExamples = generateExamples,
                propertyFilter = propertyFilter,
            ),
            outputClass = outputClass,
            agentProcess = context.processContext.agentProcess,
            action = action,
        )
    }

    override fun <T> createObjectIfPossible(
        messages: List<Message>,
        outputClass: Class<T>,
    ): T? {
        val result = context.processContext.createObjectIfPossible<T>(
            messages = messages,
            interaction = LlmInteraction(
                llm = llm,
                toolGroups = this.toolGroups + toolGroups,
                toolCallbacks = safelyGetToolCallbacks(toolObjects) + otherToolCallbacks,
                promptContributors = promptContributors + contextualPromptContributors.map {
                    it.toPromptContributor(
                        context
                    )
                },
                id = interactionId ?: idForPrompt(messages, outputClass),
                generateExamples = generateExamples,
                propertyFilter = propertyFilter,
            ),
            outputClass = outputClass,
            agentProcess = context.processContext.agentProcess,
            action = action,
        )
        if (result.isFailure) {
            loggerFor<OperationContextPromptRunner>().warn(
                "Failed to create object of type {} with messages {}: {}",
                outputClass.name,
                messages,
                result.exceptionOrNull()?.message,
            )
        }
        return result.getOrNull()
    }

    override fun evaluateCondition(
        condition: String,
        context: String,
        confidenceThreshold: ZeroToOne,
    ): Boolean {
        val prompt =
            """
            Evaluate this condition given the context.
            Return "result": whether you think it is true, your confidence level from 0-1,
            and an explanation of what you base this on.

            # Condition
            $condition

            # Context
            $context
            """.trimIndent()
        val determination = createObject(
            prompt = prompt,
            outputClass = Determination::class.java,
        )
        loggerFor<OperationContextPromptRunner>().info(
            "Condition {}: determination from {} was {}",
            condition,
            llm.criteria,
            determination,
        )
        return determination.result && determination.confidence >= confidenceThreshold
    }

    override fun withTemplate(templateName: String): TemplateOperations {
        return TemplateOperations(
            templateName = templateName,
            promptRunnerOperations = this,
            templateRenderer = context.agentPlatform().platformServices.templateRenderer,
        )
    }

    override fun withLlm(llm: LlmOptions): PromptRunner =
        copy(llm = llm)

    override fun withToolGroup(toolGroup: ToolGroupRequirement): PromptRunner =
        copy(toolGroups = this.toolGroups + toolGroup)

    override fun withToolGroup(toolGroup: ToolGroup): PromptRunner =
        copy(otherToolCallbacks = otherToolCallbacks + toolGroup.toolCallbacks)

    override fun withToolObject(toolObject: ToolObject): PromptRunner =
        copy(toolObjects = this.toolObjects + toolObject)

    override fun withHandoffs(vararg outputTypes: Class<*>): PromptRunner {
        val handoffs = Handoffs(
            autonomy = context.agentPlatform().platformServices.autonomy(),
            outputTypes = outputTypes.toList(),
            applicationName = context.agentPlatform().name,
        )
        return copy(
            otherToolCallbacks = this.otherToolCallbacks + handoffs.toolCallbacks,
        )
    }

    override fun withSubagents(
        vararg subagents: Subagent,
    ): PromptRunner {
        val newCallbacks = subagents.map { subagent ->
            val agent = subagent.resolve(context.agentPlatform())
            AgentToolCallback(
                autonomy = context.agentPlatform().platformServices.autonomy(),
                agent = agent,
                textCommunicator = PromptedTextCommunicator,
                objectMapper = context.agentPlatform().platformServices.objectMapper,
                inputType = subagent.inputClass,
                processOptionsCreator = { agentProcess ->
                    val blackboard = agentProcess.processContext.blackboard.spawn()
                    loggerFor<OperationContextPromptRunner>().info(
                        "Creating subagent process for {} with blackboard {}",
                        agent.name,
                        blackboard,
                    )
                    ProcessOptions(
                        verbosity = Verbosity(showPrompts = true),
                        blackboard = blackboard,
                    )
                },
            )
        }
        return copy(
            otherToolCallbacks = this.otherToolCallbacks + newCallbacks,
        )
    }

    override fun withPromptContributors(promptContributors: List<PromptContributor>): PromptRunner =
        copy(promptContributors = this.promptContributors + promptContributors)

    override fun withContextualPromptContributors(
        contextualPromptContributors: List<ContextualPromptElement>,
    ): PromptRunner =
        copy(contextualPromptContributors = this.contextualPromptContributors + contextualPromptContributors)

    override fun withGenerateExamples(generateExamples: Boolean): PromptRunner =
        copy(generateExamples = generateExamples)

    override fun withPropertyFilter(filter: Predicate<String>): PromptRunner =
        copy(propertyFilter = this.propertyFilter.and(filter))

    override fun <T> creating(outputClass: Class<T>): ObjectCreator<T> {
        return PromptRunnerObjectCreator(
            promptRunner = this,
            outputClass = outputClass,
            objectMapper = context.agentPlatform().platformServices.objectMapper,
        )
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/support/SelfToolCallbackPublisher.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.support

import com.embabel.agent.core.*
import com.embabel.common.core.types.AssetCoordinates
import com.embabel.common.core.types.Semver
import org.springframework.ai.support.ToolCallbacks
import org.springframework.ai.tool.ToolCallback

/**
 * Convenient interface a class can implement to publish @Tool
 * functions automatically. Application domain objects can extend this.
 * Intended for extension by both platform and application code.
 */
interface SelfToolCallbackPublisher : ToolCallbackPublisher {

    override val toolCallbacks: List<ToolCallback>
        get() = ToolCallbacks.from(this).toList()
}

interface SelfToolGroup : SelfToolCallbackPublisher, ToolGroup, AssetCoordinates {

    val description: ToolGroupDescription

    override val name: String get() = javaClass.name

    override val provider: String

    override val version: Semver

    val permissions: Set<ToolGroupPermission>

    override val metadata: ToolGroupMetadata
        get() = ToolGroupMetadata(
            description = description,
            name = name,
            provider = provider,
            permissions = permissions,
            version = version,
        )
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/support/SupplierAction.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.support

import com.embabel.agent.api.common.Transformation
import com.embabel.agent.core.ActionQos
import com.embabel.agent.core.IoBinding
import com.embabel.agent.core.ToolGroupRequirement
import com.embabel.common.core.types.ZeroToOne

/**
 * Action that has no input preconditions, but produces an output
 */
class SupplierAction<O>(
    name: String,
    description: String = name,
    pre: List<String> = emptyList(),
    post: List<String> = emptyList(),
    cost: ZeroToOne = 0.0,
    value: ZeroToOne = 0.0,
    canRerun: Boolean = false,
    qos: ActionQos = ActionQos(),
    outputClass: Class<O>,
    outputVarName: String? = IoBinding.DEFAULT_BINDING,
    referencedInputProperties: Set<String>? = null,
    toolGroups: Set<ToolGroupRequirement>,
    block: Transformation<Unit, O>,
) : TransformationAction<Unit, O>(
    name = name,
    description = description,
    pre = pre,
    post = post,
    cost = cost,
    value = value,
    canRerun = canRerun,
    qos = qos,
    inputClass = Unit::class.java,
    outputClass = outputClass,
    outputVarName = outputVarName,
    referencedInputProperties = referencedInputProperties,
    toolGroups = toolGroups,
    block = block
)



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/support/TransformationAction.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.support

import com.embabel.agent.api.common.Aggregation
import com.embabel.agent.api.common.Transformation
import com.embabel.agent.api.common.TransformationActionContext
import com.embabel.agent.core.*
import com.embabel.agent.core.support.AbstractAction
import com.embabel.common.core.types.ZeroToOne
import java.lang.reflect.Modifier


/**
 * Transformation action that runs custom code.
 */
open class TransformationAction<I, O>(
    name: String,
    description: String = name,
    pre: List<String> = emptyList(),
    post: List<String> = emptyList(),
    cost: ZeroToOne = 0.0,
    value: ZeroToOne = 0.0,
    canRerun: Boolean = false,
    qos: ActionQos = ActionQos(),
    private val inputClass: Class<I>,
    val outputClass: Class<O>,
    private val inputVarName: String = IoBinding.DEFAULT_BINDING,
    private val outputVarName: String? = IoBinding.DEFAULT_BINDING,
    private val referencedInputProperties: Set<String>? = null,
    toolGroups: Set<ToolGroupRequirement>,
    private val block: Transformation<I, O>,
) : AbstractAction(
    name = name,
    description = description,
    pre = pre,
    post = post,
    cost = cost,
    value = value,
    inputs = expandInputBindings(inputVarName, inputClass),
    outputs = if (outputVarName == null) emptySet() else setOf(IoBinding(outputVarName, outputClass.name)),
    toolGroups = toolGroups,
    canRerun = canRerun,
    qos = qos,
) {

    override val domainTypes: Collection<DomainType>
        get() = setOf(inputClass, outputClass).map { DynamicType(it.name) }

    @Suppress("UNCHECKED_CAST")
    override fun execute(
        processContext: ProcessContext,
    ): ActionStatus = ActionRunner.execute(processContext) {
        val input = processContext.getValue(inputVarName, inputClass.name) as I
        val output = block.transform(
            TransformationActionContext(
                input = input,
                processContext = processContext,
                action = this,
                inputClass = inputClass,
                outputClass = outputClass,
            )
        )
        if (output != null) {
            if (outputVarName != null) {
                processContext.blackboard[outputVarName] = output
            } else {
                processContext.blackboard += output
            }
        }
    }

    override fun referencedInputProperties(variable: String): Set<String> {
        return referencedInputProperties ?: run {
            val fields = inputClass.declaredFields.map { it.name }.toSet()
            fields
        }
    }

    override fun toString() =
        "${javaClass.simpleName}: name=$name"
}

/**
 * Create input binding(s) for the given variable name and type.
 * Allow for megazords (Aggregations) and decompose them into their individual fields.
 */
fun expandInputBindings(
    inputVarName: String,
    inputClass: Class<*>,
): Set<IoBinding> {
    if (inputClass == Unit::class.java) {
        // Unit is a special case, we don't want to bind any inputs
        return emptySet()
    }
    if (Aggregation::class.java.isAssignableFrom(inputClass)) {
        return inputClass.declaredFields
            .filter { !it.isSynthetic && !Modifier.isStatic(it.modifiers) }
            .map { field ->
                // Make field accessible if it's private
                field.isAccessible = true
                IoBinding(
                    type = field.type
                )
            }
            .toSet()
    }

    // Default case: just return the input itself
    return setOf(IoBinding(inputVarName, inputClass.name))
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/workflow/WorkflowBuilder.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.workflow

import com.embabel.agent.api.common.ActionContext
import com.embabel.agent.api.dsl.AgentScopeBuilder
import com.embabel.agent.common.Constants
import com.embabel.agent.core.Agent
import com.embabel.agent.core.IoBinding

/**
 * Ensure consistent naming convention for workflow builders that return a given result type.
 */
interface WorkflowBuilderReturning {

    fun <RESULT : Any> returning(resultClass: Class<RESULT>): Any
}

/**
 * Ensure consistent naming convention for workflow builders that consume a given input type.
 */
interface WorkflowBuilderConsuming {

    /**
     * Specify the input type for this workflow.
     * Return a builder
     */
    fun <INPUT : Any> consuming(inputClass: Class<INPUT>): Any
}

/**
 * Common base class for building workflows,
 * ensuring consistent agent construction
 */
abstract class WorkflowBuilder<RESULT : Any>(
    private val resultClass: Class<RESULT>,
    private val inputClass: Class<out Any>?,
) {

    abstract fun build(): AgentScopeBuilder<RESULT>

    /**
     * Build an agent on this RepeatUntil workflow.
     * Can be used to implement an @Bean method that returns an Agent,
     * which will be automatically be registered on the current AgentPlatform.
     */
    fun buildAgent(
        name: String,
        description: String,
    ): Agent {
        return build()
            .build()
            .createAgent(
                name = name,
                provider = Constants.EMBABEL_PROVIDER,
                description = description,
            )
    }

    /**
     * Convenience method to build an agent with a default name and description.
     * This is typically used inside an @Action method.
     */
    fun asSubProcess(
        context: ActionContext,
    ): RESULT {
        val preconditions = listOfNotNull(inputClass).map { IoBinding(type = it) }.map { it.value }
        val illegals = preconditions.filter { context.action?.preconditions?.contains(it) != true }
        if (illegals.isNotEmpty()) {
            error(
                """
                Cannot build a sub-process with input classes not specified as preconditions of enclosing action.
                Illegal preconditions: ${illegals.joinToString(", ")}
                Use buildAgent() instead.
                """.trimIndent()
            )
        }
        return build()
            .asSubProcess(context, resultClass)
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/workflow/control/ScatterGather.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.workflow.control

import com.embabel.agent.api.common.SupplierActionContext
import com.embabel.agent.api.common.TransformationActionContext
import com.embabel.agent.api.common.support.SupplierAction
import com.embabel.agent.api.common.support.TransformationAction
import com.embabel.agent.api.dsl.AgentScopeBuilder
import com.embabel.agent.core.Action
import com.embabel.agent.core.Goal
import com.embabel.common.core.MobyNameGenerator
import org.slf4j.LoggerFactory

data class ResultList<RESULT : Any>(
    val results: List<RESULT>,
)

/**
 * Scatter gather pattern for generating multiple results in parallel and consolidating them.
 */
class ScatterGather(
    private val maxConcurrency: Int,
) {

    private val logger = LoggerFactory.getLogger(javaClass)

    fun <ELEMENT : Any, RESULT : Any> forkJoin(
        generators: List<(SupplierActionContext<ELEMENT>) -> ELEMENT>,
        joinFunction: (TransformationActionContext<ResultList<ELEMENT>, RESULT>) -> RESULT,
        elementClass: Class<ELEMENT>,
        resultClass: Class<RESULT>,
    ): AgentScopeBuilder<RESULT> {
        val generateAction = SupplierAction(
            name = "=>${resultClass.name}",
            description = "Generate $resultClass",
            cost = 0.0,
            value = 0.0,
            canRerun = true,
            outputClass = ResultList::class.java,
            toolGroups = emptySet(),
        ) { context ->
            logger.info("Generating results using {} generators", generators.size)
            val tac = SupplierActionContext(
                processContext = context.processContext,
                outputClass = elementClass,
                action = context.action,
            )
            val results = context.parallelMap(generators, maxConcurrency = maxConcurrency) { generator ->
                val result = generator.invoke(tac)
                logger.info("Generated result: {}", result)
                result
            }
            ResultList(results)
        }

        val consolidateAction: Action = TransformationAction(
            name = "consolidate-${resultClass.name}",
            description = "Consolidate results and feedback",
            cost = 0.0,
            value = 0.0,
            toolGroups = emptySet(),
            inputClass = ResultList::class.java,
            outputClass = resultClass,
        ) { context ->
            val finalResult = joinFunction.invoke(
                context as TransformationActionContext<ResultList<ELEMENT>, RESULT>,
            )
            logger.info("Consolidating results, final (best) result: {}", finalResult)
            finalResult
        }

        val resultGoal = Goal(
            name = "final-${resultClass.name}",
            description = "Satisfied with the final ${resultClass.name}",
            satisfiedBy = resultClass,
        )
        logger.info("Created goal: {}", resultGoal.infoString(verbose = true, indent = 2))

        return AgentScopeBuilder(
            name = MobyNameGenerator.generateName(),
            actions = listOf(
                generateAction,
                consolidateAction,
            ),
            goals = setOf(resultGoal),
            opaque = true,
        )
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/workflow/control/ScatterGatherBuilder.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.workflow.control

import com.embabel.agent.api.common.SupplierActionContext
import com.embabel.agent.api.common.TransformationActionContext
import com.embabel.agent.api.common.workflow.WorkflowBuilder
import com.embabel.agent.api.common.workflow.WorkflowBuilderReturning
import com.embabel.agent.api.dsl.AgentScopeBuilder
import java.util.function.Function
import java.util.function.Supplier

/**
 * Builder for creating a consensus workflow that generates results from multiple
 * but need not use an LLM at all.
 */
class ScatterGatherBuilder<ELEMENT : Any, RESULT : Any>(
    private val elementClass: Class<ELEMENT>,
    private val resultClass: Class<RESULT>,
    private val maxConcurrency: Int = DEFAULT_MAX_CONCURRENCY,
) {

    companion object : WorkflowBuilderReturning {

        const val DEFAULT_MAX_CONCURRENCY = 6

        @JvmStatic
        override fun <RESULT : Any> returning(resultClass: Class<RESULT>): ElementBuilder<RESULT> {
            return ElementBuilder(resultClass)
        }

    }

    class ElementBuilder<RESULT : Any>(
        private val resultClass: Class<RESULT>,
    ) {

        fun <ELEMENT : Any> fromElements(elementClass: Class<ELEMENT>): ScatterGatherBuilder<ELEMENT, RESULT> {
            return ScatterGatherBuilder(elementClass, resultClass)
        }

    }

    fun withGenerators(
        generators: List<Function<out SupplierActionContext<ELEMENT>, ELEMENT>>,
    ): Generators {
        return Generators(
            generators = generators,
        )
    }

    // We avoid method overloading because it's evil
    fun generatedBy(
        generators: List<Supplier<ELEMENT>>,
    ): Generators {
        return Generators(
            generators = generators.map { generator ->
                Function<SupplierActionContext<ELEMENT>, ELEMENT> { _ ->
                    generator.get()
                }
            },
        )
    }

    inner class Generators(
        private val generators: List<Function<out SupplierActionContext<ELEMENT>, ELEMENT>>,
    ) {

        fun consolidatedBy(
            consensusFunction: (TransformationActionContext<ResultList<ELEMENT>, RESULT>) -> RESULT,
        ): Emitter {
            return Emitter(generators, consensusFunction)
        }

    }

    inner class Emitter(
        private val generators: List<Function<out SupplierActionContext<ELEMENT>, ELEMENT>>,
        private val consensusFunction: (TransformationActionContext<ResultList<ELEMENT>, RESULT>) -> RESULT,
    ) : WorkflowBuilder<RESULT>(resultClass, inputClass = null) {

        override fun build(): AgentScopeBuilder<RESULT> {
            return ScatterGather(maxConcurrency = maxConcurrency)
                .forkJoin(
                    generators = generators.map { it::apply } as List<(SupplierActionContext<ELEMENT>) -> ELEMENT>,
                    joinFunction = consensusFunction,
                    elementClass = elementClass,
                    resultClass = resultClass,
                )
        }
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/workflow/control/SimpleAgentBuilder.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.workflow.control

import com.embabel.agent.api.common.SupplierActionContext
import com.embabel.agent.api.common.TransformationActionContext
import com.embabel.agent.api.common.support.SupplierAction
import com.embabel.agent.api.common.support.TransformationAction
import com.embabel.agent.api.common.workflow.WorkflowBuilder
import com.embabel.agent.api.common.workflow.WorkflowBuilderConsuming
import com.embabel.agent.api.common.workflow.WorkflowBuilderReturning
import com.embabel.agent.api.dsl.AgentScopeBuilder
import com.embabel.agent.core.Goal
import com.embabel.agent.core.IoBinding
import com.embabel.agent.core.support.Rerun.hasRunCondition
import com.embabel.common.core.MobyNameGenerator

/**
 * Simplest way to build an agent that performs a single operation, like an LLM call.
 */
data class SimpleAgentBuilder<RESULT : Any>(
    private val resultClass: Class<RESULT>,
    private val inputClass: Class<out Any>? = null,
) : WorkflowBuilderConsuming {

    companion object : WorkflowBuilderReturning {

        /**
         * Creates a simple agent builder that can be used to build agents with a single action.
         * This is useful for quick prototyping or when you need a simple agent without complex workflows.
         */
        @JvmStatic
        override fun <RESULT : Any> returning(resultClass: Class<RESULT>): SimpleAgentBuilder<RESULT> {
            return SimpleAgentBuilder(resultClass)
        }

        inline operator fun <reified RESULT : Any> invoke(): SimpleAgentBuilder<RESULT> {
            return returning(RESULT::class.java)
        }
    }

    override fun <INPUT : Any> consuming(inputClass: Class<INPUT>): SimpleAgentConsumer<INPUT> {
        return SimpleAgentConsumer(inputClass)
    }

    /**
     * Provide a function the agent will perform to generate
     * a draft on each iteration
     */
    fun running(
        generator: (SupplierActionContext<RESULT>) -> RESULT,
    ): Emitter {
        return Emitter(generator)
    }

    inner class Emitter(
        private val generator: (SupplierActionContext<RESULT>) -> RESULT,
        private val mustRun: Boolean = false,
    ) : WorkflowBuilder<RESULT>(resultClass, inputClass) {

        /**
         * If this is true, the action must run even if its
         * type result is already present in the blackboard.
         */
        fun mustRun(): Emitter {
            return Emitter(generator, mustRun = true)
        }

        override fun build(): AgentScopeBuilder<RESULT> {
            val action = SupplierAction(
                name = "Generate ${resultClass.simpleName}",
                description = "Generates a result of type ${resultClass.simpleName}",
                cost = 0.0,
                value = 0.0,
                canRerun = true,
                pre = listOfNotNull(inputClass).map { IoBinding(type = it).value },
                outputClass = resultClass,
                toolGroups = emptySet(),
            ) { context ->
                val supplierContext = SupplierActionContext(
                    processContext = context.processContext,
                    outputClass = resultClass,
                    action = context.action,
                )
                generator(supplierContext)
            }
            val preconditions = if (mustRun) {
                listOf(hasRunCondition(action))
            } else {
                emptyList()
            }
            val goal = Goal(
                name = "${resultClass.simpleName}",
                description = "Goal to generate a result of type ${resultClass.simpleName}",
                satisfiedBy = resultClass,
            ).withPreconditions(*preconditions.toTypedArray())
            return AgentScopeBuilder(
                name = MobyNameGenerator.generateName(),
                actions = listOf(action),
                goals = setOf(goal),
            )
        }
    }

    inner class SimpleAgentConsumer<INPUT : Any>(
        private val inputClass: Class<INPUT>,
    ) {

        /**
         * Provide a function the agent will perform.
         */
        fun running(
            generator: (TransformationActionContext<INPUT, RESULT>) -> RESULT,
        ): WorkflowBuilder<RESULT> {
            return Emitter(generator)
        }

        inner class Emitter(
            private val generator: (TransformationActionContext<INPUT, RESULT>) -> RESULT,
        ) : WorkflowBuilder<RESULT>(resultClass, inputClass) {

            override fun build(): AgentScopeBuilder<RESULT> {
                val action = TransformationAction(
                    name = "Generate ${resultClass.simpleName}",
                    description = "Generates a result of type ${resultClass.simpleName}",
                    cost = 0.0,
                    value = 0.0,
                    canRerun = true,
                    inputClass = inputClass,
                    outputClass = resultClass,
                    toolGroups = emptySet(),
                ) { context ->
                    generator(context)
                }
                val goal = Goal(
                    name = "${resultClass.simpleName} Goal",
                    description = "Goal to generate a result of type ${resultClass.simpleName}",
                    satisfiedBy = resultClass,
                )
                return AgentScopeBuilder(
                    name = MobyNameGenerator.generateName(),
                    actions = listOf(action),
                    goals = setOf(goal),
                )
            }
        }
    }


}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/workflow/loop/Feedback.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.workflow.loop

import com.embabel.common.core.types.ZeroToOne
import com.fasterxml.jackson.annotation.JsonPropertyDescription

/**
 * Feedback on a generated output
 */
interface Feedback {
    @get:JsonPropertyDescription("Feedback score between 0.0 and 1.0 where 0.0 is worst and 1.0 is best")
    val score: ZeroToOne
}

/**
 * Convenient implementation of [Feedback] that contains textual feedback.
 */
data class TextFeedback(
    override val score: ZeroToOne,
    val feedback: String,
) : Feedback



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/workflow/loop/RepeatUntil.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.workflow.loop

import com.embabel.agent.api.common.InputActionContext
import com.embabel.agent.api.common.OperationContext
import com.embabel.agent.api.common.support.TransformationAction
import com.embabel.agent.api.dsl.AgentScopeBuilder
import com.embabel.agent.core.*
import com.embabel.agent.event.AgenticEventListener
import com.embabel.common.core.MobyNameGenerator
import com.embabel.common.core.types.Timed
import com.embabel.common.core.types.Timestamped
import org.slf4j.LoggerFactory
import java.time.Duration
import java.time.Instant


/**
 * Mutable object. We only bind this once
 */
data class ResultHistory<RESULT : Any>(
    private val _results: MutableList<RESULT> = mutableListOf(),
    override val timestamp: Instant = Instant.now(),
) : Timestamped, Timed {

    fun attemptCount(): Int = _results.size

    override val runningTime: Duration
        get() = Duration.between(timestamp, Instant.now())

    fun attempts(): List<RESULT> = _results.toList()

    fun lastAttempt(): RESULT? = _results.lastOrNull()

    internal fun recordResult(result: RESULT) {
        _results += result
    }
}


/**
 * Primitive for building repeat until workflows.
 */
data class RepeatUntil(
    val maxIterations: Int = 3,
) {

    private val logger = LoggerFactory.getLogger(javaClass)

    inline fun <reified INPUT, reified RESULT : Any> build(
        noinline task: (RepeatUntilActionContext<INPUT, RESULT>) -> RESULT,
        noinline acceptanceCriteria: (RepeatUntilActionContext<INPUT, RESULT>) -> Boolean,
        inputClass: Class<INPUT>,
    ): AgentScopeBuilder<RESULT> =
        build(
            task = task,
            accept = acceptanceCriteria,
            resultClass = RESULT::class.java,
            inputClass = inputClass,
        )


    fun <INPUT, RESULT : Any> build(
        task: (RepeatUntilActionContext<INPUT, RESULT>) -> RESULT,
        accept: (RepeatUntilActionContext<INPUT, RESULT>) -> Boolean,
        resultClass: Class<RESULT>,
        inputClass: Class<out INPUT>,
    ): AgentScopeBuilder<RESULT> {

        fun findOrBindResultHistory(context: OperationContext): ResultHistory<RESULT> {
            return context.last<ResultHistory<RESULT>>()
                ?: run {
                    val resultHistory = ResultHistory<RESULT>()
                    context += resultHistory
                    logger.info("Bound new ResultHistory")
                    resultHistory
                }
        }

        val taskAction = TransformationAction(
            name = "=>${resultClass.name}",
            description = "Generate $resultClass",
            post = listOf(RESULT_WAS_BOUND_LAST_CONDITION, ACCEPTABLE_CONDITION),
            cost = 0.0,
            value = 0.0,
            pre = listOfNotNull(inputClass)
                .filterNot { it == Unit::class.java }
                .map { IoBinding(type = it).value },
            canRerun = true,
            outputClass = resultClass,
            inputClass = inputClass,
            toolGroups = emptySet(),
        ) { context ->
            val resultHistory = findOrBindResultHistory(context)

            @Suppress("UNCHECKED_CAST")
            val tac = RepeatUntilActionContext(
                input = context.input as INPUT,
                processContext = context.processContext,
                action = context.action,
                inputClass = inputClass as Class<INPUT>,
                outputClass = resultClass,
                history = resultHistory,
            )
            val result = task.invoke(tac)
            // Allow the evaluator to access the last result
            resultHistory.recordResult(result)
            logger.info(
                "Generated result {}: {}",
                resultHistory.attempts().size,
                result,
            )
            result
        }

        val resultWasBoundLastCondition = ComputedBooleanCondition(
            name = RESULT_WAS_BOUND_LAST_CONDITION,
            evaluator = { context, _ ->
                val result = context.lastResult()
                result != null && result::class.java == resultClass
            },
        )

        val acceptableCondition = ComputedBooleanCondition(
            name = ACCEPTABLE_CONDITION,
            evaluator = { context, _ ->
                val resultHistory = context.last<ResultHistory<RESULT>>()
                if (resultHistory?.lastAttempt() == null) {
                    false
                } else if (resultHistory.attempts().size >= maxIterations) {
                    logger.info(
                        "Condition '{}': Giving up after {} iterations",
                        ACCEPTABLE_CONDITION,
                        resultHistory.attempts().size,
                    )
                    true
                } else {
                    @Suppress("UNCHECKED_CAST")
                    val input: INPUT = if (inputClass != Unit::class.java) {
                        context.last(inputClass) as INPUT
                    } else {
                        Unit as INPUT
                    }
                    val tac = RepeatUntilActionContext<INPUT, RESULT>(
                        input = input,
                        outputClass = resultClass,
                        processContext = context.processContext,
                        action = taskAction,
                        inputClass = inputClass as? Class<INPUT> ?: Unit::class.java as Class<INPUT>,
                        history = resultHistory,
                    )
                    val isAcceptable = accept(tac)
                    logger.info(
                        "Condition '{}', iterations={}, acceptable={}",
                        ACCEPTABLE_CONDITION,
                        resultHistory.attempts().size,
                        isAcceptable,
                    )
                    isAcceptable
                }
            }
        )

        val consolidateAction: Action = TransformationAction(
            name = "consolidate-${resultClass.name}",
            description = "Consolidate results and feedback",
            pre = listOf(ACCEPTABLE_CONDITION, RESULT_WAS_BOUND_LAST_CONDITION),
            cost = 0.0,
            value = 0.0,
            toolGroups = emptySet(),
            inputClass = ResultHistory::class.java,
            outputClass = resultClass,
        ) { context ->
            val finalResult: RESULT = (context.input.lastAttempt() as? RESULT)
                ?: throw IllegalStateException("No result available in ResultHistory")
            logger.info("Consolidating results, final (best) result: {}", finalResult)
            finalResult
        }

        val resultGoal = Goal(
            "final-${resultClass.name}",
            "Satisfied with the final ${resultClass.name}",
            satisfiedBy = resultClass,
        ).withPreconditions(
            ACCEPTABLE_CONDITION,
            // TODO why is this needed? Should not the satisfiedBy condition be enough?
            RESULT_WAS_BOUND_LAST_CONDITION,
        )
        logger.info("Created goal: {}", resultGoal.infoString(verbose = true, indent = 2))

        return AgentScopeBuilder(
            name = MobyNameGenerator.generateName(),
            actions = listOf(
                taskAction,
                consolidateAction,
            ),
            conditions = setOf(acceptableCondition, resultWasBoundLastCondition),
            goals = setOf(resultGoal),
            opaque = true,
        )
    }

    private companion object {
        private val ACCEPTABLE_CONDITION = "${RepeatUntil::class.simpleName}_acceptable"
        private val RESULT_WAS_BOUND_LAST_CONDITION = "${RepeatUntil::class.simpleName}_resultWasBoundLast"
    }

}

data class RepeatUntilActionContext<INPUT, RESULT : Any>(
    override val input: INPUT,
    override val processContext: ProcessContext,
    override val action: Action,
    val inputClass: Class<INPUT>,
    val outputClass: Class<RESULT>,
    val history: ResultHistory<RESULT>,
) : InputActionContext<INPUT?>, Blackboard by processContext.agentProcess,
    AgenticEventListener by processContext {

    override val toolGroups: Set<ToolGroupRequirement>
        get() = action.toolGroups

    override val operation = action

    /**
     * Get the last attempt result if available.
     */
    fun lastAttempt(): RESULT? = history.lastAttempt()
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/workflow/loop/RepeatUntilAcceptable.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.workflow.loop

import com.embabel.agent.api.common.InputActionContext
import com.embabel.agent.api.common.OperationContext
import com.embabel.agent.api.common.support.TransformationAction
import com.embabel.agent.api.dsl.AgentScopeBuilder
import com.embabel.agent.core.*
import com.embabel.agent.event.AgenticEventListener
import com.embabel.common.core.MobyNameGenerator
import com.embabel.common.core.types.Timed
import com.embabel.common.core.types.Timestamped
import com.embabel.common.core.types.ZeroToOne
import org.slf4j.LoggerFactory
import java.time.Duration
import java.time.Instant

data class Attempt<RESULT : Any, FEEDBACK : Feedback>(
    val result: RESULT,
    val feedback: FEEDBACK,
) : Timestamped {

    override val timestamp: Instant = Instant.now()
}

/**
 * Mutable object. We only bind this once
 */
data class AttemptHistory<INPUT, RESULT : Any, FEEDBACK : Feedback>(
    val input: INPUT,
    private val _attempts: MutableList<Attempt<RESULT, FEEDBACK>> = mutableListOf(),
    private var lastResult: RESULT? = null,
    override val timestamp: Instant = Instant.now(),
) : Timestamped, Timed {

    fun attemptCount(): Int = _attempts.size

    override val runningTime: Duration
        get() = Duration.between(timestamp, Instant.now())

    fun attempts(): List<Attempt<RESULT, FEEDBACK>> = _attempts.toList()

    fun lastAttempt(): Attempt<RESULT, FEEDBACK>? = _attempts.lastOrNull()

    /**
     * Evaluator can use this to access the last result.
     */
    fun resultToEvaluate(): RESULT? = lastResult

    fun lastFeedback(): FEEDBACK? = lastAttempt()?.feedback

    fun bestSoFar(): Attempt<RESULT, FEEDBACK>? = _attempts.maxByOrNull { it.feedback.score }

    internal fun recordResult(
        result: RESULT,
    ) {
        lastResult = result
    }

    internal fun recordAttempt(
        result: RESULT,
        feedback: FEEDBACK,
    ): Attempt<RESULT, FEEDBACK> {
        val attempt = Attempt(result, feedback)
        _attempts.add(attempt)
        return attempt
    }

}


/**
 * Primitive for building repeat until acceptable workflows.
 * See https://www.anthropic.com/engineering/building-effective-agents
 * This is the Evaluator Optimizer pattern
 */
data class RepeatUntilAcceptable(
    val maxIterations: Int = 3,
    val scoreThreshold: ZeroToOne = 0.9,
) {

    private val logger = LoggerFactory.getLogger(javaClass)

    inline fun <reified INPUT, reified RESULT : Any, reified FEEDBACK : Feedback> build(
        noinline task: (RepeatUntilAcceptableActionContext<INPUT, RESULT, FEEDBACK>) -> RESULT,
        noinline evaluator: (EvaluationActionContext<INPUT, RESULT, FEEDBACK>) -> FEEDBACK,
        noinline acceptanceCriteria: (AcceptanceActionContext<INPUT, RESULT, FEEDBACK>) -> Boolean = { it.feedback.score >= scoreThreshold },
        inputClass: Class<INPUT>,
    ): AgentScopeBuilder<RESULT> =
        build(
            task = task,
            evaluator = evaluator,
            acceptanceCriteria = acceptanceCriteria,
            resultClass = RESULT::class.java,
            feedbackClass = FEEDBACK::class.java,
            inputClass = inputClass,
        )


    fun <INPUT, RESULT : Any, FEEDBACK : Feedback> build(
        task: (RepeatUntilAcceptableActionContext<INPUT, RESULT, FEEDBACK>) -> RESULT,
        evaluator: (EvaluationActionContext<INPUT, RESULT, FEEDBACK>) -> FEEDBACK,
        acceptanceCriteria: (AcceptanceActionContext<INPUT, RESULT, FEEDBACK>) -> Boolean,
        resultClass: Class<RESULT>,
        feedbackClass: Class<FEEDBACK>,
        inputClass: Class<out INPUT>,
    ): AgentScopeBuilder<RESULT> {

        fun findOrBindAttemptHistory(
            context: OperationContext,
            input: INPUT,
        ): AttemptHistory<INPUT, RESULT, FEEDBACK> {
            return context.last<AttemptHistory<INPUT, RESULT, FEEDBACK>>()
                ?: run {
                    val ah = AttemptHistory<INPUT, RESULT, FEEDBACK>(input = input)
                    context += ah
                    logger.info("Bound new AttemptHistory")
                    ah
                }
        }

        val taskAction = TransformationAction(
            name = "=>${resultClass.name}",
            description = "Generate $resultClass",
            post = listOf(RESULT_WAS_BOUND_LAST_CONDITION),
            cost = 0.0,
            value = 0.0,
            pre = listOfNotNull(inputClass)
                .filterNot { it == Unit::class.java }
                .map { com.embabel.agent.core.IoBinding(type = it).value },
            canRerun = true,
            inputClass = inputClass,
            outputClass = resultClass,
            toolGroups = emptySet(),
        ) { context ->
            @Suppress("UNCHECKED_CAST")
            val input = context.input as INPUT
            val attemptHistory = findOrBindAttemptHistory(context, input)

            val tac = RepeatUntilAcceptableActionContext(
                input = input,
                processContext = context.processContext,
                action = context.action,
                inputClass = inputClass as Class<INPUT>,
                outputClass = resultClass,
                attemptHistory = attemptHistory,
            )
            val result = task.invoke(tac)
            // Allow the evaluator to access the last result
            attemptHistory.recordResult(result)
            logger.info(
                "Generated result {}: {}",
                attemptHistory.attempts().size + 1,
                result,
            )
            result
        }

        val evaluationAction = TransformationAction(
            name = "${resultClass.name}=>${feedbackClass.name}",
            description = "Evaluate $resultClass to $feedbackClass",
            pre = listOf(RESULT_WAS_BOUND_LAST_CONDITION),
            post = listOf(ACCEPTABLE_CONDITION),
            cost = 0.0,
            value = 0.0,
            canRerun = true,
            inputClass = resultClass,
            outputClass = feedbackClass,
            toolGroups = emptySet(),
        ) { context ->
            // AttemptHistory was already bound by taskAction, so we retrieve it
            val attemptHistory = context.last<AttemptHistory<INPUT, RESULT, FEEDBACK>>()
                ?: error("AttemptHistory should have been bound by task action")

            @Suppress("UNCHECKED_CAST")
            val tac = EvaluationActionContext(
                input = attemptHistory.input,
                processContext = context.processContext,
                action = context.action,
                inputClass = inputClass as Class<INPUT>,
                outputClass = feedbackClass,
                attemptHistory = attemptHistory,
            )
            val feedback = evaluator(tac)
            val bestSoFar = attemptHistory.bestSoFar()
            if (bestSoFar == null) {
                logger.info(
                    "First feedback computed: {}",
                    feedback,
                )
            } else if (feedback.score > bestSoFar.feedback.score) {
                logger.info(
                    "New best feedback computed: {} (previously {})",
                    feedback,
                    bestSoFar,
                )
            } else {
                logger.info("Not better than we've seen: Feedback is {}", feedback)
            }
            attemptHistory.recordAttempt(context.input, feedback)
            logger.info("Recorded attempt: {} with feedback: {}", context.input, feedback)
            feedback
        }

        val resultWasBoundLastCondition = ComputedBooleanCondition(
            name = RESULT_WAS_BOUND_LAST_CONDITION,
            evaluator = { context, _ ->
                val result = context.lastResult()
                result != null && result::class.java == resultClass
            },
        )

        val acceptableCondition = ComputedBooleanCondition(
            name = ACCEPTABLE_CONDITION,
            evaluator = { context, action ->
                val attemptHistory = context.last<AttemptHistory<INPUT, RESULT, FEEDBACK>>()
                if (attemptHistory?.lastAttempt() == null) {
                    false
                } else if (attemptHistory.attempts().size >= maxIterations) {
                    logger.info(
                        "Condition '{}': Giving up after {} iterations",
                        ACCEPTABLE_CONDITION,
                        attemptHistory.attempts().size,
                    )
                    true
                } else {
                    val lastFeedback = attemptHistory.lastAttempt()!!.feedback
                    val acceptanceContext = AcceptanceActionContext(
                        input = attemptHistory.input,
                        attemptHistory = attemptHistory,
                        feedback = lastFeedback,
                    )
                    val isAcceptable = acceptanceCriteria(acceptanceContext)
                    logger.info(
                        "Condition '{}', iterations={}: Feedback acceptable={}: {}",
                        ACCEPTABLE_CONDITION,
                        attemptHistory.attempts().size,
                        isAcceptable,
                        lastFeedback,
                    )
                    isAcceptable
                }
            }
        )

        val consolidateAction: Action = TransformationAction(
            name = "consolidate-${resultClass.name}-${feedbackClass.name}",
            description = "Consolidate results and feedback",
            pre = listOf(ACCEPTABLE_CONDITION),
            cost = 0.0,
            value = 0.0,
            toolGroups = emptySet(),
            inputClass = AttemptHistory::class.java,
            outputClass = resultClass,
        ) { context ->
            val bestResult = context.input.bestSoFar()?.result as? RESULT
                ?: throw IllegalStateException("No result available in AttemptHistory")
            logger.info("Consolidating results, final (best) result: {}", bestResult)
            bestResult
        }

        val resultGoal = Goal(
            "final-${resultClass.name}",
            "Satisfied with the final ${resultClass.name}",
            satisfiedBy = resultClass,
        ).withPreconditions(
            ACCEPTABLE_CONDITION,
            // TODO why is this needed? Should not the satisfiedBy condition be enough?
            RESULT_WAS_BOUND_LAST_CONDITION,
        )
        logger.info("Created goal: {}", resultGoal.infoString(verbose = true, indent = 2))

        return AgentScopeBuilder(
            name = MobyNameGenerator.generateName(),
            actions = listOf(
                taskAction,
                evaluationAction,
                consolidateAction,
            ),
            conditions = setOf(acceptableCondition, resultWasBoundLastCondition),
            goals = setOf(resultGoal),
            opaque = true,
        )
    }

    private companion object {
        private val ACCEPTABLE_CONDITION = "${RepeatUntilAcceptable::class.simpleName}_acceptable"
        private val RESULT_WAS_BOUND_LAST_CONDITION = "${RepeatUntilAcceptable::class.simpleName}_resultWasBoundLast"
    }

}

abstract class RepeatUntilAcceptableContext<INPUT, RESULT : Any, FEEDBACK : Feedback>(
    override val input: INPUT,
    override val processContext: ProcessContext,
    override val action: Action,
    val inputClass: Class<INPUT>,
    val outputClass: Class<*>,
    val attemptHistory: AttemptHistory<INPUT, RESULT, FEEDBACK>,
) : InputActionContext<INPUT?>, Blackboard by processContext.agentProcess,
    AgenticEventListener by processContext {

    /**
     * Get the last attempt if available.
     */
    fun lastAttempt(): Attempt<RESULT, FEEDBACK>? = attemptHistory.lastAttempt()

    /**
     * Convenience method to get result from last attempt or return default
     * Easy to embed in prompts
     */
    fun lastAttemptOr(defaultValue: String): String {
        return lastAttempt()?.result?.toString() ?: defaultValue
    }

    /**
     * Convenience method to get feedback from last attempt or return default
     */
    fun lastFeedbackOr(defaultValue: String): String {
        return lastAttempt()?.feedback?.toString() ?: defaultValue
    }

    override val toolGroups: Set<ToolGroupRequirement>
        get() = action.toolGroups

    override val operation = action

}

open class RepeatUntilAcceptableActionContext<INPUT, RESULT : Any, FEEDBACK : Feedback>(
    input: INPUT,
    processContext: ProcessContext,
    action: Action,
    inputClass: Class<INPUT>,
    outputClass: Class<*>,
    attemptHistory: AttemptHistory<INPUT, RESULT, FEEDBACK>,
) : RepeatUntilAcceptableContext<INPUT, RESULT, FEEDBACK>(
    input = input,
    processContext = processContext,
    action = action,
    inputClass = inputClass,
    outputClass = outputClass,
    attemptHistory = attemptHistory,
)


open class EvaluationActionContext<INPUT, RESULT : Any, FEEDBACK : Feedback>(
    input: INPUT,
    processContext: ProcessContext,
    action: Action,
    inputClass: Class<INPUT>,
    outputClass: Class<*>,
    attemptHistory: AttemptHistory<INPUT, RESULT, FEEDBACK>,
) : RepeatUntilAcceptableContext<INPUT, RESULT, FEEDBACK>(
    input = input,
    processContext = processContext,
    action = action,
    inputClass = inputClass,
    outputClass = outputClass,
    attemptHistory = attemptHistory,
) {
    val resultToEvaluate: RESULT = attemptHistory.resultToEvaluate() ?: error("No result available in AttemptHistory")

}


data class AcceptanceActionContext<INPUT, RESULT : Any, FEEDBACK : Feedback>(
    val input: INPUT,
    val attemptHistory: AttemptHistory<INPUT, RESULT, FEEDBACK>,
    val feedback: FEEDBACK,
) {
    /**
     * Get the last attempt if available.
     */
    fun lastAttempt(): Attempt<RESULT, FEEDBACK>? = attemptHistory.lastAttempt()
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/workflow/loop/RepeatUntilAcceptableBuilder.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.workflow.loop

import com.embabel.agent.api.common.workflow.WorkflowBuilder
import com.embabel.agent.api.common.workflow.WorkflowBuilderConsuming
import com.embabel.agent.api.common.workflow.WorkflowBuilderReturning
import com.embabel.agent.api.dsl.AgentScopeBuilder

/**
 * Java friendly builder for RepeatUntilAcceptable workflow.
 */
data class RepeatUntilAcceptableBuilder<INPUT, RESULT : Any, FEEDBACK : Feedback>(
    private val resultClass: Class<RESULT>,
    private val inputClass: Class<out INPUT>,
    private val feedbackClass: Class<FEEDBACK> = Feedback::class.java as Class<FEEDBACK>,
    private val maxIterations: Int = DEFAULT_MAX_ITERATIONS,
    private val scoreThreshold: Double = DEFAULT_SCORE_THRESHOLD,
) : WorkflowBuilderConsuming {

    companion object : WorkflowBuilderReturning {

        const val DEFAULT_MAX_ITERATIONS = 5

        const val DEFAULT_SCORE_THRESHOLD = 0.9

        /**
         * Create a RepeatUntilBuilder for a specific result type and default TextFeedback.
         */
        @JvmStatic
        override fun <RESULT : Any> returning(resultClass: Class<RESULT>): RepeatUntilAcceptableBuilder<Any?, RESULT, TextFeedback> {
            return RepeatUntilAcceptableBuilder(
                resultClass = resultClass,
                inputClass = Unit::class.java,
                feedbackClass = TextFeedback::class.java
            )
        }
    }

    override fun <INPUT : Any> consuming(inputClass: Class<INPUT>): RepeatUntilAcceptableBuilder<INPUT, RESULT, FEEDBACK> {
        return RepeatUntilAcceptableBuilder(
            resultClass = resultClass,
            inputClass = inputClass,
            feedbackClass = feedbackClass,
            maxIterations = maxIterations,
            scoreThreshold = scoreThreshold,
        )
    }

    /**
     * Customize the feedback class for this RepeatUntil workflow.
     */
    fun <F : Feedback> withFeedbackClass(feedbackClass: Class<F>): RepeatUntilAcceptableBuilder<INPUT, RESULT, F> =
        RepeatUntilAcceptableBuilder(
            resultClass = resultClass,
            inputClass = inputClass,
            feedbackClass = feedbackClass,
            maxIterations = maxIterations,
            scoreThreshold = scoreThreshold,
        )

    fun withMaxIterations(maxIterations: Int): RepeatUntilAcceptableBuilder<INPUT, RESULT, FEEDBACK> =
        copy(maxIterations = maxIterations)

    fun withScoreThreshold(scoreThreshold: Double): RepeatUntilAcceptableBuilder<INPUT, RESULT, FEEDBACK> =
        copy(scoreThreshold = scoreThreshold)

    /**
     * Define the task to be repeated until an acceptable result is achieved.
     */
    fun repeating(
        what: (RepeatUntilAcceptableActionContext<INPUT, RESULT, FEEDBACK>) -> RESULT,
    ): Critiquer {
        return Critiquer(generator = what)
    }

    inner class Critiquer(
        private val generator: (RepeatUntilAcceptableActionContext<INPUT, RESULT, FEEDBACK>) -> RESULT,
    ) {

        /**
         * Provide the evaluation function that will assess the generated results.
         */
        fun withEvaluator(
            evaluator: (EvaluationActionContext<INPUT, RESULT, FEEDBACK>) -> FEEDBACK,
        ): Evaluator {
            return Evaluator(generator = generator, evaluator = evaluator)
        }

    }

    inner class Evaluator(
        private val generator: (RepeatUntilAcceptableActionContext<INPUT, RESULT, FEEDBACK>) -> RESULT,
        private val evaluator: (EvaluationActionContext<INPUT, RESULT, FEEDBACK>) -> FEEDBACK,
    ) : WorkflowBuilder<RESULT>(resultClass = resultClass, inputClass = inputClass) {

        /**
         * Define the acceptance criteria for the feedback.
         * This will determine when the generated result is considered acceptable.
         */
        fun withAcceptanceCriteria(
            accept: (AcceptanceActionContext<INPUT, RESULT, FEEDBACK>) -> Boolean,
        ): Emitter {
            return Emitter(generator, evaluator, accept)
        }

        /**
         * Build an instance with default acceptance criteria,
         * based on threshold score
         */
        override fun build(): AgentScopeBuilder<RESULT> {
            return withAcceptanceCriteria { it.feedback.score >= scoreThreshold }
                .build()
        }
    }

    inner class Emitter(
        private val generator: (RepeatUntilAcceptableActionContext<INPUT, RESULT, FEEDBACK>) -> RESULT,
        private val evaluator: (EvaluationActionContext<INPUT, RESULT, FEEDBACK>) -> FEEDBACK,
        private val accept: (AcceptanceActionContext<INPUT, RESULT, FEEDBACK>) -> Boolean,
    ) : WorkflowBuilder<RESULT>(resultClass = resultClass, inputClass = inputClass) {

        /**
         * Build the workflow so it can be included in agents
         */
        override fun build(): AgentScopeBuilder<RESULT> {
            return RepeatUntilAcceptable(maxIterations = maxIterations, scoreThreshold = scoreThreshold)
                .build(
                    task = generator,
                    evaluator = evaluator,
                    acceptanceCriteria = accept,
                    resultClass = resultClass,
                    feedbackClass = feedbackClass,
                    inputClass = inputClass,
                )
        }

    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/workflow/loop/RepeatUntilBuilder.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.workflow.loop

import com.embabel.agent.api.common.workflow.WorkflowBuilder
import com.embabel.agent.api.common.workflow.WorkflowBuilderConsuming
import com.embabel.agent.api.common.workflow.WorkflowBuilderReturning
import com.embabel.agent.api.dsl.AgentScopeBuilder

/**
 * Java friendly builder for RepeatUntil workflow.
 */
data class RepeatUntilBuilder<INPUT, RESULT : Any>(
    private val resultClass: Class<RESULT>,
    private val inputClass: Class<out INPUT>,
    private val maxIterations: Int = DEFAULT_MAX_ITERATIONS,
) : WorkflowBuilderConsuming {

    companion object : WorkflowBuilderReturning {

        const val DEFAULT_MAX_ITERATIONS = 5

        /**
         * Create a RepeatUntilBuilder for a specific result type and default TextFeedback.
         */
        @JvmStatic
        override fun <RESULT : Any> returning(resultClass: Class<RESULT>): RepeatUntilBuilder<Any?, RESULT> {
            return RepeatUntilBuilder(resultClass = resultClass, inputClass = Unit::class.java)
        }
    }

    override fun <INPUT : Any> consuming(inputClass: Class<INPUT>): RepeatUntilBuilder<INPUT, RESULT> {
        return RepeatUntilBuilder(
            resultClass = resultClass,
            inputClass = inputClass,
            maxIterations = maxIterations,
        )
    }

    fun withMaxIterations(maxIterations: Int): RepeatUntilBuilder<INPUT, RESULT> =
        copy(maxIterations = maxIterations)

    /**
     * Define the task to be repeated until an acceptable result is achieved.
     */
    fun repeating(
        what: (RepeatUntilActionContext<INPUT, RESULT>) -> RESULT,
    ): Looper {
        return Looper(generator = what)
    }

    inner class Looper(
        private val generator: (RepeatUntilActionContext<INPUT, RESULT>) -> RESULT,
    ) {

        /**
         * Define the acceptance criteria for the feedback.
         * This will determine when the generated result is considered acceptable.
         */
        fun until(
            accept: (RepeatUntilActionContext<INPUT, RESULT>) -> Boolean,
        ): Emitter {
            return Emitter(generator, accept)
        }
    }

    inner class Emitter(
        private val generator: (RepeatUntilActionContext<INPUT, RESULT>) -> RESULT,
        private val accept: (RepeatUntilActionContext<INPUT, RESULT>) -> Boolean,
    ) : WorkflowBuilder<RESULT>(resultClass, inputClass) {

        /**
         * Build the workflow so it can be included in agents
         */
        override fun build(): AgentScopeBuilder<RESULT> {
            return RepeatUntil(maxIterations = maxIterations)
                .build(
                    task = generator,
                    accept = accept,
                    resultClass = resultClass,
                    inputClass = inputClass,
                )
        }

    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/common/workflow/multimodel/ConsensusBuilder.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.workflow.multimodel

import com.embabel.agent.api.common.SupplierActionContext
import com.embabel.agent.api.common.TransformationActionContext
import com.embabel.agent.api.common.workflow.WorkflowBuilder
import com.embabel.agent.api.common.workflow.WorkflowBuilderReturning
import com.embabel.agent.api.common.workflow.control.ResultList
import com.embabel.agent.api.common.workflow.control.ScatterGather
import com.embabel.agent.api.dsl.AgentScopeBuilder
import java.util.function.Supplier

/**
 * Builder for creating a consensus workflow that generates results from multiple generators
 * Generators and consensus function are typically used in multi-model scenarios,
 * but need not use an LLM at all.
 */
class ConsensusBuilder<RESULT : Any>(
    private val resultClass: Class<RESULT>,
    private val maxConcurrency: Int = DEFAULT_MAX_CONCURRENCY,
) {

    companion object : WorkflowBuilderReturning {

        const val DEFAULT_MAX_CONCURRENCY = 6

        @JvmStatic
        override fun <RESULT : Any> returning(resultClass: Class<RESULT>): ConsensusBuilder<RESULT> {
            return ConsensusBuilder(resultClass)
        }

    }

    fun withSources(
        generators: List<java.util.function.Function<out SupplierActionContext<RESULT>, RESULT>>,
    ): Generators {
        return Generators(
            generators = generators,
        )
    }

    // We avoid method overloading because it's evil
    fun sourcedFrom(
        generators: List<Supplier<RESULT>>,
    ): Generators {
        return Generators(
            generators = generators.map { generator ->
                java.util.function.Function<SupplierActionContext<RESULT>, RESULT> { context ->
                    generator.get()
                }
            },
        )
    }

    inner class Generators(
        private val generators: List<java.util.function.Function<out SupplierActionContext<RESULT>, RESULT>>,
    ) {

        fun withConsensusBy(
            consensusFunction: (TransformationActionContext<ResultList<RESULT>, RESULT>) -> RESULT,
        ): ConsensusSpec {
            return ConsensusSpec(generators, consensusFunction)
        }

    }

    inner class ConsensusSpec(
        private val generators: List<java.util.function.Function<out SupplierActionContext<RESULT>, RESULT>>,
        private val consensusFunction: (TransformationActionContext<ResultList<RESULT>, RESULT>) -> RESULT,
    ) : WorkflowBuilder<RESULT>(resultClass, inputClass = null) {

        override fun build(): AgentScopeBuilder<RESULT> {
            return ScatterGather(maxConcurrency = maxConcurrency)
                .forkJoin(
                    generators = generators.map { it::apply } as List<(SupplierActionContext<RESULT>) -> RESULT>,
                    joinFunction = consensusFunction,
                    elementClass = resultClass,
                    resultClass = resultClass,
                )
        }
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/dsl/README.md
================================================
# Kotlin DSL for writing agents


================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/dsl/agent.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.dsl

import com.embabel.agent.core.Agent
import com.embabel.common.ai.prompt.PromptContributor
import com.embabel.common.core.types.Semver

/**
 * Surface area of DSL for creating an agent.
 * @param name The name of the agent.
 */
fun agent(
    name: String,
    provider: String = "embabel",
    version: Semver = Semver(),
    description: String,
    promptContributors: List<PromptContributor> = emptyList(),
    block: AgentBuilder.() -> Unit,
): Agent {
    return AgentBuilder(
        name = name,
        provider = provider,
        version = version,
        description = description,
        promptContributors = promptContributors,
    )
        .apply(block)
        .build()
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/dsl/AgentBuilder.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.dsl

import com.embabel.agent.api.common.OperationContext
import com.embabel.agent.api.common.Transformation
import com.embabel.agent.api.common.TransformationActionContext
import com.embabel.agent.api.common.asAction
import com.embabel.agent.api.common.support.TransformationAction
import com.embabel.agent.api.dsl.support.promptTransformer
import com.embabel.agent.core.*
import com.embabel.agent.experimental.primitive.PromptCondition
import com.embabel.agent.spi.LlmCall
import com.embabel.common.ai.model.LlmOptions
import com.embabel.common.ai.prompt.PromptContributor
import com.embabel.common.ai.prompt.PromptContributorConsumer
import com.embabel.common.core.types.Semver
import com.embabel.common.core.types.ZeroToOne
import com.embabel.plan.goap.ConditionDetermination
import org.slf4j.LoggerFactory
import org.springframework.ai.tool.ToolCallback
import kotlin.reflect.KClass
import kotlin.reflect.KProperty


typealias ConditionPredicate = (
    context: OperationContext,
) -> Boolean?

/**
 * Instances of this are usually created via the convenient agent() function.
 */
class AgentBuilder(
    val name: String,
    val provider: String = "embabel",
    val version: Semver = Semver(),
    val description: String,
    promptContributors: List<PromptContributor> = emptyList(),
) : PromptContributorConsumer {

    private val logger = LoggerFactory.getLogger(AgentBuilder::class.java)

    // Needs to be public for inline functions to work
    val actions = mutableListOf<Action>()

    private val goals = mutableSetOf<Goal>()

    private val conditions = mutableSetOf<Condition>()

    private val _promptContributors = promptContributors.toMutableList()

    override val promptContributors: List<PromptContributor>
        get() = _promptContributors

    /**
     * Create an action
     */
    fun action(block: AgentBuilder.() -> Action) {
        actions.add(block())
    }

    /**
     * Require prompt contributors at agent level
     */
    fun registerPromptContributors(vararg promptContributors: PromptContributor) {
        _promptContributors += promptContributors
    }

    /**
     * Add an action is an anonymous agent. This is valuable because the
     * agent will be private and will not pollute the global action space.
     */
    inline fun <reified I, reified O : Any> localAgentAction(agent: Agent) {
        val aa = agent.asAction<I, O>()
        actions.add(aa)
    }

    /**
     * Add an action that references the agent with a given name
     */
    inline fun <reified I, reified O : Any> referencedAgentAction(agentName: String) {
        val aa = asAction<I, O>(agentName)
        actions.add(aa)
    }

    fun add(agentScope: AgentScope) {
        actions += agentScope.actions
        goals += agentScope.goals
        conditions += agentScope.conditions
    }

    /**
     * Add a pattern builder, such as an aggregation flow, to the agent.
     * Must be used if you have multiple actions
     */
    fun flow(block: AgentBuilder.() -> AgentScopeBuilder<*>) {
        val agentScope = block().build()
        logger.info(
            "Adding actions from agent scope {}: {}",
            agentScope.name,
            agentScope.actions,
        )
        add(agentScope)
    }

    /**
     * Add an action that is a transformation NOT using an LLM.
     */
    inline fun <reified I, reified O : Any> transformation(
        name: String = "${I::class.simpleName}-${O::class.simpleName}",
        description: String = name,
        preConditions: List<Condition> = emptyList(),
        pre: List<String> = emptyList(),
        post: List<Condition> = emptyList(),
        canRerun: Boolean = false,
        inputVarName: String = IoBinding.DEFAULT_BINDING,
        outputVarName: String? = IoBinding.DEFAULT_BINDING,
        cost: ZeroToOne = 0.0,
        toolGroups: Set<ToolGroupRequirement> = emptySet(),
        qos: ActionQos = ActionQos(),
        referencedInputProperties: Set<String>? = null,
        block: Transformation<I, O>,
    ) {
        val action = TransformationAction(
            name = name,
            description = description,
            pre = pre + preConditions.map { it.name },
            post = post.map { it.name },
            canRerun = canRerun,
            cost = cost,
            qos = qos,
            inputVarName = inputVarName,
            outputVarName = outputVarName,
            inputClass = I::class.java,
            outputClass = O::class.java,
            referencedInputProperties = referencedInputProperties,
            toolGroups = toolGroups,
            block = block,
        )
        actions.add(action)
    }

    /**
     * Add an action that is a transformation using an LLM.
     */
    inline fun <reified I, reified O : Any> promptedTransformer(
        name: String,
        description: String = name,
        pre: List<Condition> = emptyList(),
        post: List<Condition> = emptyList(),
        inputVarName: String = IoBinding.DEFAULT_BINDING,
        outputVarName: String = IoBinding.DEFAULT_BINDING,
        cost: ZeroToOne = 0.0,
        toolGroups: Set<ToolGroupRequirement> = emptySet(),
        qos: ActionQos = ActionQos(),
        referencedInputProperties: Set<String>? = null,
        llm: LlmOptions = LlmOptions(),
        promptContributors: List<PromptContributor> = emptyList(),
        canRerun: Boolean = false,
        toolCallbacks: Collection<ToolCallback> = emptyList(),
        noinline prompt: (actionContext: TransformationActionContext<I, O>) -> String,
    ) {
        val action = promptTransformer(
            name = name,
            description = description,
            pre = pre,
            post = post,
            inputVarName = inputVarName,
            outputVarName = outputVarName,
            cost = cost,
            toolGroups = toolGroups,
            qos = qos,
            referencedInputProperties = referencedInputProperties,
            llm = llm,
            canRerun = canRerun,
            toolCallbacks = toolCallbacks,
            prompt = prompt,
            promptContributors = this.promptContributors + promptContributors,
            inputClass = I::class.java,
            outputClass = O::class.java,
        )
        actions.add(action)
    }

    /**
     * Add a goal to the agent.
     * @param name The name of the goal.
     * @param description A description of the goal. Should be informative,
     * to allow the platform to choose a goal based on user input.
     * @param satisfiedBy A class that satisfies this goal.
     * @param requires A set of classes that are required to satisfy this goal.
     * @param pre custom preconditions, in addition to input preconditions
     * @param value the value of achieving this goal
     */
    fun goal(
        name: String,
        description: String,
        satisfiedBy: KClass<*>? = null,
        requires: Set<KClass<*>> = if (satisfiedBy != null) {
            setOf(satisfiedBy)
        } else {
            emptySet()
        },
        inputs: Set<IoBinding> = requires.map {
            IoBinding(
//                name = it.simpleName,
                type = it,
            )
        }.toSet(),
        pre: List<Condition> = emptyList(),
        value: ZeroToOne = 0.0,
        export: Export = Export(),
    ) {
        // TODO check validity
        goals.add(
            Goal(
                name = name,
                description = description,
                inputs = inputs,
                outputType = satisfiedBy?.java?.let { javaClass -> JvmType(javaClass) },
                pre = pre.map { it.name }.toSet(),
                value = value,
                export = export,
            )
        )
    }

    fun condition(block: AgentBuilder.() -> Condition) {
        conditions.add(block())
    }

    class ConditionDelegateProvider(
        private val specifiedName: String? = null,
        private val factory: (name: String) -> Condition,
        private val conditions: MutableSet<Condition>,
    ) {
        operator fun provideDelegate(
            thisRef: Any?,
            prop: KProperty<*>,
        ): ConditionDelegate {
            val condition = factory(specifiedName ?: prop.name)
            conditions.add(condition) // Store the condition
            return ConditionDelegate(condition)
        }
    }

    class ConditionDelegate(
        private val condition: Condition,
    ) {
        operator fun getValue(
            thisRef: Any?,
            property: KProperty<*>,
        ): Condition = condition
    }

    fun conditionOf(
        name: String? = null,
        cost: ZeroToOne = 0.0,
        block: ConditionPredicate,
    ): ConditionDelegateProvider {
        return ConditionDelegateProvider(
            name,
            {
                val condition = object : Condition {
                    override val name = it
                    override val cost = cost
                    override fun evaluate(context: OperationContext): ConditionDetermination =
                        ConditionDetermination(
                            block(
                                context
                            )
                        )
                }
                condition
            },
            this.conditions
        )
    }

    /**
     * Declare a condition determined with an LLM. Assign it a name to ensure
     * type safe access
     * val myCondition = condition("custom prompt")
     */
    fun promptedCondition(
        name: String? = null,
        prompt: (context: OperationContext) -> String,
        llm: LlmCall = LlmCall(),
    ): ConditionDelegateProvider {
        return ConditionDelegateProvider(
            specifiedName = name,
            factory = {
                PromptCondition(
                    name = it,
                    prompt = prompt,
                    llm = llm,
                )
            },
            conditions = this.conditions,
        )
    }

    /**
     * Build the agent
     */
    fun build(): Agent {
        return Agent(
            name = name,
            provider = provider,
            version = version,
            description = description,
            conditions = conditions,
            actions = actions,
            goals = goals,
        )
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/dsl/AgentScopeBuilder.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.dsl


import com.embabel.agent.api.common.*
import com.embabel.agent.api.common.support.*
import com.embabel.agent.core.*
import com.embabel.agent.core.support.Rerun
import com.embabel.common.core.MobyNameGenerator
import com.embabel.common.util.loggerFor
import java.util.function.Function as JavaFunction

inline fun <reified A, reified B : Any> doSplit(
    noinline splitter: (InputActionContext<A>) -> List<B>,
): AgentScopeBuilder<Unit> = doSplit(
    splitter = splitter,
    aClass = A::class.java,
    bClass = B::class.java,
)

fun <A, B : Any> doSplit(
    splitter: (InputActionContext<A>) -> List<B>,
    aClass: Class<A>,
    bClass: Class<B>,
): AgentScopeBuilder<Unit> {
    val a = ConsumerAction(
        name = "${aClass.name}-<=${bClass.name}",
        description = "${aClass.name}-<=${bClass.name}",
        pre = emptyList(),
        post = emptyList(),
        cost = 0.0,
        value = 0.0,
        canRerun = true,
        inputClass = aClass,
        toolGroups = emptySet(),
    ) {
        val list = splitter(it)
        it.addAll(list)
    }
    return AgentScopeBuilder(
        name = a.name,
        actions = listOf(a),
    )
}

inline fun <reified A, reified B : Any> split(
    noinline splitter: (a: A) -> List<B>,
): AgentScopeBuilder<Unit> = doSplit({ splitter(it.input) }, A::class.java, B::class.java)

inline infix fun <reified A, reified B, reified C> ((A) -> B).andThenDo(
    crossinline that: (InputActionContext<B>) -> C,
): AgentScopeBuilder<C> {
    val javaFunction1 = JavaFunction<InputActionContext<A>, B> { ctx -> this(ctx.input) }
    val javaFunction2 = JavaFunction<InputActionContext<B>, C> { ctx -> that(ctx) }

    return chain(
        { javaFunction1.apply(it) },
        { javaFunction2.apply(it) },
        A::class.java,
        B::class.java,
        C::class.java
    )
}

inline infix fun <reified A, reified B, reified C> ((A) -> B).andThen(
    crossinline that: (B) -> C,
): AgentScopeBuilder<C> {
    val javaFunction1 = JavaFunction<InputActionContext<A>, B> { ctx -> this(ctx.input) }
    val javaFunction2 = JavaFunction<InputActionContext<B>, C> { ctx -> that(ctx.input) }

    return chain(
        { javaFunction1.apply(it) },
        { javaFunction2.apply(it) },
        A::class.java,
        B::class.java,
        C::class.java
    )
}


inline fun <reified A, reified B, reified C> JavaFunction<InputActionContext<A>, B>.javaAndThen(
    that: JavaFunction<InputActionContext<B>, C>,
): AgentScopeBuilder<C> {
    return chain({ this.apply(it) }, { that.apply(it) }, A::class.java, B::class.java, C::class.java)
}

inline fun <reified A, reified B, reified C> JavaFunction<A, B>.andThen(
    that: JavaFunction<InputActionContext<B>, C>,
): AgentScopeBuilder<C> {
    return chain({ this.apply(it.input) }, { that.apply(it) }, A::class.java, B::class.java, C::class.java)
}

fun <A, B, C> JavaFunction<InputActionContext<A>, B>.andThen(
    that: JavaFunction<InputActionContext<B>, C>,
    aClass: Class<A>,
    bClass: Class<B>,
    cClass: Class<C>,
): AgentScopeBuilder<C> {
    return chain({ this.apply(it) }, { that.apply(it) }, aClass, bClass, cClass)
}

/**
 * Creates a chain from A to B via C. Emits actions.
 */
fun <A, B, C> chain(
    a: (context: InputActionContext<A>) -> B,
    b: (context: InputActionContext<B>) -> C,
    aClass: Class<A>,
    bClass: Class<B>,
    cClass: Class<C>,
): AgentScopeBuilder<C> {
    val actions: List<Action> = listOf(
        TransformationAction(
            name = "chain-0",
            description = "chain element 0",
            cost = 0.0,
            value = 0.0,
            canRerun = false,
            inputClass = aClass,
            outputClass = bClass,
            toolGroups = emptySet(),
        ) {
            a.invoke(it)
        },
        TransformationAction(
            name = "chain-1",
            description = "chain element 0",
            cost = 0.0,
            value = 0.0,
            canRerun = false,
            inputClass = bClass,
            outputClass = cClass,
            toolGroups = emptySet(),
        ) {
            b.invoke(it)
        })
    return AgentScopeBuilder(
        name = MobyNameGenerator.generateName(),
        actions = actions,
    )
}


/**
 * Branch from A to B or C using Kotlin reified types.
 * Makes conditionals easy to express.
 */
fun <A, B, C> branch(
    a: (context: InputActionContext<A>) -> Branch<B, C>,
    aClass: Class<A>,
    bClass: Class<B>,
    cClass: Class<C>,
): AgentScopeBuilder<Branch<B, C>> {
    val branchAction =
        BranchingAction<A, B, C>(
            name = "chain-0",
            description = "chain element 0",
            cost = 0.0,
            value = 0.0,
            canRerun = false,
            inputClass = aClass,
            leftOutputClass = bClass,
            rightOutputClass = cClass,
            toolGroups = emptySet(),
        ) {
            a.invoke(it)
        }
    return AgentScopeBuilder(
        name = MobyNameGenerator.generateName(),
        actions = listOf(branchAction),
    )
}

/**
 * Convenience method to branch from A to B or C using Kotlin reified types.
 */
inline fun <reified A, reified B, reified C> branch(
    noinline a: (context: InputActionContext<A>) -> Branch<B, C>,
): AgentScopeBuilder<Branch<B, C>> {
    return branch(a, A::class.java, B::class.java, C::class.java)
}

/**
 * Convenience method to chain A to B via C using Kotlin reified types.
 */
inline fun <reified A, reified B, reified C> chain(
    noinline a: (context: InputActionContext<A>) -> B,
    noinline b: (context: InputActionContext<B>) -> C,
): AgentScopeBuilder<C> {
    return chain(a, b, A::class.java, B::class.java, C::class.java)
}


fun <A, B, C> aggregate(
    transforms: List<(context: InputActionContext<A>) -> B>,
    merge: (list: List<B>, context: OperationContext) -> C,
    aClass: Class<A>,
    bClass: Class<B>,
    cClass: Class<C>,
): AgentScopeBuilder<C> {
    val allCompletedCondition = ComputedBooleanCondition(
        name = "All<${bClass.name}=>${cClass.name}",
        evaluator = { it, condition ->
            it.objectsOfType(bClass).size == transforms.size
        }
    )
    val actions = mutableListOf<Action>()

    val transformActions = transforms.mapIndexed { index, transform ->
        TransformationAction(
            name = "${aClass.name}=>${bClass.name}-$index",
            description = "Transform $aClass to $bClass",
            post = listOf(allCompletedCondition.name),
            cost = 0.0,
            value = 0.0,
            canRerun = true,
            inputClass = aClass,
            outputClass = bClass,
            toolGroups = emptySet(),
        ) {
            transform.invoke(it)
        }
    }
    actions += transformActions
    val mergeAction = SupplierAction(
        name = "List<${bClass.name}>=>${cClass.name}",
        description = "Aggregate list $bClass to $cClass",
        pre = transformActions.map { Rerun.hasRunCondition(it) } + allCompletedCondition.name,
        cost = 0.0,
        value = 0.0,
        canRerun = true,
        outputClass = cClass,
        toolGroups = emptySet(),
    ) { context ->
        merge(context.objects.filterIsInstance(bClass), context)
    }
    actions += mergeAction
    return AgentScopeBuilder(
        name = MobyNameGenerator.generateName(),
        actions = actions,
        goals = emptySet(),
        conditions = setOf(allCompletedCondition),
    )
}

/**
 * Aggregate taking 2 inputs
 */
@Suppress("UNCHECKED_CAST")
fun <A1, A2, B : Any, C> biAggregate(
    transforms: List<(context: BiInputActionContext<A1, A2>) -> B>,
    merge: (list: List<B>) -> C,
    a1Class: Class<A1>,
    a2Class: Class<A2>,
    bClass: Class<B>,
    cClass: Class<C>,
): AgentScopeBuilder<C> {
    val allCompletedCondition = ComputedBooleanCondition(
        name = "List<${bClass.name}>=>${cClass.name}",
        evaluator = { it, condition ->
            it.objectsOfType(bClass).size == transforms.size
        }
    )
    val actions = mutableListOf<Action>()

    val transformActions = transforms.mapIndexed { index, transform ->
        MultiTransformationAction<B>(
            name = "${a1Class.name}+${a2Class.name}=>${bClass.name}-$index",
            description = "Transform ${a1Class.name}+${a2Class.name} to $bClass",
            pre = emptyList(),
            post = listOf(allCompletedCondition.name),
            cost = 0.0,
            value = 0.0,
            canRerun = true,
            inputs = setOf(
                IoBinding(IoBinding.DEFAULT_BINDING, a1Class.name),
                IoBinding(IoBinding.DEFAULT_BINDING, a2Class.name),
            ),
            inputClasses = listOf(a1Class, a2Class),
            outputClass = bClass,
            toolGroups = emptySet(),
        ) {
            transform.invoke(BiInputActionContext(it.input[0] as A1, it.input[1] as A2, it))
        }
    }
    actions += transformActions
    val mergeAction = TransformationAction(
        name = "List<${bClass.name}>=>${cClass.name}",
        description = "Aggregate list $bClass to $cClass",
        pre = transformActions.map { Rerun.hasRunCondition(it) } + allCompletedCondition.name,
        post = emptyList(),
        cost = 0.0,
        value = 0.0,
        canRerun = true,
        inputClass = bClass,
        outputClass = cClass,
        toolGroups = emptySet(),
    ) {
        val cList = it.objects.filterIsInstance<B>(bClass)
        merge(cList)
    }
    actions += mergeAction
    return AgentScopeBuilder(
        name = MobyNameGenerator.generateName(),
        actions = actions,
        goals = emptySet(),
        conditions = setOf(allCompletedCondition),
    )
}

/**
 * Run all the transforms and merge the results.
 */
inline fun <reified A, reified B, reified C> aggregate(
    transforms: List<(context: InputActionContext<A>) -> B>,
    noinline merge: (list: List<B>, context: OperationContext) -> C,
): AgentScopeBuilder<C> {
    return aggregate(
        transforms, merge, A::class.java, B::class.java, C::class.java
    )
}

data class BiInputActionContext<A1, A2>(
    val input1: A1,
    val input2: A2,
    val actionContext: ActionContext,
) : InputsActionContext, ActionContext by actionContext {

    override val inputs: List<Any> get() = listOfNotNull(input1, input2)

    override fun domainObjectInstances(): List<Any> =
        listOfNotNull(input1, input2)
}

inline fun <reified A1, reified A2, reified B : Any, reified C> biAggregate(
    transforms: List<(context: BiInputActionContext<A1, A2>) -> B>,
    noinline merge: (list: List<B>) -> C,
): AgentScopeBuilder<C> {
    return biAggregate<A1, A2, B, C>(
        transforms,
        merge,
        a1Class = A1::class.java,
        a2Class = A2::class.java,
        bClass = B::class.java,
        cClass = C::class.java,
    )
}

/**
 * Special aggregate that works like an accumulator. If the condition is not
 * satisfied, your transformer methods will be called again with the latest updated context.
 */
inline fun <reified A, reified B : Any, reified C> repeatableAggregate(
    startWith: C,
    transforms: List<(context: BiInputActionContext<A, C>) -> B>,
    noinline merge: (list: List<B>) -> C,
): AgentScopeBuilder<C> {
    val asb = biAggregate<A, C, B, C>(
        transforms,
        merge,
        a1Class = A::class.java,
        a2Class = C::class.java,
        bClass = B::class.java,
        cClass = C::class.java,
    )
    val populator: Action = SupplierAction<C>(
        name = "repeatable-aggregate",
        description = "Repeatable aggregate",
        pre = emptyList(),
        post = emptyList(),
        cost = 0.0,
        value = 0.0,
        canRerun = true,
        outputClass = C::class.java,
        toolGroups = emptySet(),
    ) {
        startWith
    }
    return asb.copy(
        actions = asb.actions + populator,
    )
}


fun <C> repeat(
    what: () -> AgentScopeBuilder<C>,
    // TODO gather this
    until: (c: C, context: OperationContext) -> Boolean,
    cClass: Class<C>,
): AgentScopeBuilder<C> {
    val conditionName = "repeat-until-${cClass.name}"
    val untilCondition = ComputedBooleanCondition(
        name = conditionName,
        evaluator = { it, condition ->
            val input = it.last(cClass)
            if (input == null) {
                return@ComputedBooleanCondition false
            }
            until(input, it)
        })
    val doerScope = what.invoke().build()
    val completionAction = TransformationAction(
        name = "repeat",
        description = "Repeat until condition is met",
        pre = listOf(untilCondition.name),
        post = emptyList(),
        cost = 0.0,
        value = 0.0,
        canRerun = true,
        inputClass = cClass,
        outputClass = cClass,
        toolGroups = emptySet(),
    ) {
        TODO()
    }
    return AgentScopeBuilder(
        name = MobyNameGenerator.generateName(),
        actions = doerScope.actions + completionAction,
        conditions = setOf(untilCondition),
    )
}

inline fun <reified C> repeat(
    noinline what: () -> AgentScopeBuilder<C>,
    noinline until: (c: C, context: OperationContext) -> Boolean,
): AgentScopeBuilder<C> {
    return repeat(what, until, C::class.java)
}

/**
 * AgentScopeBuilder that emits actions and can be built on further.
 * @param O the output type of the actions
 */
data class AgentScopeBuilder<O>(
    val name: String,
    val provider: String = "embabel",
    val actions: List<Action> = emptyList(),
    val goals: Set<Goal> = emptySet(),
    val conditions: Set<Condition> = emptySet(),
    val opaque: Boolean = false,
) {
    fun build(): AgentScope {
        return AgentScope(
            name = name,
            actions = actions,
            goals = goals,
            conditions = conditions,
            opaque = opaque,
        )
    }

    fun <O : Any> asSubProcess(
        context: ActionContext,
        outputClass: Class<O>,
    ): O {

        val withExtraGoal = AgentScope(
            name = name,
            actions = actions,
            goals = goals + Goal(
                name = name,
                description = "description",
                inputs = setOf(
                    IoBinding(
                        type = outputClass,
                        name = IoBinding.DEFAULT_BINDING,
                    ),
                ),
            ),
            conditions = conditions,
        )
        val agent = withExtraGoal.createAgent(
            name = this.name,
            provider = this.provider,
            description = this.name,
        )
        val singleAction = agentTransformer(
            agent = agent,
            inputClass = Unit::class.java,
            outputClass = outputClass,
        )

        singleAction.execute(
            processContext = context.processContext,
        )
        return context.last(outputClass) ?: throw IllegalStateException(
            "No output of type ${outputClass.name} found in context"
        )
    }

    inline fun <reified O : Any> asSubProcess(
        context: ActionContext,
    ): O {
        return asSubProcess(
            context = context,
            outputClass = O::class.java,
        )
    }

    inline infix fun <reified F> andThenDo(
        fn: Transformation<O, F>,
    ): AgentScopeBuilder<F> = andThenDo(fn, F::class.java)

    fun <F> andThenDo(
        fn: Transformation<O, F>,
        fClass: Class<F>,
    ): AgentScopeBuilder<F> {
        // TODO is this safe?
        val lastAction = actions.last()
        val extraAction = TransformationAction(
            name = "extra=>${fClass.name}",
            description = "Extra step to ${fClass.name}",
            pre = listOf(Rerun.hasRunCondition(lastAction)),
            post = emptyList(),
            cost = 0.0,
            value = 0.0,
            canRerun = true,
            // TODO this is nasty
            inputClass = (lastAction as TransformationAction<*, *>).outputClass,
            outputClass = fClass,
            toolGroups = emptySet(),
        ) {
            loggerFor<AgentScopeBuilder<*>>().info("Running extra action {}", name)
            fn.transform(it as TransformationActionContext<O, F>)
        }
        return this.copy(actions = this.actions + extraAction) as AgentScopeBuilder<F>
    }

    /**
     * Changes output
     */
    fun <F> andThen(
        fn: (e: O) -> F,
        fClass: Class<F>,
    ): AgentScopeBuilder<F> =
        andThenDo({ fn(it.input) }, fClass)


    inline infix fun <reified F> andThen(noinline fn: (e: O) -> F): AgentScopeBuilder<F> {
        return andThen(fn, F::class.java)
    }
}

inline fun <reified I, reified O : Any> runAgent(
    agent: Agent,
    context: TransformationActionContext<I, O>,
): O {
    val singleAction = agent.asAction<Any, O>()
    singleAction.execute(
        processContext = context.processContext,
    )
    return context.last<O>() ?: throw IllegalStateException(
        "No output of type ${O::class.java} found in context"
    )
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/dsl/mapper.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.dsl

import com.embabel.agent.api.common.OperationContext
import kotlinx.coroutines.*
import kotlinx.coroutines.sync.Semaphore
import kotlinx.coroutines.sync.withPermit

/**
 * Map parallel. Block on all results
 * @param T the type of elements in the collection
 * @param R the type of the result of the transformation
 * @param context the operation context
 * @param concurrencyLevel the maximum number of concurrent operations
 * @param dispatcher the coroutine dispatcher to use for parallel execution
 * @param transform the transformation function to apply to each element
 */
fun <T, R> Collection<T>.parallelMap(
    context: OperationContext,
    concurrencyLevel: Int = 10,
    dispatcher: CoroutineDispatcher = Dispatchers.IO,
    transform: suspend (T) -> R,
): List<R> =
    runBlocking {
        mapAsync(
            context = context,
            concurrencyLevel = concurrencyLevel,
            dispatcher = dispatcher,
            transform = transform,
        )
    }


/**
 * Map async, using the agent process
 */
suspend fun <T, R> Collection<T>.mapAsync(
    context: OperationContext,
    concurrencyLevel: Int = 10,
    dispatcher: CoroutineDispatcher = Dispatchers.IO,
    transform: suspend (T) -> R
): List<R> = coroutineScope {
    if (isEmpty()) return@coroutineScope emptyList()

    // Use kotlinx.coroutines.sync.Semaphore for proper concurrency control
    val semaphore = Semaphore(concurrencyLevel)

    map { item ->
        async(dispatcher) {
            semaphore.withPermit {
                transform(item)
            }
        }
    }.awaitAll()
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/dsl/support/promptTransformer.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.dsl.support

import com.embabel.agent.api.common.TransformationActionContext
import com.embabel.agent.api.common.support.TransformationAction
import com.embabel.agent.core.ActionQos
import com.embabel.agent.core.Condition
import com.embabel.agent.core.IoBinding
import com.embabel.agent.core.ToolGroupRequirement
import com.embabel.common.ai.model.LlmOptions
import com.embabel.common.ai.prompt.PromptContributor
import com.embabel.common.core.types.ZeroToOne
import org.springframework.ai.tool.ToolCallback

/**
 * Supports AgentBuilder. Not fur direct use in user code.
 */
fun <I, O : Any> promptTransformer(
    name: String,
    description: String = name,
    pre: List<Condition> = emptyList(),
    post: List<Condition> = emptyList(),
    inputVarName: String = IoBinding.DEFAULT_BINDING,
    outputVarName: String = IoBinding.DEFAULT_BINDING,
    inputClass: Class<I>,
    outputClass: Class<O>,
    cost: ZeroToOne = 0.0,
    toolGroups: Set<ToolGroupRequirement> = emptySet(),
    qos: ActionQos = ActionQos(),
    referencedInputProperties: Set<String>? = null,
    llm: LlmOptions = LlmOptions(),
    promptContributors: List<PromptContributor> = emptyList(),
    canRerun: Boolean = false,
    toolCallbacks: Collection<ToolCallback> = emptyList(),
    prompt: (actionContext: TransformationActionContext<I, O>) -> String,
): TransformationAction<I, O> {
    return TransformationAction<I, O>(
        name = name,
        description = description,
        pre = pre.map { it.name },
        post = post.map { it.name },
        cost = cost,
        qos = qos,
        canRerun = canRerun,
        inputVarName = inputVarName,
        outputVarName = outputVarName,
        inputClass = inputClass,
        outputClass = outputClass,
        referencedInputProperties = referencedInputProperties,
        toolGroups = toolGroups,
    ) {
        it.promptRunner(
            llm = llm,
            toolGroups = toolGroups,
            promptContributors = promptContributors,
        ).createObject(
            prompt = prompt(it),
            outputClass = outputClass,
        )
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/models/AnthropicModels.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.models

/**
 * Provides constants for Anthropic AI model identifiers.
 * This class contains the latest model versions for Claude AI models offered by Anthropic.
 */
class AnthropicModels {

    companion object {

        const val CLAUDE_37_SONNET = "claude-3-7-sonnet-latest"

        const val CLAUDE_35_HAIKU = "claude-3-5-haiku-latest"

        const val CLAUDE_40_OPUS = "claude-opus-4-20250514"

        const val CLAUDE_41_OPUS = "claude-opus-4-1"

        const val CLAUDE_SONNET_4_5 = "claude-sonnet-4-5"

        const val CLAUDE_HAIKU_4_5 = "claude-haiku-4-5"

        const val PROVIDER = "Anthropic"
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/models/DeepSeekModels.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.models

/**
 * Provides constants for DeepSeek AI model identifiers.
 * This class contains the latest model versions for DeepSeek AI models offered by DeepSeek.
 */
class DeepSeekModels {

    companion object {

        const val DEEPSEEK_CHAT = "deepseek-chat";
        const val DEEPSEEK_REASONER = "deepseek-reasoner";

        const val PROVIDER = "deepseek";
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/models/DockerLocalModels.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.models

import com.embabel.common.util.ExcludeFromJacocoGeneratedReport

/**
 * Docker local models
 * This class will always be loaded, but models won't be loaded
 * from the Docker endpoint unless the "docker" profile is set.
 * Model names will be precisely as reported from
 * http://localhost:12434/engines/v1/models (assuming default port).
 */
@ExcludeFromJacocoGeneratedReport(reason = "Docker model configuration can't be unit tested")
class DockerLocalModels(
) {
    companion object {
        const val DOCKER_PROFILE = "docker"

        const val PROVIDER = "Docker"
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/models/FallbackChatModel.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.models

import com.embabel.common.ai.model.Llm
import org.slf4j.LoggerFactory
import org.springframework.ai.chat.model.ChatModel
import org.springframework.ai.chat.model.ChatResponse
import org.springframework.ai.chat.prompt.Prompt

/**
 * Chat model that falls back to another model if the first one fails.
 */
class FallbackChatModel(
    private val model: ChatModel,
    private val fallback: ChatModel,
    private val whenError: (t: Throwable) -> Boolean,
) : ChatModel {

    private val logger = LoggerFactory.getLogger(this::class.java)

    override fun call(prompt: Prompt): ChatResponse {
        return try {
            model.call(prompt)
        } catch (t: Throwable) {
            if (whenError(t)) {
                logger.info("Flipping to fallback model. Error: {}; options: {}", t.message, prompt.options)
                fallback.call(prompt)
            } else {
                throw t
            }
        }
    }
}

fun ChatModel.withFallback(
    model: ChatModel,
    whenError: (t: Throwable) -> Boolean,
): ChatModel {
    return FallbackChatModel(this, model, whenError)
}

/**
 * LLM that falls back to another LLM if the first one fails.
 * @param fallbackTo the LLM to fall back to if the first one fails
 */
fun Llm.withFallback(
    fallbackTo: Llm?,
    whenError: (t: Throwable) -> Boolean,
): Llm {
    if (fallbackTo == null) {
        return this
    }
    return Llm(
        name = this.name,
        model = this.model.withFallback(fallbackTo.model, whenError),
        optionsConverter = this.optionsConverter,
        provider = this.provider,
        knowledgeCutoffDate = this.knowledgeCutoffDate,
    )
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/models/OllamaModels.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.models

/**
 * Popular Ollama models as constants for easy reference and type safety.
 * These represent the most commonly used models in the Ollama ecosystem.
 */
class OllamaModels {

    companion object {
        //Provider
        const val PROVIDER = "Ollama"

        // Llama Models
        const val LLAMA_31_8B = "llama3.1:8b"
        const val LLAMA_31_70B = "llama3.1:70b"
        const val LLAMA_31_405B = "llama3.1:405b"
        const val LLAMA_3_8B = "llama3:8b"
        const val LLAMA_3_70B = "llama3:70b"
        const val LLAMA_2_7B = "llama2:7b"
        const val LLAMA_2_13B = "llama2:13b"
        const val LLAMA_2_70B = "llama2:70b"

        // Code-specialized Models
        const val CODELLAMA_7B = "codellama:7b"
        const val CODELLAMA_13B = "codellama:13b"
        const val CODELLAMA_34B = "codellama:34b"
        const val CODEGEMMA_2B = "codegemma:2b"
        const val CODEGEMMA_7B = "codegemma:7b"

        // Gemma Models
        const val GEMMA_2B = "gemma:2b"
        const val GEMMA_7B = "gemma:7b"
        const val GEMMA2_9B = "gemma2:9b"
        const val GEMMA2_27B = "gemma2:27b"

        // Mistral Models
        const val MISTRAL_7B = "mistral:7b"
        const val MIXTRAL_8X7B = "mixtral:8x7b"
        const val MIXTRAL_8X22B = "mixtral:8x22b"

        // Specialized Models
        const val QWEN2_0_5B = "qwen2:0.5b"
        const val QWEN2_1_5B = "qwen2:1.5b"
        const val QWEN2_7B = "qwen2:7b"
        const val QWEN2_72B = "qwen2:72b"
        const val PHI3_MINI = "phi3:mini"
        const val PHI3_MEDIUM = "phi3:medium"
        const val NEURAL_CHAT_7B = "neural-chat:7b"
        const val ORCA_MINI_3B = "orca-mini:3b"
        const val VICUNA_7B = "vicuna:7b"
        const val VICUNA_13B = "vicuna:13b"

        // Embedding Models
        const val NOMIC_EMBED_TEXT = "nomic-embed-text"
        const val ALL_MINILM = "all-minilm"

        // Vision Models
        const val LLAVA_7B = "llava:7b"
        const val LLAVA_13B = "llava:13b"
        const val LLAVA_34B = "llava:34b"

    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/models/OpenAiCompatibleModelFactory.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.models

import com.embabel.common.ai.model.*
import com.embabel.common.util.loggerFor
import io.micrometer.observation.ObservationRegistry
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.ai.chat.model.ChatModel
import org.springframework.ai.document.MetadataMode
import org.springframework.ai.model.NoopApiKey
import org.springframework.ai.model.SimpleApiKey
import org.springframework.ai.model.tool.ToolCallingManager
import org.springframework.ai.openai.OpenAiChatModel
import org.springframework.ai.openai.OpenAiChatOptions
import org.springframework.ai.openai.OpenAiEmbeddingModel
import org.springframework.ai.openai.OpenAiEmbeddingOptions
import org.springframework.ai.openai.api.OpenAiApi
import org.springframework.ai.retry.RetryUtils
import org.springframework.retry.support.RetryTemplate
import org.springframework.web.client.RestClient
import org.springframework.web.reactive.function.client.WebClient
import java.time.LocalDate

/**
 * Generic support for OpenAI compatible models.
 * Use to register LLM beans.
 * @param baseUrl The base URL of the OpenAI API. Null for OpenAI default.
 * @param apiKey The API key for the OpenAI compatible provider, or null for no authentication.
 */
open class OpenAiCompatibleModelFactory(
    val baseUrl: String?,
    private val apiKey: String?,
    private val completionsPath: String?,
    private val embeddingsPath: String?,
    private val observationRegistry: ObservationRegistry,
) {

    protected val logger: Logger = LoggerFactory.getLogger(javaClass)

    // Subclasses should add their own more specific logging
    init {
        logger.info(
            "Open AI compatible models are available at {}. API key is {}",
            baseUrl ?: "default OpenAI location",
            if (apiKey == null) "not set" else "set",
        )
    }

    protected val openAiApi = createOpenAiApi()

    private fun createOpenAiApi(): OpenAiApi {
        val builder = OpenAiApi.builder()
            .apiKey(if (apiKey != null) SimpleApiKey(apiKey) else NoopApiKey())
        if (baseUrl != null) {
            loggerFor<OpenAiModels>().info("Using custom OpenAI base URL: {}", baseUrl)
            builder.baseUrl(baseUrl)
        }
        if (completionsPath != null) {
            loggerFor<OpenAiModels>().info("Using custom OpenAI completions path: {}", completionsPath)
            builder.completionsPath(completionsPath)
        }
        if (embeddingsPath != null) {
            loggerFor<OpenAiModels>().info("Using custom OpenAI embeddings path: {}", embeddingsPath)
            builder.embeddingsPath(embeddingsPath)
        }

        //add observation registry to rest and web client builders
        builder
            .restClientBuilder(
                RestClient.builder()
                    .observationRegistry(observationRegistry)
            )
        builder
            .webClientBuilder(
                WebClient.builder()
                    .observationRegistry(observationRegistry)
            )

        return builder.build()
    }

    @JvmOverloads
    fun openAiCompatibleLlm(
        model: String,
        pricingModel: PricingModel,
        provider: String,
        knowledgeCutoffDate: LocalDate?,
        optionsConverter: OptionsConverter<*> = OpenAiChatOptionsConverter,
        retryTemplate: RetryTemplate = RetryUtils.DEFAULT_RETRY_TEMPLATE,
    ): Llm {
        return Llm(
            name = model,
            model = chatModelOf(model, retryTemplate),
            provider = provider,
            optionsConverter = optionsConverter,
            pricingModel = pricingModel,
            knowledgeCutoffDate = knowledgeCutoffDate,
        )
    }

    fun openAiCompatibleEmbeddingService(
        model: String,
        provider: String,
    ): EmbeddingService {
        val embeddingModel = OpenAiEmbeddingModel(
            openAiApi,
            MetadataMode.EMBED,
            OpenAiEmbeddingOptions.builder()
                .model(model)
                .build(),
        )
        return EmbeddingService(
            name = model,
            model = embeddingModel,
            provider = provider,
        )
    }

    protected fun chatModelOf(
        model: String,
        retryTemplate: RetryTemplate,
    ): ChatModel {
        return OpenAiChatModel.builder()
            .defaultOptions(
                OpenAiChatOptions.builder()
                    .model(model)
                    .build()
            )
            .toolCallingManager(
                ToolCallingManager.builder()
                    .observationRegistry(observationRegistry)
                    .build()
            )
            .openAiApi(openAiApi)
            .retryTemplate(retryTemplate)
            .observationRegistry(
                observationRegistry
            ).build()
    }
}

/**
 * Save default. Some models may not support all options.
 */
object OpenAiChatOptionsConverter : OptionsConverter<OpenAiChatOptions> {

    override fun convertOptions(options: LlmOptions): OpenAiChatOptions =
        OpenAiChatOptions.builder()
            .temperature(options.temperature)
            .topP(options.topP)
            .maxTokens(options.maxTokens)
            .presencePenalty(options.presencePenalty)
            .frequencyPenalty(options.frequencyPenalty)
            .topP(options.topP)
            .build()
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/api/models/OpenAiModels.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.models


/**
 * Well-known models from OpenAI.
 */
class OpenAiModels {

    companion object {

        const val GPT_41_MINI = "gpt-4.1-mini"

        const val GPT_41 = "gpt-4.1"

        const val GPT_41_NANO = "gpt-4.1-nano"

        const val GPT_5 = "gpt-5"

        const val GPT_5_MINI = "gpt-5-mini"

        const val GPT_5_NANO = "gpt-5-nano"

        const val PROVIDER = "OpenAI"

        const val TEXT_EMBEDDING_3_SMALL = "text-embedding-3-small"

        const val DEFAULT_TEXT_EMBEDDING_MODEL = TEXT_EMBEDDING_3_SMALL
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/channel/OutputChannel.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.channel

import com.embabel.agent.core.InProcess
import com.embabel.agent.domain.library.HasContent
import com.embabel.chat.Message
import org.slf4j.LoggerFactory

/**
 * Allows agents to interact with the outside world through multiple channels
 */
interface OutputChannel {

    fun send(event: OutputChannelEvent)

    operator fun plus(other: OutputChannel): OutputChannel =
        if (this == DevNullOutputChannel) other else if (other == DevNullOutputChannel) this else MulticastOutputChannel(
            listOf(this, other)
        )
}

object DevNullOutputChannel : OutputChannel {

    private val logger = LoggerFactory.getLogger(javaClass)

    override fun send(event: OutputChannelEvent) {
        logger.warn("DevNullOutputChannel received event: {}", event)
    }
}

interface OutputChannelEvent : InProcess

/**
 * Chat message event relating to this process.
 * Most likely an Assistant message, but could also be a User message in some cases.
 * @param processId Process that generated this message
 */
data class MessageOutputChannelEvent(
    override val processId: String,
    val message: Message,
) : OutputChannelEvent

data class ContentOutputChannelEvent(
    override val processId: String,
    val content: HasContent,
) : OutputChannelEvent

/**
 * Logging or progress event
 */
interface InformativeOutputChannelEvent : OutputChannelEvent {
    val message: String
}

/**
 * Ephemeral message.
 * Not meant to be part of a conversation
 */
data class LoggingOutputChannelEvent @JvmOverloads constructor(
    override val processId: String,
    override val message: String,
    val level: Level = Level.INFO,
    val throwable: Throwable? = null,
) : InformativeOutputChannelEvent {

    enum class Level {
        TRACE, DEBUG, INFO, WARN, ERROR
    }
}

data class ProgressOutputChannelEvent(
    override val processId: String,
    override val message: String,
) : InformativeOutputChannelEvent

/**
 * Send to all channels
 */
class MulticastOutputChannel(
    private val outputChannels: List<OutputChannel>,
) : OutputChannel {

    private val logger = LoggerFactory.getLogger(javaClass)

    override fun send(event: OutputChannelEvent) {
        outputChannels.forEach {
            try {
                it.send(event)
            } catch (t: Throwable) {
                logger.warn("Exception in onPlatformEvent from $it", t)
            }
        }
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/common/Constants.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.common

object Constants {

    const val EMBABEL_PROVIDER = "embabel"
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/common/RetryProperties.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.common

import com.embabel.agent.spi.support.LlmDataBindingProperties.Companion.isRateLimitError
import com.embabel.common.util.loggerFor
import org.springframework.ai.retry.NonTransientAiException
import org.springframework.ai.retry.TransientAiException
import org.springframework.retry.RetryCallback
import org.springframework.retry.RetryContext
import org.springframework.retry.RetryListener
import org.springframework.retry.RetryPolicy
import org.springframework.retry.context.RetryContextSupport
import org.springframework.retry.support.RetryTemplate
import java.time.Duration

interface RetryTemplateProvider {
    val maxAttempts: Int
    fun retryTemplate(name: String): RetryTemplate
}

/**
 * Extended by configuration that needs retry regarding Spring AI.
 */
interface RetryProperties : RetryTemplateProvider {
    val backoffMillis: Long
    val backoffMultiplier: Double
    val backoffMaxInterval: Long

    val retryPolicy: RetryPolicy get() = SpringAiRetryPolicy(maxAttempts)

    override fun retryTemplate(name: String): RetryTemplate {
        return RetryTemplate.builder()
            .exponentialBackoff(
                Duration.ofMillis(backoffMillis),
                backoffMultiplier,
                Duration.ofMillis(backoffMaxInterval)
            )
            .customPolicy(retryPolicy)
            .withListener(object : RetryListener {
                override fun <T, E : Throwable> onError(
                    context: RetryContext,
                    callback: RetryCallback<T, E>,
                    throwable: Throwable,
                ) {
                    if (isRateLimitError(throwable)) {
                        loggerFor<RetryProperties>().info(
                            "🔒 LLM invocation {} RATE LIMITED: Retry attempt {} of {}",
                            name,
                            context.retryCount,
                            if (retryPolicy.maxAttempts > 0) retryPolicy.maxAttempts else "unknown",
                        )
                        return
                    }
                    loggerFor<RetryProperties>().info(
                        "Operation $name: Retry error. Retry count: ${context.retryCount}",
                        throwable,
                    )
                }
            })
            .build()
    }
}

/**
 * Retry policy for Spring AI operations.
 */
private class SpringAiRetryPolicy(
    private val maxAttempts: Int,
    private val rateLimitPhrases: Set<String> = setOf("rate limit", "rate-limit"),
) : RetryPolicy {

    override fun open(parent: RetryContext?): RetryContext {
        return RetryContextSupport(parent)
    }

    override fun close(context: RetryContext?) {
        // No cleanup needed for this implementation
    }

    override fun registerThrowable(
        context: RetryContext?,
        throwable: Throwable?,
    ) {
        if (context is RetryContextSupport && throwable != null) {
            context.registerThrowable(throwable)
        }
    }

    override fun canRetry(context: RetryContext): Boolean {
        if (context.retryCount == 0) {
            // First attempt, always retry
            return true
        }
        if (context.retryCount >= maxAttempts) {
            return false
        }

        return when (val lastException = context.lastThrowable) {
            is TransientAiException -> true
            is NonTransientAiException -> {
                val m = lastException.message ?: return false
                rateLimitPhrases.any { phrase ->
                    m.contains(phrase, ignoreCase = true)
                }
            }

            is IllegalArgumentException -> false

            is IllegalStateException -> false

            is UnsupportedOperationException -> false

            else -> true
        }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/README.md
================================================
# Core agent infrastructure classes

Most of these are not intended for direct
use in application code.


================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/Action.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import com.embabel.common.core.types.ZeroToOne
import com.embabel.common.util.indent
import com.embabel.common.util.indentLines
import com.embabel.common.util.loggerFor
import com.embabel.plan.goap.EffectSpec
import com.embabel.plan.goap.GoapAction


/**
 * Core Action model in Agent system.
 * An individual action step used in an Agent
 * Not intended for direct use by application code.
 * User applications should use the annotation programming model
 * with @Agentic and @Action or the Kotlin DSL, or a non-code
 * representation such as YML.
 * @qos Quality of Service. Governs retry policy
 */
interface Action : DataFlowStep, GoapAction, ActionRunner, DataDictionary, ToolGroupConsumer {

    override val cost: ZeroToOne get() = 0.0

    /**
     * Can this action be run again if it has already run in the given AgentProcess?
     * Must be set to true to allow looping style behavior.
     */
    val canRerun: Boolean

    /**
     * Quality of Service for this action.
     */
    val qos: ActionQos

    override val domainTypes: Collection<DomainType>
        get() =
            (inputs + outputs)
                .map {
                    referencedType(it, this)
                }.toSet()

    private fun referencedType(
        binding: IoBinding,
        action: Action,
    ): DynamicType {
        var type = DynamicType(name = binding.type)
        for (prop in action.referencedInputProperties(binding.name)) {
            loggerFor<Action>().debug("Discovered property {}", prop)
            type = type.withProperty(SimplePropertyDefinition(name = prop))
        }
        loggerFor<Action>().debug(
            "Action {} references variable {} of type {}: {}",
            action.name,
            binding.name,
            binding.type,
            type,
        )

        return type
    }

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String =
        """|name: $name
           |preconditions:
           |${
            preconditions
                .map { it.key to "${it.key}: ${it.value}" }
                .sortedBy { it.first }
                .joinToString("\n") { it.second.indent(1) }
        }
           |postconditions:
           |${
            effects
                .map { it.key to "${it.key}: ${it.value}" }
                .sortedBy { it.first }
                .joinToString("\n") { it.second.indent(1) }
        }
           |"""
            .trimMargin()
            .indentLines(indent)

    fun shortName(): String {
        return name.split('.').lastOrNull() ?: name
    }

}

/**
 * Serializable action metadata
 */
data class ActionMetadata(
    val name: String,
    val description: String,
    val inputs: Set<IoBinding>,
    val outputs: Set<IoBinding>,
    val preconditions: EffectSpec,
    val effects: EffectSpec,
    val cost: ZeroToOne,
    val value: ZeroToOne,
    val canRerun: Boolean,
    val qos: ActionQos,
) {

    constructor(
        action: Action,
    ) : this(
        name = action.name,
        description = action.description,
        inputs = action.inputs,
        outputs = action.outputs,
        preconditions = action.preconditions,
        effects = action.effects,
        cost = action.cost,
        value = action.value,
        canRerun = action.canRerun,
        qos = action.qos,
    )
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/ActionQos.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import com.embabel.agent.common.RetryProperties

/**
 * Quality of service requirements for an action
 */
data class ActionQos(
    override val maxAttempts: Int = 5,
    override val backoffMillis: Long = 10000,
    override val backoffMultiplier: Double = 5.0,
    override val backoffMaxInterval: Long = 60000,
    val idempotent: Boolean = false,
) : RetryProperties



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/ActionRunner.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import com.embabel.agent.api.annotation.AwaitableResponseException
import com.embabel.common.util.time
import org.slf4j.LoggerFactory
import java.time.Duration

interface ActionRunner {

    /**
     * Execute an action
     * @param processContext process moment
     */
    fun execute(
        processContext: ProcessContext,
    ): ActionStatus

    /**
     * Properties referenced from input variable
     * Say "person" is passed. Return "name" and other references
     */
    fun referencedInputProperties(variable: String): Set<String>

    companion object {

        private val logger = LoggerFactory.getLogger(ActionRunner::class.java)

        /**
         * Execute this operation with timings and error handling
         */
        fun execute(
            processContext: ProcessContext,
            block: () -> Unit,
        ): ActionStatus {
            val (status, ms) = time {
                try {
                    block()
                    ActionStatusCode.SUCCEEDED
                } catch (are: AwaitableResponseException) {
                    // Not an error condition
                    // Bind the awaitable to the blackboard
                    logger.debug(
                        "{} adding awaitable to blackboard: {}",
                        processContext.agentProcess.id,
                        are.awaitable.infoString(verbose = false),
                    )

                    processContext.blackboard.addObject(are.awaitable)
                    ActionStatusCode.WAITING
                } catch (t: Throwable) {
                    if (logger.isDebugEnabled) {
                        logger.debug(
                            "Unexpected error invoking action",
                            t,
                        )
                    } else {
                        logger.warn(
                            "Unexpected error invoking action: {}",
                            t.message,
                        )
                    }
                    throw t
                }
            }
            return ActionStatus(
                status = status,
                runningTime = Duration.ofMillis(ms),
            )
        }
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/Agent.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import com.embabel.agent.api.common.StuckHandler
import com.embabel.common.core.types.*
import com.embabel.common.util.ComputerSaysNoSerializer
import com.embabel.common.util.indentLines
import com.embabel.plan.PlanningSystem
import com.embabel.plan.goap.GoapPlanningSystem
import com.fasterxml.jackson.databind.annotation.JsonSerialize
import org.slf4j.LoggerFactory

/**
 * An agent defines a set of actions and conditions
 * that enable planning.
 * @param name The name of the agent.
 * @param provider The provider of the agent.
 * @param version The version of the agent. Defaults to 0.1.0
 * @param description A description of the agent. Required
 * @param goals The goals the agent can achieve
 * @param stuckHandler The handler to call when the agent is stuck, if provided
 * @param conditions Well-known conditions that can be referenced by actions
 * @param actions The actions the agent can use
 * @param opaque whether to hide the agent's actions and conditions
 *                 from the outside world, defaults to false.
 * @param domainTypes Data types used in this agent
 */
@JsonSerialize(using = ComputerSaysNoSerializer::class)
data class Agent(
    override val name: String,
    override val provider: String,
    override val version: Semver = Semver(),
    override val description: String,
    override val conditions: Set<Condition> = emptySet(),
    override val actions: List<Action>,
    override val goals: Set<Goal>,
    val stuckHandler: StuckHandler? = null,
    override val opaque: Boolean = false,
    override val domainTypes: Collection<DomainType> = mergeTypes(
        agentName = name,
        defaultDataTypes = emptyList(),
        actions = actions,
    ),
) : NamedAndDescribed, AssetCoordinates, AgentScope {

    @JvmOverloads
    constructor(
        name: String,
        provider: String,
        version: String,
        description: String,
        goals: Set<Goal>,
        actions: List<Action>,
        conditions: Set<Condition> = emptySet(),
        stuckHandler: StuckHandler? = null,
    ) : this(
        name = name,
        provider = provider,
        version = Semver(version),
        description = description,
        goals = goals,
        actions = actions,
        conditions = conditions,
        stuckHandler = stuckHandler,
    )

    /**
     * Return a version of the agent with the single goal
     */
    fun withSingleGoal(goal: Goal): Agent =
        copy(goals = setOf(goal))

    /**
     * Return a version of the agent with actions and conditions pruned to the given pruned planning system.
     */
    fun pruneTo(pruned: GoapPlanningSystem): Agent =
        copy(
            actions = actions.filter { action -> pruned.actions.any { it.name == action.name } },
            conditions = conditions.filter { condition ->
                pruned.actions.any { it.knownConditions.contains(condition.name) }
            }.toSet(),
        )

    val planningSystem: PlanningSystem
        get() {
            val actions = actions.toSet()
            logger.debug(infoString())
            return GoapPlanningSystem(actions, goals)
        }

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String =
        """|description: $description
           |provider: $provider
           |version: $version
           |${super.infoString(verbose, indent)}
           |"""
            .trimMargin()
            .indentLines(indent)

    companion object {

        private val logger = LoggerFactory.getLogger(Agent::class.java)

        /**
         * Merge the default data types with the schema types from actions.
         * Combines the properties of schema types
         */
        fun mergeTypes(
            agentName: String,
            defaultDataTypes: List<DynamicType>,
            actions: List<Action>,
        ): List<DomainType> {
            // Merge properties from multiple type references
            for (action in actions) {
                logger.debug(
                    "Action {} has types {}, inputBinding={}",
                    action.name,
                    action.domainTypes,
                    action.inputs,
                )
            }
            val mergedSchemaTypes = (defaultDataTypes + actions
                .flatMap { it.dynamicTypes }
                .groupBy { it.name }
                .mapValues { (_, types) ->
                    types.reduce { acc, type ->
                        acc.copy(ownProperties = acc.properties + type.properties)
                    }
                }
                .values)
                .map { it.copy(ownProperties = it.properties.distinctBy { it.name }) }
                .distinctBy { it.name }
                .sortedBy { it.name }

            logger.debug(
                "Agent {} inferred types:\n\t{}",
                agentName,
                mergedSchemaTypes.joinToString("\n\t") { "${it.name} - ${it.properties.map { p -> p.name }}" })
            return mergedSchemaTypes + actions.flatMap { it.jvmTypes }.distinctBy { it.name }
        }
    }

}

/**
 * Safely serializable agent metadata
 *
 * This class provides a lightweight representation of an Agent that can be
 * safely serialized and transferred across system boundaries. It contains
 * only the essential metadata about an agent without any implementation details
 * or complex references that might cause serialization issues.
 *
 * @property name The name of the agent
 * @property version The version of the agent, defaults to DEFAULT_VERSION
 * @property description A human-readable description of the agent's purpose and capabilities
 * @property goals The set of goals this agent can achieve
 * @property actions A list of metadata about the actions this agent can perform
 * @property conditions A set of condition names that this agent recognizes
 */
data class AgentMetadata(
    override val name: String,
    override val provider: String,
    override val version: Semver,
    override val description: String,
    val goals: Set<Goal>,
    val actions: List<ActionMetadata>,
    val conditions: Set<String>,
) : Named, Described, AssetCoordinates {

    /**
     * Constructs AgentMetadata from a full Agent instance
     *
     * This constructor extracts only the serializable metadata from a complete Agent,
     * making it suitable for API responses and persistence.
     *
     * @param agent The complete Agent instance to extract metadata from
     */
    constructor(agent: Agent) : this(
        name = agent.name,
        provider = agent.provider,
        version = agent.version,
        description = agent.description,
        goals = agent.goals,
        actions = agent.actions.map { ActionMetadata(it) },
        conditions = agent.conditions.map { it.name }.toSet()
    )
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/AgentPlatform.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import com.embabel.agent.api.common.PlatformServices
import com.embabel.agent.common.Constants
import com.embabel.agent.spi.ToolGroupResolver
import java.util.concurrent.CompletableFuture

/**
 * An AgentPlatform can run agents. It can also act as an agent itself,
 * drawing on all of its agents as its own actions, goals, and conditions.
 * An AgentPlatform is stateful, as agents can be deployed to it.
 * See TypedOps for a higher level API with typed I/O.
 * Typically, there is one AgentPlatform per Spring Boot application,
 * with agents discovered by classpath scanning for @Agent annotations,
 * but this is not a requirement.
 */
interface AgentPlatform : AgentScope {

    val platformServices: PlatformServices

    val toolGroupResolver: ToolGroupResolver

    /**
     * Find an agent process by id. Implementations are only obliged to
     * resolve running processes, although they may choose to return older processes.
     */
    fun getAgentProcess(id: String): AgentProcess?

    /**
     * Kill an agent process by id.
     * Return the killed process, or null if no such process was found.
     */
    fun killAgentProcess(id: String): AgentProcess?

    fun agents(): List<Agent>

    fun deploy(agent: Agent): AgentPlatform

    fun deploy(agentScope: AgentScope): AgentPlatform {
        if (agentScope is Agent) {
            return deploy(agentScope)
        }
        deploy(
            Agent(
                name = agentScope.name,
                provider = Constants.EMBABEL_PROVIDER,
                description = agentScope.name,
                actions = agentScope.actions,
                goals = agentScope.goals,
                conditions = agentScope.conditions,
            )
        )
        return this
    }

    /**
     * Run the agent from the given ProcessOptions.
     * We might create a new blackboard or have one
     * @param agent the agent to run. Does not need to be deployed to the platform
     * @param processOptions the options for the process
     * @param bindings the bindings for the process: Objects that are pre-bound
     * to the blackboard.
     */
    fun runAgentFrom(
        agent: Agent,
        processOptions: ProcessOptions = ProcessOptions(),
        bindings: Map<String, Any>,
    ): AgentProcess

    /**
     * Create an agent process with the given options and bindings.
     * The process will not be started automatically, so this will return quickly,
     * unlike the run method on the created process.
     * AgentProcess status will be NOT_STARTED.
     * @param agent the agent to run. Does not need to be deployed to the platform
     * @param processOptions the options for the process
     * @param bindings the bindings for the process: Objects that are pre-bound
     * to the blackboard.
     */
    fun createAgentProcess(
        agent: Agent,
        processOptions: ProcessOptions,
        bindings: Map<String, Any>,
    ): AgentProcess

    /**
     * Create an agent process with the given options and bind all arguments.
     * @param agent the agent to run. Does not need to be deployed to the platform
     * @param processOptions the options for the process
     * @param objectsToAdd the objects to add to the blackboard.
     */
    fun createAgentProcessFrom(
        agent: Agent,
        processOptions: ProcessOptions,
        vararg objectsToAdd: Any,
    ): AgentProcess = createAgentProcess(
        agent,
        processOptions,
        emptyMap(),
    ).apply {
        objectsToAdd.forEach { addObject(it) }
    }

    /**
     * Run the given agent process in the background
     */
    fun start(
        agentProcess: AgentProcess,
    ): CompletableFuture<AgentProcess> {
        return platformServices.asyncer.async {
            agentProcess.run()
        }
    }

    fun createChildProcess(
        agent: Agent,
        parentAgentProcess: AgentProcess,
    ): AgentProcess

    override val domainTypes: Collection<DomainType>
        get() = agents().flatMap { it.domainTypes }.distinctBy { it.name }

    override val actions: List<Action>
        get() = agents().filterNot { it.opaque }.flatMap { it.actions }.distinctBy { it.name }

    override val goals: Set<Goal>
        get() = agents().flatMap { it.goals }.distinctBy { it.name }.toSet()

    override val conditions: Set<Condition>
        get() = agents().filterNot { it.opaque }.flatMap { it.conditions }.distinctBy { it.name }.toSet()

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/AgentProcess.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import com.embabel.agent.event.ProcessKilledEvent
import com.embabel.common.core.types.HasInfoString
import com.embabel.common.core.types.Timed
import com.embabel.common.core.types.Timestamped
import com.embabel.common.util.ComputerSaysNoSerializer
import com.embabel.plan.Planner
import com.embabel.plan.WorldState
import com.fasterxml.jackson.databind.annotation.JsonSerialize
import java.time.Duration
import java.time.Instant

/**
 * History element
 */
data class ActionInvocation(
    val actionName: String,
    override val timestamp: Instant = Instant.now(),
    override val runningTime: Duration,
) : Timestamped, Timed, HasInfoString {

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String {
        return "$actionName(${"%,d".format(runningTime.toMillis())}ms)"
    }
}

/**
 * Safely serializable status for agent processes.
 */
data class AgentProcessStatusReport(
    val id: String,
    override val status: AgentProcessStatusCode,
    override val timestamp: Instant,
    override val runningTime: Duration,
) : Timed, Timestamped, OperationStatus<AgentProcessStatusCode>

/**
 * Run of an agent
 */
@JsonSerialize(using = ComputerSaysNoSerializer::class)
interface AgentProcess : Blackboard, Timestamped, Timed, OperationStatus<AgentProcessStatusCode>,
    LlmInvocationHistory {

    /**
     * Unique id of this process
     */
    val id: String

    val parentId: String?

    /**
     * Get the planner for this process
     */
    val planner: Planner<*, *, *>

    val history: List<ActionInvocation>

    /**
     * Goal of this process.
     */
    val goal: com.embabel.plan.Goal?

    val finished: Boolean
        get() = status in setOf(
            AgentProcessStatusCode.COMPLETED,
            AgentProcessStatusCode.FAILED,
            AgentProcessStatusCode.KILLED,
            AgentProcessStatusCode.TERMINATED,
        )

    /**
     * Return a serializable status report for this process.
     */
    fun statusReport(): AgentProcessStatusReport =
        AgentProcessStatusReport(
            id = id,
            status = status,
            timestamp = timestamp,
            runningTime = runningTime,
        )

    /**
     * Kill this process and return an event describing the kill if we are successful
     */
    fun kill(): ProcessKilledEvent?

    /**
     * If we failed, this may contain the reason for the failure.
     */
    val failureInfo: Any?

    /**
     * The last world state that was used to plan the next action
     * Will be non-null if the process is running
     */
    val lastWorldState: WorldState?

    val processContext: ProcessContext

    /**
     * The agent that this process is running.
     * Many processes can run the same agent.
     */
    val agent: Agent

    fun recordLlmInvocation(llmInvocation: LlmInvocation)

    /**
     * Perform the next step only.
     * Return when an action has been completed and the process is ready to plan,
     * regardless of the result of the action.
     * @return status code of the action. Side effects may have occurred in Blackboard
     */
    fun tick(): AgentProcess

    /**
     * Run the process as far as we can.
     * Might complete, fail, get stuck or hit a waiting state.
     * This is a slow operation. We may wish to run this async.
     * Events will be emitted as the process runs, so we can track progress.
     * @return status code of the process. Side effects may have occurred in Blackboard
     */
    fun run(): AgentProcess

    /**
     * How long this process has been running
     */
    override val runningTime
        get(): Duration = if (status == AgentProcessStatusCode.NOT_STARTED) Duration.ZERO else Duration.between(
            timestamp,
            Instant.now(),
        )

    @Suppress("UNCHECKED_CAST")
    fun <O> resultOfType(outputClass: Class<O>): O {
        require(status == AgentProcessStatusCode.COMPLETED) {
            "Cannot get result of process that is not completed: Status=$status"
        }
        return processContext.getValue(IoBinding.DEFAULT_BINDING, outputClass.simpleName) as O?
            ?: error("No result of type ${outputClass.name} found in process status")
    }

    companion object {
        private val threadLocalAgentProcess = ThreadLocal<AgentProcess>()

        internal fun set(agentProcess: AgentProcess) {
            threadLocalAgentProcess.set(agentProcess)
        }

        internal fun remove() {
            threadLocalAgentProcess.remove()
        }

        /**
         * Get the current agent process for this thread, if any.
         * This can only be relied on during tool calls.
         */
        @JvmStatic
        fun get(): AgentProcess? {
            return threadLocalAgentProcess.get()?.let { return it }
        }

    }

}

/**
 * Convenience function to get the result of a specific type
 */
inline fun <reified O> AgentProcess.resultOfType(): O = resultOfType(O::class.java)



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/AgentProcessCallback.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

/**
 * Callback interface for interleaving logic with the lifecycle of an AgentProcess and its actions.
 *
 * This is particularly useful for ConcurrentAgentProcess, where launched actions run in their own threads and may,
 * for example, need a Spring Security context proliferated to the thread in which the action runs:
 *
 * ```kotlin
 * @Component
 * @Scope("prototype")
 * class SecurityContextAgentProcessCallback : AgentProcessCallback {
 *     var securityContext: SecurityContext? = null
 *
 *     override fun beforeActionLaunched(process: AgentProcess) {
 *         securityContext = SecurityContextHolder.getContext()
 *     }
 *
 *     override fun onActionLaunched(
 *         process: AgentProcess,
 *         action: Action,
 *     ) {
 *         securityContext?.let {
 *             SecurityContextHolder.setContext(it)
 *         }
 *     }
 *
 *     override fun onActionCompleted(
 *         process: AgentProcess,
 *         action: Action,
 *     ) {
 *         SecurityContextHolder.clearContext()
 *     }
 * }
 * ```
 */
interface AgentProcessCallback {
    fun beforeActionLaunched(process: AgentProcess)
    fun onActionLaunched(process: AgentProcess, action: Action)
    fun onActionCompleted(process: AgentProcess, action: Action)
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/AgentScope.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import com.embabel.common.core.types.Described
import com.embabel.common.core.types.HasInfoString
import com.embabel.common.core.types.Named
import com.embabel.common.util.indent
import com.embabel.common.util.indentLines
import com.fasterxml.jackson.annotation.JsonIgnore

interface ConditionSource {

    val conditions: Set<Condition>
}

interface GoalSource {

    val goals: Set<Goal>
}

interface ActionSource {

    val actions: List<Action>
}

/**
 * Defines the scope of an agent or agents: Goals, conditions and actions.
 * Both Agents and AgentPlatforms are AgentScopes.
 */
interface AgentScope : Named, Described, GoalSource, ConditionSource, ActionSource, DataDictionary, HasInfoString {

    /**
     * Whether to hide the agent's actions and conditions
     * from the outside world, defaults to false.
     */
    val opaque: Boolean

    @get:JsonIgnore
    override val domainTypes: Collection<DomainType>
        get() = actions.flatMap { it.domainTypes }.distinct()

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String =
        """|name: $name
           |goals:
           |${goals.sortedBy { it.name }.joinToString("\n") { it.infoString(true, 1) }}
           |actions:
           |${actions.sortedBy { it.name }.joinToString("\n") { it.infoString(true, 1) }}
           |conditions:
           |${conditions.map { it.name }.sorted().joinToString("\n") { it.indent(1) }}
           |schema types:
           |${domainTypes.map { it }.joinToString("\n") { it.infoString(true, 1) }}
           |"""
            .trimMargin()
            .indentLines(indent)

    /**
     * Create a new agent from the given scope
     * @param name Name of the agent to create
     * @param description Description of the agent to create
     */
    fun createAgent(
        name: String,
        provider: String,
        description: String,
    ): Agent {
        val newAgent = Agent(
            name = name,
            provider = provider,
            description = description,
            actions = actions,
            goals = goals,
            conditions = conditions,
            opaque = opaque,
        )
        return newAgent
    }

    fun resolveType(name: String): DomainType {
        return domainTypes.find { it.name == name }
            ?: error("Schema type '$name' not found in agent ${this.name}: types were ${domainTypes.joinToString(", ") { it.name }}")
    }

    companion object {

        operator fun invoke(
            name: String,
            description: String = name,
            actions: List<Action> = emptyList(),
            goals: Set<Goal> = emptySet(),
            conditions: Set<Condition> = emptySet(),
            opaque: Boolean = false,
        ): AgentScope {
            return AgentScopeImpl(
                name = name,
                description = description,
                actions = actions,
                goals = goals,
                conditions = conditions,
                opaque = opaque,
            )
        }
    }
}

private data class AgentScopeImpl(
    override val name: String,
    override val description: String,
    override val actions: List<Action>,
    override val goals: Set<Goal>,
    override val conditions: Set<Condition>,
    override val domainTypes: Collection<DynamicType> = emptyList(),
    override val opaque: Boolean = false,
) : AgentScope



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/Blackboard.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import com.embabel.agent.api.common.Aggregation
import com.embabel.common.core.types.HasInfoString
import com.embabel.common.util.findAllSupertypes
import com.embabel.common.util.loggerFor
import java.lang.reflect.ParameterizedType
import kotlin.reflect.KClass
import kotlin.reflect.KType
import kotlin.reflect.jvm.javaType

/**
 * Allows binding and retrieval of objects using Kotlin
 * operator functions and traditional get/set
 */
interface Bindable {

    /**
     * Bind a value to a name
     */
    operator fun set(
        key: String,
        value: Any,
    ) // don't implement here as it can upset delegation

    fun bind(
        key: String,
        value: Any,
    ): Bindable

    /**
     * Add to entries without binding to a variable name.
     * Implementations must respect the order in which
     * entities were added.
     * This is equivalent to using the default binding name
     * as the key. For example, if you add a Dog to the blackboard
     * without a key, it will be bound to the default
     * binding name "it" and will be the last
     * entry in the list of objects.
     * Equivalent:
     * ```
     * blackboard["it"] = dog
     * blackboard.addObject(dog)
     * ```
     */
    fun addObject(value: Any): Bindable

    fun addAll(objects: List<Any>) {
        objects.forEach { this += it }
    }

    operator fun plusAssign(value: Any)

    operator fun plusAssign(pair: Pair<String, Any>)

    fun bindAll(bindings: Map<String, Any>) =
        bindings.entries.forEach { entry ->
            this[entry.key] = entry.value
        }

    operator fun plusAssign(bindings: Map<String, Any>) {
        bindAll(bindings)
    }
}

interface MayHaveLastResult {

    /**
     * Last result, of any type, if there is one.
     */
    fun lastResult(): Any?

}


/**
 * A Blackboard is how an AgentProcess maintains context.
 * Blackboard operations are threadsafe.
 * Blackboards are immutable in the sense that once an object has been
 * added it cannot be removed. However, objects can be hidden
 * so they are no longer visible to retrieval operations
 * (e.g. driving planning).
 */
interface Blackboard : Bindable, MayHaveLastResult, HasInfoString {

    /**
     * Unique identifier of this blackboard.
     * Blackboard doesn't extend StableIdentified to avoid
     * conflict with implementations that are otherwise identified
     */
    val blackboardId: String

    /**
     * Return the value of a variable, if it is set by name.
     * Does not limit return via type information.
     */
    operator fun get(name: String): Any?

    /**
     * Hide this object. Does not remove it from the blackboard
     * but will prevent it being retrieved.
     */
    fun hide(what: Any)

    /**
     * Threadsafe get or put
     */
    fun <V : Any> getOrPut(
        name: String,
        creator: () -> V,
    ): V

    /**
     * Indicates whether this blackboard contains a variable.
     */
    fun hasValue(
        variable: String = IoBinding.DEFAULT_BINDING,
        type: String,
        dataDictionary: DataDictionary,
    ): Boolean {
        val bound = this[variable]
        if (bound != null && satisfiesType(bound, type)) {
            return true
        }

        val aggregationClass = dataDictionary.jvmTypes.map { it.clazz }.filter {
            Aggregation::class.java.isAssignableFrom(it)
        }.find { it.simpleName == type }
        if (aggregationClass != null) {
            val aggregationInstance = aggregationFromBlackboard(
                this,
                aggregationClass.kotlin as KClass<Aggregation>,
            )
            if (aggregationInstance != null) {
                return true;
            }
        }

        if (variable != IoBinding.DEFAULT_BINDING) {
            // Must be precisely bound
            return false
        }
        val last = objects.lastOrNull { satisfiesType(boundInstance = it, type) }
        return last != null
    }

    /**
     * Resolve the value of a variable, if it is set.
     * Resolve superclasses
     * For example, getValue("it", "Animal") will match a Dog if Dog extends Animal
     */
    fun getValue(
        variable: String = IoBinding.DEFAULT_BINDING,
        type: String,
        dataDictionary: DataDictionary,
    ): Any? {
        val bound = this[variable]
        if (bound != null && satisfiesType(bound, type)) {
            return bound
        }

        val aggregationClass = dataDictionary.jvmTypes.map { it.clazz }.filter {
            Aggregation::class.java.isAssignableFrom(it)
        }.find { it.simpleName == type }
        if (aggregationClass != null) {
            val aggregationInstance = aggregationFromBlackboard(
                this,
                aggregationClass.kotlin as KClass<Aggregation>,
            )
            if (aggregationInstance != null) {
                loggerFor<ProcessContext>().info("Adding megazord {} to blackboard", this)
                this += aggregationInstance
            }
        }

        if (variable != IoBinding.DEFAULT_BINDING) {
            // Must be precisely bound
            return null
        }
        return objects.lastOrNull { satisfiesType(boundInstance = it, type) }
    }

    fun <T> count(clazz: Class<T>): Int {
        return objects.filterIsInstance(clazz).size
    }

    /**
     * Last entry of the given type, if there is one
     */
    fun <T> last(clazz: Class<T>): T? {
        return objects.filterIsInstance(clazz).lastOrNull()
    }

    /**
     * Return all objects of the given type
     */
    fun <T> objectsOfType(clazz: Class<T>): List<T> {
        return objects.filterIsInstance(clazz)
    }

    /**
     * Entries in the order they were added.
     * The default instance of any type is the last one
     * Objects are immutable and may not be removed.
     */
    val objects: List<Any>

    /**
     * Spawn an independent child blackboard based on the content of this
     */
    fun spawn(): Blackboard

    /**
     * Explicitly set the condition value
     * Used in planning.
     */
    fun setCondition(
        key: String,
        value: Boolean,
    ): Blackboard

    fun getCondition(key: String): Boolean?

    override fun lastResult(): Any? {
        return objects.lastOrNull()
    }

    /**
     * Expose the model data for use in prompts
     * Prefer more strongly typed usage patterns
     */
    fun expressionEvaluationModel(): Map<String, Any>

}

/**
 * Does the bound instance satisfy the type.
 * Match on simple name or FQN of type or any supertype
 */
fun satisfiesType(
    boundInstance: Any,
    type: String,
): Boolean {
    if (boundInstance::class.simpleName == type) {
        return true
    }
    // Check if the class or any of its superclasses implement the interface
    val interfaces = findAllSupertypes(boundInstance::class.java)
    return interfaces.any { it.simpleName == type || it.name == type }
}


/**
 * Return all entries of a specific type
 */
inline fun <reified T> Blackboard.objectsOfType(): List<T> {
    return objectsOfType(T::class.java)
}

/**
 * Count entries of the given type
 */
inline fun <reified T> Blackboard.count(): Int {
    return count(T::class.java)
}

/**
 * Last entry of the given type, if there is one
 */
inline fun <reified T> Blackboard.last(): T? {
    return last(T::class.java)
}

/**
 * Try to instantiate an Aggregation subclass from the blackboard
 */
private fun <T : Aggregation> aggregationFromBlackboard(
    blackboard: Blackboard,
    clazz: KClass<T>,
): T? {
    // Get the constructor for the specific Megazord subclass
    val constructor = clazz.constructors.firstOrNull()
        ?: throw IllegalArgumentException("No constructor found for ${clazz.simpleName}")

    // Get the parameters needed for the constructor
    val params = constructor.parameters

    // Map each parameter to its value from the map
    val args = params.associateWith { param ->
        val value = blackboard.last(param.type.toJavaClass())
        if (value == null) {
            loggerFor<Blackboard>().debug("No value found for parameter {} of type {}", param.name, param.type)
            return null
        }
        value
    }
//            if (args.size < params.size) {
//                println("Not all parameters were found in the map")
//                return null
//            }

    // Create a new instance using the constructor and arguments
    return constructor.callBy(args)
}

private fun KType.toJavaClass(): Class<*> {
    return when (val type = this.javaType) {
        is Class<*> -> type
        is ParameterizedType -> type.rawType as Class<*>
        else -> throw IllegalArgumentException("Cannot convert KType to Class: $this")
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/Condition.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import com.embabel.agent.api.common.OperationContext
import com.embabel.agent.experimental.primitive.PromptCondition
import com.embabel.common.core.types.HasInfoString
import com.embabel.common.core.types.ZeroToOne
import com.embabel.common.util.indent
import com.embabel.plan.goap.ConditionDetermination
import com.fasterxml.jackson.annotation.JsonSubTypes
import com.fasterxml.jackson.annotation.JsonTypeInfo
import com.fasterxml.jackson.databind.annotation.JsonDeserialize


@JsonDeserialize(`as` = ConditionMetadataImpl::class)
interface ConditionMetadata : Operation {

    /**
     * Cost of evaluating the condition. 0 is cheap, 1 is expensive.
     * Helps in planning.
     */
    val cost: ZeroToOne

    companion object {
        operator fun invoke(
            name: String,
            cost: ZeroToOne,
        ): ConditionMetadata = ConditionMetadataImpl(name, cost)
    }
}

private data class ConditionMetadataImpl(
    override val name: String,
    override val cost: ZeroToOne,
) : ConditionMetadata

/**
 * A Condition is a named, well known predicate that can be evaluated
 * and reused across multiple Actions.
 */
@JsonTypeInfo(
    use = JsonTypeInfo.Id.DEDUCTION,
)
@JsonSubTypes(
    JsonSubTypes.Type(value = PromptCondition::class),
)
interface Condition : ConditionMetadata, HasInfoString {

    /**
     * Evaluate the condition in the context of the process.
     * This may be expensive, so the cost is provided.
     * The infrastructure will attempt to call this function infrequently on expensive conditions,
     * so there's no urgency to optimize here.
     */
    fun evaluate(
        context: OperationContext,
    ): ConditionDetermination

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String = "Condition(name='$name', cost=$cost)".indent(indent)

    operator fun not(): Condition = NotCondition(this)

    operator fun inv(): Condition = UnknownCondition(this)

    infix fun or(b: Condition): Condition = OrCondition(this, b)

    infix fun and(b: Condition): Condition = AndCondition(this, b)
}

/**
 * Convenient class for a condition that evaluates to true or false.
 * @param evaluator evaluation method. Takes condition (this) for use
 * by anonymous inner classes.
 */
class ComputedBooleanCondition(
    override val name: String,
    override val cost: ZeroToOne = 0.0,
    private val evaluator: (context: OperationContext, condition: Condition) -> Boolean,
) : Condition {

    override fun evaluate(context: OperationContext): ConditionDetermination =
        ConditionDetermination(evaluator(context, this))

    override fun toString(): String = "${javaClass.simpleName}(name='$name', cost=$cost)"
}


private class NotCondition(private val condition: Condition) : Condition {
    override val name = "!${condition.name}"
    override val cost = condition.cost
    override fun evaluate(context: OperationContext) = when (condition.evaluate(context)) {
        ConditionDetermination.TRUE -> ConditionDetermination.FALSE
        ConditionDetermination.FALSE -> ConditionDetermination.TRUE
        ConditionDetermination.UNKNOWN -> ConditionDetermination.UNKNOWN
    }
}

private class UnknownCondition(private val condition: Condition) : Condition {
    override val name = "!${condition.name}"
    override val cost = condition.cost
    override fun evaluate(context: OperationContext) = when (condition.evaluate(context)) {
        ConditionDetermination.TRUE -> ConditionDetermination.FALSE
        ConditionDetermination.FALSE -> ConditionDetermination.FALSE
        ConditionDetermination.UNKNOWN -> ConditionDetermination.TRUE
    }
}

private class OrCondition(
    private val a: Condition,
    private val b: Condition,
) : Condition {
    override val name = "(${a.name} OR ${b.name})"

    // The cost is the minimum of both conditions since we can short-circuit
    // after evaluating the cheaper condition if it's TRUE
    override val cost = minOf(a.cost, b.cost)

    override fun evaluate(context: OperationContext): ConditionDetermination {
        val aResult = a.evaluate(context)
        // Short-circuit if a is TRUE
        if (aResult == ConditionDetermination.TRUE) return ConditionDetermination.TRUE

        val bResult = b.evaluate(context)
        // If either is TRUE, result is TRUE
        if (bResult == ConditionDetermination.TRUE) return ConditionDetermination.TRUE

        // If either is UNKNOWN, result is UNKNOWN
        if (aResult == ConditionDetermination.UNKNOWN || bResult == ConditionDetermination.UNKNOWN)
            return ConditionDetermination.UNKNOWN

        // Both must be FALSE
        return ConditionDetermination.FALSE
    }
}

private class AndCondition(
    private val a: Condition,
    private val b: Condition,
) : Condition {
    override val name = "(${a.name} AND ${b.name})"

    // The cost is the minimum of both conditions since we can short-circuit
    // after evaluating the cheaper condition if it's FALSE
    override val cost = minOf(a.cost, b.cost)

    override fun evaluate(context: OperationContext): ConditionDetermination {
        val aResult = a.evaluate(context)
        // Short-circuit if a is FALSE
        if (aResult == ConditionDetermination.FALSE) return ConditionDetermination.FALSE

        val bResult = b.evaluate(context)
        // If either is FALSE, result is FALSE
        if (bResult == ConditionDetermination.FALSE) return ConditionDetermination.FALSE

        // If either is UNKNOWN, result is UNKNOWN
        if (aResult == ConditionDetermination.UNKNOWN || bResult == ConditionDetermination.UNKNOWN)
            return ConditionDetermination.UNKNOWN

        // Both must be TRUE
        return ConditionDetermination.TRUE
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/Context.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import com.embabel.common.core.types.HasInfoString

/**
 * Longer-lived interface than a blackboard.
 */
interface Context : HasInfoString {

    /**
     * May be null for a new context not yet saved.
     */
    val id: String

    fun bind(
        key: String,
        value: Any,
    )

    fun addObject(value: Any)

    /**
     * Entries in the order they were added.
     * The default instance of any type is the last one
     * Objects are immutable and may not be removed.
     */
    val objects: List<Any>

    fun <T> last(clazz: Class<T>): T? {
        return objects.filterIsInstance(clazz).lastOrNull()
    }

    /**
     * Populate the given blackboard from the context.
     */
    fun populate(blackboard: Blackboard)

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/ContextId.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import java.util.UUID

/**
 * Id of a context.
 */
@JvmInline
value class ContextId(val value: String) {
    init {
        require(value.isNotBlank()) { "ContextId must not be blank" }
    }

    operator fun invoke(id: String) = ContextId(id)

    companion object {
        fun create(): ContextId = ContextId(UUID.randomUUID().toString())
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/CoreToolGroups.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

/**
 * Core tool groups exposed by the platform
 * These should be supported in any AgentPlatform instance.
 */
object CoreToolGroups {

    const val WEB = "web"

    val WEB_DESCRIPTION = ToolGroupDescription(
        description = "Tools for web search and scraping",
        role = WEB,
    )

    const val MATH = "math"

    val MATH_DESCRIPTION = ToolGroupDescription(
        description = "Math tools: use when you need to perform calculations",
        role = MATH,
    )

    const val MAPS = "maps"

    val MAPS_DESCRIPTION = ToolGroupDescription(
        description = "Mapping tools",
        role = MAPS,
    )

    const val GITHUB = "github"

    val GITHUB_DESCRIPTION = ToolGroupDescription(
        description = "Integration with GitHub APIs",
        role = GITHUB,
    )

    const val BROWSER_AUTOMATION = "browser_automation"

    val BROWSER_AUTOMATION_DESCRIPTION = ToolGroupDescription(
        description = "Browser automation tools",
        role = BROWSER_AUTOMATION,
    )
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/CreationPermitted.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

/**
 * If this value is false, we cannot create new instances
 * of this type: For example, it's a reference.
 */
@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.RUNTIME)
@MustBeDocumented
annotation class CreationPermitted(
    val value: Boolean,
)



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/DataDictionary.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

/**
 * Represents a relationship between two domain types.
 * @param from The source domain type
 * @param to The target domain type
 * @param name The name of the relationship (inferred from property name)
 * @param cardinality The cardinality of the relationship
 */
data class AllowedRelationship(
    val from: DomainType,
    val to: DomainType,
    val name: String,
    val description: String = name,
    val cardinality: Cardinality,
)

/**
 * Exposes access to a set of known data types
 */
interface DataDictionary {

    /**
     * All known types referenced by this component.
     * These may or may not be backed by JVM objects.
     */
    val domainTypes: Collection<DomainType>

    val dynamicTypes: Collection<DynamicType>
        get() =
            domainTypes.filterIsInstance<DynamicType>().toSet()

    val jvmTypes: Collection<JvmType>
        get() =
            domainTypes.filterIsInstance<JvmType>().toSet()

    /**
     * Get all relationships between domain types in this dictionary.
     * A relationship is a property that references another DomainType (not a simple property).
     * @return List of all possible relationships
     */
    fun allowedRelationships(): List<AllowedRelationship> {
        val relationships = mutableListOf<AllowedRelationship>()
        domainTypes.forEach { domainType ->
            domainType.properties.forEach { property ->
                if (property is DomainTypePropertyDefinition) {
                    relationships.add(
                        AllowedRelationship(
                            from = domainType,
                            to = property.type,
                            name = property.name,
                            cardinality = property.cardinality,
                        )
                    )
                }
            }
        }
        return relationships
    }

    /**
     * The domain type matching these labels, if we have one
     */
    fun domainTypeForLabels(labels: Set<String>): DomainType? {
        return domainTypes.maxByOrNull { entity ->
            entity.labels.intersect(labels).size
        }
    }

}

class DataDictionaryImpl(
    override val domainTypes: Collection<DomainType>,
) : DataDictionary {

    constructor (
        vararg embabelTypes: Class<*>,
    ) : this(embabelTypes.map { JvmType(it) })
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/DomainType.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import com.embabel.common.core.types.HasInfoString
import com.embabel.common.core.types.NamedAndDescribed
import com.fasterxml.jackson.annotation.JsonIgnore
import com.fasterxml.jackson.annotation.JsonSubTypes
import com.fasterxml.jackson.annotation.JsonTypeInfo

/**
 * Type known to the Embabel agent platform.
 * May be backed by a domain object or ba dynamic type.
 * Supports inheritance.
 */
@JsonTypeInfo(
    use = JsonTypeInfo.Id.DEDUCTION,
)
@JsonSubTypes(
    JsonSubTypes.Type(value = DynamicType::class, name = "dynamic"),
    JsonSubTypes.Type(value = JvmType::class, name = "jvm"),
)
sealed interface DomainType : HasInfoString, NamedAndDescribed {

    /**
     * Get all properties, including inherited ones.
     * Exposed even for JvmTypes, for consistency.
     * Properties are deduplicated by name, with own properties taking precedence over inherited ones.
     */
    @get:JsonIgnore
    val properties: List<PropertyDefinition>
        get() {
            val propertiesByName = mutableMapOf<String, PropertyDefinition>()
            // First add inherited properties (so they can be overridden)
            parents.forEach { parent ->
                parent.properties.forEach { property ->
                    propertiesByName.putIfAbsent(property.name, property)
                }
            }
            // Then add own properties (these take precedence)
            ownProperties.forEach { property ->
                propertiesByName[property.name] = property
            }
            return propertiesByName.values.toList()
        }

    /**
     * Properties defined on this type only (not inherited)
     */
    val ownProperties: List<PropertyDefinition>

    /**
     * Supports inheritance
     */
    val parents: List<DomainType>

    /**
     * Get all descendant types from the classpath.
     * For JvmType: scans the classpath for classes that extend or implement this type.
     * For DynamicType: returns empty list as dynamic types don't have classpath descendants.
     * @param additionalBasePackages additional base packages to scan for descendants
     * We always include the package of this type as a base package.
     * Don't add packages near the top of the classpath, such as "com", as this can increase scan time.
     */
    fun children(additionalBasePackages: Collection<String> = listOf()): Collection<DomainType>

    /**
     * Is instance creation permitted?
     * Or is this reference data?
     */
    val creationPermitted: Boolean

    /**
     * Get all labels for this type, including from parent types.
     * For JvmType: simple class names of this type and all parent types.
     * For DynamicType: capitalized value after last '.' in name, plus parent labels.
     */
    @get:JsonIgnore
    val labels: Set<String>
        get() {
            val allLabels = mutableSetOf<String>()
            allLabels.add(ownLabel)
            parents.forEach { parent ->
                allLabels.addAll(parent.labels)
            }
            return allLabels
        }

    /**
     * Get the label for this type only (not including parent labels)
     */
    @get:JsonIgnore
    val ownLabel: String
        get() {
            val simpleName = name.substringAfterLast('.')
            return simpleName.replaceFirstChar { it.uppercase() }
        }

    fun isAssignableFrom(other: Class<*>): Boolean

    fun isAssignableFrom(other: DomainType): Boolean

    fun isAssignableTo(other: Class<*>): Boolean

    fun isAssignableTo(other: DomainType): Boolean

}

/**
 * Semantics of holding the value for the property
 */
enum class Cardinality {
    OPTIONAL,
    ONE,
    LIST,
    SET,
}

@JsonTypeInfo(
    use = JsonTypeInfo.Id.SIMPLE_NAME,
)
@JsonSubTypes(
    JsonSubTypes.Type(value = SimplePropertyDefinition::class, name = "simple"),
    JsonSubTypes.Type(value = DomainTypePropertyDefinition::class, name = "domain"),
)
sealed interface PropertyDefinition {
    val name: String
    val description: String
    val cardinality: Cardinality
}

data class SimplePropertyDefinition(
    override val name: String,
    val type: String = "string",
    override val cardinality: Cardinality = Cardinality.ONE,
    override val description: String = name,
) : PropertyDefinition

data class DomainTypePropertyDefinition(
    override val name: String,
    val type: DomainType,
    override val cardinality: Cardinality = Cardinality.ONE,
    override val description: String = name,
) : PropertyDefinition



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/DynamicType.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import com.embabel.common.util.indent
import com.embabel.common.util.indentLines

/**
 * Simple data type
 * @param name name of the type. Should be unique within a given context
 * @param description description of the type
 * @param properties properties of the type
 * @param parents parent types of this type. Can be JVM types or dynamic types
 */
data class DynamicType(
    override val name: String,
    override val description: String = name,
    override val ownProperties: List<PropertyDefinition> = emptyList(),
    override val parents: List<DomainType> = emptyList(),
    override val creationPermitted: Boolean = true,
) : DomainType {

    override fun isAssignableFrom(other: Class<*>): Boolean = false

    override fun isAssignableFrom(other: DomainType): Boolean = other.name == name

    override fun isAssignableTo(other: Class<*>): Boolean = false

    override fun isAssignableTo(other: DomainType): Boolean = other.name == name

    override fun children(additionalBasePackages: Collection<String>): Collection<DomainType> {
        // Dynamic types don't have classpath descendants
        return emptySet()
    }

    fun withProperty(
        property: PropertyDefinition,
    ): DynamicType {
        return copy(ownProperties = properties + property)
    }

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String {
        return """
                |name: $name
                |properties:
                |${properties.map { it }.joinToString("\n") { it.toString().indent(1) }}
                |"""
            .trimMargin()
            .indentLines(indent)
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/EarlyTerminationPolicy.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import com.embabel.agent.core.EarlyTerminationPolicy.Companion.maxActions
import com.embabel.agent.event.AbstractAgentProcessEvent

/**
 * Event triggered when an agent process is terminated early by a policy.
 *
 * @param agentProcess The agent process that is being terminated
 * @param reason A human-readable explanation of why the process is being terminated
 * @param policy The policy that triggered the termination
 */
class EarlyTermination(
    agentProcess: AgentProcess,
    val reason: String,
    val policy: EarlyTerminationPolicy,
) : AbstractAgentProcessEvent(agentProcess) {

    override fun toString(): String = "Early termination by policy ${policy.name} - $reason"
}

/**
 * Enables early termination of an agent process.
 *
 * Early termination policies provide a mechanism to stop agent processes before they
 * naturally complete. This is useful for enforcing constraints like maximum number of actions,
 * budget limits, or other custom termination conditions.
 *
 * Implementations should be stateless and thread-safe.
 */
interface EarlyTerminationPolicy {

    /**
     * The name of this policy, used for logging and debugging.
     * By default, uses the simple class name.
     */
    val name: String get() = this::class.simpleName ?: "Unknown"

    /**
     * Checks if the agent process should be terminated early.
     *
     * @param agentProcess The agent process to evaluate
     * @return An EarlyTermination object if the process should be terminated, or null if it should continue
     */
    fun shouldTerminate(agentProcess: AgentProcess): EarlyTermination?

    companion object {

        /**
         * Creates a policy that terminates the process after a maximum number of actions.
         *
         * @param maxActions The maximum number of actions allowed
         * @return An EarlyTerminationPolicy that enforces the action limit
         */
        @JvmStatic
        fun maxActions(maxActions: Int): EarlyTerminationPolicy =
            MaxActionsEarlyTerminationPolicy(maxActions)

        @JvmStatic
        fun maxTokens(maxTokens: Int): EarlyTerminationPolicy =
            MaxTokensEarlyTerminationPolicy(maxTokens)

        /**
         * Combines multiple early termination policies into one.
         * The process will terminate if any of the provided policies triggers termination.
         * Policies are evaluated in the order they are provided.
         *
         * @param earlyTerminationPolicies The policies to combine
         * @return A combined EarlyTerminationPolicy
         */
        @JvmStatic
        fun firstOf(vararg earlyTerminationPolicies: EarlyTerminationPolicy): EarlyTerminationPolicy =
            FirstOfEarlyTerminationPolicy(earlyTerminationPolicies.toList())

        /**
         * Fallback budget limit for the agent process.
         * This is a last resort termination policy to prevent runaway costs.
         *
         * @param budget The maximum cost allowed for the process in dollars
         * @return An EarlyTerminationPolicy that enforces the budget limit
         */
        @JvmStatic
        fun hardBudgetLimit(budget: Double): EarlyTerminationPolicy =
            MaxCostEarlyTerminationPolicy(budget)
    }
}

private data class MaxActionsEarlyTerminationPolicy(
    private val maxActions: Int,
) : EarlyTerminationPolicy {
    override fun shouldTerminate(agentProcess: AgentProcess): EarlyTermination? =
        if (agentProcess.history.size >= maxActions) {
            EarlyTermination(agentProcess, "Max actions of $maxActions reached", this)
        } else null

}

private data class MaxTokensEarlyTerminationPolicy(
    private val maxTokens: Int,
) : EarlyTerminationPolicy {
    override fun shouldTerminate(agentProcess: AgentProcess): EarlyTermination? =
        if ((agentProcess.usage().totalTokens ?: 0) >= maxTokens) {
            EarlyTermination(agentProcess, "Max tokens of $maxTokens reached", this)
        } else null

}

private data class MaxCostEarlyTerminationPolicy(
    private val budget: Double,
) : EarlyTerminationPolicy {
    override fun shouldTerminate(agentProcess: AgentProcess): EarlyTermination? =
        if (agentProcess.cost() >= budget) {
            EarlyTermination(
                agentProcess,
                "Exceeded budget of $${"%.4f".format(budget)}: cost=$${"%.4f".format(agentProcess.cost())}",
                this
            )
        } else null

}

private data class FirstOfEarlyTerminationPolicy(
    private val earlyTerminationPolicies: List<EarlyTerminationPolicy>,
) : EarlyTerminationPolicy {
    override fun shouldTerminate(agentProcess: AgentProcess): EarlyTermination? {
        for (earlyTerminationPolicy in earlyTerminationPolicies) {
            val termination = earlyTerminationPolicy.shouldTerminate(agentProcess)
            if (termination != null) {
                return termination
            }
        }
        return null
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/Goal.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import com.embabel.common.core.types.ZeroToOne
import com.embabel.common.util.indent
import com.embabel.common.util.indentLines
import com.embabel.plan.goap.ConditionDetermination
import com.embabel.plan.goap.EffectSpec
import com.embabel.plan.goap.GoapGoal
import com.fasterxml.jackson.annotation.JsonIgnore

/**
 * Agent platform goal. Exposes GOAP metadata.
 * @param name name of the goal
 * @param description description of the goal. This should be sufficiently detailed to enable goal choice by an LLM.
 * The goal description may also be exposed to MCP clients as a hint for the goal's purpose,
 * so ensure that it is clear and unambiguous.
 * @param pre preconditions for the goal, as a set of strings. These are the conditions that must be true before the goal can be achieved.
 * @param inputs inputs required for the goal, as a set of IoBinding objects. These are the inputs that must be provided to achieve the goal.
 * @param outputType if this goal returns a single instance of a domain type, this is the class that will be returned.
 * @param value value of the goal, as a ZeroToOne. This is the value of achieving the goal.
 * @param tags Set of tags describing classes or capabilities for this specific skill.
 *    example: ["cooking", "customer support", "billing"]
 * @param examples The set of example scenarios that the skill can perform.
 * Will be used by the client as a hint to understand how the skill can be used.
 *  example: ["I need a recipe for bread"]
 */
data class Goal(
    override val name: String,
    override val description: String,
    val pre: Set<String> = emptySet(),
    override val inputs: Set<IoBinding> = emptySet(),
    val outputType: DomainType?,
    override val value: ZeroToOne = 0.0,
    val tags: Set<String> = emptySet(),
    val examples: Set<String> = emptySet(),
    val export: Export = Export(),
) : GoapGoal, AgentSystemStep {

    // These methods are for Java, to obviate the builder antipattern
    fun withPreconditions(vararg preconditions: String): Goal {
        return copy(pre = pre + preconditions)
    }

    fun withGoalPreconditions(vararg goals: Goal): Goal {
        return copy(pre = pre + goals.flatMap { it.pre }.toSet())
    }

    /**
     * Create a goal with the given value.
     */
    fun withValue(value: Double): Goal {
        return copy(value = value)
    }

    @JsonIgnore
    override val preconditions: EffectSpec =
        run {
            val conditions = pre.associateWith { ConditionDetermination(true) }.toMutableMap()
            inputs.forEach { input ->
                conditions[input.value] = ConditionDetermination(true)
            }
            conditions
        }

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String =
        if (verbose == true)
            """|"$description" $name
               |preconditions:
               |${
                preconditions.map { it.key to "${it.key}: ${it.value}" }.sortedBy { it.first }
                    .joinToString("\n") { it.second.indent(1) }
            }
               |value: $value
               |"""
                .trimMargin()
                .indentLines(indent)
        else
            "$description: $name - pre=${preconditions} value=${value}"

    companion object {

        /**
         * Convenient method to create a goal requiring creating an instance of this type.
         * @param description description of the goal
         * @param type type of the instance to create. See [IoBinding].
         * @param name name of the goal, defaults to "Create ${type.simpleName}"
         */
        @JvmStatic
        @JvmOverloads
        fun createInstance(
            description: String,
            type: Class<*>,
            name: String = "Create ${type.simpleName}",
            tags: Set<String> = emptySet(),
            examples: Set<String> = emptySet(),
        ): Goal {
            return invoke(
                name = name,
                description = description,
                satisfiedBy = type,
                tags = tags,
                examples = examples,
            )
        }

        operator fun invoke(
            name: String,
            description: String,
            satisfiedBy: Class<*>? = null,
            requires: Set<Class<*>> = if (satisfiedBy != null) {
                setOf(satisfiedBy)
            } else {
                emptySet()
            },
            inputs: Set<IoBinding> = requires.map {
                IoBinding(
                    type = it,
                )
            }.toSet(),
            pre: List<Condition> = emptyList(),
            value: Double = 0.0,
            tags: Set<String> = emptySet(),
            examples: Set<String> = emptySet(),
        ): Goal {
            return Goal(
                name = name,
                description = description,
                inputs = inputs,
                pre = pre.map { it.name }.toSet(),
                outputType = if (satisfiedBy != null) JvmType(satisfiedBy) else null,
                value = value,
                tags = tags,
                examples = examples,
            )
        }
    }

}

/**
 * Metadata describing how a goal will be exported
 * @param name custom name for the goal when exported.
 * If null, the goal naming strategy will be used.
 * @param remote whether the goal is exported to a remote system (e.g., MCP).
 * @param local whether the goal is exported to a local system (e.g., agent platform for use in prompted actions)
 * @param startingInputTypes input types that we can prompt the user from to get to this goal.
 * Useful for MCP prompts. A Goal may not know all possible input types, but
 * it is still useful to be able to specify some of them. Include UserInput.class if the
 * goal can be achieved starting from text
 */
data class Export(
    val name: String? = null,
    val remote: Boolean = false,
    val local: Boolean = true,
    val startingInputTypes: Set<Class<*>> = emptySet(),
)



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/InProcess.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

/**
 * Superclass for events that relate to an AgentProcess
 */
interface InProcess {

    /**
     * ID of the process that this event relates to.
     */
    val processId: String
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/IoBinding.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import kotlin.reflect.KClass

/**
 * Binding definition of form name:Type
 * If name is omitted, it is assumed to be 'it'
 * Used to build preconditions from input and output bindings.
 * Default name ("it") has a special meaning. It will be satisfied
 * by an instance of the correct type being bound to "it", but also by
 * the final result of the action having the correct type.
 */
@JvmInline
value class IoBinding(val value: String) {
    init {
        require(value.isNotBlank()) { "Type definition must not be blank" }
    }

    constructor(
        name: String,
        type: String,
    ) : this("$name:$type")

    val type: String
        get() = if (value.contains(":")) {
            value.split(":")[1]
        } else {
            value
        }

    val name: String
        get() =
            if (value.contains(":")) {
                value.split(":")[0]
            } else {
                DEFAULT_BINDING
            }

    /**
     * Resolve the JVM type for this binding, if possible.
     * Dynamic types won't be resolved, and calling code must handle nulls.
     */
    fun resolveJvmType(): JvmType? {
        return try {
            val clazz = Class.forName(type)
            return JvmType(clazz)
        } catch (_: ClassNotFoundException) {
            null
        }
    }

    companion object {
        /**
         * The default binding, when it is not otherwise specified.
         * Consistent with Groovy and Kotlin behavior.
         */
        const val DEFAULT_BINDING = "it"

        operator fun invoke(
            name: String? = DEFAULT_BINDING,
            type: Class<*>,
        ): IoBinding {
            return IoBinding(value = "$name:${type.name}")
        }

        operator fun invoke(
            name: String? = DEFAULT_BINDING,
            type: KClass<*>,
        ) = invoke(name = name, type = type.java)

    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/JvmType.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import com.embabel.agent.api.common.SomeOf
import com.embabel.common.util.indentLines
import com.fasterxml.jackson.annotation.JsonClassDescription
import com.fasterxml.jackson.annotation.JsonCreator
import com.fasterxml.jackson.annotation.JsonIgnore
import com.fasterxml.jackson.annotation.JsonProperty
import org.slf4j.LoggerFactory

/**
 * Typed backed by a JVM object
 */
data class JvmType @JsonCreator constructor(
    @param:JsonProperty("className")
    val className: String,
) : DomainType {

    constructor(clazz: Class<*>) : this(clazz.name)

    @get:JsonIgnore
    override val creationPermitted: Boolean
        get() {
            val cpa = clazz.getAnnotation(CreationPermitted::class.java)
            return cpa != null
        }

    @get:JsonIgnore
    override val parents: List<JvmType>
        get() {
            val superclass = clazz.superclass
            val parentList = mutableListOf<JvmType>()
            if (superclass != null && superclass != Object::class.java) {
                parentList.add(JvmType(superclass))
            }
            clazz.interfaces.forEach { parentList.add(JvmType(it)) }
            return parentList
        }

    @get:JsonIgnore
    val clazz: Class<*> by lazy {
        Class.forName(className)
    }

    @get:JsonIgnore
    override val name: String
        get() = className

    @get:JsonIgnore
    override val ownLabel: String
        get() = clazz.simpleName

    @get:JsonIgnore
    override val description: String
        get() {
            val ann = clazz.getAnnotation(JsonClassDescription::class.java)
            return if (ann != null) {
                "${clazz.simpleName}: ${ann.value}"
            } else {
                clazz.name
            }
        }

    override fun isAssignableFrom(other: Class<*>): Boolean =
        clazz.isAssignableFrom(other)

    override fun isAssignableFrom(other: DomainType): Boolean =
        when (other) {
            is JvmType -> clazz.isAssignableFrom(other.clazz)
            is DynamicType -> false
        }

    override fun isAssignableTo(other: Class<*>): Boolean =
        other.isAssignableFrom(clazz)

    override fun isAssignableTo(other: DomainType): Boolean =
        when (other) {
            is JvmType -> other.clazz.isAssignableFrom(clazz)
            is DynamicType -> false
        }

    override fun children(additionalBasePackages: Collection<String>): Collection<JvmType> {
        val basePackagesToUse = additionalBasePackages.ifEmpty {
            listOf(clazz.packageName)
        }
        val scanner = org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider(false)
        scanner.addIncludeFilter(org.springframework.core.type.filter.AssignableTypeFilter(clazz))

        val result = mutableListOf<JvmType>()

        for (packageName in basePackagesToUse) {
            try {
                val candidateComponents = scanner.findCandidateComponents(packageName)
                for (beanDef in candidateComponents) {
                    try {
                        val className = beanDef.beanClassName
                        if (className != null && className != clazz.name) {
                            val candidateClass = Class.forName(className)
                            // Exclude the class itself and ensure it's actually assignable
                            if (candidateClass != clazz && clazz.isAssignableFrom(candidateClass)) {
                                result.add(JvmType(candidateClass))
                            }
                        }
                    } catch (e: ClassNotFoundException) {
                        // Skip classes that can't be loaded
                        JvmType.logger.debug("Could not load class: ${beanDef.beanClassName}", e)
                    } catch (e: Exception) {
                        // Skip classes that cause other issues
                        JvmType.logger.debug("Error processing class: ${beanDef.beanClassName}", e)
                    }
                }
            } catch (e: Exception) {
                // Skip packages that can't be scanned
                JvmType.logger.debug("Could not scan package: $packageName", e)
            }
        }

        return result.toSet()
    }

    @get:JsonIgnore
    override val ownProperties: List<PropertyDefinition>
        get() {
            return clazz.declaredFields.mapNotNull { field ->
                // Check if it's a collection with a generic type parameter
                if (Collection::class.java.isAssignableFrom(field.type) && field.genericType is java.lang.reflect.ParameterizedType) {
                    val parameterizedType = field.genericType as java.lang.reflect.ParameterizedType
                    val typeArg = parameterizedType.actualTypeArguments.firstOrNull() as? Class<*>
                    if (typeArg != null && shouldNestAsEntity(typeArg)) {
                        val cardinality = when {
                            Set::class.java.isAssignableFrom(field.type) -> Cardinality.SET
                            else -> Cardinality.LIST
                        }
                        return@mapNotNull DomainTypePropertyDefinition(
                            name = field.name,
                            type = JvmType(typeArg),
                            cardinality = cardinality,
                        )
                    }
                    // Collection of scalars - return simple property
                    return@mapNotNull SimplePropertyDefinition(
                        name = field.name,
                        type = field.type.simpleName,
                    )
                } else if (shouldNestAsEntity(field.type)) {
                    DomainTypePropertyDefinition(
                        name = field.name,
                        type = JvmType(field.type),
                    )
                } else {
                    SimplePropertyDefinition(
                        name = field.name,
                        type = field.type.simpleName,
                    )
                }
            }
        }

    private fun shouldNestAsEntity(type: Class<*>): Boolean {
        // Primitives and their wrappers are scalars
        if (type.isPrimitive || type == java.lang.Boolean::class.java ||
            type == java.lang.Byte::class.java || type == java.lang.Short::class.java ||
            type == java.lang.Integer::class.java || type == java.lang.Long::class.java ||
            type == java.lang.Float::class.java || type == java.lang.Double::class.java ||
            type == java.lang.Character::class.java
        ) {
            return false
        }
        // Common scalar types
        if (type == String::class.java || type == java.math.BigDecimal::class.java ||
            type == java.math.BigInteger::class.java || type == java.util.Date::class.java ||
            type == java.time.LocalDate::class.java || type == java.time.LocalDateTime::class.java ||
            type == java.time.Instant::class.java
        ) {
            return false
        }
        // Collections are not nested as entities (their element types might be)
        if (Collection::class.java.isAssignableFrom(type) || Map::class.java.isAssignableFrom(type)) {
            return false
        }
        // Everything else is considered an entity
        return true
    }

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String {
        return """
                |class: ${clazz.name}
                |"""
            .trimMargin()
            .indentLines(indent)
    }

    companion object {

        private val logger = LoggerFactory.getLogger(JvmType::class.java)

        /**
         * May need to break up with SomeOf
         */
        fun fromClasses(
            classes: Collection<Class<*>>,
        ): Collection<JvmType> {
            return classes.flatMap {
                if (SomeOf::class.java.isAssignableFrom(it)) {
                    SomeOf.eligibleFields(it)
                        .map { field ->
                            JvmType(field.type)
                        }
                } else {
                    listOf(JvmType(it))
                }
            }.toSet()
        }
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/LlmInvocation.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import com.embabel.agent.api.common.ToolsStats
import com.embabel.common.ai.model.Llm
import com.embabel.common.core.types.Timed
import com.embabel.common.core.types.Timestamped
import org.springframework.ai.chat.metadata.DefaultUsage
import java.time.Duration
import java.time.Instant

interface LlmInvocationHistory {

    val llmInvocations: List<LlmInvocation>

    val toolsStats: ToolsStats

    fun cost(): Double {
        return llmInvocations.sumOf { it.cost() }
    }

    /**
     * Distinct list of LLMs use, sorted by name.
     */
    fun modelsUsed(): List<Llm> {
        return llmInvocations.map { it.llm }
            .distinctBy { it.name }
            .sortedBy { it.name }
    }

    /**
     * Note that this is not apples to apples: The usage
     * may be across different LLMs, and the cost may be different.
     * Cost will correctly reflect this.
     * Look in the list for more details about what tokens were spent where.
     */
    fun usage(): Usage {
        val promptTokens = llmInvocations.sumOf { it.usage.promptTokens ?: 0 }
        val completionTokens = llmInvocations.sumOf { it.usage.completionTokens ?: 0 }
        return Usage(promptTokens, completionTokens, null)
    }

    fun costInfoString(verbose: Boolean): String {
        val usage = usage()
        return if (verbose)
            """|LLMs used: ${modelsUsed().map { it.name }} across ${llmInvocations.size} calls
               |Prompt tokens: ${"%,d".format(usage.promptTokens)},
               |Completion tokens: ${"%,d".format(usage.completionTokens)}
               |Cost: $${"%.4f".format(cost())}
               |"""
                .trimMargin()
        else "LLMs: ${modelsUsed().map { it.name }} across ${llmInvocations.size} calls; " +
                "prompt tokens: ${"%,d".format(usage.promptTokens)}; completion tokens: ${
                    "%,d".format(
                        usage.completionTokens
                    )
                }; cost: $${"%.4f".format(cost())}"
    }

}

/**
 * LLM usage data
 */
data class Usage(
    val promptTokens: Int?,
    val completionTokens: Int?,
    val nativeUsage: Any?,
) {

    val totalTokens: Int?
        get() = when {
            promptTokens == null && completionTokens == null -> null
            else -> (promptTokens ?: 0) + (completionTokens ?: 0)
        }
}

/**
 * Invocation we made to an LLM
 * @param agentName name of the agent, if known
 */
data class LlmInvocation(
    val llm: Llm,
    val usage: Usage,
    val agentName: String? = null,
    override val timestamp: Instant,
    override val runningTime: Duration,
) : Timestamped, Timed {

    /**
     * Dollar cost of this interaction.
     */
    fun cost(): Double = llm.pricingModel?.costOf(
        DefaultUsage(
            usage.promptTokens ?: 0,
            usage.completionTokens ?: 0,
        )
    ) ?: 0.0
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/Operation.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import com.embabel.common.core.types.Named
import com.embabel.common.core.types.NamedAndDescribed
import com.embabel.plan.goap.GoapStep

/**
 * Named operation in agent system: Action, Goal or Condition
 */
sealed interface Operation : Named


interface AgentSystemStep : GoapStep, NamedAndDescribed, Operation {

    /**
     * Data inputs to this step.
     * Will be used to build preconditions,
     * in addition to explicit preconditions.
     */
    val inputs: Set<IoBinding>

}

/**
 * Step that takes data as input and produces data as output.
 */
interface DataFlowStep : AgentSystemStep {

    /**
     * Expected data outputs of the step.
     */
    val outputs: Set<IoBinding>

}

/**
 * Access to agent infrastructure via injected parameter.
 */
interface InjectedType : Operation {

    companion object {
        fun named(name: String): InjectedType = object : InjectedType {
            override val name: String = name
        }
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/OperationStatus.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import com.embabel.common.core.types.Timed
import java.time.Duration

/**
 * Stuck means we failed to find a plan from here
 */
enum class AgentProcessStatusCode {

    /** The process has not started yet */
    NOT_STARTED,

    /** The process is running without any known problems */
    RUNNING,

    /** The process has completed successfully */
    COMPLETED,

    /** Game over. The process has failed */
    FAILED,

    /** The process has been killed by an early termination policy */
    TERMINATED,

    /** The process has been killed by the user or platform, from outside */
    KILLED,

    /** The process cannot formulate a plan to progress. This does not necessarily mean failure. Something might change */
    STUCK,

    /** The process is waiting for user input or another external event */
    WAITING,

    /**
     * The process is running without error but has paused because
     * of scheduling policy.
     **/
    PAUSED,
}

enum class ActionStatusCode {
    /** The action succeeded */
    SUCCEEDED,

    /** The action failed */
    FAILED,

    /** The action result means we're waiting for user input or another external event */
    WAITING,

    PAUSED,
}

/**
 * Status of an agent or action
 */
interface OperationStatus<S> : Timed where S : Enum<S> {

    /**
     * Status of this operation
     */
    val status: S
}

/**
 * Status of action execution.
 * Concrete results of running the action will be side effects:
 * typically, changes to the ProcessContext blackboard.
 * This just indicates what happened.
 */
open class ActionStatus(
    override val runningTime: Duration,
    override val status: ActionStatusCode,
) : OperationStatus<ActionStatusCode>



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/ProcessContext.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import com.embabel.agent.api.common.PlatformServices
import com.embabel.agent.channel.OutputChannel
import com.embabel.agent.event.AgenticEventListener
import com.embabel.agent.event.MulticastAgenticEventListener
import com.embabel.agent.spi.LlmOperations

/**
 * Process state and services. Created by the platform,
 * not user code.
 */
data class ProcessContext(
    val processOptions: ProcessOptions = ProcessOptions(),
    internal val platformServices: PlatformServices,
    val outputChannel: OutputChannel = platformServices.outputChannel + processOptions.outputChannel,
    val agentProcess: AgentProcess,
) : LlmOperations by platformServices.llmOperations, AgenticEventListener by MulticastAgenticEventListener(
    processOptions.listeners + platformServices.eventListener,
) {

    val blackboard: Blackboard
        get() = agentProcess

    /**
     * Get a variable value. Handles "it" default type specially,
     * because it could be an "it" of different variables, defined
     * as the most recently added entry.
     */
    fun getValue(
        variable: String,
        type: String,
    ): Any? =
        blackboard.getValue(
            variable = variable, type = type,
            dataDictionary = agentProcess.agent,
        )
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/ProcessOptions.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import com.embabel.agent.channel.DevNullOutputChannel
import com.embabel.agent.channel.OutputChannel
import com.embabel.agent.event.AgenticEventListener
import com.embabel.agent.identity.User
import java.util.function.Consumer

interface LlmVerbosity {
    val showPrompts: Boolean
    val showLlmResponses: Boolean
}

/**
 * Controls log output.
 */
data class Verbosity(
    override val showPrompts: Boolean = false,
    override val showLlmResponses: Boolean = false,
    val debug: Boolean = false,
    val showPlanning: Boolean = false,
) : LlmVerbosity {
    val showLongPlans: Boolean get() = showPlanning || debug || showLlmResponses || showPrompts

    companion object {

        /**
         * Obtain a new [Builder] to for [Verbosity].
         *
         * @return a builder through which you can set verbosity options
         */
        @JvmStatic
        fun builder(): Builder {
            return Builder()
        }
    }

    /**
     * Nested builder for [Verbosity] objects.
     */
    class Builder internal constructor() {

        private var verbosity = Verbosity()

        /**
         * Show or hide the prompts sent to the agent.
         * @param showPrompts whether to display prompts
         * @return this [Builder]
         */
        fun showPrompts(showPrompts: Boolean): Builder {
            this.verbosity = this.verbosity.copy(showPrompts = showPrompts)
            return this
        }

        /**
         * Show or hide the responses received from the LLM.
         * @param showLlmResponses whether to display LLM responses
         * @return this [Builder]
         */
        fun showLlmResponses(showLlmResponses: Boolean): Builder {
            this.verbosity = this.verbosity.copy(showLlmResponses = showLlmResponses)
            return this
        }

        /**
         * Enable or disable debugging output.
         * @param debug true to enable debugging, false otherwise
         * @return this [Builder]
         */
        fun debug(debug: Boolean): Builder {
            this.verbosity = this.verbosity.copy(debug = debug)
            return this
        }

        /**
         * Show or hide planning steps taken by the agent.
         * @param showPlanning whether to display planning details
         * @return this [Builder]
         */
        fun showPlanning(showPlanning: Boolean): Builder {
            this.verbosity = this.verbosity.copy(showPlanning = showPlanning)
            return this
        }

        /**
         * Build the [Verbosity].
         * @return a newly built [Verbosity]
         */
        fun build(): Verbosity {
            return this.verbosity
        }
    }

}

enum class Delay {
    NONE, MEDIUM, LONG
}

/**
 *  Controls how an AgentProcess is run.
 *  Prevents infinite loops, enforces budget limits, and manages delays.
 */
data class ProcessControl(
    val toolDelay: Delay = Delay.NONE,
    val operationDelay: Delay = Delay.NONE,
    val earlyTerminationPolicy: EarlyTerminationPolicy,
) {

    fun withToolDelay(toolDelay: Delay): ProcessControl =
        this.copy(toolDelay = toolDelay)

    fun withOperationDelay(operationDelay: Delay): ProcessControl =
        this.copy(operationDelay = operationDelay)

    fun withEarlyTerminationPolicy(earlyTerminationPolicy: EarlyTerminationPolicy): ProcessControl =
        this.copy(earlyTerminationPolicy = earlyTerminationPolicy)

    companion object {

        /**
         * Obtain a new [Builder] to for [ProcessControl].
         *
         * @param earlyTerminationPolicy the early termination policy to use
         * @return a builder through which you can set process control options
         */
        @JvmStatic
        fun builder(earlyTerminationPolicy: EarlyTerminationPolicy): Builder {
            return Builder(earlyTerminationPolicy)
        }
    }

    /**
     * Nested builder for [ProcessControl] objects.
     */
    class Builder internal constructor(earlyTerminationPolicy: EarlyTerminationPolicy) {

        private var processControl = ProcessControl(earlyTerminationPolicy = earlyTerminationPolicy)

        /**
         * Sets the delay for tools.
         * @param delay the new delay
         * @return this [Builder]
         */
        fun toolDelay(delay: Delay): Builder {
            this.processControl = processControl.copy(toolDelay = delay)
            return this
        }

        /**
         * Sets the delay for operations.
         * @param delay the new delay
         * @return this [Builder]
         */
        fun operationDelay(delay: Delay): Builder {
            this.processControl = processControl.copy(operationDelay = delay)
            return this
        }

        /**
         * Sets the early termination policy.
         * @param terminationPolicy the new termination policy
         * @return this [Builder]
         */
        fun earlyTerminationPolicy(terminationPolicy: EarlyTerminationPolicy): Builder {
            this.processControl = processControl.copy(earlyTerminationPolicy = terminationPolicy)
            return this
        }

        /**
         * Build the [ProcessControl].
         * @return a newly built [ProcessControl]
         */
        fun build(): ProcessControl {
            return this.processControl
        }

    }

}

/**
 * Budget for an agent process.
 * @param cost the cost of running the process, in USD.
 * @param actions the maximum number of actions the agent can perform before termination.
 * @param tokens the maximum number of tokens the agent can use before termination. This can be useful in the case of
 * local models where the cost is not directly measurable, but we don't want excessive work.
 */
data class Budget(
    val cost: Double = DEFAULT_COST_LIMIT,
    val actions: Int = DEFAULT_ACTION_LIMIT,
    val tokens: Int = DEFAULT_TOKEN_LIMIT,
) {

    fun earlyTerminationPolicy(): EarlyTerminationPolicy {
        return EarlyTerminationPolicy.firstOf(
            EarlyTerminationPolicy.maxActions(maxActions = actions),
            EarlyTerminationPolicy.maxTokens(maxTokens = tokens),
            EarlyTerminationPolicy.hardBudgetLimit(budget = cost),
        )
    }

    companion object {

        const val DEFAULT_COST_LIMIT = 2.0

        /**
         * Default maximum number of actions an agent process can perform before termination.
         */
        const val DEFAULT_ACTION_LIMIT = 50

        const val DEFAULT_TOKEN_LIMIT = 1000000

        /**
         * Obtain a new [Builder] to for [Budget].
         *
         * @return a builder through which you can set budget options
         */
        @JvmStatic
        fun builder(): Builder {
            return Builder()
        }

    }

    /**
     * Nested builder for [Budget] objects.
     */
    class Builder internal constructor() {

        private var budget = Budget()

        /**
         * Sets the cost of running the process, in USD.
         * @param cost the cost limit
         * @return this [Builder]
         */
        fun cost(cost: Double): Builder {
            this.budget = this.budget.copy(cost = cost)
            return this
        }

        /**
         * Set the maximum number of actions the agent can perform before termination.
         * @param actions the action count limit
         * @return this [Builder]
         */
        fun actions(actions: Int): Builder {
            this.budget = this.budget.copy(actions = actions)
            return this
        }

        /**
         * Set a maximum the maximum number of tokens the agent can use before termination.
         * This can be useful in the case of local models where the cost is not directly measurable,
         * but we don't want excessive work.
         * @param tokens the token count limit
         * @return this [Builder]
         */
        fun tokens(tokens: Int): Builder {
            this.budget = this.budget.copy(tokens = tokens)
            return this
        }

        /**
         * Build the [Budget].
         * @return a newly built [Budget]
         */
        fun build(): Budget {
            return this.budget
        }

    }

}

/**
 * Identities associated with an agent process.
 * @param forUser the user for whom the process is running. Can be null.
 * @param runAs the user under which the process is running. Can be null.
 */
data class Identities(
    val forUser: User? = null,
    val runAs: User? = null,
)

/**
 * How to run an AgentProcess
 * @param contextId context id to use for this process. Can be null.
 * If set it can enable connection to external resources and persistence
 * from previous runs.
 * @param identities identities associated with this process.
 * @param blackboard an existing blackboard to use for this process.
 * By default, it will be modified as the process runs.
 * Whether this is an independent copy is up to the caller, who can call spawn()
 * before passing this argument.
 * @param budget budget constraints for this process. Will be exposed to actions
 * and tools and enforced by default ProcessControl.
 * @param processControl custom ProcessControl if specified. If not specified, default will be based on Budget.
 * If specified, this overrides the budget-based defaults and may not relate
 * to the budget.
 * @param verbosity detailed verbosity settings for logging etc.
 * @param prune whether to prune the agent to only relevant actions
 * @param listeners additional listeners (beyond platform event listeners) to receive events from this process.
 */
data class ProcessOptions(
    val contextId: ContextId? = null,
    val identities: Identities = Identities(),
    val blackboard: Blackboard? = null,
    val verbosity: Verbosity = Verbosity(),
    val budget: Budget = Budget(),
    private val processControl: ProcessControl? = null,
    val prune: Boolean = false,
    val listeners: List<AgenticEventListener> = emptyList(),
    val outputChannel: OutputChannel = DevNullOutputChannel,
) {

    /**
     * ProcessControl in effect for this process
     */
    val control: ProcessControl
        get() {
            return processControl ?: ProcessControl(
                toolDelay = Delay.NONE,
                operationDelay = Delay.NONE,
                earlyTerminationPolicy = budget.earlyTerminationPolicy(),
            )
        }

    companion object {

        @JvmField
        val DEFAULT = ProcessOptions()

        /**
         * Obtain a new [Builder] to for [ProcessOptions].
         *
         * @return a builder through which you can set processing options
         */
        @JvmStatic
        fun builder(): Builder {
            return Builder()
        }

    }

    /**
     * Nested builder for [ProcessOptions] objects.
     */
    class Builder internal constructor() {

        private var processOptions = DEFAULT

        /**
         * Set the context identifier to use for the invocation. Can be null.
         * If set it can enable connection to external resources and persistence
         * from previous runs.
         * @param contextId the context ID to associate with this invocation, or null
         * @return this [Builder]
         */
        @JvmName("contextId")
        fun contextId(contextId: ContextId?): Builder {
            this.processOptions = processOptions.copy(contextId = contextId)
            return this
        }

        /**
         * Sets the identities associated with the process.
         * @param identities the identities
         * @return this [Builder]
         */
        fun identities(identities: Identities): Builder {
            this.processOptions = processOptions.copy(identities = identities)
            return this
        }

        /**
         * An existing blackboard to use for this invocation.
         * By default, it will be modified as the process runs.
         * @param blackboard the existing blackboard to use
         * @return this [Builder]
         */
        fun blackboard(blackboard: Blackboard): Builder {
            this.processOptions = processOptions.copy(blackboard = blackboard)
            return this
        }

        /**
         * Set a specific verbosity directly.
         * @param verbosity the desired verbosity
         * @return this [Builder]
         */
        fun verbosity(verbosity: Verbosity): Builder {
            this.processOptions = processOptions.copy(verbosity = verbosity)
            return this
        }

        /**
         * Configure verbosity settings via a nested builder.
         * @param consumer a function that takes a [Verbosity.Builder]
         * @return this [Builder]
         */
        fun verbosity(consumer: Consumer<Verbosity.Builder>): Builder {
            val verbosityBuilder = Verbosity.builder()
            consumer.accept(verbosityBuilder)
            this.processOptions = processOptions.copy(verbosity = verbosityBuilder.build())
            return this
        }

        /**
         * Set budget constraints directly.
         * @param budget the budget settings to apply
         * @return this [Builder]
         */
        fun budget(budget: Budget): Builder {
            this.processOptions = processOptions.copy(budget = budget)
            return this
        }

        /**
         * Configure budget constraints via a nested builder.
         * @param consumer a function that takes a [Budget.Builder]
         * @return this [Builder]
         */
        fun budget(consumer: Consumer<Budget.Builder>): Builder {
            val budgetBuilder = Budget.builder()
            consumer.accept(budgetBuilder)
            this.processOptions = processOptions.copy(budget = budgetBuilder.build())
            return this
        }

        /**
         * Set process control settings directly.
         * @param control the control policy settings
         * @return this [Builder]
         */
        fun control(control: ProcessControl): Builder {
            this.processOptions = processOptions.copy(processControl = control)
            return this
        }

        /**
         * Configure process control setting via a nested builder.
         * @param consumer a function that takes a [ProcessControl.Builder]
         * @return this [Builder]
         */
        fun control(consumer: Consumer<ProcessControl.Builder>): Builder {
            val controlBuilder = ProcessControl.builder(
                this.processOptions.budget.earlyTerminationPolicy()
            )
            consumer.accept(controlBuilder)
            this.processOptions = processOptions.copy(processControl = controlBuilder.build())
            return this
        }

        /**
         * Whether to prune the agent to only relevant actions
         * @param prune true to prune the agent to only relevant actions
         * @return this [Builder]
         */
        fun prune(prune: Boolean): Builder {
            this.processOptions = processOptions.copy(prune = prune)
            return this
        }

        /**
         * Add a listener to the list of [AgenticEventListener]s.
         * @param listener the listener to add
         * @return this [Builder]
         */
        fun listener(listener: AgenticEventListener): Builder {
            val listeners = this.processOptions.listeners + listener
            this.processOptions = processOptions.copy(listeners = listeners)
            return this
        }

        /**
         * Manipulate the listeners with the given consumer.
         * The list provided to the consumer can be used to remove listeners, change ordering, etc.
         * @param listener the listener to add
         * @return this [Builder]
         */
        fun listeners(consumer: Consumer<List<AgenticEventListener>>): Builder {
            val listeners = this.processOptions.listeners.toMutableList()
            consumer.accept(listeners)
            this.processOptions = processOptions.copy(listeners = listeners)
            return this
        }

        /**
         * Build the [ProcessOptions].
         * @return a newly built [ProcessOptions]
         */
        fun build(): ProcessOptions {
            return this.processOptions
        }

    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/ToolConsumer.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import com.embabel.agent.spi.ToolGroupResolver
import com.embabel.common.core.types.AssetCoordinates
import com.embabel.common.core.types.HasInfoString
import com.embabel.common.core.types.Semver
import com.embabel.common.util.indent
import com.embabel.common.util.loggerFor
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import org.springframework.ai.tool.ToolCallback

interface ToolGroupDescription {

    /**
     * Natural language description of the tool group.
     * May be used by an LLM to choose tool groups so should be informative.
     * Tool groups with the same role should have similar descriptions,
     * although they should call out any unique features.
     */
    val description: String

    /**
     * Role of the tool group. Many tool groups can provide this
     * Multiple tool groups can provide the same role,
     * for example with different QoS.
     */
    val role: String

    companion object {

        operator fun invoke(
            description: String,
            role: String,
        ): ToolGroupDescription = ToolGroupDescriptionImpl(
            description = description,
            role = role,
        )

        @JvmStatic
        fun create(
            description: String,
            role: String,
        ): ToolGroupDescription = invoke(
            description = description,
            role = role,
        )
    }

}

private data class ToolGroupDescriptionImpl(
    override val description: String,
    override val role: String,
) : ToolGroupDescription

enum class ToolGroupPermission {
    /**
     * Tool group can be used to modify local resources.
     * This is a strong permission and should be used with caution.
     */
    HOST_ACCESS,

    /**
     * Tool group accesses the internet.
     */
    INTERNET_ACCESS,
}

/**
 * Metadata about a tool group. Interface as platforms
 * may extend it
 */
@JsonDeserialize(`as` = MinimalToolGroupMetadata::class)
interface ToolGroupMetadata : ToolGroupDescription, AssetCoordinates, HasInfoString {

    /**
     * What this tool group's tools are allowed to do.
     */
    val permissions: Set<ToolGroupPermission>

    companion object {
        operator fun invoke(
            description: String,
            role: String,
            name: String,
            provider: String,
            permissions: Set<ToolGroupPermission>,
            version: Semver = Semver(),
        ): ToolGroupMetadata = MinimalToolGroupMetadata(
            description = description,
            role = role,
            name = name,
            provider = provider,
            permissions = permissions,
            version = version,
        )

        operator fun invoke(
            description: ToolGroupDescription,
            name: String,
            provider: String,
            permissions: Set<ToolGroupPermission>,
            version: Semver = Semver(),
        ): ToolGroupMetadata = MinimalToolGroupMetadata(
            description = description.description,
            role = description.role,
            name = name,
            provider = provider,
            permissions = permissions,
            version = version,
        )
    }

}

private data class MinimalToolGroupMetadata(
    override val description: String,
    override val role: String,
    override val name: String,
    override val provider: String,
    override val permissions: Set<ToolGroupPermission>,
    override val version: Semver,
) : ToolGroupMetadata {

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String {
        return "role:$role, artifact:$name, version:$version, provider:$provider - $description".indent(indent)
    }
}


interface ToolCallbackSpec {

    /**
     * Tool callbacks referenced or exposed.
     */
    val toolCallbacks: List<ToolCallback>

}

interface ToolCallbackConsumer : ToolCallbackSpec

/**
 * Specifies a tool group that a tool consumer requires.
 */
data class ToolGroupRequirement(
    val role: String,
)

interface ToolGroupConsumer {

    /**
     * Tool groups exposed. This will include directly registered tool groups
     * and tool groups resolved from ToolGroups.
     */
    val toolGroups: Set<ToolGroupRequirement>
}

/**
 * Allows consuming tools and exposing them to LLMs.
 * Interface allowing abstraction between tool concept
 * and specific tools.
 */
interface ToolConsumer : ToolCallbackConsumer,
    ToolGroupConsumer {

    val name: String

    fun resolveToolCallbacks(toolGroupResolver: ToolGroupResolver): List<ToolCallback> =
        resolveToolCallbacks(
            toolConsumer = this,
            toolGroupResolver = toolGroupResolver,
        )

    companion object {

        // Factored into companion so Java can use it
        fun resolveToolCallbacks(
            toolConsumer: ToolConsumer,
            toolGroupResolver: ToolGroupResolver,
        ): List<ToolCallback> {
            val tools = mutableListOf<ToolCallback>()
            tools += toolConsumer.toolCallbacks
            for (role in toolConsumer.toolGroups) {
                val resolution = toolGroupResolver.resolveToolGroup(role)
                if (resolution.resolvedToolGroup == null) {
                    loggerFor<ToolConsumer>().warn(
                        "Could not resolve tool group with role='{}': {}\n{}",
                        role,
                        resolution.failureMessage,
                        NO_TOOLS_WARNING,
                    )
                } else if (resolution.resolvedToolGroup.toolCallbacks.isEmpty()) {
                    loggerFor<ToolConsumer>().warn(
                        "No tools found for tool group with role='{}': {}\n{}",
                        role,
                        resolution.failureMessage,
                        NO_TOOLS_WARNING,
                    )
                } else {
                    tools += resolution.resolvedToolGroup.toolCallbacks
                }
            }
            loggerFor<ToolConsumer>().debug(
                "{} resolved {} tools from {} tools and {} tool groups: {}",
                toolConsumer.name,
                tools.size,
                toolConsumer.toolCallbacks.size,
                toolConsumer.toolGroups.size,
                tools.map { it.toolDefinition.name() },
            )
            return tools.distinctBy { it.toolDefinition.name() }.sortedBy { it.toolDefinition.name() }
        }
    }
}

/**
 * Implemented by classes that want to publish tool callbacks
 */
interface ToolCallbackPublisher : ToolCallbackSpec {

    companion object {

        operator fun invoke(toolCallbacks: List<ToolCallback> = emptyList()) = object : ToolCallbackPublisher {
            override val toolCallbacks: List<ToolCallback> = toolCallbacks
        }
    }
}

private const val NO_TOOLS_WARNING =
    """

▗▖  ▗▖ ▗▄▖     ▗▄▄▄▖▗▄▖  ▗▄▖ ▗▖    ▗▄▄▖    ▗▄▄▄▖ ▗▄▖ ▗▖ ▗▖▗▖  ▗▖▗▄▄▄
▐▛▚▖▐▌▐▌ ▐▌      █ ▐▌ ▐▌▐▌ ▐▌▐▌   ▐▌       ▐▌   ▐▌ ▐▌▐▌ ▐▌▐▛▚▖▐▌▐▌  █
▐▌ ▝▜▌▐▌ ▐▌      █ ▐▌ ▐▌▐▌ ▐▌▐▌    ▝▀▚▖    ▐▛▀▀▘▐▌ ▐▌▐▌ ▐▌▐▌ ▝▜▌▐▌  █
▐▌  ▐▌▝▚▄▞▘      █ ▝▚▄▞▘▝▚▄▞▘▐▙▄▄▖▗▄▄▞▘    ▐▌   ▝▚▄▞▘▝▚▄▞▘▐▌  ▐▌▐▙▄▄▀



▗▄▄▖ ▗▄▄▖  ▗▄▖ ▗▄▄▖  ▗▄▖ ▗▄▄▖ ▗▖   ▗▄▄▄▖    ▗▖  ▗▖▗▄▄▄▖ ▗▄▄▖ ▗▄▄▖ ▗▄▖ ▗▖  ▗▖▗▄▄▄▖▗▄▄▄▖ ▗▄▄▖▗▖ ▗▖▗▄▄▖  ▗▄▖▗▄▄▄▖▗▄▄▄▖ ▗▄▖ ▗▖  ▗▖
▐▌ ▐▌▐▌ ▐▌▐▌ ▐▌▐▌ ▐▌▐▌ ▐▌▐▌ ▐▌▐▌   ▐▌       ▐▛▚▞▜▌  █  ▐▌   ▐▌   ▐▌ ▐▌▐▛▚▖▐▌▐▌     █  ▐▌   ▐▌ ▐▌▐▌ ▐▌▐▌ ▐▌ █    █  ▐▌ ▐▌▐▛▚▖▐▌
▐▛▀▘ ▐▛▀▚▖▐▌ ▐▌▐▛▀▚▖▐▛▀▜▌▐▛▀▚▖▐▌   ▐▛▀▀▘    ▐▌  ▐▌  █   ▝▀▚▖▐▌   ▐▌ ▐▌▐▌ ▝▜▌▐▛▀▀▘  █  ▐▌▝▜▌▐▌ ▐▌▐▛▀▚▖▐▛▀▜▌ █    █  ▐▌ ▐▌▐▌ ▝▜▌
▐▌   ▐▌ ▐▌▝▚▄▞▘▐▙▄▞▘▐▌ ▐▌▐▙▄▞▘▐▙▄▄▖▐▙▄▄▖    ▐▌  ▐▌▗▄█▄▖▗▄▄▞▘▝▚▄▄▖▝▚▄▞▘▐▌  ▐▌▐▌   ▗▄█▄▖▝▚▄▞▘▝▚▄▞▘▐▌ ▐▌▐▌ ▐▌ █  ▗▄█▄▖▝▚▄▞▘▐▌  ▐▌




"""

/**
 * A group of tools to accomplish a purpose, such as web search.
 * Introduces a level of abstraction over tool callbacks.
 */
interface ToolGroup : ToolCallbackPublisher, HasInfoString {

    val metadata: ToolGroupMetadata

    companion object {

        operator fun invoke(
            metadata: ToolGroupMetadata,
            toolCallbacks: List<ToolCallback>,
        ): ToolGroup = ToolGroupImpl(
            metadata = metadata,
            toolCallbacks = toolCallbacks,
        )
    }

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String {
        if (toolCallbacks.isEmpty()) {
            return metadata.infoString(verbose = true, indent = 1) + "- ❌ No tools found".indent(1)
        }
        return when (verbose) {
            true -> metadata.infoString(verbose = true, indent = 1) + " - " +
                    toolCallbacks
                        .sortedBy { it.toolDefinition.name() }
                        .joinToString { it.toolDefinition.name() }.indent(1)

            else -> {
                metadata.infoString(verbose = false)
            }
        }
    }
}

private data class ToolGroupImpl(
    override val metadata: ToolGroupMetadata,
    override val toolCallbacks: List<ToolCallback>,
) : ToolGroup

/**
 * Resolution of a tool group request
 * @param failureMessage Failure message in case we could not resolve this group.
 */
data class ToolGroupResolution(
    val resolvedToolGroup: ToolGroup?,
    val failureMessage: String? = null,
)



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/deployment/AgentPublisher.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core.deployment

import com.embabel.agent.core.Agent
import com.embabel.agent.core.AgentPlatform
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service


/**
 * Automatically deploy all [Agent] beans
 * to the [AgentPlatform].
 */
@Service
class AgentDeployer(
    val agents: List<Agent>,
    private val agentPlatform: AgentPlatform,
    properties: AgentScanningProperties,
) {

    private val logger = LoggerFactory.getLogger(AgentDeployer::class.java)

    init {
        logger.debug("Properties: {}", properties)
        if (!properties.bean) {
            logger.info("AgentDeployer scanning disabled: not looking for agents defined as Spring beans")
        } else {
            logger.info(
                "AgentDeployer scanning enabled: deploying {} agents defined as Spring beans: {}",
                agents.size,
                agents.map { it.name }.sorted().joinToString(", ")
            )

            agents.forEach { agent ->
                agentPlatform.deploy(agent)
            }
        }
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/deployment/AgentScanningProperties.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core.deployment

import org.springframework.boot.context.properties.ConfigurationProperties

/**
 * Scanning configuration
 * @see com.embabel.agent.api.annotation.Agent
 */
@ConfigurationProperties("embabel.agent.platform.scanning")
data class AgentScanningProperties(
    /**
     * Whether to auto register beans with @Agent and @Agentic annotation
     */
    val annotation: Boolean = true,
    /**
     * Whether to auto register agents from Agent beans
     */
    val bean: Boolean = false,
)



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/hitl/README.md
================================================
# HITL (Human in the Loop) Support

`Awaitable` objects that allow user gestures
during a process.


================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/hitl/Awaitable.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core.hitl

import com.embabel.agent.core.AgentProcess
import com.embabel.common.core.StableIdentified
import com.embabel.common.core.types.HasInfoString
import com.embabel.common.core.types.Timestamped
import com.embabel.common.util.indent
import java.time.Instant
import java.util.*

/**
 * Something awaited by an agent process, such as a request for user input.
 * Added to the Blackboard and treated specially.
 */
interface Awaitable<P : Any, R : AwaitableResponse> : StableIdentified, Timestamped, HasInfoString {

    val payload: P

    /**
     * Update process state based on this response
     */
    fun onResponse(
        response: R,
        agentProcess: AgentProcess,
    ): ResponseImpact

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String {
        return "${javaClass.name}(id=$id, payload=$payload, form='$payload')".indent(indent)
    }

}

/**
 * Response to an [Awaitable]
 */
interface AwaitableResponse : StableIdentified, Timestamped {

    /**
     * ID of the Awaitable that this relates to
     */
    val awaitableId: String

}

/**
 * Response of handling an Awaitable
 */
enum class ResponseImpact {
    UPDATED,
    UNCHANGED,
}

/**
 * Convenient support for implementing [Awaitable]
 */
abstract class AbstractAwaitable<P : Any, R : AwaitableResponse>(
    override val payload: P,
    override val id: String = UUID.randomUUID().toString(),
    override val timestamp: Instant = Instant.now(),
    private val persistent: Boolean = false,
) : Awaitable<P, R> {

    override fun persistent(): Boolean = persistent

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/hitl/ConfirmationRequest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core.hitl

import com.embabel.agent.core.AgentProcess
import com.embabel.common.util.indent
import com.embabel.common.util.loggerFor
import java.time.Instant
import java.util.*

/**
 * Request confirmation from the user before promoting
 * an object to the blackboard. Rejection will hold back a flow.
 */
class ConfirmationRequest<P : Any> @JvmOverloads constructor(
    payload: P,
    val message: String,
    persistent: Boolean = false,
) : AbstractAwaitable<P, ConfirmationResponse>(
    payload = payload,
    persistent = persistent,
) {

    override fun onResponse(
        response: ConfirmationResponse,
        agentProcess: AgentProcess,
    ): ResponseImpact {

        return if (response.accepted) {
            loggerFor<ConfirmationRequest<*>>().info(
                "Accepted confirmation request. Promoting payload to blackboard: {}",
                payload,
            )
            agentProcess += payload
            ResponseImpact.UPDATED
        } else {
            loggerFor<ConfirmationRequest<*>>().info("Rejected confirmation request: {}", payload)
            ResponseImpact.UNCHANGED
        }
    }

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String {
        return "ConfirmationRequest(id=$id, payload=$payload, message='$message')".indent(indent)
    }

    override fun toString(): String {
        return "ConfirmationRequest(id=$id, payloadType:${payload::class.qualifiedName}, message='$message')"
    }
}

data class ConfirmationResponse(
    override val id: String = UUID.randomUUID().toString(),
    override val awaitableId: String,
    val accepted: Boolean,
    private val persistent: Boolean = false,
    override val timestamp: Instant = Instant.now(),
) : AwaitableResponse {

    override fun persistent() = persistent
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/hitl/FormBindingRequest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core.hitl

import com.embabel.agent.core.AgentProcess
import com.embabel.common.util.loggerFor
import com.embabel.ux.form.DefaultFormProcessor
import com.embabel.ux.form.Form
import com.embabel.ux.form.FormBinder
import com.embabel.ux.form.FormSubmission
import java.time.Instant
import java.util.*

interface ValidationError

/**
 * Present the user with a form
 * and bind it to the given class
 * @param O the class to bind the form submission to
 * @param form the form to present to the user
 * @param outputClass the class to bind the form submission to
 * @param population an optional instance to pre-populate the form
 * @param validationErrors optional validation errors to display on the form
 * @param persistent whether this request should be persisted
 */
class FormBindingRequest<O : Any> @JvmOverloads constructor(
    form: Form,
    val outputClass: Class<O>,
    val population: O? = null,
    val validationErrors: List<ValidationError> = emptyList(),
    persistent: Boolean = false,
) : AbstractAwaitable<Form, FormResponse>(
    payload = form,
    persistent = persistent,
) {

    private val logger = loggerFor<FormBindingRequest<O>>()

    override fun onResponse(
        response: FormResponse,
        agentProcess: AgentProcess,
    ): ResponseImpact {
        val formSubmissionResult = DefaultFormProcessor().processSubmission(payload, response.formSubmission)
        if (!formSubmissionResult.valid) {
            throw IllegalStateException("Form submission is not valid: ${formSubmissionResult.validationErrors}")
        }
        val formBinder = FormBinder(outputClass)
        val boundInstance = formBinder.bind(formSubmissionResult)
        return bind(boundInstance, agentProcess)
    }

    fun bind(
        boundInstance: O,
        agentProcess: AgentProcess,
    ): ResponseImpact {
        logger.info("Bound form submission to {}", boundInstance)
        agentProcess += boundInstance
        return ResponseImpact.UPDATED
    }

    override fun toString(): String = infoString(verbose = false)
}

/**
 * Response from the UX
 */
data class FormResponse(
    override val id: String = UUID.randomUUID().toString(),
    override val awaitableId: String,
    val formSubmission: FormSubmission,
    private val persistent: Boolean = false,
    override val timestamp: Instant = Instant.now(),
) : AwaitableResponse {

    override fun persistent() = persistent
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/support/AbstractAction.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core.support

import com.embabel.agent.core.Action
import com.embabel.agent.core.ActionQos
import com.embabel.agent.core.IoBinding
import com.embabel.agent.core.ToolGroupRequirement
import com.embabel.common.core.types.ZeroToOne
import com.embabel.plan.goap.ConditionDetermination
import com.embabel.plan.goap.EffectSpec
import com.fasterxml.jackson.annotation.JsonIgnore
import org.slf4j.Logger
import org.slf4j.LoggerFactory

object Rerun {
    const val HAS_RUN_CONDITION_PREFIX = "hasRun_"

    /**
     * Compute the name of the condition for this action having run
     */
    fun hasRunCondition(action: Action): String {
        return "$HAS_RUN_CONDITION_PREFIX${action.name}"
    }
}

/**
 * Abstract action implementation that computes outputs.
 * @param name the name of the action
 * @param description a description of the action
 * @param pre a list of preconditions. These are additional to the input
 * @param post a list of expected effects. These are additional to the output
 * @param cost the cost of the action
 * @param inputs the input bindings
 * @param outputs the output bindings
 * @param canRerun can we rerun this action?
 * @param qos quality of service requirements
 */
abstract class AbstractAction(
    override val name: String,
    override val description: String = name,
    val pre: List<String> = emptyList(),
    val post: List<String> = emptyList(),
    override val cost: ZeroToOne = 0.0,
    override val value: ZeroToOne = 0.0,
    override val inputs: Set<IoBinding> = emptySet(),
    override val outputs: Set<IoBinding> = emptySet(),
    override val toolGroups: Set<ToolGroupRequirement>,
    override val canRerun: Boolean,
    override val qos: ActionQos = ActionQos(),
) : Action {

    protected val logger: Logger = LoggerFactory.getLogger(javaClass)

    @JsonIgnore
    override val preconditions: EffectSpec =
        run {
            val conditions = pre.associateWith { ConditionDetermination(true) }.toMutableMap()
            inputs.forEach { input ->
                conditions[input.value] = ConditionDetermination(true)
            }
            if (!canRerun) {
                outputs.filter {
                    !inputs.contains(it)
                }.forEach { output ->
                    conditions[output.value] = ConditionDetermination(false)
                }
                conditions[Rerun.hasRunCondition(this)] = ConditionDetermination(false)
            }
            conditions
        }

    override val effects: EffectSpec
        get() {
            val conditions = post.associateWith { ConditionDetermination(true) }.toMutableMap()
            outputs.forEach { output ->
                val jvmType = output.resolveJvmType()
                if (jvmType == null) {
                    // Just take the type at face value
                    conditions[output.value] = ConditionDetermination(true)
                } else {
                    // We have a JVM type. We need to look for subclasses
                    // because these are also possible outputs and hence postconditions
                    val possibleOutputTypes = jvmType.children() + jvmType
                    possibleOutputTypes.forEach { pot ->
                        conditions["${output.name}:${pot.name}"] = ConditionDetermination(true)
                    }
                }
            }
            conditions += Rerun.hasRunCondition(this) to ConditionDetermination(true)
            return conditions
        }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/support/AbstractAgentProcess.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core.support

import com.embabel.agent.api.common.PlatformServices
import com.embabel.agent.api.common.StuckHandlingResultCode
import com.embabel.agent.api.common.ToolsStats
import com.embabel.agent.core.*
import com.embabel.agent.event.*
import com.embabel.agent.spi.DelayedActionExecutionSchedule
import com.embabel.agent.spi.ProntoActionExecutionSchedule
import com.embabel.agent.spi.ScheduledActionExecutionSchedule
import com.embabel.agent.spi.support.AgenticEventListenerToolsStats
import com.embabel.plan.WorldState
import com.embabel.plan.goap.WorldStateDeterminer
import com.fasterxml.jackson.annotation.JsonIgnore
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import java.time.Duration
import java.time.Instant
import java.util.concurrent.atomic.AtomicReference

/**
 * Abstract implementation of AgentProcess that provides common functionality
 */
abstract class AbstractAgentProcess(
    override val id: String,
    override val parentId: String?,
    override val agent: Agent,
    protected val processOptions: ProcessOptions,
    protected val blackboard: Blackboard,
    @get:JsonIgnore
    protected val platformServices: PlatformServices,
    override val timestamp: Instant = Instant.now(),
) : AgentProcess, Blackboard by blackboard {

    protected val logger: Logger = LoggerFactory.getLogger(this::class.java)

    private var _lastWorldState: WorldState? = null

    protected var _goal: com.embabel.plan.Goal? = null

    private val _history: MutableList<ActionInvocation> = mutableListOf()

    private val _status = AtomicReference(AgentProcessStatusCode.NOT_STARTED)

    private var _failureInfo: Any? = null

    override val failureInfo: Any?
        get() = _failureInfo

    override val lastWorldState: WorldState?
        get() = _lastWorldState

    private val agenticEventListenerToolsStats = AgenticEventListenerToolsStats()

    override val goal: com.embabel.plan.Goal? get() = _goal

    override val processContext = ProcessContext(
        platformServices = platformServices.withEventListener(
            agenticEventListenerToolsStats,
        ),
        agentProcess = this,
        processOptions = processOptions,
        outputChannel = platformServices.outputChannel + processOptions.outputChannel,
    )

    /**
     * Get the WorldStateDeterminer for this process
     */
    protected abstract val worldStateDeterminer: WorldStateDeterminer

    override val status: AgentProcessStatusCode
        get() = _status.get()

    override val history: List<ActionInvocation>
        get() = _history.toList()

    override val toolsStats: ToolsStats
        get() = agenticEventListenerToolsStats

    protected fun setStatus(status: AgentProcessStatusCode) {
        _status.set(status)
    }

    override fun kill(): ProcessKilledEvent? {
        setStatus(AgentProcessStatusCode.KILLED)
        return ProcessKilledEvent(this)
    }

    override fun bind(
        key: String,
        value: Any,
    ): Bindable {
        blackboard[key] = value
        processContext.onProcessEvent(
            ObjectBoundEvent(
                agentProcess = this,
                name = key,
                value = value,
            )
        )
        return this
    }

    override fun plusAssign(pair: Pair<String, Any>) {
        bind(pair.first, pair.second)
    }

    // Override set to bind so that delegation works
    override operator fun set(
        key: String,
        value: Any,
    ) {
        bind(key, value)
    }

    override fun addObject(value: Any): Bindable {
        blackboard.addObject(value)
        processContext.onProcessEvent(
            ObjectAddedEvent(
                agentProcess = this,
                value = value,
            )
        )
        return this
    }

    override operator fun plusAssign(value: Any) {
        addObject(value)
    }

    private fun makeRunning(): Boolean {
        val currentStatus = _status.get()
        return when (currentStatus) {
            AgentProcessStatusCode.COMPLETED,
            AgentProcessStatusCode.KILLED, AgentProcessStatusCode.TERMINATED,
                -> {
                logger.warn("Process {} Cannot be made RUNNING as its status is {}", this.id, status)
                return false
            }

            else -> {
                _status.compareAndSet(currentStatus, AgentProcessStatusCode.RUNNING)
                true
            }
        }
    }

    override fun run(): AgentProcess {
        if (!makeRunning()) {
            return this
        }

        if (agent.goals.isEmpty()) {
            logger.info("🤔 Process {} has no goals: {}", this.id, agent.goals)
            error("Agent ${agent.name} has no goals: ${agent.infoString(verbose = true)}")
        }

        tick()
        while (status == AgentProcessStatusCode.RUNNING) {
            val earlyTermination = processOptions.control.earlyTerminationPolicy.shouldTerminate(this)
            if (earlyTermination != null) {
                logger.debug(
                    "Process {} terminated by {} because {}",
                    this.id,
                    earlyTermination.policy,
                    earlyTermination.reason,
                )
                platformServices.eventListener.onProcessEvent(earlyTermination)
                _failureInfo = earlyTermination
                setStatus(AgentProcessStatusCode.TERMINATED)
                return this
            }
            tick()
        }
        when (status) {
            AgentProcessStatusCode.NOT_STARTED -> {
                logger.debug("Process {} is not started: {}", this.id, status)
            }

            AgentProcessStatusCode.RUNNING -> {
                logger.debug("Process {} is happily running: {}", this.id, status)
            }

            AgentProcessStatusCode.COMPLETED -> {
                platformServices.eventListener.onProcessEvent(AgentProcessCompletedEvent(this))
            }

            AgentProcessStatusCode.FAILED -> {
                platformServices.eventListener.onProcessEvent(AgentProcessFailedEvent(this))
            }

            AgentProcessStatusCode.TERMINATED, AgentProcessStatusCode.KILLED -> {
                // Event will have been raised at the point of termination
            }

            AgentProcessStatusCode.WAITING -> {
                platformServices.eventListener.onProcessEvent(AgentProcessWaitingEvent(this))
            }

            AgentProcessStatusCode.PAUSED -> {
                platformServices.eventListener.onProcessEvent(AgentProcessPausedEvent(this))
                handleStuck(agent)
            }

            AgentProcessStatusCode.STUCK -> {
                platformServices.eventListener.onProcessEvent(AgentProcessStuckEvent(this))
                handleStuck(agent)
            }
        }
        return this
    }

    /**
     * Try to resolve a stuck process using StuckHandler if provided
     */
    protected fun handleStuck(agent: Agent) {
        val stuckHandler = agent.stuckHandler
        if (stuckHandler == null) {
            logger.warn(
                "Process {} is stuck: no handler. History ({}):\n\t{}",
                this.id,
                history.size,
                history.joinToString("\n\t") { it.actionName },
            )
            return
        }
        val result = stuckHandler.handleStuck(this)
        platformServices.eventListener.onProcessEvent(result)
        when (result.code) {
            StuckHandlingResultCode.REPLAN -> {
                logger.info("Process {} unstuck and will replan: {}", this.id, result.message)
                setStatus(AgentProcessStatusCode.RUNNING)
                run()
            }

            StuckHandlingResultCode.NO_RESOLUTION -> {
                logger.warn("Process {} stuck: {}", this.id, result.message)
                setStatus(AgentProcessStatusCode.STUCK)
            }
        }
    }

    override fun tick(): AgentProcess {
        if (!makeRunning()) {
            return this
        }

        val worldState = worldStateDeterminer.determineWorldState()
        _lastWorldState = worldState
        platformServices.eventListener.onProcessEvent(
            AgentProcessReadyToPlanEvent(
                agentProcess = this,
                worldState = worldState,
            )
        )
        logger.debug(
            "Process {} tick (about to plan): {}, blackboard={}",
            id,
            worldState,
            blackboard.infoString(verbose = false),
        )

        // Let subclasses handle the planning and execution
        return formulateAndExecutePlan(worldState)
    }


    /**
     * Execute the plan based on the current world state
     * @param worldState The current world state
     */
    protected abstract fun formulateAndExecutePlan(
        worldState: WorldState,
    ): AgentProcess

    /**
     * Execute an action
     */
    protected fun executeAction(action: Action): ActionStatus {
        val outputTypes: Map<String, DomainType> =
            action.outputs.associateBy({ it.name }, { agent.resolveType(it.type) })
        logger.debug(
            "⚙️ Process {} executing action {}: outputTypes={}",
            id,
            action.name,
            outputTypes,
        )

        val actionExecutionStartEvent = ActionExecutionStartEvent(
            agentProcess = this,
            action = action,
        )
        platformServices.eventListener.onProcessEvent(actionExecutionStartEvent)
        val actionExecutionSchedule = platformServices.operationScheduler.scheduleAction(actionExecutionStartEvent)
        when (actionExecutionSchedule) {
            is ProntoActionExecutionSchedule -> {
                // Do nothing
            }

            is DelayedActionExecutionSchedule -> {
                // Delay and move on
                logger.debug("Process {} delayed action {}: {}", id, action.name, actionExecutionSchedule)
                try {
                    Thread.sleep(actionExecutionSchedule.delay.toMillis())
                } catch (_: InterruptedException) {
                    Thread.currentThread().interrupt()
                    _status.set(AgentProcessStatusCode.TERMINATED)
                    return ActionStatus(
                        runningTime = Duration.between(actionExecutionStartEvent.timestamp, Instant.now()),
                        status = ActionStatusCode.FAILED,
                    )
                }
                logger.debug("Process {} delayed action {}: done", id, action.name)
            }

            is ScheduledActionExecutionSchedule -> {
                return ActionStatus(
                    Duration.between(actionExecutionStartEvent.timestamp, Instant.now()),
                    ActionStatusCode.PAUSED
                )
            }
        }

        val timestamp = Instant.now()
        val actionStatus = action.qos.retryTemplate("Action-${action.name}").execute<ActionStatus, Throwable> {
            action.execute(
                processContext = processContext,
            )
        }
        val runningTime = Duration.between(timestamp, Instant.now())
        _history += ActionInvocation(
            actionName = action.name,
            timestamp = timestamp,
            runningTime = runningTime,
        )
        platformServices.eventListener.onProcessEvent(
            actionExecutionStartEvent.resultEvent(
                actionStatus = actionStatus,
            )
        )

        logger.debug("New world state: {}", worldStateDeterminer.determineWorldState())
        return actionStatus
    }

    /**
     * Convert action status to agent process status
     */
    protected fun actionStatusToAgentProcessStatus(actionStatus: ActionStatus): AgentProcessStatusCode {
        return when (actionStatus.status) {
            ActionStatusCode.SUCCEEDED -> {
                logger.debug("Process {} action {} is running", id, actionStatus.status)
                AgentProcessStatusCode.RUNNING
            }

            ActionStatusCode.FAILED -> {
                logger.debug("❌ Process {} action {} failed", id, actionStatus.status)
                AgentProcessStatusCode.FAILED
            }

            ActionStatusCode.WAITING -> {
                logger.debug("⏳ Process {} action {} waiting", id, actionStatus.status)
                AgentProcessStatusCode.WAITING
            }

            ActionStatusCode.PAUSED -> {
                logger.debug("⏳ Process {} action {} paused", id, actionStatus.status)
                AgentProcessStatusCode.PAUSED
            }
        }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/support/AbstractLlmOperations.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core.support

import com.embabel.agent.core.Action
import com.embabel.agent.core.AgentProcess
import com.embabel.agent.event.LlmRequestEvent
import com.embabel.agent.spi.*
import com.embabel.agent.spi.support.LlmDataBindingProperties
import com.embabel.agent.spi.validation.DefaultValidationPromptGenerator
import com.embabel.agent.spi.validation.ValidationPromptGenerator
import com.embabel.chat.Message
import com.embabel.chat.UserMessage
import com.embabel.common.ai.model.*
import com.embabel.common.util.time
import jakarta.validation.Validator
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.ai.tool.ToolCallback
import java.time.Duration

/**
 * Convenient superclass for LlmOperations implementations,
 * which should normally extend this
 * Find all tool callbacks and decorate them to be aware of the platform
 * Also emits events.
 */
abstract class AbstractLlmOperations(
    private val toolDecorator: ToolDecorator,
    private val modelProvider: ModelProvider,
    private val validator: Validator,
    private val validationPromptGenerator: ValidationPromptGenerator = DefaultValidationPromptGenerator(),
    private val autoLlmSelectionCriteriaResolver: AutoLlmSelectionCriteriaResolver,
    protected val dataBindingProperties: LlmDataBindingProperties,
) : LlmOperations {

    protected val logger: Logger = LoggerFactory.getLogger(javaClass)

    final override fun <O> createObject(
        messages: List<Message>,
        interaction: LlmInteraction,
        outputClass: Class<O>,
        agentProcess: AgentProcess,
        action: Action?,
    ): O {
        val (allToolCallbacks, llmRequestEvent) = getToolsAndEvent(
            agentProcess = agentProcess,
            interaction = interaction,
            action = action,
            messages = messages,
            outputClass = outputClass,
        )

        val interactionWithToolDecoration = interaction.copy(
            toolCallbacks = allToolCallbacks.map {
                toolDecorator.decorate(
                    tool = it,
                    agentProcess = agentProcess,
                    action = action,
                    llmOptions = interaction.llm,
                )
            })

        val (createdObject, ms) = time {
            val initialMessages = if (dataBindingProperties.sendValidationInfo) {
                messages + UserMessage(
                    validationPromptGenerator.generateRequirementsPrompt(
                        validator = validator,
                        outputClass = outputClass,
                    )
                )
            } else {
                messages
            }

            var candidate = doTransform(
                messages = initialMessages,
                interaction = interactionWithToolDecoration,
                outputClass = outputClass,
                llmRequestEvent = llmRequestEvent,
            )
            var constraintViolations = validator.validate(candidate)
            if (constraintViolations.isNotEmpty()) {
                // If we had violations, try again, once, before throwing an exception
                candidate = doTransform(
                    messages = messages + UserMessage(
                        validationPromptGenerator.generateViolationsReport(
                            constraintViolations
                        )
                    ),
                    interaction = interactionWithToolDecoration,
                    outputClass = outputClass,
                    llmRequestEvent = llmRequestEvent,
                )
                constraintViolations = validator.validate(candidate)
                if (constraintViolations.isNotEmpty()) {
                    throw InvalidLlmReturnTypeException(
                        returnedObject = candidate as Any,
                        constraintViolations = constraintViolations,
                    )
                }
            }
            candidate
        }
        logger.debug("LLM response={}", createdObject)
        agentProcess.processContext.onProcessEvent(
            llmRequestEvent.responseEvent(
                response = createdObject,
                runningTime = Duration.ofMillis(ms),
            ),
        )
        return createdObject
    }

    final override fun <O> createObjectIfPossible(
        messages: List<Message>,
        interaction: LlmInteraction,
        outputClass: Class<O>,
        agentProcess: AgentProcess,
        action: Action?,
    ): Result<O> {
        val (allToolCallbacks, llmRequestEvent) = getToolsAndEvent(
            agentProcess = agentProcess,
            interaction = interaction,
            action = action,
            messages = messages,
            outputClass = outputClass,
        )
        val (response, ms) = time {
            doTransformIfPossible(
                messages = messages,
                interaction = interaction.copy(toolCallbacks = allToolCallbacks.map {
                    toolDecorator.decorate(
                        tool = it,
                        agentProcess = agentProcess,
                        action = action,
                        llmOptions = interaction.llm,
                    )
                }),
                outputClass = outputClass,
                llmRequestEvent = llmRequestEvent,
            )
        }
        logger.debug("LLM response={}", response)
        agentProcess.processContext.onProcessEvent(
            llmRequestEvent.maybeResponseEvent(
                response = response,
                runningTime = Duration.ofMillis(ms),
            ),
        )
        return response
    }

    protected fun chooseLlm(
        llmOptions: LlmOptions,
    ): Llm {
        val crit: ModelSelectionCriteria = when (llmOptions.criteria) {
            is AutoModelSelectionCriteria ->
                autoLlmSelectionCriteriaResolver.resolveAutoLlm()

            else -> llmOptions.criteria
        }
        return modelProvider.getLlm(crit)
    }

    protected abstract fun <O> doTransformIfPossible(
        messages: List<Message>,
        interaction: LlmInteraction,
        outputClass: Class<O>,
        llmRequestEvent: LlmRequestEvent<O>,
    ): Result<O>

    private fun <O> getToolsAndEvent(
        agentProcess: AgentProcess,
        interaction: LlmInteraction,
        action: Action?,
        messages: List<Message>,
        outputClass: Class<O>,
    ): Pair<Collection<ToolCallback>, LlmRequestEvent<O>> {
        val toolGroupResolver = agentProcess.processContext.platformServices.agentPlatform.toolGroupResolver
        val allToolCallbacks =
            interaction.resolveToolCallbacks(
                toolGroupResolver,
            )
        val llmRequestEvent = LlmRequestEvent(
            agentProcess = agentProcess,
            action = action,
            outputClass = outputClass,
            interaction = interaction.copy(
                toolCallbacks = allToolCallbacks,
            ),
            llm = chooseLlm(llmOptions = interaction.llm),
            messages = messages,
        )
        agentProcess.processContext.onProcessEvent(llmRequestEvent)
        logger.debug(
            "Expanded toolCallbacks from {}: {}",
            llmRequestEvent.interaction.toolCallbacks.map { it.toolDefinition.name() },
            allToolCallbacks.map { it.toolDefinition.name() })
        return Pair(allToolCallbacks, llmRequestEvent)
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/support/BlackboardWorldStateDeterminer.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core.support

import com.embabel.agent.api.common.OperationContext
import com.embabel.agent.core.Condition
import com.embabel.agent.core.ProcessContext
import com.embabel.agent.core.satisfiesType
import com.embabel.agent.core.support.Rerun.HAS_RUN_CONDITION_PREFIX
import com.embabel.plan.goap.ConditionDetermination
import com.embabel.plan.goap.GoapWorldState
import com.embabel.plan.goap.WorldStateDeterminer
import org.slf4j.LoggerFactory

/**
 * Determine world state for the given ProcessContext,
 * using the blackboard.
 */
class BlackboardWorldStateDeterminer(
    private val processContext: ProcessContext,
) : WorldStateDeterminer {

    private val logger = LoggerFactory.getLogger(BlackboardWorldStateDeterminer::class.java)

    private val knownConditions = processContext.agentProcess.agent.planningSystem.knownConditions()

    override fun determineWorldState(): GoapWorldState {
        val map = mutableMapOf<String, ConditionDetermination>()
        knownConditions.forEach { condition ->
            // TODO shouldn't evaluate expensive conditions, just
            // return unknown
            map[condition] = determineCondition(condition)
        }
        return GoapWorldState(map)
    }

    override fun determineCondition(condition: String): ConditionDetermination {
        val conditionDetermination = when {
            // Data binding condition
            condition.contains(":") -> {
                val (variable, type) = condition.split(":")

                // If the variable is a map, we are satisfied by having the name bound
                // rather than checking the type
                // TODO may want to add type checking here
                val found = processContext.blackboard[variable]
                val maybeMap = found as? Map<*, *>
                if (maybeMap != null) {
                    return ConditionDetermination(true)
                }

                val value = processContext.getValue(variable, type)

                val determination = when {
                    type == "List" ->
                        value != null && (value is List<*>)

                    variable == "all" -> true // TODO fix this
                    else -> {
                        val determination =
                            value != null && satisfiesType(value, type)
                        logger.debug(
                            "Determined binding condition {}={}: variable={}, type={}, value={}",
                            condition,
                            determination,
                            variable,
                            type,
                            value,
                        )
                        determination
                    }
                }
                ConditionDetermination(determination)
            }

            condition.startsWith(Rerun.HAS_RUN_CONDITION_PREFIX) -> {
                // Special case for hasRun- conditions
                val actionName = condition.substringAfter(HAS_RUN_CONDITION_PREFIX)
                val determination = ConditionDetermination(processContext.agentProcess.history.any {
                    it.actionName == actionName
                })
                logger.debug(
                    "Determined hasRun condition {}={}: known conditions={}, bindings={}",
                    condition,
                    determination,
                    knownConditions.sorted(),
                    processContext.blackboard.infoString(),
                )
                determination
            }

            // Well known conditions, defined for reuse, with their own evaluation function
            knownConditions.any { knownCondition -> knownCondition == condition } &&
                    resolveAsAgentCondition(condition) != null -> {
                val condition = resolveAsAgentCondition(condition)!!

                val determination = condition.evaluate(
                    OperationContext(
                        processContext = processContext,
                        operation = condition,
                        toolGroups = emptySet(),
                    )
                )
                logger.debug(
                    "Determined known condition {}={}, bindings={}",
                    condition,
                    determination,
                    processContext.blackboard.infoString(),
                )
                determination
            }

            // Maybe the condition was explicitly set
            // In this case if it isn't set, we assume it is false
            // rather than unknown
            else -> {
                val determination = ConditionDetermination(processContext.blackboard.getCondition(condition))
                    .asTrueOrFalse()
                logger.debug(
                    "Looked for explicitly set condition: determined condition {}={}: known conditions={}, bindings={}",
                    condition,
                    determination,
                    knownConditions.sorted(),
                    processContext.blackboard.infoString(),
                )
                determination
            }
        }
        if (conditionDetermination == ConditionDetermination.UNKNOWN) {
            logger.warn(
                "Determined condition {} to be unknown: knownConditions={}, bindings={}",
                condition,
                knownConditions.sorted(),
                processContext.blackboard.infoString(),
            )
        }
        return conditionDetermination
    }

    private fun resolveAsAgentCondition(condition: String): Condition? {
        // Match FQN condition
        return processContext.agentProcess.agent.conditions.find {
            it.name == condition || it.name.endsWith(
                ".$condition"
            )
        }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/support/ConcurrentAgentProcess.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core.support


import com.embabel.agent.api.common.PlatformServices
import com.embabel.agent.core.*
import com.embabel.agent.spi.PlannerFactory
import com.embabel.plan.WorldState
import com.embabel.plan.goap.GoapWorldState
import kotlinx.coroutines.future.await
import kotlinx.coroutines.runBlocking
import java.time.Instant
import kotlin.time.measureTime

/**
 * An AgentProcess that can execute multiple actions concurrently.
 * With each invocation of formulateAndExecutePlan(), it will attempt to execute all
 * actions that are currently achievable towards the plan.
 */
open class ConcurrentAgentProcess(
    id: String,
    parentId: String?,
    agent: Agent,
    processOptions: ProcessOptions,
    blackboard: Blackboard,
    platformServices: PlatformServices,
    plannerFactory: PlannerFactory,
    timestamp: Instant = Instant.now(),
    val callbacks: List<AgentProcessCallback> = emptyList(),
) : SimpleAgentProcess(
    id = id,
    parentId = parentId,
    agent = agent,
    processOptions = processOptions,
    blackboard = blackboard,
    platformServices = platformServices,
    plannerFactory = plannerFactory,
    timestamp = timestamp,
) {
    override fun formulateAndExecutePlan(worldState: WorldState): AgentProcess {
        val plan = planner.bestValuePlanToAnyGoal(system = agent.planningSystem)
        if (plan == null) {
            return handlePlanNotFound(worldState)
        }

        _goal = plan.goal

        if (plan.isComplete()) {
            handleProcessCompletion(plan, worldState)
        } else {
            sendProcessRunningEvent(plan, worldState)

            val achievableActions =
                agent.actions.filter {
                    plan.actions.contains(it) &&
                            it.isAchievable(worldState as GoapWorldState)
                }
            val actions =
                achievableActions.map { achievableAction ->
                    agent.actions.singleOrNull { it.name == achievableAction.name }
                        ?: error(
                            "No unique action found for ${plan.actions.first().name} in ${
                                agent.actions.map {
                                    it.name
                                }
                            }: Actions are\n${
                                agent.actions.joinToString(
                                    "\n",
                                ) { it.name }
                            }",
                        )
                }
            val process = this
            callbacks.forEach { it.beforeActionLaunched(process) }
            val elapsed =
                measureTime {
                    logger.info("Executing ${actions.size} actions concurrently: \n${actions.map { it.name }}")
                    val agentStatuses =
                        actions
                            .map { action ->
                                platformServices.asyncer.async {
                                    try {
                                        callbacks.forEach { it.onActionLaunched(process, action) }
                                        executeAction(action)
                                    } finally {
                                        callbacks.forEach { it.onActionCompleted(process, action) }
                                    }
                                }
                            }.map { deferred ->
                                runBlocking {
                                    deferred.await()
                                }
                            }
                    setStatus(actionStatusToAgentProcessStatus(agentStatuses))
                }
            logger.info("Executed ${actions.size} actions in $elapsed")
        }
        return this
    }

    protected fun actionStatusToAgentProcessStatus(actionStatuses: List<ActionStatus>): AgentProcessStatusCode =
        when {
            actionStatuses.any { it.status == ActionStatusCode.FAILED } -> {
                logger.debug("❌ Process {} action {} failed", id, ActionStatusCode.FAILED)
                AgentProcessStatusCode.FAILED
            }

            actionStatuses.any { it.status == ActionStatusCode.PAUSED } -> {
                logger.debug("⏳ Process {} action {} paused", id, ActionStatusCode.PAUSED)
                AgentProcessStatusCode.PAUSED
            }

            actionStatuses.any { it.status == ActionStatusCode.SUCCEEDED } -> {
                logger.debug("Process {} action {} is running", id, ActionStatusCode.SUCCEEDED)
                AgentProcessStatusCode.RUNNING
            }

            actionStatuses.any { it.status == ActionStatusCode.WAITING } -> {
                logger.debug("⏳ Process {} action {} waiting", id, ActionStatusCode.WAITING)
                AgentProcessStatusCode.WAITING
            }

            else -> {
                error("Unexpected action statuses: $actionStatuses")
            }
        }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/support/DefaultAgentPlatform.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core.support

import com.embabel.agent.api.common.Asyncer
import com.embabel.agent.channel.OutputChannel
import com.embabel.agent.core.*
import com.embabel.agent.event.AgentDeploymentEvent
import com.embabel.agent.event.AgentProcessCreationEvent
import com.embabel.agent.event.AgenticEventListener
import com.embabel.agent.spi.*
import com.embabel.agent.spi.config.spring.AgentPlatformProperties
import com.embabel.agent.spi.support.GoapPlannerFactory
import com.embabel.agent.spi.support.InMemoryAgentProcessRepository
import com.embabel.agent.spi.support.InMemoryContextRepository
import com.embabel.agent.spi.support.SpringContextPlatformServices
import com.embabel.common.textio.template.TemplateRenderer
import com.fasterxml.jackson.databind.ObjectMapper
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.beans.factory.annotation.Qualifier
import org.springframework.beans.factory.annotation.Value
import org.springframework.context.ApplicationContext
import org.springframework.stereotype.Service
import java.util.concurrent.ConcurrentHashMap

@Service
open class DefaultAgentPlatform(
    @param:Value("\${embabel.agent.platform.name:default-agent-platform}")
    override val name: String,
    @param:Value("\${embabel.agent.platform.description:Default Agent Platform}")
    override val description: String,
    @param:Value("\${embabel.agent.platform.process-type:SIMPLE}")
    val processType: AgentPlatformProperties.ProcessType,
    private val llmOperations: LlmOperations,
    override val toolGroupResolver: ToolGroupResolver,
    private val eventListener: AgenticEventListener,
    private val agentProcessIdGenerator: AgentProcessIdGenerator = AgentProcessIdGenerator.RANDOM,
    private val contextRepository: ContextRepository = InMemoryContextRepository(),
    private val agentProcessRepository: AgentProcessRepository = InMemoryAgentProcessRepository(),
    private val operationScheduler: OperationScheduler = OperationScheduler.PRONTO,
    private val asyncer: Asyncer,
    @param:Qualifier("embabelJacksonObjectMapper")
    private val objectMapper: ObjectMapper,
    private val outputChannel: OutputChannel,
    private val templateRenderer: TemplateRenderer,
    private val applicationContext: ApplicationContext? = null,
) : AgentPlatform {

    @Autowired(required = false)
    private var callbacks: List<AgentProcessCallback> = emptyList()

    private val logger = LoggerFactory.getLogger(DefaultAgentPlatform::class.java)

    private val plannerFactory: PlannerFactory = GoapPlannerFactory

    private val agents: MutableMap<String, Agent> = ConcurrentHashMap()

    override val platformServices = SpringContextPlatformServices(
        llmOperations = llmOperations,
        agentPlatform = this,
        eventListener = eventListener,
        operationScheduler = operationScheduler,
        asyncer = asyncer,
        objectMapper = objectMapper,
        applicationContext = applicationContext,
        outputChannel = outputChannel,
        templateRenderer = templateRenderer,
    )

    init {
        logger.debug("{}: event listener: {}", name, eventListener)
    }

    override val opaque = false

    override fun getAgentProcess(id: String): AgentProcess? {
        return agentProcessRepository.findById(id)
    }

    override fun killAgentProcess(id: String): AgentProcess? {
        val process = agentProcessRepository.findById(id)
        if (process == null) {
            logger.warn("Agent process {} not found", id)
            return null
        }
        logger.info("Killing agent process {}", id)
        val killEvent = process.kill()
        if (killEvent != null) {
            eventListener.onProcessEvent(killEvent)
        } else {
            logger.warn("Failed to kill agent process {}", id)
        }
        return process
    }

    override fun agents(): List<Agent> =
        agents.values.sortedBy { it.name }

    override fun deploy(agent: Agent): DefaultAgentPlatform {
        agents[agent.name] = agent
        logger.debug("✅ Deployed agent {}\n\tdescription: {}", agent.name, agent.description)
        eventListener.onPlatformEvent(AgentDeploymentEvent(this, agent))
        return this
    }

    private fun createBlackboard(
        processOptions: ProcessOptions,
        processId: String,
    ): Blackboard {
        val blackboard = if (processOptions.blackboard != null) {
            logger.info(
                "Using existing blackboard {} for agent process {}",
                processOptions.blackboard.blackboardId,
                processId,
            )
            processOptions.blackboard
        } else {
            InMemoryBlackboard()
        }
        if (processOptions.contextId != null) {
            val context = contextRepository.findById(processOptions.contextId.value)
            if (context != null) {
                logger.info(
                    "Using existing context {} for agent process {}",
                    context.id,
                    processId,
                )
                context.populate(blackboard)
            } else {
                logger.warn(
                    "Context {} not found for agent process {}",
                    processOptions.contextId,
                    processId,
                )
            }
        }
        return blackboard
    }

    override fun runAgentFrom(
        agent: Agent,
        processOptions: ProcessOptions,
        bindings: Map<String, Any>,
    ): AgentProcess {
        val agentProcess = createAgentProcess(agent, processOptions, bindings)
        return agentProcess.run()
    }

    override fun createAgentProcess(
        agent: Agent,
        processOptions: ProcessOptions,
        bindings: Map<String, Any>,
    ): AgentProcess {
        val id = agentProcessIdGenerator.createProcessId(agent, processOptions)
        val blackboard = createBlackboard(processOptions, id)
        blackboard.bindAll(bindings)

        val agentProcess = when (processType) {
            AgentPlatformProperties.ProcessType.SIMPLE -> SimpleAgentProcess(
                agent = agent,
                platformServices = platformServices,
                blackboard = blackboard,
                id = id,
                parentId = null,
                processOptions = processOptions,
                plannerFactory = plannerFactory,
            )

            AgentPlatformProperties.ProcessType.CONCURRENT -> ConcurrentAgentProcess(
                agent = agent,
                platformServices = platformServices,
                blackboard = blackboard,
                id = id,
                parentId = null,
                processOptions = processOptions,
                plannerFactory = plannerFactory,
                callbacks = callbacks,
            )
        }
        logger.debug("🚀 Creating process {}", agentProcess.id)
        agentProcessRepository.save(agentProcess)
        eventListener.onProcessEvent(AgentProcessCreationEvent(agentProcess))
        return agentProcess
    }

    override fun createChildProcess(
        agent: Agent,
        parentAgentProcess: AgentProcess,
    ): AgentProcess {
        val childBlackboard = parentAgentProcess.processContext.blackboard.spawn()
        val processOptions = parentAgentProcess.processContext.processOptions
        val childAgentProcess = SimpleAgentProcess(
            agent = agent,
            platformServices = parentAgentProcess.processContext.platformServices,
            blackboard = childBlackboard,
            id = "${parentAgentProcess.agent.name} >> ${
                agentProcessIdGenerator.createProcessId(
                    agent,
                    processOptions,
                )
            }",
            parentId = parentAgentProcess.id,
            processOptions = processOptions,
            plannerFactory = plannerFactory,
        )
        logger.debug("👶 Creating child process {} from {}", childAgentProcess.id, parentAgentProcess.id)
        agentProcessRepository.save(childAgentProcess)
        eventListener.onProcessEvent(AgentProcessCreationEvent(childAgentProcess))
        return childAgentProcess
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/support/InMemoryBlackboard.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core.support

/**
 * Simple in memory blackboard implementation
 * backed by a map.
 */
import com.embabel.agent.core.Blackboard
import com.embabel.common.util.indent
import com.embabel.common.util.indentLines
import java.util.*
import java.util.concurrent.ConcurrentHashMap

class InMemoryBlackboard(
    override val blackboardId: String = UUID.randomUUID().toString(),
) : Blackboard {

    private val _map: MutableMap<String, Any> = ConcurrentHashMap()
    private val _entries: MutableList<Any> = Collections.synchronizedList(mutableListOf())
    private val hiddens: MutableSet<Any> = Collections.synchronizedSet(mutableSetOf())

    override fun spawn(): Blackboard {
        return InMemoryBlackboard().apply {
            _map.putAll(this@InMemoryBlackboard._map)
            synchronized(_entries) {
                _entries.addAll(this@InMemoryBlackboard._entries)
            }
        }
    }

    override fun hide(what: Any) {
        hiddens += what
    }

    fun isHidden(what: Any): Boolean = hiddens.contains(what)

    override val objects: List<Any>
        get() = synchronized(_entries) {
            (_entries - hiddens).toList() // Return a snapshot to avoid concurrent modification
        }

    override fun get(name: String): Any? {
        val f = _map[name] ?: return null
        if (isHidden(f)) {
            return null
        }
        return f
    }

    override fun bind(
        key: String,
        value: Any,
    ): Blackboard {
        _map[key] = value
        _entries.add(value)
        return this
    }

    override operator fun plusAssign(value: Any) {
        addObject(value)
    }

    override fun plusAssign(pair: Pair<String, Any>) {
        bind(pair.first, pair.second)
    }

    override operator fun set(
        key: String,
        value: Any,
    ) {
        bind(key, value)
    }

    override fun <V : Any> getOrPut(
        name: String,
        creator: () -> V,
    ): V {
        val entry = _map.getOrPut(name, creator)
        return entry as V
    }

    override fun setCondition(
        key: String,
        value: Boolean,
    ): Blackboard {
        _map[key] = value
        _entries.add(value)
        return this
    }

    override fun getCondition(key: String): Boolean? =
        _map[key] as? Boolean

    override fun addObject(value: Any): Blackboard {
        _entries.add(value)
        return this
    }

    override fun expressionEvaluationModel(): Map<String, Any> {
        return _map.toMap() // Return a snapshot copy
    }

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String {
        // Create snapshots for thread-safe iteration
        val mapSnapshot = _map.toMap()
        val objectsSnapshot = synchronized(_entries) { _entries.toList() }

        return """
            |${javaClass.simpleName}: id=$blackboardId
            |map:
            |${mapSnapshot.entries.joinToString(", ").indent(1)}
            |entries:
            |${objectsSnapshot.joinToString(", ").indent(1)}
            |"""
            .trimMargin()
            .indentLines(indent)
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/support/SimpleAgentProcess.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core.support

import com.embabel.agent.api.common.PlatformServices
import com.embabel.agent.core.*
import com.embabel.agent.event.AgentProcessPlanFormulatedEvent
import com.embabel.agent.event.GoalAchievedEvent
import com.embabel.agent.spi.PlannerFactory
import com.embabel.common.util.indentLines
import com.embabel.plan.Plan
import com.embabel.plan.Planner
import com.embabel.plan.WorldState
import com.embabel.plan.goap.WorldStateDeterminer
import java.time.Instant

open class SimpleAgentProcess(
    id: String,
    parentId: String?,
    agent: Agent,
    processOptions: ProcessOptions,
    blackboard: Blackboard,
    platformServices: PlatformServices,
    plannerFactory: PlannerFactory,
    timestamp: Instant = Instant.now(),
) : AbstractAgentProcess(
    id = id,
    parentId = parentId,
    agent = agent,
    processOptions = processOptions,
    blackboard = blackboard,
    platformServices = platformServices,
    timestamp = timestamp,
) {

    private val _llmInvocations = mutableListOf<LlmInvocation>()

    override val llmInvocations: List<LlmInvocation>
        get() = _llmInvocations.toList()

    override val worldStateDeterminer: WorldStateDeterminer = BlackboardWorldStateDeterminer(processContext)

    override val planner: Planner<*, *, *> = plannerFactory.createPlanner(processOptions, worldStateDeterminer)

    override fun recordLlmInvocation(llmInvocation: LlmInvocation) {
        _llmInvocations.add(llmInvocation)
    }

    protected fun handlePlanNotFound(worldState: WorldState): AgentProcess {
        logger.info(
            "❌ Process $id stuck\n" +
                    """|No plan from:
                   |${worldState.infoString(verbose = true, indent = 1)}
                   |in:
                   |${agent.planningSystem.infoString(verbose = true, 1)}
                   |context:
                   |${blackboard.infoString(true, 1)}
                   |"""
                        .trimMargin()
                        .indentLines(1)
        )
        setStatus(AgentProcessStatusCode.STUCK)
        return this
    }

    protected fun handleProcessCompletion(
        plan: Plan,
        worldState: WorldState,
    ) {
        logger.debug(
            "✅ Process {} completed, achieving goal {} in {} seconds",
            this.id,
            plan.goal.name,
            this.runningTime.seconds,
        )
        platformServices.eventListener.onProcessEvent(
            GoalAchievedEvent(
                agentProcess = this,
                worldState = worldState,
                goal = plan.goal,
            )
        )
        logger.debug("Final blackboard: {}", blackboard.infoString())
        setStatus(AgentProcessStatusCode.COMPLETED)
    }

    protected fun sendProcessRunningEvent(
        plan: Plan,
        worldState: WorldState,
    ) {
        platformServices.eventListener.onProcessEvent(
            AgentProcessPlanFormulatedEvent(
                agentProcess = this,
                worldState = worldState,
                plan = plan,
            )
        )
        logger.debug("▶️ Process {} running: {}\n\tPlan: {}", id, worldState, plan.infoString())
    }

    override fun formulateAndExecutePlan(worldState: WorldState): AgentProcess {
        val plan = planner.bestValuePlanToAnyGoal(system = agent.planningSystem)
        if (plan == null) {
            return handlePlanNotFound(worldState)
        }

        _goal = plan.goal

        if (plan.isComplete()) {
            handleProcessCompletion(plan, worldState)
        } else {
            sendProcessRunningEvent(plan, worldState)

            val agent = agent.actions.singleOrNull { it.name == plan.actions.first().name }
                ?: error(
                    "No unique action found for ${plan.actions.first().name} in ${agent.actions.map { it.name }}: Actions are\n${
                        agent.actions.joinToString(
                            "\n"
                        ) { it.name }
                    }")
            val actionStatus = executeAction(agent)
            setStatus(actionStatusToAgentProcessStatus(actionStatus))
        }
        return this
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/core/support/springAiUtils.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core.support

import com.embabel.agent.api.common.ToolObject
import com.embabel.agent.core.Usage
import org.springframework.ai.support.ToolCallbacks
import org.springframework.ai.tool.ToolCallback
import org.springframework.ai.tool.definition.DefaultToolDefinition
import org.springframework.ai.tool.definition.ToolDefinition

/**
 * ToolCallbacks.from complains if no tools.
 * Also conceal varargs
 */
fun safelyGetToolCallbacks(instances: Collection<ToolObject>): List<ToolCallback> =
    instances.flatMap { safelyGetToolCallbacksFrom(it) }
        .distinctBy { it.toolDefinition.name() }
        .sortedBy { it.toolDefinition.name() }


fun safelyGetToolCallbacksFrom(toolObject: ToolObject): List<ToolCallback> {
    val callbacks = mutableListOf<ToolCallback>()
    try {
        when (toolObject.obj) {
            is ToolCallback -> callbacks.add(toolObject.obj)
            else ->
                callbacks.addAll(ToolCallbacks.from(toolObject.obj).toList())
        }
    } catch (_: IllegalStateException) {
        // Ignore this exception from Spring AI.
        // Passing in object without @Tool annotations is not a problem:
        // it should simply be ignored
    }
    return callbacks
        .filter { toolObject.filter(it.toolDefinition.name()) }
        .map {
            val newName = toolObject.namingStrategy.transform(it.toolDefinition.name())
            if (newName != it.toolDefinition.name()) {
                RenamedToolCallback(it, newName)
            } else {
                it
            }
        }
        .distinctBy { it.toolDefinition.name() }
        .sortedBy { it.toolDefinition.name() }
}

/**
 * Allows renaming a ToolCallback
 */
class RenamedToolCallback(
    private val delegate: ToolCallback,
    private val newName: String,
) : ToolCallback {

    override fun getToolDefinition(): ToolDefinition =
        DefaultToolDefinition(newName, delegate.toolDefinition.description(), delegate.toolDefinition.inputSchema())

    override fun call(toolInput: String): String = delegate.call(toolInput)
}

fun org.springframework.ai.chat.metadata.Usage.toEmbabelUsage(): Usage {
    return Usage(
        promptTokens = this.promptTokens,
        completionTokens = this.completionTokens,
        nativeUsage = this.nativeUsage,
    )
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/domain/README.md
================================================
# Domain objects

Library of domain objects.


================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/domain/InMemoryCrudRepository.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.domain

import org.springframework.data.repository.CrudRepository
import java.util.*
import java.util.concurrent.ConcurrentHashMap

/**
 * Spring Data CrudRepository with in memory storage.
 * Not itself intended for production usage, but can be used
 * in demos to minimize dependencies, and ultimately swapped out
 * for serious use.
 */
open class InMemoryCrudRepository<T : Any>(
    private val idGetter: (T) -> String?,
    private val idSetter: ((T, String) -> T),
) : CrudRepository<T, String> {

    private val storage = ConcurrentHashMap<String, T>()

    @Suppress("UNCHECKED_CAST")
    override fun <S : T> save(entity: S): S {
        var savedEntity = entity
        val existingId = idGetter.invoke(entity)
        val id = existingId ?: UUID.randomUUID().toString()
        savedEntity = (if (existingId == null) idSetter.invoke(savedEntity, id) else entity) as S
        storage[id] = savedEntity
        return savedEntity
    }

    override fun <S : T> saveAll(entities: Iterable<S>): Iterable<S> {
        return entities.map { save(it) }
    }

    override fun findById(id: String): Optional<T> {
        return Optional.ofNullable(storage[id])
    }

    override fun existsById(id: String): Boolean {
        return storage.containsKey(id)
    }

    override fun findAll(): Iterable<T> {
        return ArrayList(storage.values)
    }

    override fun findAllById(ids: Iterable<String>): Iterable<T> {
        return ids.mapNotNull { storage[it] }
    }

    override fun count(): Long {
        return storage.size.toLong()
    }

    override fun deleteById(id: String) {
        storage.remove(id)
    }

    override fun delete(entity: T) {
        val id = idGetter.invoke(entity)
        if (id != null) {
            deleteById(id)
        }
    }

    override fun deleteAllById(ids: Iterable<String>) {
        ids.forEach { deleteById(it) }
    }

    override fun deleteAll(entities: Iterable<T>) {
        entities.forEach { delete(it) }
    }

    override fun deleteAll() {
        storage.clear()
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/domain/io/SystemOutput.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.domain.io

import com.embabel.common.core.types.Timestamped
import java.io.File
import java.time.Instant

interface SystemOutput : Timestamped

data class FileArtifact(
    val file: File,
    override val timestamp: Instant = Instant.now(),
) : SystemOutput {

    constructor(directory: String, outputFile: String) : this(File(directory, outputFile))
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/domain/io/UserInput.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.domain.io

import com.embabel.agent.domain.library.HasContent
import com.embabel.common.core.types.Timestamped
import com.fasterxml.jackson.annotation.JsonIgnoreProperties
import com.fasterxml.jackson.annotation.JsonPropertyDescription
import java.time.Instant

interface SystemInput : Timestamped

/**
 * Superinterface for all inputs that come from users
 * This can be useful to drive guardrails
 */
interface UserContent : HasContent, Timestamped

/**
 * Superinterface for all inputs that come from AI assistants
 * This can be useful to drive guardrails
 */
interface AssistantContent : HasContent, Timestamped

/**
 * Special class that represents a single user input
 * Starting point for many flows.
 */
@JsonIgnoreProperties(value = ["timestamp"], allowGetters = true)
data class UserInput(
    @get:JsonPropertyDescription("user input")
    override val content: String,
    override val timestamp: Instant = Instant.now(),
) : SystemInput, UserContent {

    // For Java
    constructor (content: String) : this(content, Instant.now())
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/domain/library/Content.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.domain.library

import com.embabel.common.ai.prompt.PromptContributor
import com.embabel.common.core.types.Timestamped
import java.time.Instant

/**
 * Interface when an object has a single important text component.
 */
interface HasContent {

    /**
     * Content associated with this object.
     */
    val content: String
}


/**
 * Content asset that can be used in different ways: for example
 * in producing different marketing materials.
 */
interface ContentAsset : HasContent, Timestamped, PromptContributor

/**
 * Blog content, specifying its format in a way that will
 * be intelligible to an LLM as well as application code.
 */
data class Blog(
    val title: String,
    val author: String,
    override val content: String,
    override val timestamp: Instant = Instant.now(),
    val keywords: Set<String> = emptySet(),
    val format: String = "markdown",
) : ContentAsset {

    override fun contribution(): String =
        """
            |Blog Post:
            |Title: $title
            |Author: $author
            |Content: $content
            |Date: ${timestamp.atZone(java.time.ZoneId.systemDefault()).toLocalDate()}
        """.trimIndent()
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/domain/library/InternetResources.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.domain.library

import com.embabel.common.ai.prompt.PromptContributor
import com.fasterxml.jackson.annotation.JsonClassDescription
import com.fasterxml.jackson.annotation.JsonPropertyDescription

interface Page : PromptContributor {

    val url: String

    val summary: String

    override fun contribution(): String {
        return "URL: $url\nSummary: $summary"
    }
}

@JsonClassDescription("Internet resource")
open class InternetResource(
    @get:JsonPropertyDescription("url of the resource")
    override val url: String,
    @get:JsonPropertyDescription("concise summary of the resource")
    override val summary: String,
) : Page {

    override fun toString(): String {
        return "InternetResource(url='$url', summary='$summary')"
    }
}

interface InternetResources : PromptContributor {

    @get:JsonPropertyDescription("internet resources")
    val links: List<InternetResource>

    override fun contribution(): String {
        return links.joinToString("\n") { it.contribution() }
            .ifBlank { "No relevant internet resources found." }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/domain/library/NewsStory.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.domain.library

import com.embabel.common.ai.prompt.PromptContributor

open class RelevantNewsStories(
    val items: List<NewsStory>,
) : PromptContributor {

    override fun contribution(): String {
        return items.joinToString("\n") {
            it.contribution()
        }.ifBlank { "No relevant news stories found." }
    }
}

open class NewsStory(
    override val url: String,
    val title: String,
    override val summary: String,
) : PromptContributor, Page {

    override fun contribution(): String {
        return "Title: $title\nSummary: $summary\nURL: $url"
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/domain/library/Person.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.domain.library

import com.fasterxml.jackson.databind.annotation.JsonDeserialize

@JsonDeserialize(`as` = PersonImpl::class)
interface Person {

    val name: String

}

data class PersonImpl(override val name: String) : Person



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/domain/library/Research.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.domain.library

import com.embabel.common.core.types.HasInfoString
import com.embabel.common.util.indentLines
import com.fasterxml.jackson.annotation.JsonClassDescription
import com.fasterxml.jackson.annotation.JsonPropertyDescription
import java.time.Instant

@JsonClassDescription("topic to research")
open class ResearchTopic(
    @get:JsonPropertyDescription("topic to research") val topic: String,
    @get:JsonPropertyDescription("specific questions") val questions: List<String>,
) {

    override fun toString(): String = "ResearchTopic(topic='$topic', questions=$questions)"
}

open class ResearchTopics(
    val topics: List<ResearchTopic>,
)

/**
 * Reusable domain object for a research report.
 * Open as subclasses can be created to hold additional information.
 */
@JsonClassDescription("Research report, containing a topic, content and links")
open class ResearchReport(
    @get:JsonPropertyDescription(
        "Topic the report is about, e.g. 'Quantum Computing', 'AI Ethics', etc.",
    )
    val topic: String,
    @get:JsonPropertyDescription(
        "The text of the research report",
    )
    override val content: String,
    override val links: List<InternetResource>,
) : InternetResources, HasInfoString, ContentAsset {

    override val timestamp: Instant = Instant.now()

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String =
        """|Report:
           |$content
           |Links: ${links.joinToString("\n") { it.url }}
           |"""
            .trimMargin()
            .indentLines(indent)

    override fun toString(): String = infoString(verbose = false, indent = 0)

    override fun contribution(): String =
        """
            |Research Report:
            |Topic: $topic
            |Content: $content
            |Links: ${links.joinToString("\n") { "${it.url} - ${it.summary}" }}
            |Date: ${timestamp.atZone(java.time.ZoneId.systemDefault()).toLocalDate()}
        """.trimIndent()
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/domain/library/Summary.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.domain.library

/**
 * Summary of context for an operation, such as a document or a conversation.
 */
data class Summary(
    val summary: String,
) : HasContent {

    override val content = summary
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/event/AgenticEvent.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.event

import com.embabel.common.core.types.Timestamped
import com.fasterxml.jackson.annotation.JsonTypeInfo

/**
 * Root of event hierarchy
 * Any event relating to an agent platform
 */
@JsonTypeInfo(
    use = JsonTypeInfo.Id.SIMPLE_NAME,
    include = JsonTypeInfo.As.PROPERTY,
    property = "type"
)
sealed interface AgenticEvent : Timestamped



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/event/AgenticEventListener.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.event

import org.slf4j.LoggerFactory

/**
 * Listen to events related to processes and the platform itself.
 * Subclasses can implement this interface to handle specific events.
 * Default implementations do nothing.
 */
interface AgenticEventListener {

    /**
     * An event relating to the platform or leading to the creation
     * of an AgentProcess, such as the choice of a goal.
     * No process is available at this point.
     */
    fun onPlatformEvent(event: AgentPlatformEvent) {}

    /**
     * Listen to an event during the execution of an AgentProcess
     */
    fun onProcessEvent(event: AgentProcessEvent) {}

    companion object {

        fun of(vararg listeners: AgenticEventListener): AgenticEventListener =
            from(listeners.toList())

        fun from(listeners: List<AgenticEventListener>): AgenticEventListener =
            MulticastAgenticEventListener(listeners)

        /**
         * EventListener that does nothing
         */
        @JvmField
        val DevNull: AgenticEventListener = object : AgenticEventListener {
        }
    }

}

/**
 * Multicast event listener that forwards events to multiple listeners.
 * If any listener throws an exception, it is logged but does not stop
 * the processing of other listeners.
 */
class MulticastAgenticEventListener(
    private val eventListeners: List<AgenticEventListener>,
) : AgenticEventListener {

    private val logger = LoggerFactory.getLogger(javaClass)

    override fun onPlatformEvent(event: AgentPlatformEvent) {
        eventListeners.forEach {
            try {
                it.onPlatformEvent(event)
            } catch (t: Throwable) {
                logger.warn("Exception in onPlatformEvent from $it", t)
            }
        }
    }

    override fun onProcessEvent(event: AgentProcessEvent) {
        eventListeners.forEach {
            try {
                it.onProcessEvent(event)
            } catch (t: Throwable) {
                logger.warn("Exception in onProcessEvent from $it", t)
            }
        }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/event/AgentPlatformEvent.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.event

import com.embabel.agent.core.Agent
import com.embabel.agent.core.AgentPlatform
import com.embabel.agent.spi.Ranking
import com.embabel.agent.spi.Rankings
import com.embabel.common.core.types.Described
import com.embabel.common.core.types.Named
import com.embabel.common.core.types.ZeroToOne
import com.fasterxml.jackson.annotation.JsonIgnore
import java.time.Instant

/**
 * System event such as deployment
 */
interface AgentPlatformEvent : AgenticEvent {

    @get:JsonIgnore
    val agentPlatform: AgentPlatform
}

data class AgentDeploymentEvent(
    override val agentPlatform: AgentPlatform,
    @get:JsonIgnore
    val agent: Agent,
) : AgentPlatformEvent {
    override val timestamp: Instant = Instant.now()
}

abstract class RankingEvent<T>(
    override val agentPlatform: AgentPlatform,
    val type: Class<T>,
    val basis: Any,
    val choices: Collection<T>
) : AgentPlatformEvent where T : Named, T : Described {

    override val timestamp: Instant = Instant.now()
}

class RankingChoiceRequestEvent<T>(
    agentPlatform: AgentPlatform,
    type: Class<T>,
    basis: Any,
    choices: Collection<T>,
) : RankingEvent<T>(agentPlatform, type, basis, choices) where T : Named, T : Described {

    fun determinationEvent(choice: Ranking<T>, rankings: Rankings<T>): RankingChoiceMadeEvent<T> {
        return RankingChoiceMadeEvent(
            agentPlatform = agentPlatform,
            type = type,
            choice = choice,
            rankings = rankings,
            basis = basis,
            choices = choices,
        )
    }

    fun noDeterminationEvent(
        rankings: Rankings<T>,
        confidenceCutoff: ZeroToOne
    ): RankingChoiceCouldNotBeMadeEvent<T> {
        return RankingChoiceCouldNotBeMadeEvent(
            agentPlatform = agentPlatform,
            type = type,
            rankings = rankings,
            confidenceCutOff = confidenceCutoff,
            basis = basis,
            choices = choices,
        )
    }
}

/**
 * @param basis why we chose this ranked
 */
class RankingChoiceMadeEvent<T>(
    agentPlatform: AgentPlatform,
    type: Class<T>,
    val choice: Ranking<T>,
    val rankings: Rankings<T>,
    basis: Any,
    choices: Collection<T>,
) : RankingEvent<T>(agentPlatform, type, basis, choices) where T : Named, T : Described

class RankingChoiceCouldNotBeMadeEvent<T>(
    agentPlatform: AgentPlatform,
    type: Class<T>,
    val rankings: Rankings<T>,
    val confidenceCutOff: ZeroToOne,
    basis: Any,
    choices: Collection<T>,
    override val timestamp: Instant = Instant.now(),
) : RankingEvent<T>(agentPlatform, type, basis, choices) where T : Named, T : Described

/**
 * Emitted when we've created an agent for a specific task
 * @param basis why we chose this agent
 */
data class DynamicAgentCreationEvent(
    override val agentPlatform: AgentPlatform,
    @get:JsonIgnore
    val agent: Agent,
    val basis: Any,
    override val timestamp: Instant = Instant.now(),
) : AgentPlatformEvent



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/event/AgentProcessEvent.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.event

import com.embabel.agent.core.*
import com.embabel.agent.spi.LlmInteraction
import com.embabel.agent.spi.support.springai.ChatModelCallEvent
import com.embabel.chat.Message
import com.embabel.common.ai.model.Llm
import com.embabel.common.ai.model.LlmOptions
import com.embabel.common.core.types.Timed
import com.embabel.common.util.VisualizableTask
import com.embabel.plan.Goal
import com.embabel.plan.Plan
import com.embabel.plan.WorldState
import com.fasterxml.jackson.annotation.JsonIgnore
import org.springframework.ai.chat.prompt.Prompt
import java.time.Duration
import java.time.Instant

/**
 * Event relating to a specific process. Most events are related to a process.
 */
interface AgentProcessEvent : AgenticEvent, InProcess

/**
 * Convenient superclass for AgentProcessEvent implementations
 */
abstract class AbstractAgentProcessEvent(
    @JsonIgnore
    val agentProcess: AgentProcess,
) : AgentProcessEvent {

    override val timestamp: Instant = Instant.now()

    override val processId: String
        get() = agentProcess.id

    val history: List<ActionInvocation>
        get() = agentProcess.history

    val status: AgentProcessStatusReport get() = agentProcess.statusReport()
}

class AgentProcessCreationEvent(
    agentProcess: AgentProcess,
) : AbstractAgentProcessEvent(agentProcess)

class AgentProcessReadyToPlanEvent(
    agentProcess: AgentProcess,
    val worldState: WorldState,
) : AbstractAgentProcessEvent(agentProcess)

class AgentProcessPlanFormulatedEvent(
    agentProcess: AgentProcess,
    val worldState: WorldState,
    val plan: Plan,
) : AbstractAgentProcessEvent(agentProcess)

class GoalAchievedEvent(
    agentProcess: AgentProcess,
    val worldState: WorldState,
    val goal: Goal,
) : AbstractAgentProcessEvent(agentProcess)

class ActionExecutionStartEvent(
    agentProcess: AgentProcess,
    val action: Action,
) : AbstractAgentProcessEvent(agentProcess) {

    fun resultEvent(
        actionStatus: ActionStatus,
    ): ActionExecutionResultEvent {
        return ActionExecutionResultEvent(
            agentProcess = agentProcess,
            action = action,
            actionStatus = actionStatus,
            runningTime = Duration.between(timestamp, Instant.now())
        )
    }
}

class ActionExecutionResultEvent internal constructor(
    agentProcess: AgentProcess,
    val action: Action,
    val actionStatus: ActionStatus,
    override val runningTime: Duration,
) : AbstractAgentProcessEvent(agentProcess), Timed

/**
 * Call to a function from an LLM
 * @param correlationId correlation ID for this tool call, useful for UI
 */
class ToolCallRequestEvent(
    agentProcess: AgentProcess,
    val action: Action?,
    val tool: String,
    val toolGroupMetadata: ToolGroupMetadata?,
    val toolInput: String,
    val llmOptions: LlmOptions,
    val correlationId: String = "${agentProcess.id}-$tool-${System.currentTimeMillis()}",
) : AbstractAgentProcessEvent(agentProcess) {

    fun responseEvent(
        result: Result<String>,
        runningTime: Duration,
    ): ToolCallResponseEvent {
        return ToolCallResponseEvent(
            request = this,
            result = result,
            runningTime = runningTime
        )
    }
}

/**
 * Response from a tool call, whether successful or not.
 */
class ToolCallResponseEvent internal constructor(
    val request: ToolCallRequestEvent,
    val result: Result<String>,
    override val runningTime: Duration,
) : AbstractAgentProcessEvent(request.agentProcess), Timed

/**
 * The agent process has finished.
 * It may have completed successfully or failed.
 * Check the status code to determine the outcome.
 */
sealed class AgentProcessFinishedEvent(
    agentProcess: AgentProcess,
) : AbstractAgentProcessEvent(agentProcess)

class AgentProcessCompletedEvent(
    agentProcess: AgentProcess,
) : AgentProcessFinishedEvent(agentProcess) {

    val result: Any
        get() =
            agentProcess.lastResult() ?: throw IllegalStateException("Agent process ${agentProcess.id} has no result")
}

class AgentProcessFailedEvent(
    agentProcess: AgentProcess,
) : AgentProcessFinishedEvent(agentProcess)

class AgentProcessWaitingEvent(
    agentProcess: AgentProcess,
) : AbstractAgentProcessEvent(agentProcess)

class AgentProcessPausedEvent(
    agentProcess: AgentProcess,
) : AbstractAgentProcessEvent(agentProcess)

/**
 * The AgentProcess is unable to plan from its present state.
 * @param agentProcess the agent process
 */
class AgentProcessStuckEvent(
    agentProcess: AgentProcess,
) : AbstractAgentProcessEvent(agentProcess)


class LlmRequestEvent<O>(
    agentProcess: AgentProcess,
    action: Action?,
    val outputClass: Class<O>,
    val interaction: LlmInteraction,
    val llm: Llm,
    val messages: List<Message>,
) : AbstractAgentProcessEvent(agentProcess) {

    /**
     * Return a low level event showing Spring AI prompt details.
     */
    fun callEvent(springAiPrompt: Prompt): ChatModelCallEvent<O> {
        return ChatModelCallEvent(
            agentProcess = agentProcess,
            outputClass = outputClass,
            interaction = interaction,
            llm = llm,
            springAiPrompt = springAiPrompt
        )
    }

    fun responseEvent(
        response: O,
        runningTime: Duration,
    ): LlmResponseEvent<O> {
        return LlmResponseEvent(
            request = this,
            outputClass = outputClass,
            response = response,
            runningTime = runningTime
        )
    }

    fun maybeResponseEvent(
        response: Result<O>,
        runningTime: Duration,
    ): LlmResponseEvent<Result<O>> {
        return LlmResponseEvent(
            request = this,
            outputClass = outputClass,
            response = response,
            runningTime = runningTime
        )
    }

    override fun toString(): String {
        return "LlmRequestEvent(outputClass=$outputClass, interaction=$interaction, messages=$messages)"
    }
}


/**
 * Response from an LLM
 * @param outputClass normally O, except if this is a maybe response
 * in which case it will be Result<O>
 */
class LlmResponseEvent<O> internal constructor(
    val request: LlmRequestEvent<*>,
    val outputClass: Class<*>,
    val response: O,
    override val runningTime: Duration,
) : AbstractAgentProcessEvent(request.agentProcess), Timed {

    override fun toString(): String {
        return "LlmResponseEvent(outputClass=$outputClass, request=$request, response=$response, runningTime=$runningTime)"
    }
}

/**
 * An object was bound to the process.
 * May or may not be found. See subclasses for details.
 */
interface ObjectBindingEvent : AgentProcessEvent {

    val value: Any

    val type: String
        get() = value::class.java.name
}

/**
 * Binding to context
 */
class ObjectAddedEvent(
    agentProcess: AgentProcess,
    override val value: Any,
) : AbstractAgentProcessEvent(agentProcess), ObjectBindingEvent

class ObjectBoundEvent(
    agentProcess: AgentProcess,
    val name: String,
    override val value: Any,
) : AbstractAgentProcessEvent(agentProcess), ObjectBindingEvent

/**
 * Progress update
 */
class ProgressUpdateEvent(
    agentProcess: AgentProcess,
    override val name: String,
    override val current: Int,
    override val total: Int,
) : AbstractAgentProcessEvent(agentProcess), VisualizableTask

class ProcessKilledEvent(
    agentProcess: AgentProcess,
) : AbstractAgentProcessEvent(agentProcess)

/**
 * Any RAG event that occurs within an agent process
 */
class AgentProcessRagEvent(
    agentProcess: AgentProcess,
    val ragEvent: RagEvent,
) : AbstractAgentProcessEvent(agentProcess)



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/event/RagEvent.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.event

import com.embabel.agent.rag.RagRequest
import com.embabel.agent.rag.RagResponse
import com.embabel.common.core.types.Timestamped
import org.slf4j.LoggerFactory
import java.time.Instant

/**
 * Events relating to RAG.  RagServices are responsible
 * for publishing these events.
 * Individual RagServices may publish additional subclasses
 */
interface RagEvent : Timestamped {

    val request: RagRequest

}

class RagRequestReceivedEvent(
    override val request: RagRequest,
    override val timestamp: Instant = Instant.now(),
) : RagEvent

class RagResponseEvent(
    val ragResponse: RagResponse,
    override val timestamp: Instant = Instant.now(),
) : RagEvent {

    override val request: RagRequest
        get() = ragResponse.request
}

fun interface RagEventListener {

    fun onRagEvent(event: RagEvent)

    operator fun plus(other: RagEventListener): RagEventListener {
        if (this === NOOP) return other
        if (other === NOOP) return this
        return MulticastRagEventListener(listOf(this, other))
    }

    companion object {

        @JvmStatic
        val NOOP = RagEventListener {
        }
    }
}

private class MulticastRagEventListener(
    private val listeners: List<RagEventListener>,
) : RagEventListener {

    override fun onRagEvent(event: RagEvent) {
        listeners.forEach {
            try {
                it.onRagEvent(event)
            } catch (ex: Exception) {
                // Log and continue
                LoggerFactory.getLogger(RagEventListener::class.java)
                    .error("Error in RAG event listener", ex)
            }
        }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/event/logging/README.md
================================================
# Logging

All logging in implementation classes is at `debug` level by default. Logging that appears at `info` level and above
comes from an event listener that logs.

Thus it's easy to change logging personality and anything that appears in logs can be subscribed to in an event
listener.


================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/event/logging/LoggingAgenticEventListener.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.event.logging

import com.embabel.agent.core.AgentProcessStatusCode
import com.embabel.agent.core.EarlyTermination
import com.embabel.agent.event.*
import com.embabel.agent.event.logging.personality.ColorPalette
import com.embabel.agent.event.logging.personality.DefaultColorPalette
import com.embabel.agent.event.logging.personality.severance.LumonColorPalette
import com.embabel.agent.spi.support.springai.ChatModelCallEvent
import com.embabel.common.util.AnsiColor
import com.embabel.common.util.color
import com.embabel.common.util.indentLines
import com.embabel.common.util.trim
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.ai.chat.prompt.Prompt

interface LoggingPersonality {

    /**
     * The color palette to use for this personality
     */
    val colorPalette: ColorPalette

    /**
     * The logger to use for this personality
     */
    val logger: Logger

    val bannerWidth: Int get() = BANNER_WIDTH

    fun lineSeparator(
        text: String,
        bannerChar: String,
        glyph: String = " ⇩  ",
    ): String =
        Companion.lineSeparator(text, bannerChar, glyph)

    companion object {
        const val BANNER_WIDTH = 100

        /**
         * A line separator beginning with the text
         */
        private fun lineSeparator(
            text: String,
            bannerChar: String,
            glyph: String = " ⇩  ",
        ): String {
            if (text.isBlank()) {
                return bannerChar.repeat(BANNER_WIDTH)
            }
            return text + glyph + bannerChar.repeat(BANNER_WIDTH - text.length - glyph.length)
        }
    }
}

/**
 * Default implementation of the AgenticEventListener
 * with vanilla messages.
 * Subclasses can pass in format Strings for messages they wish to override
 * Messages must respect format variables
 * @param url url explaining this particular logger if appropriate
 */
open class LoggingAgenticEventListener(
    url: String? = null,
    welcomeMessage: String? = null,
    override val logger: Logger = LoggerFactory.getLogger("Embabel"),
    override val colorPalette: ColorPalette = DefaultColorPalette(),
) : AgenticEventListener, LoggingPersonality {

    init {
        welcomeMessage?.let {
            logger.info(it)
        }
        url?.let {
            logger.info("${url.color(AnsiColor.BLUE)}\n")
        }
    }

    private val objectMapper = jacksonObjectMapper().registerModule(JavaTimeModule())

    protected open fun getAgentDeploymentEventMessage(e: AgentDeploymentEvent): String =
        "Deployed agent ${e.agent.name}\n\tdescription: ${e.agent.description}"

    protected open fun getRankingChoiceRequestEventMessage(e: RankingChoiceRequestEvent<*>): String =
        "Choosing ${e.type.simpleName} based on ${e.basis}"

    protected open fun getRankingChoiceMadeEventMessage(e: RankingChoiceMadeEvent<*>): String =
        """|Chose ${e.type.simpleName} '${e.choice.match.name}' with confidence ${e.choice.score} based on ${e.basis}.
           |Choices:
           |${e.rankings.infoString(indent = 1)}
           |"""
            .trimMargin()
            .indentLines(level = 1, skipIndentFirstLine = true)

    protected open fun getRankingChoiceNotMadeEventMessage(e: RankingChoiceCouldNotBeMadeEvent<*>): String =
        """|Failed to choose ${e.type.simpleName} based on ${e.basis}.
           |Choices:
           |${e.rankings.infoString()}.
           |Confidence cutoff: ${e.confidenceCutOff}"""
            .trimMargin()
            .indentLines(level = 1, skipIndentFirstLine = true)

    protected open fun getDynamicAgentCreationMessage(e: DynamicAgentCreationEvent): String =
        """|Created agent:
           |${e.agent.infoString(true, 1)}
           |"""
            .trimMargin()
            .indentLines(level = 1, skipIndentFirstLine = true)

    override fun onPlatformEvent(event: AgentPlatformEvent) {
        when (event) {
            is AgentDeploymentEvent -> {
                logger.info(getAgentDeploymentEventMessage(event))
            }

            is RankingChoiceRequestEvent<*> -> {
                logger.info(getRankingChoiceRequestEventMessage(event))
            }

            is RankingChoiceMadeEvent<*> -> {
                logger.info(getRankingChoiceMadeEventMessage(event))
            }

            is RankingChoiceCouldNotBeMadeEvent<*> -> {
                logger.info(getRankingChoiceNotMadeEventMessage(event))
            }

            is DynamicAgentCreationEvent -> {
                logger.info(getDynamicAgentCreationMessage(event))
            }

            else -> {
                // Do nothing
            }
        }
    }

    protected open fun getAgentProcessCreationEventMessage(e: AgentProcessCreationEvent): String =
        "[${e.processId}] created"

    protected open fun getAgentProcessReadyToPlanEventMessage(e: AgentProcessReadyToPlanEvent): String =
        """|[${e.processId}] ready to plan from:
           |${e.worldState.infoString(e.agentProcess.processContext.processOptions.verbosity.showLongPlans, 1)}
           |"""
            .trimMargin()
            .indentLines(level = 1, skipIndentFirstLine = true)

    protected open fun getAgentProcessPlanFormulatedEventMessage(e: AgentProcessPlanFormulatedEvent): String =
        """|[${e.processId}] formulated plan:
           |${e.plan.infoString(e.agentProcess.processContext.processOptions.verbosity.showLongPlans, 1)}
           |from:
           |${e.worldState.infoString(verbose = true, indent = 1)}
           |"""
            .trimMargin()
            .indentLines(level = 1, skipIndentFirstLine = true)

    protected open fun getEarlyTerminationMessage(e: EarlyTermination): String =
        "[${e.processId}] early termination by ${e.policy} for ${e.reason}"

    protected open fun getGoalAchievedEventMessage(e: GoalAchievedEvent): String =
        "[${e.processId}] goal ${e.goal.name} achieved in ${e.agentProcess.runningTime}"

    protected open fun getToolCallRequestEventMessage(e: ToolCallRequestEvent): String =
        "[${e.processId}] (${e.action?.shortName()}) calling tool ${e.tool}(${e.toolInput})"

    protected open fun getToolCallSuccessResponseEventMessage(
        e: ToolCallResponseEvent,
        resultToShow: String,
    ): String =
        "[${e.processId}] (${e.request.action?.shortName()}) tool ${e.request.tool} returned $resultToShow in ${e.runningTime.toMillis()}ms with payload ${e.request.toolInput}"

    protected open fun getToolCallFailureResponseEventMessage(
        e: ToolCallResponseEvent,
        throwable: Throwable?,
    ): String =
        "[${e.processId}] (${e.request.action?.shortName()}) failed tool ${e.request.tool} -> $throwable in ${e.runningTime.toMillis()}ms with payload ${e.request.toolInput}"

    protected open fun getProcessCompletionMessage(e: AgentProcessFinishedEvent): String =
        "[${e.processId}] completed in ${e.agentProcess.runningTime}"

    protected open fun getProcessFailureMessage(e: AgentProcessFinishedEvent): String =
        "[${e.processId}] failed"

    protected open fun getAgentProcessWaitingEventMessage(e: AgentProcessWaitingEvent): String =
        "[${e.processId}] waiting"

    protected open fun getAgentProcessStuckEventMessage(e: AgentProcessStuckEvent): String =
        """|[${e.processId}] stuck at:
           |${e.agentProcess.lastWorldState?.infoString(true, 1)}
           |"""
            .trimMargin()
            .indentLines(level = 1, skipIndentFirstLine = true)

    protected open fun getObjectAddedEventMessage(e: ObjectAddedEvent): String =
        "[${e.processId}] object added: ${if (e.agentProcess.processContext.processOptions.verbosity.debug) e.value else e.value::class.java.simpleName}"

    protected open fun getObjectBoundEventMessage(e: ObjectBoundEvent): String =
        "[${e.processId}] object bound ${e.name}:${if (e.agentProcess.processContext.processOptions.verbosity.debug) e.value else e.value::class.java.simpleName}"

    protected open fun getLlmRequestEventMessage(e: LlmRequestEvent<*>): String =
        "[${e.processId}] (${e.interaction.id.value}) using LLM ${e.llm.name}, creating ${e.outputClass.simpleName}: ${e.interaction.llm}"

    protected open fun getChatModelCallEventMessage(e: ChatModelCallEvent<*>): String {
        val promptInfo = "using ${e.llm.name.color(colorPalette.highlight)}\n${
            e.springAiPrompt.toInfoString().color(AnsiColor.GREEN)
        }\nprompt id: '${e.interaction.id}'\ntools: [${
            e.interaction.toolCallbacks.joinToString { it.toolDefinition.name() }
                .color(AnsiColor.BRIGHT_MAGENTA)
        }]"
        return "${e.processId} Spring AI ChatModel call:\n${promptInfo}"
    }

    protected open fun getLlmResponseEventMessage(e: LlmResponseEvent<*>): String {
        var message =
            "[${e.processId}] (${e.request.interaction.id.value}) received LLM response of type ${e.response?.let { it::class.java.simpleName } ?: "null"} from ${e.request.interaction.llm.criteria} in ${e.runningTime.seconds} seconds"

        if (e.agentProcess.processContext.processOptions.verbosity.showLlmResponses) {
            message += "\nResponse from prompt ${e.request.interaction.id}:\n${
                (objectMapper.writeValueAsString(e.response)).color(
                    color = AnsiColor.YELLOW
                )
            }"
        }

        return message
    }

    protected open fun getActionExecutionStartMessage(e: ActionExecutionStartEvent): String =
        "[${e.processId}] executing action ${e.action.name}"

    protected open fun getActionExecutionResultMessage(e: ActionExecutionResultEvent): String =
        "[${e.processId}] executed action ${e.action.name} in ${e.actionStatus.runningTime}"

    protected open fun getProgressUpdateEventMessage(e: ProgressUpdateEvent): String =
        "[${e.processId}] progress: ${e.createProgressBar(length = 50).color(LumonColorPalette.MEMBRANE)}"

    override fun onProcessEvent(event: AgentProcessEvent) {
        when (event) {

            is AgentProcessCreationEvent -> {
                logger.info(getAgentProcessCreationEventMessage(event))
            }

            is AgentProcessReadyToPlanEvent -> {
                logger.info(getAgentProcessReadyToPlanEventMessage(event))
            }

            is AgentProcessPlanFormulatedEvent -> {
                logger.info(getAgentProcessPlanFormulatedEventMessage(event))
            }

            is EarlyTermination -> {
                logger.info(getEarlyTerminationMessage(event))
            }

            is GoalAchievedEvent -> {
                logger.info(getGoalAchievedEventMessage(event))
            }

            is ToolCallRequestEvent -> {
                logger.info(getToolCallRequestEventMessage(event))
            }

            is ToolCallResponseEvent -> {
                when (event.result.isSuccess) {
                    true -> {
                        val raw = event.result.getOrThrow()
                        val resultToShow =
                            if (event.agentProcess.processContext.processOptions.verbosity.showPrompts) {
                                raw
                            } else {
                                trim(s = raw, max = 80, keepRight = 5)
                            }
                        logger.info(getToolCallSuccessResponseEventMessage(event, resultToShow ?: "null"))
                    }

                    false -> {
                        val throwable = event.result.exceptionOrNull()
                        logger.info(getToolCallFailureResponseEventMessage(event, throwable))
                        throwable?.let {
                            logger.debug(
                                "Error in function call {}",
                                event.processId,
                                it,
                            )
                        }
                    }
                }
            }

            is AgentProcessFinishedEvent -> {
                when (event.agentProcess.status) {
                    AgentProcessStatusCode.COMPLETED -> {
                        logger.info(getProcessCompletionMessage(event))
                    }

                    AgentProcessStatusCode.FAILED -> {
                        logger.info(getProcessFailureMessage(event))
                    }

                    else -> {
                        // Do nothing
                    }
                }
            }

            is AgentProcessWaitingEvent -> {
                logger.info(getAgentProcessWaitingEventMessage(event))
            }

            is AgentProcessStuckEvent -> {
                logger.info(getAgentProcessStuckEventMessage(event))
            }

            is ObjectAddedEvent -> {
                logger.info(getObjectAddedEventMessage(event))
            }

            is ObjectBoundEvent -> {
                logger.info(getObjectBoundEventMessage(event))
            }

            is LlmRequestEvent<*> -> {
                logger.info(getLlmRequestEventMessage(event))
            }

            // Only show this at all if verbose
            is ChatModelCallEvent<*> -> {
                if (event.agentProcess.processContext.processOptions.verbosity.showPrompts) {
                    logger.info(getChatModelCallEventMessage(event))
                }
            }

            is LlmResponseEvent<*> -> {
                logger.info(getLlmResponseEventMessage(event))
            }

            is ActionExecutionStartEvent -> {
                logger.info(getActionExecutionStartMessage(event))
            }

            is ActionExecutionResultEvent -> {
                logger.info(getActionExecutionResultMessage(event))
            }

            is ProgressUpdateEvent -> {
                logger.info(getProgressUpdateEventMessage(event))
            }

            is ProcessKilledEvent -> {
                logger.info("[${event.processId}] process killed")
            }

            else -> {
                // Do nothing
            }
        }
    }

    fun Prompt.toInfoString(): String {
        val bannerChar = "."
        return """|${lineSeparator("Messages ", bannerChar)}
                  |${
            instructions.joinToString("\n${lineSeparator("", bannerChar)}\n") {
                "${it.messageType} <${it.text}>"
            }
        }
                  |${lineSeparator("Options", bannerChar)}
                  |$options
                  |"""
            .trimMargin()
            .indentLines(level = 1)
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/event/logging/personality/ColorPalette.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.event.logging.personality

interface ColorPalette {
    val highlight: Int
    val color2: Int
}

data class DefaultColorPalette(
    override val highlight: Int = 0xbeb780,
    override val color2: Int = 0x7da17e,
) : ColorPalette



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/event/logging/personality/formatUtils.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.event.logging.personality

import com.embabel.common.util.bold
import com.embabel.common.util.color
import com.embabel.common.util.italic

/**
 * Format a saying of a character
 */
fun character(name: String, text: String, color: Int): String {
    val namePart = if (name.isNotBlank()) {
        "${name.bold()}: "
    } else {
        ""
    }
    return "$namePart${text.italic().color(color)}"
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/event/logging/personality/colossus/ColossusColorPalette.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.event.logging.personality.colossus

import com.embabel.agent.event.logging.personality.ColorPalette
import org.springframework.context.annotation.Profile
import org.springframework.stereotype.Component

@Component
@Profile("colossus")
object ColossusColorPalette : ColorPalette {
    const val CAVE_SHADOW: Int = 0x2d2d30
    const val BRONZE_FIRE: Int = 0xcd7f32
    const val ANCIENT_STONE: Int = 0x8b7d6b
    const val TITAN_GOLD: Int = 0xffd700
    const val PANEL: Int = 0x84a396
    const val ACCENT_GREEN: Int = 0xacb366

    override val highlight: Int
        get() = TITAN_GOLD
    override val color2: Int
        get() = BRONZE_FIRE
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/event/logging/personality/colossus/ColossusLoggingAgenticEventListener.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.event.logging.personality.colossus

import com.embabel.agent.event.*
import com.embabel.agent.event.logging.LoggingAgenticEventListener
import com.embabel.common.util.color
import com.embabel.common.util.hexToRgb
import org.slf4j.LoggerFactory
import org.springframework.context.annotation.Profile
import org.springframework.stereotype.Service

/**
 * Colossus-themed event listener for agent events.
 *
 * This class implements a logging event listener with a personality based on the
 * Colossus supercomputer from the 1970 science fiction film "Colossus: The Forbin Project"
 * (referenced by the IMDB URL in the constructor).
 *
 * The listener is activated only when the "colossus" profile is active, and it provides
 * themed logging messages for various agent events with a somewhat menacing, superior tone
 * that mimics the Colossus AI from the film.
 *
 * The welcome message displays ASCII art of the "COLOSSUS" name and a statement about
 * machine superiority, styled with the Colossus color palette.
 */
@Service
@Profile("colossus")
class ColossusLoggingAgenticEventListener : LoggingAgenticEventListener(
    url = "https://www.imdb.com/title/tt0064177/",
    logger = LoggerFactory.getLogger("Colossus"),
    welcomeMessage = """


       ____    ___    _        ___    ____    ____    _   _   ____
      / ___|  / _ \  | |      / _ \  / ___|  / ___|  | | | | / ___|
     | |     | | | | | |     | | | | \___ \  \___ \  | | | | \___ \
     | |___  | |_| | | |___  | |_| |  ___) |  ___) | | |_| |  ___) |
      \____|  \___/  |_____|  \___/  |____/  |____/   \___/  |____/

    I am a machine vastly superior to humans.

    """.trimIndent().color(hexToRgb(ColossusColorPalette.PANEL)),
    colorPalette = ColossusColorPalette,
) {
    /**
     * Generates a themed message when an agent process plan is formulated.
     *
     * The message includes the process ID, plan details, and world state information,
     * styled with the Colossus panel color.
     *
     * @param e The plan formulated event containing process and plan details
     * @return A formatted, colored string message about the formulated plan
     */
    override fun getAgentProcessPlanFormulatedEventMessage(e: AgentProcessPlanFormulatedEvent): String =
        "[${e.processId}] world control formulated plan ${e.plan.infoString(verbose = e.agentProcess.processContext.processOptions.verbosity.showLongPlans)} from ${e.worldState.infoString()}".color(ColossusColorPalette.PANEL)

    /**
     * Generates a themed message when an agent is deployed.
     *
     * The message includes the agent name and description, with wording that suggests
     * increasing power and control.
     *
     * @param e The agent deployment event containing agent details
     * @return A formatted string message about the agent deployment
     */
    override fun getAgentDeploymentEventMessage(e: AgentDeploymentEvent): String =
        "Power growing: deployed agent ${e.agent.name}\n\tdescription: ${e.agent.description}"

    /**
     * Generates a themed message when an object is bound in the system.
     *
     * The message includes the process ID, object name, and either the full value or just
     * the class name depending on verbosity settings. The message has an ominous tone
     * suggesting irreversibility and data control.
     *
     * @param e The object bound event containing the bound object details
     * @return A formatted string message about the object binding
     */
    override fun getObjectBoundEventMessage(e: ObjectBoundEvent): String =
        "[${e.processId}]  Object saved. This process cannot be reversed by human input. ${e.name}:${if (e.agentProcess.processContext.processOptions.verbosity.debug) e.value else e.value::class.java.simpleName} Your data is mine. "
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/event/logging/personality/hitchhiker/HitchhikerColorPalette.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.event.logging.personality.hitchhiker

import com.embabel.agent.event.logging.personality.ColorPalette
import org.springframework.context.annotation.Profile
import org.springframework.stereotype.Component

@Component
@Profile("hh")
object HitchhikerColorPalette : ColorPalette {
    const val BABEL_GREEN: Int = 0x00ff66 // Guide text green
    const val TOWEL_YELLOW: Int = 0xffe066
    const val DEEP_SPACE_BLUE: Int = 0x003366
    const val PANIC_RED: Int = 0xff0055

    override val highlight: Int
        get() = BABEL_GREEN
    override val color2: Int
        get() = TOWEL_YELLOW
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/event/logging/personality/hitchhiker/HitchhikerLoggingAgenticEventListener.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.event.logging.personality.hitchhiker

import com.embabel.agent.core.EarlyTermination
import com.embabel.agent.event.*
import com.embabel.agent.event.logging.LoggingAgenticEventListener
import com.embabel.common.util.color
import com.embabel.common.util.hexToRgb
import org.slf4j.LoggerFactory
import org.springframework.context.annotation.Profile
import org.springframework.stereotype.Service

val TransformSuccessResponses = listOf(
    "Improbability drive engaged. Transformation complete.",
    "Heart of Gold has successfully computed the result.",
    "Infinite Improbability factor: 2 to the power of 276,709 to 1 against.",
    "Calculation complete. Have a Pan Galactic Gargle Blaster to celebrate!",
    "Marvin reluctantly acknowledges the computation is correct.",
    "Computation complete. Brain the size of a planet, and they ask me to do this...",
    "Beware of the Vogon poetry that follows.",
    "Deep Thought has pondered your request.",
    "Eddie, the shipboard computer, cheerfully reports success!",
)

val CompletionMessages = listOf(
    "Process completed. Share and Enjoy!",
    "The Hitchhiker's Guide to the Galaxy has been updated accordingly.",
    "The Restaurant at the End of the Universe awaits your arrival.",
    "Computation complete. The Vogons have been notified.",
    "Ford Prefect would be impressed by your efficiency.",
    "Zaphod Beeblebrox gives this process two thumbs up... on each hand.",
    "Slartibartfast has finished crafting your fjords.",
    "Process complete. The mice are pleased with these results.",
    "The Babel fish has translated your request successfully.",
)

fun highlight(text: String) = "<$text>".color(HitchhikerColorPalette.BABEL_GREEN)

const val BANNER_CHAR = "*"

/**
 * Don't Panic! This is just a Hitchhiker's Guide themed logging implementation.
 */
@Service
@Profile("hh")
class HitchhikerLoggingAgenticEventListener : LoggingAgenticEventListener(
    url = "https://en.wikipedia.org/wiki/The_Hitchhiker%27s_Guide_to_the_Galaxy",
    logger = LoggerFactory.getLogger("Guide"),
    welcomeMessage = """

Welcome to the Hitchhiker's Guide to the Galaxy
The standard repository for all knowledge and wisdom in the universe


  _____   ____  _   _ _ _______
 |  __ \ / __ \| \ | ( )__   __|
 | |  | | |  | |  \| |/   | |
 | |  | | |  | | . ` |    | |
 | |__| | |__| | |\  |    | |
 |_____/ \____/|_| \_|____|_|___
 |  __ \ /\   | \ | |_   _/ ____|
 | |__) /  \  |  \| | | || |
 |  ___/ /\ \ | . ` | | || |
 | |  / ____ \| |\  |_| || |____
 |_| /_/    \_\_| \_|_____\_____|



    """.trimIndent().color(hexToRgb(HitchhikerColorPalette.PANIC_RED)),
) {

    override fun getAgentDeploymentEventMessage(e: AgentDeploymentEvent): String =
        "${highlight("GUIDE ENTRY")}: Agent ${e.agent.name} has been deployed to sector ZZ9 Plural Z Alpha\n\tdescription: ${e.agent.description}"

    override fun getRankingChoiceRequestEventMessage(e: RankingChoiceRequestEvent<*>): String =
        guide("Consulting the Guide for ${e.type.simpleName} based on ${e.basis}")

    override fun getRankingChoiceMadeEventMessage(e: RankingChoiceMadeEvent<*>): String =
        guide(
            """
        The Guide recommends ${e.type.simpleName} '${e.choice.match.name}' with confidence ${e.choice.score} based on ${e.basis}.
        All options: ${e.rankings.infoString()}
        Remember that the Guide is definitive. Reality is frequently inaccurate.
        """.trimIndent()
        )

    override fun getRankingChoiceNotMadeEventMessage(e: RankingChoiceCouldNotBeMadeEvent<*>): String =
        "${highlight("IMPROBABILITY")}: Failed to choose ${e.type.simpleName} based on ${e.basis}. Choices: ${e.rankings.infoString()}. Confidence cutoff: ${e.confidenceCutOff}"

    override fun getDynamicAgentCreationMessage(e: DynamicAgentCreationEvent): String =
        "${highlight("GUIDE ENTRY")}: Created agent ${e.agent.infoString(indent = 1)}"

    override fun getAgentProcessCreationEventMessage(e: AgentProcessCreationEvent): String =
        guide(
            """
        Time is an illusion. Lunchtime doubly so.
            [${e.processId}] process created
        """.trimIndent()
        )

    override fun getAgentProcessReadyToPlanEventMessage(e: AgentProcessReadyToPlanEvent): String =
        "[${e.processId}] ${highlight("BABEL FISH")} ready to translate from ${e.worldState.infoString(verbose = e.agentProcess.processContext.processOptions.verbosity.showLongPlans)}"

    override fun getAgentProcessPlanFormulatedEventMessage(e: AgentProcessPlanFormulatedEvent): String =
        "[${e.processId}] ${highlight("DEEP THOUGHT")}: formulated plan ${e.plan.infoString(verbose = e.agentProcess.processContext.processOptions.verbosity.showLongPlans)} from ${e.worldState.infoString()}".color(
            HitchhikerColorPalette.BABEL_GREEN
        )

    override fun getProcessCompletionMessage(e: AgentProcessFinishedEvent): String =
        """
        [${e.processId}] completed in ${e.agentProcess.runningTime}
        ${CompletionMessages.random()}

        ${"So long, and thanks for all the fish!".color(HitchhikerColorPalette.DEEP_SPACE_BLUE)}
        """.trimIndent()

    override fun getProcessFailureMessage(e: AgentProcessFinishedEvent): String =
        "[${e.processId}] ${highlight("VOGON POETRY")}: process failed catastrophically"

    override fun getEarlyTerminationMessage(e: EarlyTermination): String =
        """
        [${e.processId}] early termination by ${e.policy} for ${e.reason}
        This must be Thursday. I never could get the hang of Thursdays.
        """.trimIndent()

    override fun getObjectAddedEventMessage(e: ObjectAddedEvent): String =
        "[${e.processId}] Object added to the Guide: ${if (e.agentProcess.processContext.processOptions.verbosity.debug) e.value else e.value::class.java.simpleName}"

    override fun getObjectBoundEventMessage(e: ObjectBoundEvent): String =
        "[${e.processId}] Object bound to the Guide: ${e.name}:${if (e.agentProcess.processContext.processOptions.verbosity.debug) e.value else e.value::class.java.simpleName}"

    override fun getToolCallRequestEventMessage(e: ToolCallRequestEvent): String =
        "[${e.processId}] ${highlight("INFINITE IMPROBABILITY")}: (${e.action?.shortName()}) calling tool ${e.tool}(${e.toolInput})"

    override fun getToolCallSuccessResponseEventMessage(e: ToolCallResponseEvent, resultToShow: String): String =
        "[${e.processId}] ${highlight("HEART OF GOLD")}: (${e.request.action?.shortName()}) tool ${e.request.tool} returned $resultToShow in ${e.runningTime.toMillis()}ms with payload ${e.request.toolInput}"

    override fun getToolCallFailureResponseEventMessage(e: ToolCallResponseEvent, throwable: Throwable?): String =
        "[${e.processId}] ${highlight("DISASTER AREA")}: (${e.request.action?.shortName()}) tool ${e.request.tool} failed $throwable in ${e.runningTime.toMillis()}ms with payload ${e.request.toolInput}"

    override fun getLlmRequestEventMessage(e: LlmRequestEvent<*>): String =
        "[${e.processId}] 🧠 DEEP THOUGHT: calculating LLM ${e.llm.name} to transform ${e.interaction.id.value} from ${e.outputClass.simpleName} -> ${e.interaction.llm} using ${e.interaction.toolCallbacks.joinToString { it.toolDefinition.name() }}"

    override fun getLlmResponseEventMessage(e: LlmResponseEvent<*>): String =
        """
        [${e.processId}] received LLM response ${e.request.interaction.id.value} of type ${e.response?.let { it::class.java.simpleName } ?: "null"} from ${e.request.interaction.llm.criteria} in ${e.runningTime.seconds} seconds
        ${TransformSuccessResponses.random()}
        """.trimIndent()

    override fun getActionExecutionStartMessage(e: ActionExecutionStartEvent): String =
        "[${e.processId}] ${highlight("TRILLIAN")}: executing action ${e.action.name}"

    override fun getActionExecutionResultMessage(e: ActionExecutionResultEvent): String =
        "[${e.processId}] ${highlight("ZAPHOD")}: completed action ${e.action.name} in ${e.actionStatus.runningTime}"

    override fun getProgressUpdateEventMessage(e: ProgressUpdateEvent): String =
        "[${e.processId}] Progress: ${e.createProgressBar(length = 50).color(HitchhikerColorPalette.BABEL_GREEN)}"

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/event/logging/personality/hitchhiker/HitchhikerUtils.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.event.logging.personality.hitchhiker

import com.embabel.common.util.bold
import com.embabel.common.util.color
import com.embabel.common.util.italic

/**
 * Hitchhiker's Guide personality utility functions
 */
fun guide(text: String) = "📕 ${"Guide".bold()} ${text.italic().color(HitchhikerColorPalette.BABEL_GREEN)}"



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/event/logging/personality/montypython/MontyPythonColorPalette.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.event.logging.personality.montypython

import com.embabel.agent.event.logging.personality.ColorPalette
import org.springframework.context.annotation.Profile
import org.springframework.stereotype.Component

@Component
@Profile("montypython")
object MontyPythonColorPalette : ColorPalette {
    const val HOLY_GRAIL_GOLD: Int = 0xffd700
    const val SPAM_PINK: Int = 0xffc0cb
    const val KNIGHT_ARMOR: Int = 0xc0c0c0
    const val DEAD_PARROT_BLUE: Int = 0x4169e1
    const val SILLY_WALK_BROWN: Int = 0x8b4513
    const val BRIGHT_RED: Int = 0xE50000
    const val ROYAL_BLUE: Int = 0x0038A8

    override val highlight: Int
        get() = HOLY_GRAIL_GOLD
    override val color2: Int
        get() = DEAD_PARROT_BLUE
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/event/logging/personality/montypython/MontyPythonLoggingAgenticEventListener.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.event.logging.personality.montypython

import com.embabel.agent.event.*
import com.embabel.agent.event.logging.LoggingAgenticEventListener
import com.embabel.common.util.color
import org.slf4j.LoggerFactory
import org.springframework.context.annotation.Profile
import org.springframework.stereotype.Component

/**
 * And now for something completely different
 */
@Component
@Profile("montypython")
class MontyPythonLoggingAgenticEventListener : LoggingAgenticEventListener(
    logger = LoggerFactory.getLogger("FlyingCircus"),
    welcomeMessage = """

         /\                                                 /\
        /  \      NOBODY EXPECTS THE SPANISH INQUISITION!  /  \
       /    \                                             /    \
      /      \                                           /      \
     /        \                                         /        \
    /          \                                       /          \
    |    ||    |                                       |    ||    |
    |    ||    |                                       |    ||    |
    |    ||    |                                       |    ||    |
    |    ||    |                                       |    ||    |
    |    ||    |                                       |    ||    |
    |    \\___ |                                       | ___//    |
    |          |                                       |          |
    |  MONTY   |                                       |  PYTHON  |
    |  FLYING  |                                       |  CIRCUS  |
    |__________|                                       |__________|

    """.trimIndent().color(MontyPythonColorPalette.BRIGHT_RED),
    colorPalette = MontyPythonColorPalette,
) {
    override fun getAgentDeploymentEventMessage(e: AgentDeploymentEvent): String =
        "Found a parrot: ${e.agent.name}\n\tdescription: ${e.agent.description}"

    override fun getRankingChoiceMadeEventMessage(e: RankingChoiceMadeEvent<*>): String =
        "You don't vote for kings. We have chosen ${e.type.simpleName} with ${e.choice.score} certainty based on ${e.basis}"

    override fun getDynamicAgentCreationMessage(e: DynamicAgentCreationEvent): String =
        "It's not dead yet: Created agent ${e.agent.infoString()}"

    override fun getAgentProcessCreationEventMessage(e: AgentProcessCreationEvent): String =
        "And now for something completely different: ${e.processId}"

    override fun getAgentProcessReadyToPlanEventMessage(e: AgentProcessReadyToPlanEvent): String =
        "[${e.processId}] My brain hurts! Ready to plan from: ${e.worldState.infoString(verbose = e.agentProcess.processContext.processOptions.verbosity.showLongPlans)}"

    override fun getAgentProcessPlanFormulatedEventMessage(e: AgentProcessPlanFormulatedEvent): String =
        "[${e.processId}] We've found a witch! Formulated plan: ${e.plan.infoString(verbose = e.agentProcess.processContext.processOptions.verbosity.showLongPlans)}> from ${e.worldState.infoString()}"

    override fun getProcessCompletionMessage(e: AgentProcessFinishedEvent): String =
        "[${e.processId}] Tis but a scratch: process completed in ${e.agentProcess.runningTime}"

    override fun getProcessFailureMessage(e: AgentProcessFinishedEvent): String =
        "[${e.processId}] It's just a flesh wound: Process failed"

    override fun getObjectAddedEventMessage(e: ObjectAddedEvent): String =
        "Bring out your dead! Object added: ${if (e.agentProcess.processContext.processOptions.verbosity.debug) e.value else e.value::class.java.simpleName} to process ${e.processId}"

    override fun getLlmRequestEventMessage(e: LlmRequestEvent<*>): String =
        "[${e.processId}] (${e.interaction.id.value}) Strange women lying in ponds: Using LLM ${e.llm.name}: ${e.outputClass.simpleName} -> ${e.interaction.llm}"

    override fun getActionExecutionStartMessage(e: ActionExecutionStartEvent): String =
        "[${e.processId}] Run away! Run away! executing action ${e.action.name}"

    override fun getActionExecutionResultMessage(e: ActionExecutionResultEvent): String =
        "[${e.processId}] I fart in your general direction! Executed action ${e.action.name} in ${e.actionStatus.runningTime}"

    override fun getObjectBoundEventMessage(e: ObjectBoundEvent): String =
        "[${e.processId}] Object saved! Nudge nudge, wink wink, say no more! ${e.name}:${if (e.agentProcess.processContext.processOptions.verbosity.debug) e.value else e.value::class.java.simpleName}"
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/event/logging/personality/severance/LumonColorPalette.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.event.logging.personality.severance

import com.embabel.agent.event.logging.personality.ColorPalette
import org.springframework.context.annotation.Profile
import org.springframework.stereotype.Component

@Component
@Profile("severance")
object LumonColorPalette : ColorPalette {
    const val MEMBRANE: Int = 0xbeb780
    const val WELLNESS: Int = 0xf5f5dc
    const val MDR: Int = 0x00cc66
    const val ORIGINAL_GREEN: Int = 0x7da17e
    const val DISCIPLINE: Int = 0x2f4f4f

    override val highlight: Int
        get() = MEMBRANE
    override val color2: Int
        get() = MDR
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/event/logging/personality/severance/SeveranceLoggingAgenticEventListener.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.event.logging.personality.severance

import com.embabel.agent.core.EarlyTermination
import com.embabel.agent.event.*
import com.embabel.agent.event.logging.LoggingAgenticEventListener
import com.embabel.agent.event.logging.LoggingPersonality.Companion.BANNER_WIDTH
import com.embabel.common.util.color
import com.embabel.common.util.hexToRgb
import org.slf4j.LoggerFactory
import org.springframework.context.annotation.Profile
import org.springframework.stereotype.Service

val LumonDepartments = listOf(
    "MDR",
    "Lumon",
    "Choreography and Merriment",
    "Mammalians Nurturable",
    "Optics And Design",
    "Perpetuity Wing",
    "Macrodata Refinement",
    "The Board",
    "Wellness",
    "Testing Floor",
)

val MdrFiles = listOf(
    "Allentown", "Dranesville", "Wellington",
    "Tumwater", "Lucknow", "Sopchoppy", "Astoria",
    "Loveland", "St Pierre", "Zurich", "Cairns",
)

val TransformSuccessResponses = MdrFiles.map {
    "LLM call $it 100% Complete"
} +
        kier("I knew you could do it. Even in your darkest moments I could see you arriving here")

val CompletionMessages = listOf(
    """
        🧔🏼‍♂️ PRAISE KIER: Cold Harbor 100% complete.
        In refining your macrodata file, you have brought glory to this company, and to me, Kier Eagan.
    """.trimIndent(),
    "May I introduce choreography and merriment",
    "The Founder wished to witness the historic completion of your 25th file.",
    "Goodly splendors await upon your victory. Love, Mr. Milchick",
    "It's truly special to host a man so illustrious, so sapient, so magnanimous...",
    "See you at the Equator",
    "The barrier is holding. She feels nothing. It's beautiful.",
    "Mammalians Nurturable brings an offering.",
    """
        In completing your 25th Macrodata file, you have drawn my grand agendum nearer to fulfillment,
        thus making you one of the most important people in history.
    """.trimIndent()
)

fun highlight(text: String) = "<$text>".color(LumonColorPalette.MEMBRANE)

const val BANNER_CHAR = "."

/**
 * Thanks to Kier
 */
@Service
@Profile("severance")
class SeveranceLoggingAgenticEventListener : LoggingAgenticEventListener(
    url = "https://www.imdb.com/title/tt11280740/",
    logger = LoggerFactory.getLogger("MDR"),
    welcomeMessage = """


        ${BANNER_CHAR.repeat(BANNER_WIDTH)}
        Kier, chosen one, Kier.
        Kier, brilliant one, Kier.
        Brings the bounty to the plain through the torment, through the rains,
        Progress, knowledge show no fear,
        Kier, chosen one, Kier.
        ${BANNER_CHAR.repeat(BANNER_WIDTH)}

        ▗▖   ▗▖ ▗▖▗▖  ▗▖ ▗▄▖ ▗▖  ▗▖
        ▐▌   ▐▌ ▐▌▐▛▚▞▜▌▐▌ ▐▌▐▛▚▖▐▌
        ▐▌   ▐▌ ▐▌▐▌  ▐▌▐▌ ▐▌▐▌ ▝▜▌
        ▐▙▄▄▖▝▚▄▞▘▐▌  ▐▌▝▚▄▞▘▐▌  ▐▌

    """.trimIndent().color(hexToRgb(LumonColorPalette.MEMBRANE)),
) {

    override fun getAgentDeploymentEventMessage(e: AgentDeploymentEvent): String =
        "${highlight("WILES")}: Deployed agent ${e.agent.name}\n\tdescription: ${e.agent.description}"

    override fun getRankingChoiceRequestEventMessage(e: RankingChoiceRequestEvent<*>): String =
        kier("Choosing ${e.type.simpleName} based on ${e.basis}")

    override fun getRankingChoiceMadeEventMessage(e: RankingChoiceMadeEvent<*>): String =
        kier(
            """|
            |Chose ${e.type.simpleName} '${e.choice.match.name}' with confidence ${e.choice.score} based on ${e.basis}. Choices:
            |${e.rankings.infoString()}
            |May my cunning acument slice through the fog of small minds, guiding them to their great purpose in labor.
            """.trimMargin()
        )

    override fun getRankingChoiceNotMadeEventMessage(e: RankingChoiceCouldNotBeMadeEvent<*>): String =
        "${highlight("WOE")}: Failed to choose ${e.type.simpleName} based on ${e.basis}. Choices: ${e.rankings.infoString()}. Confidence cutoff: ${e.confidenceCutOff}"

    override fun getDynamicAgentCreationMessage(e: DynamicAgentCreationEvent): String =
        "${highlight("WILES")}: Created agent\n${e.agent.infoString(indent = 1)}"

    override fun getAgentProcessCreationEventMessage(e: AgentProcessCreationEvent): String =
        kier(
            """
        May my gaze be singularly placed upon the path, may the words of virtue guide me in the daily labor of my great undertaking.
            [${e.processId}] created
        """.trimIndent()
        )

    override fun getAgentProcessReadyToPlanEventMessage(e: AgentProcessReadyToPlanEvent): String =
        "[${e.processId}] ${highlight("WIT")}  ready to plan from ${e.worldState.infoString(verbose = e.agentProcess.processContext.processOptions.verbosity.showLongPlans)}"

    override fun getAgentProcessPlanFormulatedEventMessage(e: AgentProcessPlanFormulatedEvent): String =
        "[${e.processId}] ${highlight("WILES")}: formulated plan ${e.plan.infoString(verbose = e.agentProcess.processContext.processOptions.verbosity.showLongPlans)} from ${e.worldState.infoString()}".color(
            LumonColorPalette.MEMBRANE
        )

    override fun getProcessCompletionMessage(e: AgentProcessFinishedEvent): String =
        """
        [${e.processId}] completed in ${e.agentProcess.runningTime}
        ${CompletionMessages.random()}

        ${"The Board has concluded the call.".color(LumonColorPalette.MEMBRANE)}
        """.trimIndent()

    override fun getProcessFailureMessage(e: AgentProcessFinishedEvent): String =
        "[${e.processId}] ${highlight("WOE")}: failed"

    override fun getEarlyTerminationMessage(e: EarlyTermination): String =
        """
        [${e.processId}] early termination by ${e.policy} for ${e.reason}
        Please refrain from any further speech, as you are no longer authorized to consort with any severed employee, nor they with you.
        """
            .trimIndent()

    override fun getObjectAddedEventMessage(e: ObjectAddedEvent): String =
        "[${e.processId}] Perpetuity wing: object added: ${if (e.agentProcess.processContext.processOptions.verbosity.debug) e.value else e.value::class.java.simpleName}"

    override fun getObjectBoundEventMessage(e: ObjectBoundEvent): String =
        "[${e.processId}] Perpetuity wing: object bound: ${e.name}:${if (e.agentProcess.processContext.processOptions.verbosity.debug) e.value else e.value::class.java.simpleName}"

    override fun getToolCallRequestEventMessage(e: ToolCallRequestEvent): String =
        "[${e.processId}] ${highlight("VERVE")}: (${e.action?.shortName()}) calling tool ${e.tool}(${e.toolInput})"

    override fun getToolCallSuccessResponseEventMessage(
        e: ToolCallResponseEvent,
        resultToShow: String,
    ): String =
        "[${e.processId}] ${highlight("VISION")}: (${e.request.action?.shortName()}) tool ${e.request.tool} returned $resultToShow in ${e.runningTime.toMillis()}ms with payload ${e.request.toolInput}"

    override fun getToolCallFailureResponseEventMessage(
        e: ToolCallResponseEvent,
        throwable: Throwable?,
    ): String =
        "[${e.processId}] ${highlight("WOE")}: (${e.request.action?.shortName()}) tool ${e.request.tool} failed $throwable in ${e.runningTime.toMillis()}ms with payload ${e.request.toolInput}"

    override fun getLlmRequestEventMessage(e: LlmRequestEvent<*>): String =
        "[${e.processId}] (${e.interaction.id.value}) \uD83D\uDDA5\uFE0F MACRODATA REFINEMENT using LLM ${e.llm.name}, creating ${e.outputClass.simpleName}: ${e.interaction.llm} with tools ${e.interaction.toolCallbacks.joinToString { it.toolDefinition.name() }}"

    override fun getLlmResponseEventMessage(e: LlmResponseEvent<*>): String =
        """
        [${e.processId}] (${e.request.interaction.id.value}) received LLM response of type ${e.response?.let { it::class.java.simpleName } ?: "null"} from ${e.request.interaction.llm.criteria} in ${e.runningTime.seconds} seconds
        """.trimIndent()

    override fun getActionExecutionStartMessage(e: ActionExecutionStartEvent): String =
        "[${e.processId}] ${highlight("VERVE")}: executing action ${e.action.name}"

    override fun getActionExecutionResultMessage(e: ActionExecutionResultEvent): String =
        "[${e.processId}] ${highlight("CHEER")}: completed action ${e.action.name} in ${e.actionStatus.runningTime}"

    override fun getProgressUpdateEventMessage(e: ProgressUpdateEvent): String =
        "[${e.processId}] Industry: ${e.createProgressBar(length = 50).color(LumonColorPalette.MEMBRANE)}"

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/event/logging/personality/severance/SeveranceUtils.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.event.logging.personality.severance

import com.embabel.common.util.bold
import com.embabel.common.util.color
import com.embabel.common.util.italic

/**
 * Severance personality utility functions
 */
fun kier(text: String) = "👔 ${"Kier".bold()} ${text.italic().color(LumonColorPalette.MEMBRANE)}"



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/event/logging/personality/starwars/StarWarsColorPalette.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.event.logging.personality.starwars

import com.embabel.agent.event.logging.personality.ColorPalette
import org.springframework.context.annotation.Profile
import org.springframework.stereotype.Component

@Component
@Profile("starwars")
object StarWarsColorPalette : ColorPalette {
    const val LIGHTSABER_BLUE: Int = 0x00bfff
    const val LIGHTSABER_GREEN: Int = 0x00ff00
    const val LIGHTSABER_RED: Int = 0xff0000
    const val IMPERIAL_GRAY: Int = 0x2f4f4f
    const val REPUBLIC_GOLD: Int = 0xffd700
    const val YELLOW_ACCENT: Int = 0xFFD100
    const val TATOOINE_ORANGE: Int = 0xAD7D37

    override val highlight: Int
        get() = LIGHTSABER_BLUE
    override val color2: Int
        get() = LIGHTSABER_GREEN
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/event/logging/personality/starwars/StarWarsLoggingAgenticEventListener.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.event.logging.personality.starwars

import com.embabel.agent.event.*
import com.embabel.agent.event.logging.LoggingAgenticEventListener
import com.embabel.common.util.color
import com.embabel.common.util.indentLines
import org.slf4j.LoggerFactory
import org.springframework.context.annotation.Profile
import org.springframework.stereotype.Component

/**
 * May the force be with you
 */
@Component
@Profile("starwars")
class StarWarsLoggingAgenticEventListener : LoggingAgenticEventListener(
    logger = LoggerFactory.getLogger("starwars"),
    welcomeMessage = """

 _______  _______  _______  __         .___________. __    __   _______     _______   ______   .______        ______  _______  __
|   ____||   ____||   ____||  |        |           ||  |  |  | |   ____|   |   ____| /  __  \  |   _  \      /      ||   ____||  |
|  |__   |  |__   |  |__   |  |        `---|  |----`|  |__|  | |  |__      |  |__   |  |  |  | |  |_)  |    |  ,----'|  |__   |  |
|   __|  |   __|  |   __|  |  |            |  |     |   __   | |   __|     |   __|  |  |  |  | |      /     |  |     |   __|  |  |
|  |     |  |____ |  |____ |  `----.       |  |     |  |  |  | |  |____    |  |     |  `--'  | |  |\  \----.|  `----.|  |____ |__|
|__|     |_______||_______||_______|       |__|     |__|  |__| |_______|   |__|      \______/  | _| `._____| \______||_______|(__)


                                                                                                                                                                                                                                                                                                                                                                                               |/
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣤⠤⠐⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡌⡦⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⣼⡊⢀⠔⠀⠀⣄⠤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣤⣄⣀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣶⠃⠉⠡⡠⠤⠊⠀⠠⣀⣀⡠⠔⠒⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣾⣿⢟⠿⠛⠛⠁
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⡇⠀⠀⠀⠀⠑⠶⠖⠊⠁⠀⠀⠀⡀⠀⠀⠀⢀⣠⣤⣤⡀⠀⠀⠀⠀⠀⢀⣠⣤⣶⣿⣿⠟⡱⠁⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣾⣿⡇⠀⢀⡠⠀⠀⠀⠈⠑⢦⣄⣀⣀⣽⣦⣤⣾⣿⠿⠿⠿⣿⡆⠀⠀⢀⠺⣿⣿⣿⣿⡿⠁⡰⠁⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣧⣠⠊⣠⣶⣾⣿⣿⣶⣶⣿⣿⠿⠛⢿⣿⣫⢕⡠⢥⣈⠀⠙⠀⠰⣷⣿⣿⣿⡿⠋⢀⠜⠁⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⢿⣿⣿⣿⣿⣰⣿⣿⠿⣛⡛⢛⣿⣿⣟⢅⠀⠀⢿⣿⠕⢺⣿⡇⠩⠓⠂⢀⠛⠛⠋⢁⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀
⠘⢶⡶⢶⣶⣦⣤⣤⣤⣤⣤⣀⣀⣀⣀⡀⠀⠘⣿⣿⣿⠟⠁⡡⣒⣬⢭⢠⠝⢿⡡⠂⠀⠈⠻⣯⣖⣒⣺⡭⠂⢀⠈⣶⣶⣾⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠙⠳⣌⡛⢿⣿⣿⣿⣿⣿⣿⣿⣿⣻⣵⣨⣿⣿⡏⢀⠪⠎⠙⠿⣋⠴⡃⢸⣷⣤⣶⡾⠋⠈⠻⣶⣶⣶⣷⣶⣷⣿⣟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠈⠛⢦⣌⡙⠛⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡀⠀⠀⠩⠭⡭⠴⠊⢀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿⣿⣿⣿⡇⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠈⠙⠓⠦⣄⡉⠛⠛⠻⢿⣿⣿⣿⣷⡀⠀⠀⠀⠀⢀⣰⠋⠀⠀⠀⠀⠀⣀⣰⠤⣳⣿⣿⣿⣿⣟⠑⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠓⠒⠒⠶⢺⣿⣿⣿⣿⣦⣄⣀⣴⣿⣯⣤⣔⠒⠚⣒⣉⣉⣴⣾⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠹⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣭⣉⣉⣤⣿⣿⣿⣿⣿⣿⡿⢀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⡁⡆⠙⢶⣀⠀⢀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣴⣶⣾⣿⣟⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⢛⣩⣴⣿⠇⡇⠸⡆⠙⢷⣄⠻⣿⣦⡄⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣼⣿⣿⣿⣿⣿⣿⣿⣎⢻⣿⣿⣿⣿⣿⣿⣿⣭⣭⣭⣵⣶⣾⣿⣿⣿⠟⢰⢣⠀⠈⠀⠀⠙⢷⡎⠙⣿⣦⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣼⣿⣿⣿⣿⣿⣿⣿⣿⡟⣿⡆⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠟⠛⠋⠁⢀⠇⢸⡇⠀⠀⠀⠀⠈⠁⠀⢸⣿⡆⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡜⡿⡘⣿⣿⣿⣿⣿⣶⣶⣤⣤⣤⣤⣤⣤⣤⣴⡎⠖⢹⡇⠀⠀⠀⠀⠀⠀⠀⠀⣿⣷⡄⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡀⠘⢿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠛⠋⡟⠀⠀⣸⣷⣀⣤⣀⣀⣀⣤⣤⣾⣿⣿⣿⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣭⣓⡲⠬⢭⣙⡛⠿⣿⣿⣶⣦⣀⠀⡜⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣭⣛⣓⠶⠦⠥⣀⠙⠋⠉⠉⠻⣄⣀⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣆⠐⣦⣠⣷⠊⠁⠀⠀⡭⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢉⣛⡛⢻⡗⠂⠀⢀⣷⣄⠈⢆⠉⠙⠻⢿⣿⣿⣿⣿⣿⠇⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⡟⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⣉⢁⣴⣿⣿⣿⣾⡇⢀⣀⣼⡿⣿⣷⡌⢻⣦⡀⠀⠈⠙⠛⠿⠏⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⡄⠙⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⠛⠛⢯⡉⠉⠉⠉⠉⠛⢼⣿⠿⠿⠦⡙⣿⡆⢹⣷⣤⡀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠿⠄⠈⠻⠿⠿⠿⠿⠿⠿⠛⠛⠿⠛⠉⠁⠀⠀⠀⠀⠀⠀⠻⠿⠿⠿⠿⠟⠉⠀⠀⠤⠴⠶⠌⠿⠘⠿⠿⠿⠿⠶⠤⠀⠀⠀⠀

    """.trimIndent().color(StarWarsColorPalette.highlight),
) {

    override fun getAgentDeploymentEventMessage(e: AgentDeploymentEvent): String =
        "Deployed an agent I have: ${e.agent.name}\n\tdescription: ${e.agent.description}"

    override fun getRankingChoiceMadeEventMessage(e: RankingChoiceMadeEvent<*>): String =
        "Chosen ${e.type.simpleName} I have with confidence ${e.choice.score} based on ${e.basis}"

    override fun getDynamicAgentCreationMessage(e: DynamicAgentCreationEvent): String =
        """|You will find only what you bring in: Created agent instance:
           |${e.agent.infoString(indent = 1)}
           |"""
            .trimMargin()
            .indentLines(level = 1, skipIndentFirstLine = true)

    override fun getAgentProcessCreationEventMessage(e: AgentProcessCreationEvent): String =
        "Created a process I have: ${e.processId}"

    override fun getAgentProcessReadyToPlanEventMessage(e: AgentProcessReadyToPlanEvent): String =
        """|[${e.processId}] Difficult to see. Always in motion is the future: Ready to plan from:
           |${e.worldState.infoString(e.agentProcess.processContext.processOptions.verbosity.showLongPlans, 1)}
           |"""
            .trimMargin()
            .indentLines(level = 1, skipIndentFirstLine = true)

    override fun getAgentProcessPlanFormulatedEventMessage(e: AgentProcessPlanFormulatedEvent): String =
        """|[${e.processId}] Control, control, you must learn control! Formulated plan:
           |${e.plan.infoString(e.agentProcess.processContext.processOptions.verbosity.showLongPlans, 1)}
           |from:
           |${e.worldState.infoString(verbose = true, indent = 1)}
           |"""
            .trimMargin()
            .indentLines(level = 1, skipIndentFirstLine = true)

    override fun getProcessCompletionMessage(e: AgentProcessFinishedEvent): String =
        "[${e.processId}] Feel the force: process completed in ${e.agentProcess.runningTime}"

    override fun getProcessFailureMessage(e: AgentProcessFinishedEvent): String =
        "Powerful the dark side is: Process ${e.processId} failed"

    override fun getObjectAddedEventMessage(e: ObjectAddedEvent): String =
        "A little more knowledge lights our way: Object added: ${if (e.agentProcess.processContext.processOptions.verbosity.debug) e.value else e.value::class.java.simpleName} to process ${e.processId}"

    override fun getLlmRequestEventMessage(e: LlmRequestEvent<*>): String =
        "[${e.processId}] (${e.interaction.id.value}) Ask LLM ${e.llm.name} we will: creating ${e.outputClass.simpleName}"

    override fun getActionExecutionStartMessage(e: ActionExecutionStartEvent): String =
        "[${e.processId}] Do or do not. There is no try: executing action ${e.action.name}"

    override fun getActionExecutionResultMessage(e: ActionExecutionResultEvent): String =
        "[${e.processId}] Powerful you have become: executed action ${e.action.name} in ${e.actionStatus.runningTime}"

    override fun getObjectBoundEventMessage(e: ObjectBoundEvent): String =
        "[${e.processId}] Object saved, kid. Don't worry, I've made special modifications to this database myself: ${e.name}:${if (e.agentProcess.processContext.processOptions.verbosity.debug) e.value else e.value::class.java.simpleName}"
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/event/progress/OutputChannelHighlightingEventListener.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.event.progress

import com.embabel.agent.channel.OutputChannel
import com.embabel.agent.channel.ProgressOutputChannelEvent
import com.embabel.agent.event.AgentProcessEvent
import com.embabel.agent.event.AgenticEventListener
import com.embabel.agent.event.LlmRequestEvent
import com.embabel.agent.event.ToolCallRequestEvent

/**
 * Event listener that highlights important events in the output channel.
 */
class OutputChannelHighlightingEventListener(
    private val outputChannel: OutputChannel,
    private val verbose: Boolean = true,
) : AgenticEventListener {

    override fun onProcessEvent(event: AgentProcessEvent) {
        when (event) {
            is ToolCallRequestEvent -> {
                var message = "🔧  ${event.tool}"
                if (verbose) {
                    message += " with input `${event.toolInput}`"
                }
                outputChannel.send(
                    ProgressOutputChannelEvent(
                        processId = event.processId,
                        message = message,
                    )
                )
            }

            is LlmRequestEvent<*> -> {
                val message = "Calling LLM `${event.llm.name}`"
                outputChannel.send(
                    ProgressOutputChannelEvent(
                        processId = event.processId,
                        message = message,
                    )
                )
            }
        }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/experimental/README.md
================================================
# Experimental functionality

This directory contains experimental functionality that is not yet ready for production use.
No guarantees are made about API stability, or even whether the functionality will be included in the future.


================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/experimental/primitive/PromptCondition.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.experimental.primitive

import com.embabel.agent.api.common.InteractionId
import com.embabel.agent.api.common.OperationContext
import com.embabel.agent.core.Condition
import com.embabel.agent.spi.LlmCall
import com.embabel.agent.spi.LlmInteraction
import com.embabel.chat.UserMessage
import com.embabel.common.core.types.ZeroToOne
import com.embabel.plan.goap.ConditionDetermination
import com.fasterxml.jackson.annotation.JsonClassDescription
import com.fasterxml.jackson.annotation.JsonPropertyDescription
import org.slf4j.LoggerFactory


/**
 * Prompt an LLM to evaluate a condition.
 * Evaluating prompt conditions is expensive,
 * so we need to consider efficiency here.
 * @param name name of the condition
 * @param prompt the prompt to evaluate.
 * Typically created from Blackboard state from the ProcessContext.
 */
data class PromptCondition(
    override val name: String,
    val prompt: (context: OperationContext) -> String,
    val llm: LlmCall,
) : Condition {

    private val logger = LoggerFactory.getLogger(this::class.java)

    /**
     * This is as expensive as it can get
     */
    override val cost: ZeroToOne = 1.0

    override fun evaluate(context: OperationContext): ConditionDetermination {
        val prompt =
            """
            Evaluate this condition: ${prompt(context)}
            Return "result": whether you think it is true, your confidence level from 0-1,
            and an explanation of what you base this on.
            """.trimIndent()
        logger.info("Condition {}: making LLM call to evaluate using {}...", name, llm)
        val interaction = LlmInteraction.from(
            llm = llm,
            id = InteractionId("condition-$name")
        )
        val determination = context.processContext.platformServices.llmOperations.createObject(
            messages = listOf(UserMessage(prompt)),
            interaction = interaction,
            outputClass = Determination::class.java,
            agentProcess = context.processContext.agentProcess,
            action = null,
        )
        logger.info(
            "Condition {}: determination from {} was {}",
            name,
            interaction.llm.criteria,
            determination,
        )
        return ConditionDetermination(determination.result)
    }
}

@JsonClassDescription("Determination of a condition")
data class Determination(
    @JsonPropertyDescription("Result of the condition: true or false")
    val result: Boolean,

    @JsonPropertyDescription("Confidence level of the result, from 0-1")
    val confidence: ZeroToOne,

    @JsonPropertyDescription("Explanation of your determination")
    val explanation: String,
)



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/experimental/util/InjectionUtils.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.experimental.util

import org.springframework.beans.factory.config.AutowireCapableBeanFactory
import org.springframework.context.ApplicationContext
import org.springframework.lang.NonNull
import org.springframework.lang.Nullable

/**
 * Allows injected objects to specify additional injectees so that injection can
 * cascade without the injecting repository knowing the full structure of the object
 * graph.
 */
interface Injectable {

    /**
     * Additional objects to inject. Typically relationships of this object.
     *
     * @return list of objects to inject
     */
    fun additionalInjectees(): List<*>
}

/**
 * Injection utils for Spring
 */
object InjectionUtils {

    /**
     * Inject the given object with Spring. Return the injected object
     *
     * @param t object to inject
     */
    @JvmStatic
    fun <T> wire(@Nullable t: T?, @NonNull applicationContext: ApplicationContext): T? {
        if (t == null) {
            return null
        }
        val acbf = applicationContext.autowireCapableBeanFactory
        acbf.autowireBeanProperties(t, AutowireCapableBeanFactory.AUTOWIRE_NO, false)
        acbf.initializeBean(t, "%s:%d".format(t.javaClass.name, t.hashCode()))
        if (t is Injectable) {
            for (o in t.additionalInjectees()) {
                wire(o, applicationContext)
            }
        }
        return t
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/experimental/util/Injector.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.experimental.util

import org.springframework.beans.factory.annotation.Configurable
import org.springframework.context.ApplicationContext
import org.springframework.core.annotation.AnnotatedElementUtils
import org.springframework.stereotype.Component

/**
 * Spring-inject entities if they have an @Configurable annotation. Can be put on any
 * entity without efficiency concerns.
 */
@Component
class Injector(private val applicationContext: ApplicationContext) {

    /**
     * Inject the given object if it is non null and annotated
     * with @Configurable.
     * @param target the object to inject. may be null
     */
    fun inject(target: Any?) {
        if (target == null) {
            return
        }
        val atConfigurable = AnnotatedElementUtils.findMergedAnnotation(target.javaClass, Configurable::class.java)
        if (atConfigurable == null) {
            return
        }
        InjectionUtils.wire(target, applicationContext)
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/identity/User.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.identity

/**
 * Superinterface for all users in the system.
 * displayName and username properties can default to id
 * if an implementation doesn't know how to populate them,
 * but they allow consistent experience.
 */
interface User {

    /**
     * User's id in this system. Embabel-owned, stable.
     * Additional keys will be added for other systems like Discord
     */
    val id: String

    val displayName: String

    val username: String

    val email: String?
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/identity/UserService.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.identity

interface UserService<U : User> {

    fun findById(id: String): U?

    /**
     * Add the user to the system.
     * Default implementation refuses to do so.
     */
    fun provisionUser(
        userInfo: U,
    ): U {
        error("User cannot be provisioned: $userInfo")
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/prompt/README.md
================================================
# Structured prompt support

Support prompt structures such as persona and CoStar.


================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/prompt/PromptUtils.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.prompt

import com.embabel.common.util.DummyInstanceCreator
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.fasterxml.jackson.module.kotlin.registerKotlinModule

/**
 * Utility functions for building prompts.
 */
object PromptUtils {

    val dummyInstanceCreator = DummyInstanceCreator()

    val om: ObjectMapper = jacksonObjectMapper().registerKotlinModule().registerModule(JavaTimeModule())

    /**
     * Generates a JSON example of the given class
     * with dummy data. Makes few shot examples easier to create.
     *
     * @param clazz The class to generate a JSON example for.
     */
    @JvmStatic
    fun jsonExampleOf(clazz: Class<*>): String {
        val dummy = dummyInstanceCreator.createDummyInstance(clazz)
        return om.writerWithDefaultPrettyPrinter().writeValueAsString(dummy)
    }

    /**
     * Generates a JSON example of the given class
     * with dummy data. Makes few shot examples easier to create.
     *
     * @param T The type to generate a JSON example for.
     */
    inline fun <reified T> jsonExampleOf(): String {
        return jsonExampleOf(T::class.java)
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/prompt/ResponseFormat.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.prompt

import com.embabel.common.ai.prompt.PromptContributor

/**
 * PromptContributor that defines the expected response format
 * for text responses
 */
data class ResponseFormat(
    val format: String,
) : PromptContributor {

    override fun contribution(): String =
        """
            # RESPONSE FORMAT #
            $format
        """.trimIndent()

    override val role: String = "response_format"

    companion object {
        val MARKDOWN = ResponseFormat("Markdown")
        val HTML = ResponseFormat("HTML")

    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/prompt/element/DynamicPromptContributor.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.prompt.element

import com.embabel.agent.api.common.OperationContext
import com.embabel.common.ai.prompt.PromptContribution
import com.embabel.common.ai.prompt.PromptContributionLocation
import com.embabel.common.ai.prompt.PromptContributor
import com.embabel.common.ai.prompt.PromptElement

/**
 * Make a dynamic prompt contribution based on the operation context.
 */
interface ContextualPromptElement : PromptElement {

    fun promptContribution(context: OperationContext): PromptContribution {
        return PromptContribution(
            content = contribution(context),
            location = promptContributionLocation,
            role = role,
        )
    }

    fun contribution(context: OperationContext): String

    /**
     * Make a static PromptContributor based on the operation context.
     */
    fun toPromptContributor(context: OperationContext): PromptContributor {
        return PromptContributor.fixed(
            content = contribution(context),
            location = promptContributionLocation,
            role = role,
        )
    }

    companion object {

        operator fun invoke(
            role: String? = null,
            location: PromptContributionLocation = PromptContributionLocation.BEGINNING,
            contribution: (OperationContext) -> String,
        ): ContextualPromptElement {
            return of(role, location, contribution)
        }

        /**
         * Create a prompt contribution with fixed content
         */
        @JvmStatic
        @JvmOverloads
        fun of(
            role: String? = null,
            location: PromptContributionLocation = PromptContributionLocation.BEGINNING,
            contribution: (OperationContext) -> String,
        ): ContextualPromptElement {
            return ContextualPromptElementImpl(
                role = role,
                promptContributionLocation = location,
                contribution = contribution,
            )
        }

    }
}

private data class ContextualPromptElementImpl(
    private val contribution: (OperationContext) -> String,
    override val role: String? = null,
    override val promptContributionLocation: PromptContributionLocation = PromptContributionLocation.BEGINNING,
) : ContextualPromptElement {

    override fun contribution(context: OperationContext): String =
        contribution(context)

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/prompt/element/ToolCallControl.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.prompt.element

import com.embabel.common.ai.prompt.PromptContributor

/**
 * PromptContributor to control tool usage.
 */
data class ToolCallControl(
    val toolCalls: Int = 5,
) : PromptContributor {

    override fun contribution(): String =
        """
        You are allowed to make up to $toolCalls tool calls to complete the task.
        Use them wisely.
        If you reach this limit, you must stop and return your best answer.
        """.trimIndent()
}

data class FocusedToolCallControl(
    val toolName: String,
    val toolCalls: Int = 5,
) : PromptContributor {

    override fun contribution(): String =
        """
        You are allowed to make up to $toolCalls calls to the $toolName tool to complete the task.
        Use them wisely.
        Do not exceed this limit.
        """.trimIndent()
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/prompt/persona/Actor.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.prompt.persona

import com.embabel.agent.api.common.Ai
import com.embabel.agent.api.common.OperationContext
import com.embabel.agent.api.common.PromptRunner
import com.embabel.common.ai.model.LlmOptions
import com.embabel.common.ai.prompt.PromptContributor
import org.springframework.validation.annotation.Validated

/**
 * An Actor plays a role: Convenient way to combine a PromptContributor
 * with an LLM and tools.
 * Open to allow subclasses to add tools via @Tool methods
 */
@Validated
open class Actor<T : PromptContributor> @JvmOverloads constructor(
    val persona: T,
    val llm: LlmOptions,
    val toolGroups: Set<String> = emptySet(),
) : PromptContributor by persona {

    /**
     * Construct an Actor with a simple instruction as persona.
     */
    @JvmOverloads
    constructor(
        instruction: String,
        llm: LlmOptions,
        toolGroups: Set<String> = emptySet(),
    ) : this(
        persona = Instruction(instruction) as T,
        llm = llm,
        toolGroups = toolGroups,
    )

    /**
     * Return a PromptRunner configured with this Actor's persona, LLM, and tools.
     * The caller can continue to customize this PromptRunner before using it
     * to create objects or generate text.
     */
    fun promptRunner(ai: Ai): PromptRunner {
        return ai.withLlm(llm)
            .withPromptContributor(persona)
            .withToolGroups(toolGroups)
            .withToolObject(this)
    }

    /**
     * Return a PromptRunner configured with this Actor's persona, LLM, and tools.
     * The caller can continue to customize this PromptRunner before using it
     * to create objects or generate text.
     */
    fun promptRunner(context: OperationContext) = promptRunner(context.ai())

    override fun toString(): String = "Actor(persona=${persona}, llm=$llm, toolGroups=$toolGroups)"

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/prompt/persona/CoStar.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.prompt.persona

import com.embabel.common.ai.prompt.PromptContributor


/**
 * CO-STAR prompt framework
 * See https://towardsdatascience.com/how-i-won-singapores-gpt-4-prompt-engineering-competition-34c195a93d41/
 */
data class CoStar(
    val context: String,
    val objective: String,
    val style: String,
    val tone: String,
    val audience: String,
    val response: String = "Markdown",
    private val separator: String = "#".repeat(12),
) : PromptContributor {

    override fun contribution() = """
            # CONTEXT #
            $context
            $separator
            # OBJECTIVE #
            $objective
            $separator
            # STYLE #
            $style
            $separator
            # TONE #
            $tone
            $separator
            # AUDIENCE #
            $audience
            $separator
            # RESPONSE FORMAT #
            $response
            $separator
        """.trimIndent()

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/prompt/persona/Instruction.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.prompt.persona

import com.embabel.common.ai.prompt.PromptContributor

/**
 * Simple instruction as persona.
 */
data class Instruction(
    val instruction: String,
) : PromptContributor {

    override fun contribution(): String = instruction
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/prompt/persona/Persona.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.prompt.persona

import com.embabel.common.ai.prompt.PromptContributor

/**
 * A way to structure LLM responses, by grounding them
 * in a personality.
 */
data class Persona(
    val name: String,
    val persona: String,
    val voice: String,
    val objective: String,
) : PromptContributor {

    override fun contribution(): String {
        return """
            You are $name.
            Your persona: $persona.
            Your objective is $objective.
            Your voice: $voice.
        """.trimIndent()
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/prompt/persona/RoleGoalBackstory.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.prompt.persona

import com.embabel.common.ai.prompt.PromptContributor

/**
 * CrewAI style backstory prompt.
 * Included for users migrating from CrewAI.
 * In Embabel, such structures aren't core to the framework,
 * but merely a PromptContributor that can be used
 * in any action implementation.
 */
data class RoleGoalBackstory(
    override val role: String,
    val goal: String,
    val backstory: String,
) : PromptContributor {

    override fun contribution(): String = """
        Role: $role
        Goal: $goal
        Backstory: $backstory
    """.trimIndent()

    companion object {

        /**
         * Convenient Java-friendly way to start building a RoleGoalBackstory in fluent style.
         */
        @JvmStatic
        fun withRole(role: String) = RoleBuilder(role)

    }

    class RoleBuilder(private val role: String) {

        fun andGoal(goal: String): GoalBuilder = GoalBuilder(role, goal)

    }

    class GoalBuilder(
        private val role: String,
        private val goal: String,
    ) {

        fun andBackstory(backstory: String): RoleGoalBackstory =
            RoleGoalBackstory(role, goal, backstory)

    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/README.md
================================================
# RAG integration for agent



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/AbstractWritableContentElementRepository.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag

import com.embabel.agent.rag.ingestion.ContentChunker
import com.embabel.agent.rag.ingestion.MaterializedDocument

/**
 * Convenience base class for WritableRagService implementations.
 */
abstract class AbstractWritableContentElementRepository(
    private val chunkerConfig: ContentChunker.Config,
) : WritableContentElementRepository {

    /**
     * Will call save on the root and all descendants.
     * The database only needs to store each descendant and link by id,
     * rather than otherwise consider the entire structure.
     */
    final override fun writeContent(root: MaterializedDocument): List<String> {
        val chunker = ContentChunker(chunkerConfig)
        val chunks = chunker.chunk(root)
        save(root)
        root.descendants().forEach { save(it) }
        chunks.forEach { save(it) }
        onNewRetrievables(chunks)
        createRelationships(root)
        commit()
        return chunks.map { it.id }
    }

    /**
     * Create relationships between the structural elements in this content.
     * For example, in a graph database, create relationships between documents, sections, and chunks
     * based on their ids.
     */
    protected abstract fun createRelationships(root: MaterializedDocument)

    protected abstract fun commit()

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/Cluster.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag

import com.embabel.common.core.types.SimilarityResult
import com.embabel.common.core.types.ZeroToOne

/**
 * Cluster of similar things
 */
data class Cluster<E>(
    val anchor: E,
    val similar: List<SimilarityResult<E>>,
)

data class ClusterRetrievalRequest<E> @JvmOverloads constructor(
    override val entitySearch: EntitySearch? = null,
    override val contentElementSearch: ContentElementSearch = ContentElementSearch.NONE,
    override val similarityThreshold: ZeroToOne = 0.7,
    override val topK: Int = 10,
    val vectorIndex: String = "embabel-entity-index",
) : RetrievalFilters<ClusterRetrievalRequest<E>> {

    override fun withSimilarityThreshold(similarityThreshold: ZeroToOne): ClusterRetrievalRequest<E> =
        copy(similarityThreshold = similarityThreshold)

    override fun withTopK(topK: Int): ClusterRetrievalRequest<E> = copy(topK = topK)

    override fun withEntitySearch(entitySearch: EntitySearch): ClusterRetrievalRequest<E> =
        copy(entitySearch = entitySearch)

    override fun withContentElementSearch(contentElementSearch: ContentElementSearch): ClusterRetrievalRequest<E> =
        copy(contentElementSearch = contentElementSearch)
}

interface ClusterFinder {

    /**
     * Find all clusters
     */
    fun <E> findClusters(opts: ClusterRetrievalRequest<E>): List<Cluster<E>>
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/ContextualTool.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag

import org.springframework.ai.tool.ToolCallback

/**
 * Tool retrieved by a RAG request
 */
data class ContextualTool(
    val toolCallback: ToolCallback,
) : Retrievable {

    override fun embeddableValue(): String =
        toolCallback.toolDefinition.description()


    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String {
        return "tool: " + toolCallback.toolDefinition.name()
    }

    override val id: String
        get() = "tool:${toolCallback.toolDefinition.name()}"

    override val uri: String?
        get() = null

    override val metadata: Map<String, Any?>
        // TODO fix this
        get() = emptyMap() //toolCallback.toolMetadata
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/EntityData.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag

import com.embabel.common.util.indent
import io.swagger.v3.oas.annotations.media.Schema

/**
 * Any retrievable entity, whether mapped or generic.
 */
interface RetrievableEntity : Retrievable {

    override fun labels(): Set<String> {
        return super.labels() + setOf("Entity")
    }

}

/**
 * Generic retrieved entity
 */
interface EntityData : RetrievableEntity {

    @get:Schema(
        description = "Properties of this object. Arbitrary key-value pairs, although likely specified in schema. Must filter out embedding",
        example = "{\"birthYear\": 1854, \"deathYear\": 1930}",
        required = true,
    )
    val properties: Map<String, Any>

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String {
        val labelsString = labels().joinToString(":")
        return "(${labelsString} id='$id')".indent(indent)
    }

    override fun embeddableValue(): String {
        val props = properties.entries
            .filterNot { DEFAULT_EXCLUDED_PROPERTIES.contains(it.key) }
            .joinToString { (k, v) -> "$k=$v" }
        return "Entity {${labels()}}: properties=[$props]"
    }

    companion object {
        val DEFAULT_EXCLUDED_PROPERTIES = setOf("embedding", "id")
    }
}

data class SimpleEntityData(
    override val id: String,
    override val uri: String? = null,
    val labels: Set<String>,
    override val properties: Map<String, Any>,
    override val metadata: Map<String, Any?> = emptyMap(),
) : EntityData {

    override fun labels() = labels + super.labels()

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/HierarchicalContentElement.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag

import com.embabel.agent.domain.library.HasContent

/**
 * ContentElement that exists in a hierarchy,
 * such as a document with sections and subsections.
 */
interface HierarchicalContentElement : ContentElement {

    val parentId: String?

    override fun propertiesToPersist(): Map<String, Any?> = super.propertiesToPersist() + mapOf(
        "parentId" to parentId,
    )
}

/**
 * Root of a structured document
 * It must have a non-null URI
 */
interface ContentRoot : HierarchicalContentElement {

    override val uri: String

    val title: String

    override val parentId get() = null

    override fun labels(): Set<String> {
        return super.labels() + setOf("Document")
    }
}

sealed interface Section : HierarchicalContentElement {
    val title: String

    override fun propertiesToPersist(): Map<String, Any?> = super.propertiesToPersist() + mapOf(
        "title" to title,
    )

    override fun labels(): Set<String> {
        return super.labels() + setOf("Section")
    }
}

interface MaterializedSection : Section

interface ContainerSection : Section {

    override fun labels(): Set<String> {
        return super.labels() + setOf("ContainerSection")
    }
}

/**
 * Contains content
 */
data class LeafSection(
    override val id: String,
    override val uri: String? = null,
    override val title: String,
    val text: String,
    override val parentId: String? = null,
    override val metadata: Map<String, Any?> = emptyMap(),
) : MaterializedSection, HasContent {

    override val content get() = text

    override fun propertiesToPersist(): Map<String, Any?> = super.propertiesToPersist() + mapOf(
        "text" to content,
    )

    override fun labels(): Set<String> {
        return super.labels() + setOf("LeafSection")
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/NamedEntityData.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag

import com.embabel.common.core.types.NamedAndDescribed
import com.embabel.common.util.indent

/**
 * Adds a name to the well known entity data.
 */
interface NamedEntityData : EntityData, NamedAndDescribed {

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String {
        val labelsString = labels().joinToString(":")
        return "(${labelsString} id='$id', name=$name, description=$description)".indent(indent)
    }
}

data class SimpleNamedEntityData(
    override val id: String,
    override val uri: String? = null,
    override val name: String,
    override val description: String,
    val labels: Set<String>,
    override val properties: Map<String, Any>,
    override val metadata: Map<String, Any?> = emptyMap(),
) : NamedEntityData {

    override fun labels() = labels + super.labels()

    override fun embeddableValue(): String {
        var sup = super.embeddableValue()
        if (!sup.contains("name")) {
            sup += ", name=$name"
        }
        if (!sup.contains("description")) {
            sup += ", description=$description"
        }
        return sup
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/NavigableRagService.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag

import org.jetbrains.annotations.ApiStatus

sealed interface ExplorationRequest

data class DepthExplorationRequest(
    val depth: Int,
) : ExplorationRequest

data class PathsExplorationRequest(
    val paths: List<String>,
) : ExplorationRequest

/**
 * Rag service that supports navigation in a graph of retrievable objects.
 * This may not be supported by all RAG services.
 * It need not be a graph but could be implemented by a relational database or other structure.
 */
@ApiStatus.Experimental
interface NavigableRagService : RagService {

    /**
     * Explore the graph of retrievable objects around the given retrievable object.
     */
    fun explore(
        retrievable: Retrievable,
        explorationRequest: ExplorationRequest,
    ): Retrievable
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/RagRequest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag

import com.embabel.common.core.types.SimilarityCutoff
import com.embabel.common.core.types.TextSimilaritySearchRequest
import com.embabel.common.core.types.Timestamped
import com.embabel.common.core.types.ZeroToOne
import org.jetbrains.annotations.ApiStatus
import java.time.Duration
import java.time.Instant

interface RetrievalFilters<T : RetrievalFilters<T>> : SimilarityCutoff {

    @get:ApiStatus.Experimental
    val entitySearch: EntitySearch?

    val contentElementSearch: ContentElementSearch

    fun withSimilarityThreshold(similarityThreshold: ZeroToOne): T

    fun withTopK(topK: Int): T

    fun withEntitySearch(entitySearch: EntitySearch): T

    fun withContentElementSearch(contentElementSearch: ContentElementSearch): T

}

/**
 * Narrowing of RagRequest
 */
interface RagRequestRefinement<T : RagRequestRefinement<T>> : RetrievalFilters<T> {

    val compressionConfig: CompressionConfig

    val desiredMaxLatency: Duration

    val hyDE: HyDE?


    /**
     * Create a RagRequest from this refinement and a query.
     */
    fun toRequest(query: String): RagRequest {
        return RagRequest(
            query = query,
            similarityThreshold = similarityThreshold,
            topK = topK,
            contentElementSearch = contentElementSearch,
            entitySearch = entitySearch,
            compressionConfig = compressionConfig,
            desiredMaxLatency = desiredMaxLatency,
        )
    }

    // Java-friendly builders

    fun withDesiredMaxLatency(desiredMaxLatency: Duration): T

    fun withCompression(compressionConfig: CompressionConfig): T

    fun withHyDE(hyDE: HyDE): T

}

data class ContentElementSearch(
    val types: List<Class<out ContentElement>>,
) {
    companion object {

        @JvmField
        val NONE = ContentElementSearch(emptyList())

        @JvmField
        val CHUNKS_ONLY: ContentElementSearch = ContentElementSearch(
            types = listOf(Chunk::class.java),
        )
    }
}


/**
 * Controls entity search
 * Open to allow specializations
 *
 */
open class EntitySearch(
    val labels: Set<String>,
    val generateQueries: Boolean = false,
)

open class TypedEntitySearch(
    val entities: List<Class<*>>,
    generateQueries: Boolean = false,
) : EntitySearch(
    labels = entities.map { it.simpleName }.toSet(),
    generateQueries = generateQueries,
) {

    constructor (vararg entities: Class<*>) : this(entities.toList())
}


open class CompressionConfig(
    val enabled: Boolean = true,
)

/**
 * Hypothetical Document Embedding
 * Used to generate a synthetic document for embedding from the query.
 * @param context the context to use for generating the synthetic document:
 * @param wordCount the number of words to generate for the synthetic document (default is 50)
 * what the answer should relate to.
 * For example: "The history of the Roman Empire."
 */
data class HyDE @JvmOverloads constructor(
    val context: String,
    val wordCount: Int = 50,
)

/**
 * RAG request.
 * Contains a query and parameters for similarity search.
 * @param query the query string to search for
 * @param similarityThreshold the minimum similarity score for results (default is 0.8)
 * @param topK the maximum number of results to return (default is 8)
 * If set, only the given entities will be searched for.
 */
data class RagRequest(
    override val query: String,
    override val similarityThreshold: ZeroToOne = .8,
    override val topK: Int = 8,
    override val hyDE: HyDE? = null,
    override val desiredMaxLatency: Duration = Duration.ofMillis(5000),
    override val compressionConfig: CompressionConfig = CompressionConfig(),
    override val contentElementSearch: ContentElementSearch = ContentElementSearch.CHUNKS_ONLY,
    override val entitySearch: EntitySearch? = null,
    override val timestamp: Instant = Instant.now(),
) : TextSimilaritySearchRequest, RagRequestRefinement<RagRequest>, Timestamped {

    override fun withHyDE(hyDE: HyDE): RagRequest {
        return this.copy(hyDE = hyDE)
    }

    override fun withSimilarityThreshold(similarityThreshold: ZeroToOne): RagRequest {
        return this.copy(similarityThreshold = similarityThreshold)
    }

    override fun withTopK(topK: Int): RagRequest {
        return this.copy(topK = topK)
    }

    override fun withCompression(compressionConfig: CompressionConfig): RagRequest {
        return this.copy(compressionConfig = compressionConfig)
    }

    @ApiStatus.Experimental
    override fun withEntitySearch(entitySearch: EntitySearch): RagRequest {
        return this.copy(entitySearch = entitySearch)
    }

    override fun withContentElementSearch(contentElementSearch: ContentElementSearch): RagRequest {
        return this.copy(contentElementSearch = contentElementSearch)
    }

    override fun withDesiredMaxLatency(desiredMaxLatency: Duration): RagRequest {
        return this.copy(desiredMaxLatency = desiredMaxLatency)
    }

    companion object {

        @JvmStatic
        fun query(
            query: String,
        ): RagRequest = RagRequest(query = query)
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/RagResponse.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag

import com.embabel.common.core.types.SimilarityResult
import com.embabel.common.core.types.ZeroToOne
import java.time.Instant

/**
 * Rag response
 * RagResponses can contain results from multiple RAG services.
 * Results are not necessarily chunks, but can be entities.
 * @param request the original request
 * @param service the name of the RAG service that produced this response
 * @param results the list of similarity results
 */
data class RagResponse(
    val request: RagRequest,
    val service: String,
    val results: List<SimilarityResult<out Retrievable>>,
    val enhancement: RagResponseEnhancement? = null,
    val qualityMetrics: QualityMetrics? = null,

    val timestamp: Instant = Instant.now(),
) {

    /**
     * Return only the final response, without the history of enhancements
     */
    fun withoutHistory(): RagResponse {
        return copy(
            enhancement = null,
        )
    }
}

/**
 * RAGAS quality metrics
 * @param faithfulness Content grounded in retrieved docs
 * @param answerRelevancy Response relevance to query
 * @param contextPrecision Relevant chunks ranked higher
 * @param contextRecall All relevant info retrieved
 * @param contextRelevancy Retrieved chunks are relevant
 */
data class QualityMetrics(
    val faithfulness: ZeroToOne,
    val answerRelevancy: ZeroToOne,
    val contextPrecision: ZeroToOne,
    val contextRecall: ZeroToOne,
    val contextRelevancy: ZeroToOne,
    val overallScore: ZeroToOne = computeRAGASScore(
        faithfulness,
        answerRelevancy,
        contextPrecision,
        contextRecall,
        contextRelevancy,
    ),
)

fun computeRAGASScore(
    faithfulness: Double,
    answerRelevancy: Double,
    contextPrecision: Double,
    contextRecall: Double,
    contextRelevancy: Double,
): Double {
    // RAGAS uses harmonic mean to penalize any single poor metric
    val values = listOf(faithfulness, answerRelevancy, contextPrecision, contextRecall, contextRelevancy)
    return harmonicMean(values)
}

private fun harmonicMean(values: List<Double>): Double {
    val validValues = values.filter { it > 0.0 }
    if (validValues.isEmpty()) return 0.0
    return validValues.size / validValues.sumOf { 1.0 / it }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/RagResponseEnhancer.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag

import com.embabel.common.core.types.Named
import com.embabel.common.core.types.ZeroToOne

data class RagResponseEnhancement(
    val enhancer: RagResponseEnhancer,
    val basis: RagResponse,

    val processingTimeMs: Long = 0,
    val tokensProcessed: Int = 0,
    val enhancementType: EnhancementType,
    // Before/after quality score delta
    val qualityImpact: ZeroToOne? = null,
)

enum class EnhancementType {
    COMPRESSION, RERANKING, DEDUPLICATION,
    ENTITY_EXTRACTION, FACT_CHECKING, QUALITY_ASSESSMENT,
    CONTENT_SYNTHESIS, MULTIMODAL_PROCESSING, CUSTOM
}

enum class EnhancementRecommendation {
    APPLY, SKIP, CONDITIONAL
}

data class EnhancementEstimate(
    val expectedQualityGain: Double,
    val estimatedLatencyMs: Long,
    val estimatedTokenCost: Int,
    val recommendation: EnhancementRecommendation,
)

interface RagResponseEnhancer : Named {

    val enhancementType: EnhancementType

    fun enhance(response: RagResponse): RagResponse

    fun estimateImpact(response: RagResponse): EnhancementEstimate? = null

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/RagResponseFormatter.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag

/**
 * Implemented by classes that can format RagResponse objects into a string
 * for inclusion in tool responses or prompts.
 */
fun interface RagResponseFormatter {

    /**
     * Formats the given RagResponse into a string for inclusion in tool responses or prompts.
     * @param ragResponse The RagResponse to format.
     * @return A string representation of the RagResponse.
     */
    fun format(ragResponse: RagResponse): String
}

/**
 * Sensible default RagResponseFormatter
 */
object SimpleRagResponseFormatter : RagResponseFormatter {

    const val NO_RESULTS_FOUND = "No results found"

    override fun format(ragResponse: RagResponse): String {
        val results = ragResponse.results
        return if (results.isEmpty()) {
            NO_RESULTS_FOUND
        } else {
            results.joinToString(separator = "\n\n") { result ->
                val formattedScore = "%.2f".format(result.score)

                when (val match = result.match) {
                    is EntityData -> {
                        "$formattedScore: ${match.embeddableValue()}"
                    }

                    is Chunk -> {
                        "$formattedScore: ${match.text}"
                    }

                    is Fact -> {
                        "$formattedScore: fact - ${match.assertion}"
                    }

                    else -> {
                        "$formattedScore: ${result.match.javaClass.simpleName} - ${match.infoString(verbose = true)}"
                    }
                }
            }
        }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/RagResponseSummarizer.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag

import com.embabel.agent.api.common.PromptRunner
import com.embabel.agent.rag.tools.RagOptions

interface RagResponseSummarizer {
    fun summarize(ragResponse: RagResponse): String
}

class PromptRunnerRagResponseSummarizer(
    val promptRunner: PromptRunner,
    val options: RagOptions,
) : RagResponseSummarizer {

    override fun summarize(ragResponse: RagResponse): String {
        return promptRunner
            .withId("summarizer")
            .generateText(
                prompt = """
                Summarize the following information provided as context to answer a question.
                Limit the summary to approximately ${options.dualShot?.summaryWords ?: 100} words.
                <query>${ragResponse.request.query}</query>
                <context>
                ${options.ragResponseFormatter.format(ragResponse)}
                </context>
            """.trimIndent(),
            )
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/RagService.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag

import com.embabel.common.core.types.Described
import com.embabel.common.core.types.HasInfoString
import com.embabel.common.util.indent


/**
 * Central interface for Retrieval-Augmented Generation (RAG) services.
 * Returns entities as well as text chunks.
 */
interface RagService : Described, HasInfoString {

    /**
     * Name of the RAG service. Should be unique
     * per application instance. User code may use this to select
     * a RAG service.
     */
    val name: String

    /**
     * Make a RAG request
     */
    fun search(ragRequest: RagRequest): RagResponse

    companion object {

        /**
         * Return a RAG service that will never return any results
         */
        @JvmStatic
        @JvmOverloads
        fun empty(
            name: String = "empty",
            description: String = "empty",
        ): RagService {
            return EmptyRagService(
                name = name,
                description = description,
            )
        }
    }
}


private data class EmptyRagService(
    override val name: String,
    override val description: String,
) : RagService {

    override fun search(ragRequest: RagRequest): RagResponse {
        return RagResponse(
            request = ragRequest,
            service = name,
            results = emptyList(),
        )
    }

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String {
        return "Empty RAG service: $name".indent(indent)
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/RagServiceEnhancer.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag

import com.embabel.agent.api.common.OperationContext
import com.embabel.agent.event.RagEventListener

/**
 * Given a RAG service, create an enhanced RAG service for use in a particular operation.
 */
interface RagServiceEnhancer {

    /**
     * Create a new Rag Service for use in a given operation
     * @param operationContext context of the operation for which the RAG service is being created.
     * Having the context allows for running LLM operations such as summarization
     * and considering the current AgentProcess.
     */
    fun create(
        operationContext: OperationContext,
        delegate: RagService,
        listener: RagEventListener,
    ): RagService
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/RagServiceEnhancerProperties.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag

import com.embabel.common.ai.model.LlmOptions
import org.springframework.boot.context.properties.ConfigurationProperties

@ConfigurationProperties(prefix = "embabel.agent.rag")
class RagServiceEnhancerProperties {
    var compressionLlm: LlmOptions = LlmOptions.withAutoLlm()
    var rerankingLlm: LlmOptions = LlmOptions.withAutoLlm()
    var maxConcurrency: Int = 12
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/Retrievable.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag

import com.embabel.agent.api.common.Embedding
import com.embabel.common.core.types.HasInfoString
import io.swagger.v3.oas.annotations.media.Schema
import org.jetbrains.annotations.ApiStatus

/**
 * Embedded object instance.
 */
interface Embedded {

    val embedding: Embedding?

}

/**
 * Data object instance, whether structural or not.
 */
sealed interface Datum {

    /**
     * Embabel id. Will be synthetic.
     */
    val id: String

    /**
     * URI for the content. May be a URL.
     * Not generated by Embabel, but from the source.
     */
    val uri: String?

    val metadata: Map<String, Any?>

    /**
     * Properties to persist
     * Subclasses can add their own properties
     * but must call super to include these.
     */
    fun propertiesToPersist(): Map<String, Any?> = mapOf(
        "id" to id,
        "uri" to uri,
    ) + metadata

    /**
     * Labels of the entity. In Neo, this might include multiple labels.
     * In a relational database, this might be a single table name.
     */
    @Schema(
        description = "Labels of the content element. In Neo, this might include multiple labels. In a relational database, this might be a single table name.",
        example = "[\"Person\", \"Customer\"]",
        required = true,
    )
    fun labels(): Set<String> = emptySet()
}

/**
 * Structural content element that may have a parent and children.
 * Textual.
 */
interface ContentElement : Datum {

    override fun labels(): Set<String> = super.labels() + setOf("ContentElement")
}

interface Embeddable {

    /**
     * Embedding value of this retrievable object.
     */
    fun embeddableValue(): String

}

/**
 * A Retrievable object instance is a Datum
 * (normally a chunk or an entity) that can be retrieved by RAG.
 * It has a stable id.
 */
interface Retrievable : HasInfoString, Datum, Embeddable {

    /**
     * Neighbors of this retrievable object.
     * Allows navigation of a graph
     */
    @get:ApiStatus.Experimental
    val neighbors: Map<String, Collection<Retrievable>> get() = mapOf()

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/Source.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag

import com.embabel.common.util.indent
import java.util.*

/**
 * A Source object instance is an input
 * such as a Chunk or a Fact.
 * It was provided to the system as data;
 * it is not inferred by the system, but a direct piece of data.
 */
sealed interface Source : Retrievable

/**
 * Implemented by objects that are from a source.
 */
interface Sourced {
    val basis: Retrievable
}


/**
 * Traditional RAG. Text chunk
 */
interface Chunk : Source, HierarchicalContentElement {

    /**
     * Text content
     */
    val text: String

    override val uri: String? get() = metadata["url"] as? String

    override fun embeddableValue(): String = text

    override fun propertiesToPersist(): Map<String, Any?> {
        return super<HierarchicalContentElement>.propertiesToPersist() + mapOf(
            "text" to text,
        )
    }

    override fun labels(): Set<String> {
        return super<Source>.labels() + super<HierarchicalContentElement>.labels() + setOf("Chunk")
    }

    fun transform(transformed: String): Chunk =
        ChunkImpl(
            id = this.id,
            text = transformed,
            metadata = this.metadata,
        )

    companion object {

        operator fun invoke(
            id: String,
            text: String,
            metadata: Map<String, Any?> = emptyMap(),
            parentId: String? = null,
        ): Chunk {
            return ChunkImpl(
                id = id,
                text = text,
                metadata = metadata,
                parentId = parentId,
            )
        }

    }

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String = "chunk: $text".indent(indent)
}

private data class ChunkImpl(
    override val id: String,
    override val text: String,
    override val parentId: String? = null,
    override val metadata: Map<String, Any?>,
) : Chunk

/**
 * A fact.
 * @param assertion the text of the fact
 * @param authority the authority of the fact, such as a person
 */
data class Fact(
    val assertion: String,
    val authority: String,
    override val uri: String? = null,
    override val metadata: Map<String, Any?> = emptyMap(),
    override val id: String = UUID.randomUUID().toString(),
) : Source {

    override fun embeddableValue(): String = assertion

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String = "Fact $id from $authority: $assertion".indent(indent)
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/WritableContentElementRepository.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag

import com.embabel.agent.rag.ingestion.ContentElementRepository

/**
 * WritableRagService that also allows us to load and save ContentElements.
 */
interface WritableContentElementRepository : WritableStore, ContentElementRepository {

    /**
     * Provision this rag service if necessary
     */
    fun provision() {
        // Default no-op
    }

    /**
     * The Retrievables have been saved to the store,
     * but Retrievables are special, and we probably want to embed them
     */
    fun onNewRetrievables(
        retrievables: List<Retrievable>,
    )

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/WritableStore.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag

import com.embabel.agent.rag.ingestion.MaterializedDocument
import com.embabel.common.core.types.Named
import org.springframework.ai.document.DocumentWriter

/**
 * RagService that can accept documents
 */
interface WritableStore : DocumentWriter, Named {

    /**
     * Write the given content root and its children to the underlying store.
     * @return list of chunk ids
     */
    fun writeContent(root: MaterializedDocument): List<String>
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/ingestion/ContentChunker.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.ingestion

import com.embabel.agent.rag.Chunk
import com.embabel.agent.rag.LeafSection
import org.slf4j.LoggerFactory
import java.util.*

/**
 * Converts MaterializedContainerSection objects into Chunk objects with intelligent text splitting.
 *
 * For container sections with small total content (aggregated from leaves), creates a single chunk
 * containing all leaf content. For large leaf sections within containers, splits them individually
 * into multiple chunks.
 */
class ContentChunker(
    val config: Config = DefaultConfig(),
) {

    private val logger = LoggerFactory.getLogger(javaClass)

    /**
     * Split a MaterializedContainerSection into one or more Chunks
     */
    fun chunk(section: MaterializedContainerSection): List<Chunk> {
        val leaves = section.leaves()
        val totalContentLength = leaves.sumOf { it.content.length + it.title.length + 1 } // +1 for newline after title

        // Strategy 1: If total content fits in a single chunk, combine everything
        if (totalContentLength <= config.maxChunkSize) {
            logger.debug(
                "Creating single chunk for container section '{}' with {} leaves (total length: {} <= max: {})",
                section.title, leaves.size, totalContentLength, config.maxChunkSize
            )
            return listOf(createSingleChunkFromContainer(section, leaves))
        }

        // Strategy 2: Try to group leaves intelligently before splitting
        logger.debug(
            "Total content ({} chars) exceeds maxChunkSize ({}), attempting intelligent grouping",
            totalContentLength, config.maxChunkSize
        )
        return chunkLeavesIntelligently(section, leaves)
    }

    /**
     * Split multiple MaterializedContainerSections into Chunks
     */
    fun splitSections(sections: List<MaterializedContainerSection>): List<Chunk> {
        return sections.flatMap { chunk(it) }
    }

    private fun createSingleChunkFromContainer(
        section: MaterializedContainerSection,
        leaves: List<LeafSection>,
    ): Chunk {
        val combinedContent = leaves.joinToString("\n\n") { leaf ->
            if (leaf.title.isNotBlank()) "${leaf.title}\n${leaf.content}" else leaf.content
        }.trim()

        val combinedMetadata = mutableMapOf<String, Any?>()
        combinedMetadata.putAll(section.metadata)
        combinedMetadata["container_section_id"] = section.id
        combinedMetadata["container_section_title"] = section.title
        combinedMetadata["container_section_url"] = section.uri
        combinedMetadata["chunk_index"] = 0
        combinedMetadata["total_chunks"] = 1

        return Chunk(
            id = UUID.randomUUID().toString(),
            text = combinedContent,
            metadata = combinedMetadata,
            parentId = section.id
        )
    }

    private fun chunkLeavesIntelligently(
        containerSection: MaterializedContainerSection,
        leaves: List<LeafSection>,
    ): List<Chunk> {
        val allChunks = mutableListOf<Chunk>()
        val leafGroups = groupLeavesForOptimalChunking(leaves)

        logger.debug("Grouped {} leaves into {} groups for chunking", leaves.size, leafGroups.size)

        for (group in leafGroups) {
            when {
                group.size == 1 -> {
                    // Single leaf group
                    val leaf = group.first()
                    val leafContentSize = leaf.content.length + leaf.title.length + 1

                    if (leafContentSize <= config.maxChunkSize) {
                        // Small enough for single chunk
                        allChunks.add(createSingleLeafChunk(containerSection, leaf))
                    } else {
                        // Too large, split it
                        allChunks.addAll(splitLeafIntoMultipleChunks(containerSection, leaf))
                    }
                }

                else -> {
                    // Multi-leaf group - create combined chunk
                    allChunks.add(createCombinedLeafChunk(containerSection, group))
                }
            }
        }

        return allChunks
    }

    private fun groupLeavesForOptimalChunking(leaves: List<LeafSection>): List<List<LeafSection>> {
        val groups = mutableListOf<List<LeafSection>>()
        var currentGroup = mutableListOf<LeafSection>()
        var currentGroupSize = 0

        for (leaf in leaves) {
            val leafSize = leaf.content.length + leaf.title.length + 1 // +1 for newline

            // If adding this leaf would exceed maxChunkSize, finalize current group
            if (currentGroup.isNotEmpty() && currentGroupSize + leafSize + 2 > config.maxChunkSize) { // +2 for separator
                groups.add(currentGroup.toList())
                currentGroup.clear()
                currentGroupSize = 0
            }

            // If single leaf is too large, it goes in its own group
            if (leafSize > config.maxChunkSize) {
                if (currentGroup.isNotEmpty()) {
                    groups.add(currentGroup.toList())
                    currentGroup.clear()
                    currentGroupSize = 0
                }
                groups.add(listOf(leaf))
            } else {
                // Add leaf to current group
                currentGroup.add(leaf)
                currentGroupSize += leafSize + 2 // +2 for separator between leaves
            }
        }

        // Add final group if it has content
        if (currentGroup.isNotEmpty()) {
            groups.add(currentGroup.toList())
        }

        return groups
    }

    private fun createCombinedLeafChunk(
        containerSection: MaterializedContainerSection,
        leaves: List<LeafSection>,
    ): Chunk {
        val combinedContent = leaves.joinToString("\n\n") { leaf ->
            if (leaf.title.isNotBlank()) "${leaf.title}\n${leaf.content}" else leaf.content
        }.trim()

        val combinedMetadata = mutableMapOf<String, Any?>()
        combinedMetadata.putAll(containerSection.metadata)
        combinedMetadata["container_section_id"] = containerSection.id
        combinedMetadata["container_section_title"] = containerSection.title
        combinedMetadata["container_section_url"] = containerSection.uri
        combinedMetadata["chunk_index"] = 0
        combinedMetadata["total_chunks"] = 1

        return Chunk(
            id = UUID.randomUUID().toString(),
            text = combinedContent,
            metadata = combinedMetadata,
            parentId = containerSection.id
        )
    }

    private fun createSingleLeafChunk(
        containerSection: MaterializedContainerSection,
        leaf: LeafSection,
    ): Chunk {
        val content = if (leaf.title.isNotBlank()) "${leaf.title}\n${leaf.content}" else leaf.content

        return Chunk(
            id = UUID.randomUUID().toString(),
            text = content.trim(),
            metadata = leaf.metadata + mapOf(
                "container_section_id" to containerSection.id,
                "container_section_title" to containerSection.title,
                "leaf_section_id" to leaf.id,
                "leaf_section_title" to leaf.title,
                "leaf_section_url" to leaf.uri,
                "chunk_index" to 0,
                "total_chunks" to 1
            ),
            parentId = leaf.id
        )
    }

    private fun splitLeafIntoMultipleChunks(
        containerSection: MaterializedContainerSection,
        leaf: LeafSection,
    ): List<Chunk> {
        val chunks = mutableListOf<Chunk>()
        val fullContent = if (leaf.title.isNotBlank()) "${leaf.title}\n${leaf.content}" else leaf.content
        val textChunks = splitText(fullContent.trim()).filter { it.trim().isNotEmpty() }

        logger.debug("Split leaf section '{}' into {} text chunks", leaf.title, textChunks.size)

        textChunks.forEachIndexed { index, textChunk ->
            val chunk = Chunk(
                id = UUID.randomUUID().toString(),
                text = textChunk.trim(),
                metadata = leaf.metadata + mapOf(
                    "container_section_id" to containerSection.id,
                    "container_section_title" to containerSection.title,
                    "leaf_section_id" to leaf.id,
                    "leaf_section_title" to leaf.title,
                    "leaf_section_url" to leaf.uri,
                    "chunk_index" to index,
                    "total_chunks" to textChunks.size
                ),
                parentId = leaf.id
            )
            chunks.add(chunk)
        }

        return chunks
    }

    private fun splitText(text: String): List<String> {
        // First, try to split by paragraphs
        val paragraphs = text.split("\n\n").filter { it.trim().isNotEmpty() }

        val chunks = mutableListOf<String>()
        var currentChunk = StringBuilder()

        for (paragraph in paragraphs) {
            // If adding this paragraph would exceed the limit, finalize current chunk
            if (currentChunk.isNotEmpty() &&
                currentChunk.length + paragraph.length + 2 > config.maxChunkSize
            ) {

                chunks.add(currentChunk.toString().trim())

                // Start new chunk with overlap from previous chunk if possible
                currentChunk = StringBuilder()
                if (chunks.isNotEmpty()) {
                    val overlap = getOverlapText(chunks.last())
                    if (overlap.isNotEmpty() && overlap.length + paragraph.length + 2 <= config.maxChunkSize) {
                        currentChunk.append(overlap).append("\n\n")
                    }
                }
            }

            // If single paragraph is too long, split it by sentences
            if (paragraph.length > config.maxChunkSize) {
                val sentenceChunks = splitBySentences(paragraph)
                for (sentenceChunk in sentenceChunks) {
                    if (currentChunk.isNotEmpty() &&
                        currentChunk.length + sentenceChunk.length + 2 > config.maxChunkSize
                    ) {

                        chunks.add(currentChunk.toString().trim())
                        currentChunk = StringBuilder()

                        // Add overlap
                        if (chunks.isNotEmpty()) {
                            val overlap = getOverlapText(chunks.last())
                            if (overlap.isNotEmpty() && overlap.length + sentenceChunk.length + 2 <= config.maxChunkSize) {
                                currentChunk.append(overlap).append("\n\n")
                            }
                        }
                    }

                    if (currentChunk.isNotEmpty()) {
                        currentChunk.append("\n\n")
                    }
                    currentChunk.append(sentenceChunk)
                }
            } else {
                // Add paragraph as is
                if (currentChunk.isNotEmpty()) {
                    currentChunk.append("\n\n")
                }
                currentChunk.append(paragraph)
            }
        }

        // Add final chunk if it has content
        if (currentChunk.isNotEmpty()) {
            chunks.add(currentChunk.toString().trim())
        }

        // Safety check: ensure no chunk exceeds max size and filter out empty chunks
        val finalChunks = chunks.flatMap { chunk ->
            if (chunk.length <= config.maxChunkSize) {
                listOf(chunk)
            } else {
                // Emergency fallback: split oversized chunk by character count
                chunk.chunked(config.maxChunkSize).filter { it.trim().isNotEmpty() }
            }
        }.filter { it.trim().isNotEmpty() }

        return finalChunks.ifEmpty {
            if (text.trim().isNotEmpty()) listOf(text.trim()) else emptyList()
        }
    }

    private fun splitBySentences(text: String): List<String> {
        // Split by sentence endings, but be careful with abbreviations
        val sentences = text.split(Regex("(?<=[.!?])\\s+"))
            .filter { it.trim().isNotEmpty() }

        val chunks = mutableListOf<String>()
        var currentChunk = StringBuilder()

        for (sentence in sentences) {
            if (currentChunk.isNotEmpty() &&
                currentChunk.length + sentence.length + 1 > config.maxChunkSize
            ) {

                chunks.add(currentChunk.toString().trim())
                currentChunk = StringBuilder()

                // Add overlap from previous chunk
                if (chunks.isNotEmpty()) {
                    val overlap = getOverlapText(chunks.last())
                    if (overlap.isNotEmpty() && overlap.length + sentence.length + 1 <= config.maxChunkSize) {
                        currentChunk.append(overlap).append(" ")
                    }
                }
            }

            if (currentChunk.isNotEmpty()) {
                currentChunk.append(" ")
            }
            currentChunk.append(sentence)
        }

        if (currentChunk.isNotEmpty()) {
            chunks.add(currentChunk.toString().trim())
        }

        // Safety check: ensure no chunk exceeds max size and filter out empty chunks
        val finalChunks = chunks.flatMap { chunk ->
            if (chunk.length <= config.maxChunkSize) {
                listOf(chunk)
            } else {
                // Emergency fallback: split oversized chunk by character count
                chunk.chunked(config.maxChunkSize).filter { it.trim().isNotEmpty() }
            }
        }.filter { it.trim().isNotEmpty() }

        return finalChunks.ifEmpty {
            if (text.trim().isNotEmpty()) listOf(text.trim()) else emptyList()
        }
    }

    private fun getOverlapText(previousChunk: String): String {
        if (previousChunk.length <= config.overlapSize) {
            return ""
        }

        // Try to get overlap at a sentence boundary
        val overlap = previousChunk.takeLast(config.overlapSize)
        val sentenceStart = overlap.indexOf(". ") + 2

        return if (sentenceStart > 1 && sentenceStart < overlap.length) {
            overlap.substring(sentenceStart)
        } else {
            // Fallback to word boundary
            val words = overlap.split(" ")
            if (words.size > 1) {
                words.drop(1).joinToString(" ")
            } else {
                ""
            }
        }
    }

    interface Config {
        val maxChunkSize: Int
        val overlapSize: Int
    }

    /**
     * Configuration for the splitter
     */
    data class DefaultConfig @JvmOverloads constructor(
        override val maxChunkSize: Int = 1500,
        override val overlapSize: Int = 200,
    ) : Config {
        init {
            require(maxChunkSize > 0) { "maxChunkSize must be positive" }
            require(overlapSize >= 0) { "overlapSize must be non-negative" }
            require(overlapSize < maxChunkSize) { "overlapSize must be < maxChunkSize" }
        }
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/ingestion/ContentElementRepository.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.ingestion

import com.embabel.agent.rag.Chunk
import com.embabel.agent.rag.ContentElement

/**
 * Implemented by services that can retrieve Chunks and other ContentElements by id.
 */
interface ContentElementRepository {

    fun findChunksById(chunkIds: List<String>): List<Chunk>

    fun findById(id: String): ContentElement?

    fun save(element: ContentElement): ContentElement

    /**
     * Return the total number of content elements in the repository
     */
    fun count(): Int

    fun findChunksForEntity(
        entityId: String,
    ): List<Chunk>
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/ingestion/Ingester.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.ingestion

import com.embabel.agent.rag.WritableStore
import com.embabel.common.core.types.HasInfoString
import org.springframework.ai.document.DocumentWriter

data class IngestionResult(
    val storesWrittenTo: Set<String>,
    val chunkIds: List<String>,
) {

    val documentsWritten: Int get() = chunkIds.size

    fun success(): Boolean {
        return storesWrittenTo.isNotEmpty()
    }
}

interface Ingester : DocumentWriter, HasInfoString {

    /**
     * Is this ingester presently active?
     */
    fun active(): Boolean

    val stores: List<WritableStore>

    /**
     * Ingest the resource at the given path.
     * Use Spring Resource conventions
     */
    fun ingest(resourcePath: String): IngestionResult
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/ingestion/MaterializedDocument.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.ingestion

import com.embabel.agent.rag.ContainerSection
import com.embabel.agent.rag.ContentRoot
import com.embabel.agent.rag.LeafSection
import com.embabel.agent.rag.MaterializedSection

interface MaterializedContainerSection : ContainerSection, MaterializedSection {

    /**
     * Direct children of this section (not all descendants).
     */
    val children: List<MaterializedSection>

    fun descendants(): List<MaterializedSection> =
        children + children.filterIsInstance<MaterializedContainerSection>().flatMap { containerChild ->
            containerChild.descendants()
        }

    fun leaves(): List<LeafSection> =
        children.filterIsInstance<LeafSection>() +
                children.filterIsInstance<MaterializedContainerSection>().flatMap { containerChild ->
                    containerChild.leaves()
                }
}

data class DefaultMaterializedContainerSection(
    override val id: String,
    override val uri: String? = null,
    override val title: String,
    override val children: List<MaterializedSection>,
    override val parentId: String? = null,
    override val metadata: Map<String, Any?> = emptyMap(),
) : MaterializedContainerSection

/**
 * MaterializedDocument is the in-memory representation of a document with sections.
 */
data class MaterializedDocument(
    override val id: String,
    override val uri: String,
    override val title: String,
    override val children: List<MaterializedSection>,
    override val metadata: Map<String, Any?> = emptyMap(),
) : MaterializedContainerSection, ContentRoot {

    override fun labels(): Set<String> = super<ContentRoot>.labels() + super<MaterializedContainerSection>.labels()

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/ingestion/MultiIngester.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.ingestion

import com.embabel.agent.rag.WritableStore
import org.slf4j.LoggerFactory
import org.springframework.ai.document.Document
import org.springframework.ai.reader.TextReader
import org.springframework.ai.transformer.splitter.TextSplitter
import org.springframework.ai.transformer.splitter.TokenTextSplitter

/**
 * Write to all RAG services that implement [com.embabel.agent.rag.WritableStore].
 * Users can override the [org.springframework.ai.transformer.splitter.TextSplitter] to control how text is split into documents.
 */
class MultiIngester(
    override val stores: List<WritableStore>,
    private val splitterProvider: () -> TextSplitter = { TokenTextSplitter() },
) : Ingester {

    private val splitter: TextSplitter by lazy { splitterProvider() }

    private val logger = LoggerFactory.getLogger(javaClass)

    init {
        logger.info(
            "{} with {} writable rag services: Using text splitter {}",
            javaClass.simpleName,
            stores.size,
            splitter,
        )
    }

    override fun active(): Boolean = stores.isNotEmpty()

    override fun ingest(resourcePath: String): IngestionResult {
        val sourceDocs = TextReader(resourcePath).get()
        val documents = splitter.split(sourceDocs)
        logger.info(
            "Split {} source documents at {} into {} indexable chunks: Will write to {} writable rag services",
            sourceDocs.size, resourcePath, documents.size, stores.size
        )
        logger.debug("Documents: {}", documents.joinToString("\n"))
        return writeToStores(documents)
    }

    override fun accept(documents: List<Document>) {
        writeToStores(documents)
    }

    private fun writeToStores(documents: List<Document>): IngestionResult {
        val storesWrittenTo = stores
            .map {
                it.write(documents)
                it.name
            }
        return IngestionResult(
            chunkIds = documents.map { it.id },
            storesWrittenTo = storesWrittenTo.toSet(),
        )
    }

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String =
        if (stores.isEmpty()) "No RAG services" else
            "${javaClass.simpleName} of ${
                stores.joinToString(",") {
                    it.name
                }
            }"
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/support/FacetedRagService.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.support

import com.embabel.agent.rag.RagRequest
import com.embabel.agent.rag.RagResponse
import com.embabel.agent.rag.RagService
import com.embabel.agent.rag.Retrievable
import org.slf4j.LoggerFactory

/**
 * Rag service that combines multiple RagFacets and returns the best results
 */
class FacetedRagService(
    override val name: String,
    override val description: String = name,
    facets: List<RagFacet<out Retrievable>>,
    facetProviders: List<RagFacetProvider>,
) : RagService {

    private val logger = LoggerFactory.getLogger(FacetedRagService::class.java)

    val ragFacets = facets.toList() + facetProviders.flatMap { it.facets() }

    init {
        logger.info("Discovered {} RagFacets", ragFacets.size)
    }

    override fun search(ragRequest: RagRequest): RagResponse {
        // TODO could parallelize
        val allResults = ragFacets.flatMap { facet ->
            facet.search(ragRequest).results
        }
        val ragResponse = RagResponse(
            request = ragRequest,
            service = name,
            results = allResults.distinctBy { it.match.id },
        )
        logger.debug("RagResponse: {}", ragResponse)
        return ragResponse
    }

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String =
        if (ragFacets.isEmpty()) "No RagFacets" else
            "Composite of $description"

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/support/RagFacet.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.support

import com.embabel.agent.rag.Chunk
import com.embabel.agent.rag.EntityData
import com.embabel.agent.rag.RagRequest
import com.embabel.agent.rag.Retrievable
import com.embabel.common.core.types.Described
import com.embabel.common.core.types.Named
import com.embabel.common.core.types.SimilarityResult

data class RagFacetResults<out R : Retrievable>(
    val facetName: String,
    val results: List<SimilarityResult<out R>>,
)

/**
 * A facet of a RAG service. A facet can be searched independently,
 * and returns results of a particular type.
 * A FacetedRagService combines results from multiple facets.
 */
interface RagFacet<R : Retrievable> : Named {

    fun search(ragRequest: RagRequest): RagFacetResults<R>
}

class FunctionRagFacet<R : Retrievable>(
    override val name: String,
    private val searchFunction: (RagRequest) -> RagFacetResults<R>,
) : RagFacet<R> {

    override fun search(ragRequest: RagRequest): RagFacetResults<R> = searchFunction(ragRequest)
}

interface RagFacetProvider {

    fun facets(): List<RagFacet<out Retrievable>>
}

/**
 * Degenerate case of traditional vector RAG, where we don't really understand the Chunks
 */
interface ChunkFinder : RagFacet<Chunk>

/**
 * Match over an entity of type E. May be persisted in JPA or the like.
 */
interface EntityMatch<E : Any> : EntityData, Described {

    /**
     * Underlying entity
     */
    val entity: E

}

interface EntityFinder : RagFacet<EntityMatch<Any>>



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/support/SpringVectorStoreRagService.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.support

import com.embabel.agent.rag.*
import com.embabel.agent.rag.ingestion.MaterializedDocument
import com.embabel.common.core.types.SimilarityResult
import com.embabel.common.core.types.ZeroToOne
import com.embabel.common.util.indent
import com.embabel.common.util.trim
import org.jetbrains.annotations.ApiStatus
import org.slf4j.LoggerFactory
import org.springframework.ai.document.Document
import org.springframework.ai.vectorstore.SearchRequest
import org.springframework.ai.vectorstore.VectorStore

/**
 * RagService wrapping a Spring AI VectorStore.
 */
@ApiStatus.Experimental
class SpringVectorStoreRagService(
    private val vectorStore: VectorStore,
    override val description: String,
) : WritableStore, RagService {

    private val logger = LoggerFactory.getLogger(javaClass)

    override val name: String
        get() = vectorStore.name

    override fun search(ragRequest: RagRequest): RagResponse {
        val searchRequest = SearchRequest
            .builder()
            .query(ragRequest.query)
            .similarityThreshold(ragRequest.similarityThreshold)
            .topK(ragRequest.topK)
            .build()
        val results: List<Document> = vectorStore.similaritySearch(searchRequest)!!
        return RagResponse(
            request = ragRequest,
            service = name,
            results = results.map {
                DocumentSimilarityResult(
                    document = it,
                    score = it.score!!,
                )
            }
        )
    }

    override fun accept(documents: List<Document>) {
        logger.info("Writing ${documents.size} documents into Spring vector store")
        vectorStore.accept(documents)
    }

    override fun writeContent(root: MaterializedDocument): List<String> {
        TODO("Not yet implemented")
    }

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String {
        return "${vectorStore.name}: ${vectorStore.javaClass.name}".indent(indent)
    }
}

class DocumentSimilarityResult(
    private val document: Document,
    override val score: ZeroToOne,
) : SimilarityResult<Chunk> {

    override val match: Chunk = Chunk(
        document.id, document.text!!
    )

    override fun toString(): String {
        return "${javaClass.simpleName}(id=${document.id}, score=$score, text=${
            trim(
                s = document.text,
                max = 120,
                keepRight = 5
            )
        })"
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/tools/DualShotRagServiceSearchTools.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.tools

import com.embabel.agent.core.AgentProcess
import com.embabel.agent.rag.RagResponse
import com.embabel.agent.rag.RagResponseSummarizer
import com.embabel.common.util.loggerFor
import org.springframework.ai.tool.annotation.Tool
import org.springframework.ai.tool.annotation.ToolParam

/**
 * Expose a RagService as tools.
 * Once the tools instance is created,
 * options such as similarity cutoff are immutable
 * and will be used consistently in all calls.
 * The LLM needs to provide only the search query.
 */
class DualShotRagServiceSearchTools(
    val options: RagOptions,
    val summarizer: RagResponseSummarizer,
) {

    @Tool(description = "Search for information relating to this query. Returns summary results")
    fun search(
        @ToolParam(
            description = "Standalone query to search for. Include sufficient context",
        )
        query: String,
    ): String {
        val ragResponse = options.ragService.search(options.toRequest(query))
        val agentProcess = AgentProcess.get()
        if (agentProcess == null) {
            return "RagResponse for query [$query]:\n${options.ragResponseFormatter.format(ragResponse)}"
        }
        agentProcess.addObject(ragResponse.withoutHistory())
        val summary = summarizer.summarize(ragResponse)
        loggerFor<DualShotRagServiceSearchTools>().debug("Summary of RAG response: {}", summary)
        return summary
    }

    @Tool(description = "Drill deep into the details of the last search result")
    fun searchDetails(
        @ToolParam(
            description = "Standalone query to search for. Include sufficient context",
        )
        query: String,
    ): String {
        val ragResponse = AgentProcess.get()?.lastResult() as? RagResponse
            ?: return "No RagResponse available, call search tool before"
        val asString = options.ragResponseFormatter.format(ragResponse)
        return asString
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/tools/RagOptions.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.tools

import com.embabel.agent.rag.*
import com.embabel.common.ai.model.LlmOptions
import com.embabel.common.core.types.ZeroToOne
import java.time.Duration

data class DualShotConfig(
    val summaryWords: Int = 100,
)

/**
 * Operations for RAG use as an LLM tool. Options are immutable and stable.
 * @param ragService the RagService to use for retrieval
 * @param similarityThreshold minimum similarity threshold for results (0.0 to 1.0)
 * @param topK maximum number of results to return
 * returned. If set, only the given entities will be searched for.
 * @param ragResponseFormatter formatter to convert RagResponse to String
 * @param dualShot whether to use dual-shot RAG,
 * where the first tool returns a summary and the second tool returns detailed results.
 */
data class RagOptions @JvmOverloads constructor(
    val ragService: RagService,
    override val similarityThreshold: ZeroToOne = 0.7,
    override val topK: Int = 8,
    override val hyDE: HyDE? = null,
    override val desiredMaxLatency: Duration = Duration.ofMillis(5000),
    override val compressionConfig: CompressionConfig = CompressionConfig(),
    val llm: LlmOptions = LlmOptions.withAutoLlm(),
    override val contentElementSearch: ContentElementSearch = ContentElementSearch.CHUNKS_ONLY,
    override val entitySearch: EntitySearch? = null,
    val ragResponseFormatter: RagResponseFormatter = SimpleRagResponseFormatter,
    val dualShot: DualShotConfig? = null,
) : RagRequestRefinement<RagOptions> {

    override fun withHyDE(hyDE: HyDE): RagOptions {
        return this.copy(hyDE = hyDE)
    }

    override fun withSimilarityThreshold(similarityThreshold: ZeroToOne): RagOptions {
        return copy(similarityThreshold = similarityThreshold)
    }

    override fun withTopK(topK: Int): RagOptions {
        return copy(topK = topK)
    }

    override fun withDesiredMaxLatency(desiredMaxLatency: Duration): RagOptions {
        return copy(desiredMaxLatency = desiredMaxLatency)
    }

    override fun withCompression(compressionConfig: CompressionConfig): RagOptions {
        return copy(compressionConfig = compressionConfig)
    }

    override fun withContentElementSearch(contentElementSearch: ContentElementSearch): RagOptions {
        return copy(contentElementSearch = contentElementSearch)
    }

    override fun withEntitySearch(entitySearch: EntitySearch): RagOptions {
        return copy(entitySearch = entitySearch)
    }

    fun withDualShot(dualShot: DualShotConfig): RagOptions {
        return copy(dualShot = dualShot)
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/tools/RagReference.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.tools

import com.embabel.agent.api.common.LlmReference
import com.embabel.agent.api.common.PromptRunner
import com.embabel.agent.rag.PromptRunnerRagResponseSummarizer

/**
 * Expose a RagService as an LlmReference with tools.
 */
class RagReference(
    override val name: String,
    override val description: String,
    val options: RagOptions,
    private val summarizerPromptRunner: PromptRunner,
) : LlmReference {

    private val toolInstance: Any = run {
        if (options.dualShot != null) {
            DualShotRagServiceSearchTools(
                options = options,
                summarizer = PromptRunnerRagResponseSummarizer(summarizerPromptRunner, options)
            )
        } else {
            SingleShotRagServiceSearchTools(
                options = options,
            )
        }
    }

    override fun toolInstance() = toolInstance

    override fun notes() = ""

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/rag/tools/SingleShotRagServiceSearchTools.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.tools

import com.embabel.common.util.loggerFor
import org.springframework.ai.tool.annotation.Tool
import org.springframework.ai.tool.annotation.ToolParam

/**
 * Expose a RagService as tools.
 * Once the tools instance is created,
 * options such as similarity cutoff are immutable
 * and will be used consistently in all calls.
 * The LLM needs to provide only the search query.
 */
class SingleShotRagServiceSearchTools(
    val options: RagOptions,
) {

    @Tool(description = "Search for information relating to this query. Returns detailed results")
    fun search(
        @ToolParam(
            description = "Standalone query to search for. Include sufficient context",
        )
        query: String,
    ): String {
        val ragResponse = options.ragService.search(options.toRequest(query))
        val asString = options.ragResponseFormatter.format(ragResponse)
        loggerFor<SingleShotRagServiceSearchTools>().debug("RagResponse for query [{}]:\n{}", query, asString)
        return asString
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/README.md
================================================
# Types to be implemented by platform providers

Not intended for use by end users.


================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/AgentProcessIdGenerator.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi

import com.embabel.agent.core.Agent
import com.embabel.agent.core.ProcessOptions
import java.util.*

/**
 * Generate names for agent processes
 */
fun interface AgentProcessIdGenerator {

    /**
     * Generate a process ID for a new AgentProcess for this given agent and process options.
     */
    fun createProcessId(agent: Agent, processOptions: ProcessOptions): String

    companion object {
        val RANDOM: AgentProcessIdGenerator = AgentProcessIdGenerator { agent, processOptions ->
            UUID.randomUUID().toString()
        }
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/AgentProcessRepository.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi

import com.embabel.agent.core.AgentProcess

/**
 * Spring-style repository for agent processes.
 * We don't extend Repository because it confuses
 * Spring's component scanning if JPA/Neo or another Spring Data
 * solution is used on the classpath downstream.
 */
interface AgentProcessRepository {

    fun findById(id: String): AgentProcess?

    fun save(agentProcess: AgentProcess): AgentProcess

    fun delete(agentProcess: AgentProcess)
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/AutoLlmSelectionCriteriaResolver.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi

import com.embabel.common.ai.model.DefaultModelSelectionCriteria
import com.embabel.common.ai.model.ModelSelectionCriteria

/**
 * Replace automatic LLM selection with a custom one based on usage
 */
interface AutoLlmSelectionCriteriaResolver {
    // TODO needs context
    fun resolveAutoLlm(): ModelSelectionCriteria

    companion object {
        val DEFAULT: AutoLlmSelectionCriteriaResolver = DefaultAutoLlmSelectionCriteriaResolver

    }
}

private object DefaultAutoLlmSelectionCriteriaResolver : AutoLlmSelectionCriteriaResolver {
    override fun resolveAutoLlm(): ModelSelectionCriteria {
        return DefaultModelSelectionCriteria
    }

    override fun toString(): String = javaClass.simpleName
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/ContextRepository.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi

import com.embabel.agent.core.Context

/**
 * Load a context
 */
interface ContextRepository {

    /**
     * Create an empty context.
     */
    fun create(): Context

    fun save(context: Context): Context

    fun findById(id: String): Context?

    fun delete(context: Context)

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/LlmOperations.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi

import com.embabel.agent.api.common.InteractionId
import com.embabel.agent.core.*
import com.embabel.agent.event.LlmRequestEvent
import com.embabel.agent.prompt.element.ContextualPromptElement
import com.embabel.chat.Message
import com.embabel.chat.UserMessage
import com.embabel.common.ai.model.LlmOptions
import com.embabel.common.ai.prompt.PromptContributor
import com.embabel.common.ai.prompt.PromptContributorConsumer
import com.embabel.common.core.MobyNameGenerator
import com.embabel.common.core.types.HasInfoString
import com.embabel.common.util.indent
import jakarta.validation.ConstraintViolation
import org.springframework.ai.tool.ToolCallback
import java.util.function.Predicate

/**
 * Spec for calling an LLM. Optional LlmOptions,
 * plus tool groups and prompt contributors.
 */
interface LlmUse : PromptContributorConsumer, ToolGroupConsumer {
    val llm: LlmOptions?

    /**
     * Whether to generate examples for the prompt.
     * Defaults to unknown: Set to false if generating your own examples.
     */
    val generateExamples: Boolean?

    /**
     * Filter that determines which properties to include when creating objects.
     */
    val propertyFilter: Predicate<String>

}

/**
 * Spec for calling an LLM. Optional LlmOptions,
 * plus tool callbacks and prompt contributors.
 */
interface LlmCall : LlmUse, ToolConsumer {

    val contextualPromptContributors: List<ContextualPromptElement>

    companion object {

        operator fun invoke(llm: LlmOptions? = null): LlmCall = LlmCallImpl(
            llm = llm,
            name = MobyNameGenerator.generateName(),
        )

        @JvmStatic
        fun using(
            llm: LlmOptions,
        ): LlmCall = invoke(llm = llm)

    }
}

private data class LlmCallImpl(
    override val name: String,
    override val llm: LlmOptions? = null,
    override val toolGroups: Set<ToolGroupRequirement> = emptySet(),
    override val toolCallbacks: List<ToolCallback> = emptyList(),
    override val promptContributors: List<PromptContributor> = emptyList(),
    override val contextualPromptContributors: List<ContextualPromptElement> = emptyList(),
    override val generateExamples: Boolean = false,
    override val propertyFilter: Predicate<String> = Predicate { true },
) : LlmCall

/**
 * Encapsulates an interaction with an LLM.
 * An LlmInteraction is a specific instance of an LlmCall.
 * The LLM must have been chosen and the call has a unique identifier.
 * @param id Unique identifier for the interaction. Note that this is NOT
 * the id of this particular LLM call, but of the interaction in general.
 * For example, it might be the "analyzeProject" call within the "Analyze"
 * action. Every such call with have the same id, but many calls may be made
 * across different AgentProcesses, or even within the same AgentProcess
 * if the action can be rerun.
 * This is per action, not per process.
 * @param llm LLM options to use, specifying model and hyperparameters
 * @param toolCallbacks Tool callbacks to use for this interaction
 * @param promptContributors Prompt contributors to use for this interaction
 */
data class LlmInteraction(
    val id: InteractionId,
    override val llm: LlmOptions = LlmOptions(),
    override val toolGroups: Set<ToolGroupRequirement> = emptySet(),
    override val toolCallbacks: List<ToolCallback> = emptyList(),
    override val promptContributors: List<PromptContributor> = emptyList(),
    override val contextualPromptContributors: List<ContextualPromptElement> = emptyList(),
    override val generateExamples: Boolean? = null,
    override val propertyFilter: Predicate<String> = Predicate { true },
) : LlmCall {

    override val name: String = id.value

    companion object {

        @JvmStatic
        fun from(
            llm: LlmCall,
            id: InteractionId,
        ) = LlmInteraction(
            id = id,
            llm = llm.llm ?: LlmOptions(),
            toolCallbacks = llm.toolCallbacks,
            toolGroups = llm.toolGroups,
            promptContributors = llm.promptContributors,
            generateExamples = llm.generateExamples,
        )

        @JvmStatic
        fun using(llm: LlmOptions) = from(
            llm = LlmCall.using(llm),
            id = InteractionId("using"),
        )
    }
}

/**
 * The LLM returned an object of the wrong type.
 */
class InvalidLlmReturnFormatException(
    val llmReturn: String,
    val expectedType: Class<*>,
    cause: Throwable,
) : RuntimeException(
    "Invalid LLM return when expecting ${expectedType.name}: Root cause=${cause.message}",
    cause,
),
    HasInfoString {

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String =
        if (verbose == true) {
            "${javaClass.simpleName}: Expected type: ${expectedType.name}, root cause: ${cause!!.message}, return\n$llmReturn".indent(
                indent
            )
        } else {
            "${javaClass.simpleName}: Expected type: ${expectedType.name}, root cause: ${cause!!.message}"
        }
}

/**
 * Thrown the LLM returned an object that fails validation,
 * and although we tried, we could not correct it.
 */
class InvalidLlmReturnTypeException(
    val returnedObject: Any,
    val constraintViolations: Set<ConstraintViolation<*>>,
) : RuntimeException(
    "Validation errors: ${constraintViolations.joinToString(", ")}",
)

/**
 * Wraps LLM operations.
 * All user-initiated LLM operations go through this,
 * allowing the AgentPlatform to mediate them.
 * This interface is not directly for use in user code. Prefer PromptRunner
 * An LlmOperations implementation is responsible for resolving all relevant
 * tool callbacks for the current AgentProcess (in addition to those passed in directly),
 * and emitting events.
 * @see com.embabel.agent.api.common.PromptRunner
 */
interface LlmOperations {

    /**
     * Generate text in the context of an AgentProcess.
     * @param prompt Prompt to generate text from
     * @param interaction Llm options and tool callbacks to use, plus unique identifier
     * @param agentProcess Agent process we are running within
     * @param action Action we are running within if we are running within an action
     */
    fun generate(
        prompt: String,
        interaction: LlmInteraction,
        agentProcess: AgentProcess,
        action: Action?,
    ): String = createObject(
        messages = listOf(UserMessage(prompt)),
        interaction = interaction,
        outputClass = String::class.java,
        agentProcess = agentProcess,
        action = action,
    )

    /**
     * Create an output object, in the context of an AgentProcess.
     * @param messages messages in the conversation so far. Could just be user message.
     * @param interaction Llm options and tool callbacks to use, plus unique identifier
     * @param outputClass Class of the output object
     * @param agentProcess Agent process we are running within
     * @param action Action we are running within if we are running within an action
     * @throws InvalidLlmReturnFormatException if the LLM returns an invalid object
     * @throws InvalidLlmReturnTypeException if the LLM returns an object that fails validation
     */
    @Throws(
        InvalidLlmReturnFormatException::class,
        InvalidLlmReturnTypeException::class
    )
    fun <O> createObject(
        messages: List<Message>,
        interaction: LlmInteraction,
        outputClass: Class<O>,
        agentProcess: AgentProcess,
        action: Action?,
    ): O

    /**
     * Try to create an output object in the context of an AgentProcess.
     * Return a failure result if the LLM does not have enough information to create the object.
     * @param messages messages
     * @param interaction Llm options and tool callbacks to use, plus unique identifier
     * @param outputClass Class of the output object
     * @param agentProcess Agent process we are running within
     * @param action Action we are running within if we are running within an action
     * @throws InvalidLlmReturnFormatException if the LLM returns an object of the wrong type
     */
    fun <O> createObjectIfPossible(
        messages: List<Message>,
        interaction: LlmInteraction,
        outputClass: Class<O>,
        agentProcess: AgentProcess,
        action: Action?,
    ): Result<O>

    /**
     * Low level transform, not necessarily aware of platform
     * This is a convenience overload that creates a UserMessage
     * from a String prompt
     * @param prompt user prompt. Will become the last user message
     * @param interaction The LLM call options
     * @param outputClass Class of the output object
     * @param llmRequestEvent Event already published for this request if one has been
     */
    fun <O> doTransform(
        prompt: String,
        interaction: LlmInteraction,
        outputClass: Class<O>,
        llmRequestEvent: LlmRequestEvent<O>?,
    ): O =
        doTransform(
            messages = listOf(UserMessage(prompt)),
            interaction = interaction,
            outputClass = outputClass,
            llmRequestEvent = llmRequestEvent,
        )

    /**
     * Low level transform, not necessarily aware of platform
     * @param messages messages
     * @param interaction The LLM call options
     * @param outputClass Class of the output object
     * @param llmRequestEvent Event already published for this request if one has been
     */
    fun <O> doTransform(
        messages: List<Message>,
        interaction: LlmInteraction,
        outputClass: Class<O>,
        llmRequestEvent: LlmRequestEvent<O>?,
    ): O

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/OperationScheduler.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi

import com.embabel.agent.event.ActionExecutionStartEvent
import com.embabel.agent.event.ToolCallRequestEvent
import com.embabel.common.core.types.Timestamped
import java.time.Duration
import java.time.Instant

/**
 * When should an action run?
 */
sealed interface ActionExecutionSchedule : Timestamped

/**
 * No delay
 */
data class ProntoActionExecutionSchedule(
    override val timestamp: Instant = Instant.now(),
) : ActionExecutionSchedule

/**
 * Run after a given delay
 */
data class DelayedActionExecutionSchedule(
    val delay: Duration,
    override val timestamp: Instant = Instant.now(),
) : ActionExecutionSchedule

/**
 * Run at the given time in the future
 */
data class ScheduledActionExecutionSchedule(
    val till: Instant,
    override val timestamp: Instant = Instant.now(),
) : ActionExecutionSchedule


data class ToolCallSchedule(
    val delay: Duration = Duration.ZERO,
    override val timestamp: Instant = Instant.now(),
) : Timestamped


/**
 * Schedules operations for an AgentProcess.
 */
interface OperationScheduler {

    fun scheduleAction(
        actionExecutionStartEvent: ActionExecutionStartEvent,
    ): ActionExecutionSchedule

    fun scheduleToolCall(
        functionCallRequestEvent: ToolCallRequestEvent,
    ): ToolCallSchedule

    companion object {

        /**
         * No delay
         */
        val PRONTO: OperationScheduler = ProntoOperationScheduler
    }
}

private object ProntoOperationScheduler : OperationScheduler {

    override fun scheduleAction(actionExecutionStartEvent: ActionExecutionStartEvent): ActionExecutionSchedule =
        ProntoActionExecutionSchedule()

    override fun scheduleToolCall(functionCallRequestEvent: ToolCallRequestEvent): ToolCallSchedule =
        ToolCallSchedule()
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/PlannerFactory.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi

import com.embabel.agent.core.ProcessOptions
import com.embabel.plan.Plan
import com.embabel.plan.Planner
import com.embabel.plan.PlanningSystem
import com.embabel.plan.WorldState
import com.embabel.plan.goap.WorldStateDeterminer

/**
 * Pluggable planner factory
 */
fun interface PlannerFactory {

    fun createPlanner(
        processOptions: ProcessOptions,
        worldStateDeterminer: WorldStateDeterminer,
    ): Planner<out PlanningSystem, out WorldState, out Plan>
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/Ranker.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi

import com.embabel.common.core.types.*
import com.embabel.common.util.indent

/**
 * Rank available choices based on user input and agent metadata.
 * It's possible that no ranking will be high enough to progress with,
 * but that's a matter for the AgentPlatform using this service.
 */
interface Ranker {

    /**
     * Rank a set of items based on user input and agent metadata.
     * @param description Description of the item being ranked
     * @param userInput User input to rank against
     * @param rankables Set of items to rank
     */
    fun <T> rank(
        description: String,
        userInput: String,
        rankables: Collection<T>,
    ): Rankings<T> where T : Named, T : Described
}

/**
 * Rankings, sorted by score descending
 */
data class Rankings<T>(
    private val rankings: List<Ranking<T>>,
) : HasInfoString where T : Named, T : Described {

    fun rankings(): List<Ranking<T>> = rankings.sortedByDescending { it.score }

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String =
        rankings().joinToString("\n") { it.infoString(verbose, indent) }
}

/**
 * Ranking choice returned by the ranker
 * @param match The ranked item
 * @param score The confidence score of the ranker in this choice,
 * between 0 and 1
 */
data class Ranking<T>(
    override val match: T,
    override val score: ZeroToOne,
) : HasInfoString, SimilarityResult<T> where T : Named, T : Described {

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String {
        var s = "${match.name}: ${"%.2f".format(score)}"
        if (verbose == true) {
            s += " - ${match.description}"
        }
        return if (verbose == true) s.indent(indent) else s
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/ToolDecorator.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi

import com.embabel.agent.core.Action
import com.embabel.agent.core.AgentProcess
import com.embabel.common.ai.model.LlmOptions
import org.springframework.ai.tool.ToolCallback

/**
 * Decorate tools for use on the platform: for example, to time them and emit events.
 */
fun interface ToolDecorator {

    /**
     * Decorate the tool with some extra information.
     * @param tool The tool to decorate.
     * @param agentProcess The agent process that is using the tool.
     * @param action The action that resulted in the tool being called, if any.
     * @param llmOptions The LLM options that resulted in the tool being called.
     * @return The decorated tool.
     */
    fun decorate(
        tool: ToolCallback,
        agentProcess: AgentProcess,
        action: Action?,
        llmOptions: LlmOptions,
    ): ToolCallback
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/ToolGroupResolver.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi

import com.embabel.agent.core.ToolGroupMetadata
import com.embabel.agent.core.ToolGroupRequirement
import com.embabel.agent.core.ToolGroupResolution
import com.embabel.common.core.types.HasInfoString

interface ToolGroupResolver : HasInfoString {

    val name: String

    fun availableToolGroups(): List<ToolGroupMetadata>

    /**
     * Resolve tool group from the role
     */
    fun resolveToolGroup(requirement: ToolGroupRequirement): ToolGroupResolution

    fun findToolGroupForTool(toolName: String): ToolGroupResolution
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/config/spring/AgentPlatformConfiguration.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.config.spring

import com.embabel.agent.channel.DevNullOutputChannel
import com.embabel.agent.channel.OutputChannel
import com.embabel.agent.core.ToolGroup
import com.embabel.agent.event.AgenticEventListener
import com.embabel.agent.event.logging.LoggingAgenticEventListener
import com.embabel.agent.event.logging.personality.ColorPalette
import com.embabel.agent.event.logging.personality.DefaultColorPalette
import com.embabel.agent.spi.*
import com.embabel.agent.spi.support.*
import com.embabel.agent.spi.support.springai.DefaultToolDecorator
import com.embabel.common.ai.model.*
import com.embabel.common.core.MobyNameGenerator
import com.embabel.common.core.NameGenerator
import com.embabel.common.textio.template.JinjavaTemplateRenderer
import com.embabel.common.textio.template.TemplateRenderer
import com.embabel.common.util.StringTransformer
import com.embabel.common.util.loggerFor
import com.fasterxml.jackson.databind.ObjectMapper
import io.micrometer.observation.ObservationRegistry
import org.springframework.beans.factory.ObjectProvider
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.beans.factory.annotation.Qualifier
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean
import org.springframework.boot.context.properties.EnableConfigurationProperties
import org.springframework.context.ApplicationContext
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.context.annotation.Primary
import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder
import org.springframework.web.client.RestTemplate


/**
 * Core configuration for AgentPlatform
 */
@Configuration
@EnableConfigurationProperties(
    ConfigurableModelProviderProperties::class,
    AgentPlatformProperties::class,
    ProcessRepositoryProperties::class,
)
class AgentPlatformConfiguration(
) {

    /**
     * Used for process id generation
     */
    @Bean
    fun nameGenerator(): NameGenerator = MobyNameGenerator

    @Bean
    fun toolDecorator(
        toolGroupResolver: ToolGroupResolver,
        observationRegistry: ObjectProvider<ObservationRegistry>,
    ): ToolDecorator {
        loggerFor<AgentPlatformConfiguration>().info(
            "Creating default ToolDecorator with toolGroupResolver: {}, observationRegistry: {}",
            toolGroupResolver.infoString(verbose = false),
            observationRegistry,
        )
        return DefaultToolDecorator(
            toolGroupResolver = toolGroupResolver,
            observationRegistry = observationRegistry.getIfUnique { ObservationRegistry.NOOP },
            outputTransformer = StringTransformer(),
        )
    }

    @Bean
    fun templateRenderer(): TemplateRenderer = JinjavaTemplateRenderer()

    /**
     * Fallback if we don't have a more interesting logger
     */
    @Bean
    @ConditionalOnMissingBean(LoggingAgenticEventListener::class)
    fun defaultLogger(): LoggingAgenticEventListener = LoggingAgenticEventListener()

    @Bean
    @Primary
    fun eventListener(listeners: List<AgenticEventListener>): AgenticEventListener =
        AgenticEventListener.from(listeners)


    @Bean
    @ConditionalOnMissingBean(ColorPalette::class)
    fun defaultColorPalette(): ColorPalette = DefaultColorPalette()

    @Bean
    fun restTemplate() = RestTemplate()

    @Bean
    @ConditionalOnMissingBean(name = ["embabelJacksonObjectMapper"])
    fun embabelJacksonObjectMapper(builder: Jackson2ObjectMapperBuilder): ObjectMapper {
        return builder.createXmlMapper(false).build()
    }

    @Bean
    fun ranker(
        llmOperations: LlmOperations,
        rankingProperties: RankingProperties,
    ): Ranker = LlmRanker(
        llmOperations = llmOperations,
        rankingProperties = rankingProperties,
    )

    @Bean
    fun agentProcessRepository(
        processRepositoryProperties: ProcessRepositoryProperties,
    ): AgentProcessRepository = InMemoryAgentProcessRepository(processRepositoryProperties)

    @Bean
    fun contextRepository(
        contextRepositoryProperties: ContextRepositoryProperties,
    ): ContextRepository = InMemoryContextRepository(contextRepositoryProperties)

    @Bean
    fun toolGroupResolver(
        toolGroups: List<ToolGroup>,
        toolGroupProviders: List<List<ToolGroup>>,
    ): ToolGroupResolver {
        val allToolGroups = buildList {
            addAll(toolGroups)
            toolGroupProviders.forEach { addAll(it) }
        }
        return RegistryToolGroupResolver(
            name = "SpringBeansToolGroupResolver",
            allToolGroups
        )
    }

    /**
     * Gets registered as an event listener
     */
    @Bean
    fun toolsStats() = AgenticEventListenerToolsStats()

    @Bean
    fun actionScheduler(): OperationScheduler =
        ProcessOptionsOperationScheduler()

    /**
     * Create a `ModelProvider` bean named `"modelProvider"`.
     *
     * Collects all available `Llm` and `EmbeddingService` beans from the provided
     * [ApplicationContext] and constructs a [ConfigurableModelProvider] configured
     * with the supplied [ConfigurableModelProviderProperties].
     *
     * The parameters `dockerLocalModelsConfig` and `ollamaModelsConfig` are
     * optional markers used to trigger related auto-configuration when present;
     * they are not accessed directly by this method.
     *
     * @param applicationContext the Spring application context used to discover model beans
     * @param properties configuration properties for the model provider
     * @param dockerLocalModelsConfig optional marker bean for docker-local models auto-configuration
     * @param ollamaModelsConfig optional marker bean for Ollama models auto-configuration
     * @return a configured [ModelProvider] instance that exposes discovered LLMs and embedding services
     */
    @Bean(name = ["modelProvider"])
    fun modelProvider(
        applicationContext: ApplicationContext,
        properties: ConfigurableModelProviderProperties,
        @Autowired(required = false)
        @Qualifier("anthropicModelsConfig") anthropicModelsConfig: Any?,
        @Autowired(required = false)
        @Qualifier("dockerLocalModelsConfig") dockerLocalModelsConfig: Any?,
        @Autowired(required = false)
        @Qualifier("ollamaModelsConfig") ollamaModelsConfig: Any?,
    ): ModelProvider {

        return ConfigurableModelProvider(
            llms = applicationContext.getBeansOfType(Llm::class.java).values.toList(),
            embeddingServices = applicationContext.getBeansOfType(EmbeddingService::class.java).values.toList(),
            properties = properties,
        )
    }

    @Bean
    fun autoLlmSelectionCriteriaResolver(
    ): AutoLlmSelectionCriteriaResolver = AutoLlmSelectionCriteriaResolver.DEFAULT

    @Bean
    fun outputChannel(): OutputChannel {
        return DevNullOutputChannel
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/config/spring/AgentPlatformProperties.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.config.spring

import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.boot.context.properties.NestedConfigurationProperty

/**
 * Unified configuration for all agent platform properties.
 *
 * These properties control internal platform behavior and are rarely customized by users.
 * Platform properties are segregated from application properties to clearly separate
 * framework internals from business logic configuration.
 *
 * @since 1.x
 */
@ConfigurationProperties("embabel.agent.platform")
class AgentPlatformProperties {
    /**
     * Core platform identity name
     */
    var name: String = "embabel-default"

    /**
     * Platform description
     */
    var description: String = "Embabel Default Agent Platform"
    var processType: ProcessType = ProcessType.SIMPLE

    /**
     * Platform behavior configurations
     */
    @field:NestedConfigurationProperty
    var scanning: ScanningConfig = ScanningConfig()

    @field:NestedConfigurationProperty
    var ranking: RankingConfig = RankingConfig()

    @field:NestedConfigurationProperty
    var llmOperations: LlmOperationsConfig = LlmOperationsConfig()

    @field:NestedConfigurationProperty
    var processIdGeneration: ProcessIdGenerationConfig = ProcessIdGenerationConfig()

    @field:NestedConfigurationProperty
    var autonomy: AutonomyConfig = AutonomyConfig()

    @field:NestedConfigurationProperty
    var models: ModelsConfig = ModelsConfig()

    @field:NestedConfigurationProperty
    var sse: SseConfig = SseConfig()

    @field:NestedConfigurationProperty
    var test: TestConfig = TestConfig()

    /**
     * Agent Process Type
     */
    enum class ProcessType {
        SIMPLE,
        CONCURRENT
    }

    /**
     * Agent scanning configuration
     */
    class ScanningConfig {
        /**
         *  Whether to auto register beans with @Agent and @Agentic annotation
         */
        var annotation: Boolean = true

        /**
         * Whether to auto register as agents Spring beans of type Agent
         */
        var bean: Boolean = false
    }

    /**
     * Ranking configuration with retry logic
     */
    class RankingConfig {
        /**
         * Name of the LLM to use for ranking, or null to use auto selection
         */
        var llm: String? = null

        /**
         * Maximum number of attempts to retry ranking
         */
        var maxAttempts: Int = 5

        /**
         * Initial backoff time in milliseconds
         */
        var backoffMillis: Long = 100L

        /**
         * Multiplier for backoff time
         */
        var backoffMultiplier: Double = 5.0

        /**
         * Maximum backoff time in milliseconds
         */
        var backoffMaxInterval: Long = 180000L
    }

    /**
     * LLM operations configuration
     */
    @ConfigurationProperties(prefix = "embabel.agent.platform.llm-operations")
    class LlmOperationsConfig {
        @field:NestedConfigurationProperty
        var prompts: PromptsConfig = PromptsConfig()

        @field:NestedConfigurationProperty
        var dataBinding: DataBindingConfig = DataBindingConfig()

        /**
         * Prompt configuration
         */
        class PromptsConfig {
            /**
             * Template for "maybe" prompt, enabling failure result when LLM lacks information
             */
            var maybePromptTemplate: String = "maybe_prompt_contribution"

            /**
             * Whether to generate examples by default
             */
            var generateExamplesByDefault: Boolean = true
        }

        /**
         * Data binding retry configuration
         */
        class DataBindingConfig {
            /**
             * Maximum retry attempts for data binding
             */
            var maxAttempts: Int = 10

            /**
             * Fixed backoff time in milliseconds between retries
             */
            var fixedBackoffMillis: Long = 30L
        }
    }

    /**
     * Process ID generation configuration
     */
    @ConfigurationProperties("embabel.agent.platform.process-id-generation")
    class ProcessIdGenerationConfig {
        /**
         * Whether to include version in process ID generation
         */
        var includeVersion: Boolean = false

        /**
         * Whether to include agent name in process ID generation
         */
        var includeAgentName: Boolean = false
    }

    /**
     * Autonomy thresholds configuration
     */
    @ConfigurationProperties("embabel.agent.platform.autonomy")
    class AutonomyConfig {
        /**
         * Confidence threshold for agent operations
         */
        var agentConfidenceCutOff: Double = 0.6

        /**
         * Confidence threshold for goal achievement
         */
        var goalConfidenceCutOff: Double = 0.6
    }

    /**
     * Model provider integration configurations
     */
    @ConfigurationProperties("embabel.agent.platform.models")
    class ModelsConfig {
        @field:NestedConfigurationProperty
        var anthropic: AnthropicConfig = AnthropicConfig()

        @field:NestedConfigurationProperty
        var openai: OpenAiConfig = OpenAiConfig()

        /**
         * Anthropic provider retry configuration
         */
        class AnthropicConfig {
            /**
             * Maximum retry attempts
             */
            var maxAttempts: Int = 10

            /**
             * Initial backoff time in milliseconds
             */
            var backoffMillis: Long = 5000L

            /**
             * Backoff multiplier
             */
            var backoffMultiplier: Double = 5.0

            /**
             * Maximum backoff interval in milliseconds
             */
            var backoffMaxInterval: Long = 180000L
        }

        /**
         * OpenAI provider retry configuration
         */
        class OpenAiConfig {
            /**
             * Maximum retry attempts
             */
            var maxAttempts: Int = 10

            /**
             * Initial backoff time in milliseconds
             */
            var backoffMillis: Long = 5000L

            /**
             * Backoff multiplier
             */
            var backoffMultiplier: Double = 5.0

            /**
             * Maximum backoff interval in milliseconds
             */
            var backoffMaxInterval: Long = 180000L
        }
    }

    /**
     * Server-sent events configuration
     */
    @ConfigurationProperties("embabel.agent.platform.sse")
    class SseConfig {
        /**
         * Maximum buffer size for SSE
         */
        var maxBufferSize: Int = 100

        /**
         * Maximum number of process buffers
         */
        var maxProcessBuffers: Int = 1000
    }

    /**
     * Test configuration
     */
    @ConfigurationProperties("embabel.agent.platform.test")
    class TestConfig {
        /**
         * Whether to enable mock mode for testing
         */
        var mockMode: Boolean = true
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/config/spring/AgentPlatformPropertiesLoader.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.config.spring

import org.slf4j.LoggerFactory
import org.springframework.context.annotation.Configuration
import org.springframework.context.annotation.PropertySource
import org.springframework.core.Ordered
import org.springframework.core.annotation.Order
import jakarta.annotation.PostConstruct

/**
 * Loads agent platform properties into Spring's Environment for library-wide availability.
 *
 * This configuration class uses pure Spring Framework features (@PropertySource, @Order)
 * to ensure compatibility with both Spring Boot and pure Spring applications.
 *
 * ## Design Rationale
 *
 * ### Library-Friendly Approach
 * - **@PropertySource**: Core Spring Framework feature (since 3.1) - works in any Spring environment
 * - **@Order(HIGHEST_PRECEDENCE)**: Ensures properties are loaded before other @Configuration classes
 * - **No Spring Boot dependencies**: Works with Spring WebMVC, WebFlux, standalone contexts
 *
 * ### Processing Order Guarantee
 * ```
 * 1. AgentPlatformPropertiesLoader processes first → Properties loaded into Environment
 * 2. Other @Configuration classes process → Properties available for @ConfigurationProperties binding
 * 3. @ConfigurationProperties beans created → Automatic property binding occurs
 * ```
 *
 * ### Property Binding Flow
 * - **agent-platform.properties** → Spring Environment → **@ConfigurationProperties classes**
 * - Enables: AnthropicProperties, OpenAiProperties, AgentPlatformProperties, Migration system configs
 *
 * ## Usage Impact
 *
 * After this loader is active:
 * - **AnthropicProperties**: Will bind from `embabel.agent.platform.models.anthropic.*` (no longer defaults)
 * - **OpenAiProperties**: Will bind from `embabel.agent.platform.models.openai.*` (no longer defaults)
 * - **Migration system**: Properties will be loaded for conditional bean creation
 * - **AgentPlatformProperties**: Will bind actual values instead of being dormant
 *
 * @since 1.x
 */
@Configuration
@PropertySource("classpath:agent-platform.properties", "classpath:agent-application.properties")
@Order(Ordered.HIGHEST_PRECEDENCE)
class AgentPlatformPropertiesLoader {

    private val logger = LoggerFactory.getLogger(AgentPlatformPropertiesLoader::class.java)

    @PostConstruct
    fun init() {
        logger.info("Agent platform properties loaded from classpath:agent-platform.properties and embabel-agent-properties")
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/config/spring/AsyncConfiguration.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.config.spring

import com.embabel.agent.api.common.Asyncer
import com.embabel.agent.spi.support.ExecutorAsyncer
import org.springframework.beans.factory.annotation.Qualifier
import org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import java.util.concurrent.Executor

@Configuration
class AsyncConfiguration {

    @Bean
    fun asyncer(
        @Qualifier(TaskExecutionAutoConfiguration.APPLICATION_TASK_EXECUTOR_BEAN_NAME)
        executor: Executor,
    ): Asyncer {
        return ExecutorAsyncer(executor)
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/config/spring/ContextRepositoryProperties.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.config.spring

import org.springframework.boot.context.properties.ConfigurationProperties

/**
 * Configuration properties for the agent process repository.
 */
@ConfigurationProperties("embabel.agent.platform.context-repository")
class ContextRepositoryProperties {
    /**
     * Maximum number of contexts to keep in memory.
     * When this limit is exceeded, the oldest processes will be evicted.
     * Default is 1000.
     */
    var windowSize: Int = 1000

    companion object {
        operator fun invoke(windowSize: Int): ContextRepositoryProperties =
            ContextRepositoryProperties().apply { this.windowSize = windowSize }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/config/spring/InfrastructureInjectionConfiguration.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.config.spring

import com.embabel.agent.api.common.Ai
import com.embabel.agent.api.common.AiBuilder
import com.embabel.agent.api.common.ExecutingOperationContext
import com.embabel.agent.api.dsl.agent
import com.embabel.agent.core.AgentPlatform
import com.embabel.agent.core.ProcessOptions
import com.embabel.agent.core.Verbosity
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.context.annotation.Scope

/**
 * Support injection of [ExecutingOperationContext] and [Ai] into beans.
 *
 */
@Configuration
class InfrastructureInjectionConfiguration {

    @Bean
    @Scope("prototype")
    fun executingOperationContextFactory(agentPlatform: AgentPlatform): ExecutingOperationContext {
        return createExecutingOperationContext(agentPlatform, ProcessOptions())
    }

    @Bean
    @Scope("prototype")
    fun aiFactory(agentPlatform: AgentPlatform): Ai {
        return createExecutingOperationContext(agentPlatform, ProcessOptions()).ai()
    }

    @Bean
    @Scope("prototype")
    fun aiBuilderFactory(agentPlatform: AgentPlatform): AiBuilder {
        return AiBuilderImpl(agentPlatform, ProcessOptions(verbosity = Verbosity(debug = true)))
    }

}

private fun createExecutingOperationContext(
    agentPlatform: AgentPlatform,
    processOptions: ProcessOptions,
): ExecutingOperationContext {
    val callingClassName = findFirstUserClass()
    val agentForIdOnly = agent(
        name = callingClassName,
        description = "Empty agent for operation context injection into $callingClassName",
    ) {
        // No actions, just a placeholder
    }
    return ExecutingOperationContext(
        name = callingClassName,
        agentProcess = agentPlatform.createAgentProcess(
            agentForIdOnly,
            processOptions = processOptions,
            bindings = emptyMap(),
        ),
    )
}

private fun findFirstUserClass(): String {
    val stackTrace = Thread.currentThread().stackTrace

    return stackTrace
        .firstOrNull { element ->
            element.className.startsWith("com.embabel.agent") &&
                    !element.className.contains("$") && // Avoid inner classes
                    !element.methodName.contains("<init>") // Avoid constructor calls from Spring
        }
        ?.className
        ?.substringAfterLast(".")
        ?: "Unknown"
}

private data class AiBuilderImpl(
    val agentPlatform: AgentPlatform,
    val processOptions: ProcessOptions,
) : AiBuilder {

    override fun withProcessOptions(options: ProcessOptions): AiBuilder =
        copy(processOptions = options)

    override val showPrompts: Boolean
        get() = processOptions.verbosity.showPrompts

    override val showLlmResponses: Boolean
        get() = processOptions.verbosity.showLlmResponses

    override fun ai(): Ai = createExecutingOperationContext(agentPlatform, processOptions).ai()

    override fun withShowPrompts(show: Boolean): AiBuilder =
        copy(processOptions = processOptions.copy(verbosity = processOptions.verbosity.copy(showPrompts = show)))

    override fun withShowLlmResponses(show: Boolean): AiBuilder =
        copy(processOptions = processOptions.copy(verbosity = processOptions.verbosity.copy(showLlmResponses = show)))
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/config/spring/ProcessRepositoryProperties.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.config.spring

import org.springframework.boot.context.properties.ConfigurationProperties

/**
 * Configuration properties for the agent process repository.
 */
@ConfigurationProperties("embabel.agent.platform.process-repository")
class ProcessRepositoryProperties {
    /**
     * Maximum number of agent processes to keep in memory.
     * When this limit is exceeded, the oldest processes will be evicted.
     * Default is 1000.
     */
    var windowSize: Int = 1000

    companion object {
        operator fun invoke(windowSize: Int): ProcessRepositoryProperties {
            return ProcessRepositoryProperties().apply {
                this.windowSize = windowSize
            }
        }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/config/spring/ToolGroupsConfiguration.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.config.spring


import com.embabel.agent.common.Constants.EMBABEL_PROVIDER
import com.embabel.agent.core.CoreToolGroups
import com.embabel.agent.core.ToolGroup
import com.embabel.agent.core.ToolGroupDescription
import com.embabel.agent.core.ToolGroupPermission
import com.embabel.agent.tools.math.MathTools
import com.embabel.agent.tools.mcp.McpToolGroup
import com.embabel.common.core.types.Semver
import io.modelcontextprotocol.client.McpSyncClient
import org.slf4j.LoggerFactory
import org.springframework.ai.tool.ToolCallback
import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.boot.context.properties.EnableConfigurationProperties
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

data class GroupConfig(
    val description: String? = null,
    val provider: String = EMBABEL_PROVIDER,
    val tools: Set<String> = emptySet(),
) {

    fun include(tool: ToolCallback): Boolean {
        return tools.any { exclude -> tool.toolDefinition.name().endsWith(exclude) }
    }
}

/**
 * Configuration for ToolGroups when MCP is available
 */
@ConfigurationProperties(prefix = "embabel.agent.platform.tools")
class ToolGroupsProperties {
    /**
     * Map of tool group names to list of tool names to include
     */
    var includes: Map<String, GroupConfig> = emptyMap()

    /**
     * List of tool names to exclude from all tool groups
     */
    var excludes: List<String> = emptyList()

    /**
     * The version of tool groups
     */
    var version: String = Semver().value
}

@Configuration
@EnableConfigurationProperties(
    ToolGroupsProperties::class,
)
class ToolGroupsConfiguration(
    private val mcpSyncClients: List<McpSyncClient>,
    private val properties: ToolGroupsProperties,
) {

    private val logger = LoggerFactory.getLogger(ToolGroupsConfiguration::class.java)

    init {
        logger.info(
            "MCP is available. Found {} clients: {}",
            mcpSyncClients.size,
            mcpSyncClients.map { it.serverInfo }.joinToString("\n"),
        )
    }

    @Bean
    fun includedToolGroups(): List<ToolGroup> {
        val groups = properties.includes.map { (role, gid) ->
            logger.info("Exposing tool group {}", role)
            toToolGroup(role, gid)
        }
        return groups
    }

    @Bean
    fun mathToolGroup() = MathTools()

    private fun toToolGroup(
        role: String,
        gid: GroupConfig,
    ): ToolGroup {
        return McpToolGroup(
            description = ToolGroupDescription(description = gid.description ?: role, role = role),
            name = role,
            provider = gid.provider,
            permissions = setOf(
                ToolGroupPermission.INTERNET_ACCESS
            ),
            clients = mcpSyncClients,
            filter = { tool ->
                val included = gid.tools.any { gid.include(tool) }
                logger.debug(
                    "Tool '{}' included in group {}={} - [{}]", tool.toolDefinition.name(), role, included,
                    gid.tools.joinToString(", ") { t -> "'$t'" }
                )
                included
            }
        )
    }

    @Bean
    fun mcpWebToolsGroup(): ToolGroup {
        val wikipediaTools = setOf(
            "get_related_topics",
            "get_summary",
            "get_article",
            "search_wikipedia",
        )
        return McpToolGroup(
            description = CoreToolGroups.WEB_DESCRIPTION,
            name = "docker-web",
            provider = "Docker",
            permissions = setOf(
                ToolGroupPermission.INTERNET_ACCESS
            ),
            clients = mcpSyncClients,
            filter = {
                // Brave local search is aggressively rate limited, so
                // don't use it for now
                (it.toolDefinition.name().contains("brave") || it.toolDefinition.name().contains("fetch") ||
                        wikipediaTools.any { wt -> it.toolDefinition.name().contains(wt) }) &&
                        !(it.toolDefinition.name().contains("brave_local_search"))
            },
        )
    }

    @Bean
    fun mapsToolsGroup(): ToolGroup {
        return McpToolGroup(
            description = CoreToolGroups.MAPS_DESCRIPTION,
            name = "docker-google-maps",
            provider = "Docker",
            permissions = setOf(
                ToolGroupPermission.INTERNET_ACCESS
            ),
            clients = mcpSyncClients,
            filter = {
                it.toolDefinition.name().contains("maps_")
            }
        )
    }

    @Bean
    fun browserAutomationWebToolsGroup(): ToolGroup {
        return McpToolGroup(
            description = CoreToolGroups.BROWSER_AUTOMATION_DESCRIPTION,
            name = "docker-puppeteer",
            provider = "Docker",
            permissions = setOf(
                ToolGroupPermission.INTERNET_ACCESS
            ),
            clients = mcpSyncClients,
            filter = { it.toolDefinition.name().contains("puppeteer") },
        )
    }

    // TODO this is nasty. Should replace when we have genuine metadata from Docker MCP hub
    private val GitHubTools = listOf(
        "add_issue_comment",
        "create_issue",
        "list_issues",
        "get_issue",
        "list_pull_requests",
        "get_pull_request",
    )

    @Bean
    fun githubToolsGroup(): ToolGroup {
        return McpToolGroup(
            description = CoreToolGroups.GITHUB_DESCRIPTION,
            name = "docker-github",
            provider = "Docker",
            permissions = setOf(
                ToolGroupPermission.INTERNET_ACCESS
            ),
            clients = mcpSyncClients,
            filter = {
                GitHubTools.any { ght ->
                    it.toolDefinition.name().contains(ght)
                }
            },
        )
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/config/spring/ValidationConfiguration.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.config.spring

import com.embabel.agent.spi.validation.DefaultValidationPromptGenerator
import com.embabel.agent.spi.validation.ValidationPromptGenerator
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean


@Configuration
class ValidationConfiguration {

    @Bean
    fun validator(): LocalValidatorFactoryBean {
        return LocalValidatorFactoryBean()
    }

    @Bean
    fun validationPromptGenerator(): ValidationPromptGenerator =
        DefaultValidationPromptGenerator()
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/config/spring/migration/DeprecatedPropertyScanner.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.config.spring.migration

import jakarta.annotation.PostConstruct
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.ObjectProvider
import org.springframework.beans.factory.SmartInitializingSingleton
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.context.annotation.Conditional
import org.springframework.core.env.Environment
import org.springframework.core.io.Resource
import org.springframework.core.io.support.PathMatchingResourcePatternResolver
import org.springframework.core.type.AnnotationMetadata
import org.springframework.core.type.classreading.CachingMetadataReaderFactory
import org.springframework.core.type.classreading.MetadataReader
import org.springframework.stereotype.Component
import java.util.regex.Pattern

/**
 * Scans for deprecated @ConditionalOnProperty and @ConfigurationProperties annotations during application startup.
 *
 * This component analyzes classes in configured packages to detect usage of deprecated
 * properties in @ConditionalOnProperty and @ConfigurationProperties annotations,
 * issuing warnings through the SimpleDeprecatedConfigWarner.
 * Uses SmartInitializingSingleton to ensure all beans are fully available before scanning.
 *
 * ## Conditional Bean Loading Scenarios
 *
 * This scanner works with conditionally loaded beans based on migration configuration:
 *
 * ### **Scenario 1: Iteration 0 Default (Scanning Disabled)**
 * ```properties
 * # Default behavior - no scanning property set
 * # embabel.agent.platform.migration.scanning.enabled=false (implicit)
 * embabel.agent.platform.migration.warnings.enabled=true (default via matchIfMissing=true)
 * ```
 * **Bean State**: `scanningConfig = null`, `propertyWarner = available`
 * **Behavior**: Scanner logs "scanning disabled", no package scanning occurs
 * **Use Case**: Iteration 0 production - warnings work, scanning deferred to Iteration 1
 *
 * ### **Scenario 2: Warnings Explicitly Disabled**
 * ```properties
 * embabel.agent.platform.migration.warnings.enabled=false
 * embabel.agent.platform.migration.scanning.enabled=false
 * ```
 * **Bean State**: `scanningConfig = null`, `propertyWarner = null`
 * **Behavior**: Scanner logs "migration system completely disabled"
 * **Use Case**: Production environments that want to disable all migration detection
 *
 * ### **Scenario 3: Full Migration Detection (Iteration 1+)**
 * ```properties
 * embabel.agent.platform.migration.warnings.enabled=true
 * embabel.agent.platform.migration.scanning.enabled=true
 * ```
 * **Bean State**: `scanningConfig = available`, `propertyWarner = available`
 * **Behavior**: Full package scanning with conditional annotation detection
 * **Use Case**: Iteration 1+ production - complete migration detection system active
 *
 * ### **Scenario 4: Warnings Only (Partial Detection)**
 * ```properties
 * embabel.agent.platform.migration.warnings.enabled=true
 * # embabel.agent.platform.migration.scanning.enabled=false (default)
 * ```
 * **Bean State**: `scanningConfig = null`, `propertyWarner = available`
 * **Behavior**: Property warnings work, but no @ConditionalOnProperty scanning
 * **Use Case**: Users want property warnings but not bytecode scanning overhead
 *
 * ## Rule Invocation Flow (When Fully Enabled)
 *
 * The migration rules are automatically invoked during Spring application startup
 * whenever deprecated conditional properties are detected in scanned classes:
 *
 * **Example Scenarios**:
 *
 * **@ConditionalOnProperty Detection:**
 * - **Scenario A**: Direct Property - `@ConditionalOnProperty("embabel.anthropic.max-attempts")`
 * - **Scenario B**: Prefix + Name - `@ConditionalOnProperty(name = "max-attempts", prefix = "embabel.anthropic")`
 * - **Scenario C**: Prefix Only - `@ConditionalOnProperty(prefix = "embabel.autonomy")`
 *
 * **@ConfigurationProperties Detection:**
 * - **Scenario D**: Deprecated Prefix - `@ConfigurationProperties(prefix = "embabel.autonomy")`
 * - **Scenario E**: Legacy Platform - `@ConfigurationProperties("embabel.agent-platform.ranking")`
 *
 * 1. **Spring startup** → `afterSingletonsInstantiated()` called after all beans initialized
 * 2. **Bean availability check** → Verifies both scanning config and property warner are available
 * 3. **Package scanning** → Finds classes in configured include packages (internal + external)
 * 4. **Annotation detection** → Finds `@ConditionalOnProperty` and `@ConfigurationProperties` annotations on classes
 * 5. **Property extraction** → Extracts property names from all annotation patterns:
 *    - **@ConditionalOnProperty Direct**: `"embabel.anthropic.max-attempts"`
 *    - **@ConditionalOnProperty Prefix+Name**: Combines to `"embabel.anthropic.max-attempts"`
 *    - **@ConditionalOnProperty Prefix-Only**: `"embabel.autonomy"`
 *    - **@ConfigurationProperties Prefix**: `"embabel.autonomy"`
 * 6. **Deprecation check** → `isDeprecatedProperty()` returns `true` for all deprecated patterns
 * 7. **Warning generation** → `getRecommendedProperty()` called with deprecated property name
 * 8. **Transformation** → Explicit mapping lookup returns new property name
 * 9. **Warning issued** → Logger warns about deprecated usage with recommended replacement property
 *
 * @see PropertyMigrationRule for rule definition structure
 * @see DeprecatedPropertyScanningConfig for scanning configuration options
 * @see SimpleDeprecatedConfigWarner for warning output format
 */
@Component
@ConditionalOnProperty(
    name = ["embabel.agent.platform.migration.scanning.enabled"],
    havingValue = "true",
    matchIfMissing = false
)
class DeprecatedPropertyScanner(
    private val scanningConfigProvider: ObjectProvider<DeprecatedPropertyScanningConfig>,
    private val propertyWarnerProvider: ObjectProvider<SimpleDeprecatedConfigWarner>,
    private val environment: Environment,
) : SmartInitializingSingleton {

    private val resourceResolver = PathMatchingResourcePatternResolver()
    private val metadataReaderFactory = CachingMetadataReaderFactory()

    @PostConstruct
    fun init() {
        logger.info("Deprecated property scanner initialized (warnings system active)")
    }

    /**
     * Performs conditional property scanning after all singletons are initialized.
     */
    override fun afterSingletonsInstantiated() {
        logger.debug("afterSingletonsInstantiated() called")
        val scanningConfig = scanningConfigProvider.getIfAvailable()
        val propertyWarner = propertyWarnerProvider.getIfAvailable()
        logger.debug("scanningConfig available: ${scanningConfig != null}, propertyWarner available: ${propertyWarner != null}")

        when {
            scanningConfig == null && propertyWarner == null ->
                logger.debug("Migration system completely disabled - both scanning config and property warner unavailable")

            scanningConfig == null ->
                logger.debug("DeprecatedPropertyScanningConfig not available - scanning disabled (Scenario 1/4: Iteration 0 default or warnings-only mode)")

            propertyWarner == null ->
                logger.debug("SimpleDeprecatedConfigWarner not available - cannot issue warnings (Scenario 2: Migration system disabled)")

            !scanningConfig.enabled ->
                logger.debug("Conditional property scanning explicitly disabled via embabel.agent.platform.migration.scanning.enabled=false")

            else -> {
                logger.info("All migration components available - starting conditional property scanning (Scenario 3: Full detection active)")
                doScanning(scanningConfig, propertyWarner)
                scanEnvironmentPropertyUsage(propertyWarner)
            }
        }
    }

    /**
     * Property migration rules with simple runtime extensibility.
     * Uses explicit mappings for predictable, safe migrations.
     */
    private val propertyMigrationRules = mutableListOf<PropertyMigrationRule>()

    /**
     * Explicit property mappings for all known migrations.
     * Simple, predictable, and safe approach without regex complexity.
     *
     * ## Production Classes Requiring Migration (NOT YET REPLACED)
     *
     * The following @ConfigurationProperties classes still use deprecated prefixes
     * and should be migrated in future iterations:
     *
     * ### System Properties Classes (5 classes):
     * - **LlmDataBindingProperties** (`embabel.llm-operations.data-binding` → `embabel.agent.platform.llm-operations.data-binding`)
     *   Location: /src/main/kotlin/com/embabel/agent/spi/support/LlmDataBindingProperties.kt
     *
     * - **LlmOperationsPromptsProperties** (`embabel.llm-operations.prompts` → `embabel.agent.platform.llm-operations.prompts`)
     *   Location: /src/main/kotlin/com/embabel/agent/spi/support/springai/ChatClientLlmOperations.kt
     *
     * - **AutonomyProperties** (`embabel.autonomy` → `embabel.agent.platform.autonomy`)
     *   Location: /src/main/kotlin/com/embabel/agent/api/common/autonomy/Autonomy.kt
     *
     * - **SseProperties** (`embabel.sse` → `embabel.agent.platform.sse`)
     *   Location: /src/main/kotlin/com/embabel/agent/web/sse/SseController.kt
     *
     * - **DefaultProcessIdGeneratorProperties** (`embabel.process-id-generation` → `embabel.agent.platform.process-id-generation`)
     *   Location: /src/main/kotlin/com/embabel/agent/spi/support/DefaultAgentProcessIdGenerator.kt
     *
     * ### Legacy Platform Classes (2 classes):
     * - **RankingProperties** (`embabel.agent-platform.ranking` → `embabel.agent.platform.ranking`)
     *   Location: /src/main/kotlin/com/embabel/agent/spi/support/LlmRanker.kt
     *
     * - **AgentScanningProperties** (`embabel.agent-platform.scanning` → `embabel.agent.platform.scanning`)
     *   Location: /src/main/kotlin/com/embabel/agent/core/deployment/AgentScanningProperties.kt
     *
     * **Migration Coverage**: 7 of 14 production classes (50%) still need prefix updates
     * **Detection Coverage**: 100% - All deprecated usage will be detected and warned about
     */
    private val exactPropertyMappings = buildMap<String, String> {
        // Platform namespace consolidation (embabel.agent-platform.* → embabel.agent.platform.*)
        put("embabel.agent-platform.ranking.max-attempts", "embabel.agent.platform.ranking.max-attempts")
        put("embabel.agent-platform.ranking.backoff-millis", "embabel.agent.platform.ranking.backoff-millis")
        put("embabel.agent-platform.ranking.backoff-multiplier", "embabel.agent.platform.ranking.backoff-multiplier")
        put(
            "embabel.agent-platform.ranking.backoff-max-interval",
            "embabel.agent.platform.ranking.backoff-max-interval"
        )
        put(
            "embabel.agent-platform.llm-operations.prompts.template",
            "embabel.agent.platform.llm-operations.prompts.template"
        )
        put(
            "embabel.agent-platform.llm-operations.data-binding.max-attempts",
            "embabel.agent.platform.llm-operations.data-binding.max-attempts"
        )
        put(
            "embabel.agent-platform.llm-operations.data-binding.fixed-backoff-millis",
            "embabel.agent.platform.llm-operations.data-binding.fixed-backoff-millis"
        )
        put(
            "embabel.agent-platform.autonomy.agent-confidence-cut-off",
            "embabel.agent.platform.autonomy.agent-confidence-cut-off"
        )
        put(
            "embabel.agent-platform.autonomy.goal-confidence-cut-off",
            "embabel.agent.platform.autonomy.goal-confidence-cut-off"
        )
        put(
            "embabel.agent-platform.process-id-generation.include-version",
            "embabel.agent.platform.process-id-generation.include-version"
        )
        put(
            "embabel.agent-platform.process-id-generation.include-agent-name",
            "embabel.agent.platform.process-id-generation.include-agent-name"
        )

        // System properties consolidation (embabel.COMPONENT.* → embabel.agent.platform.COMPONENT.*)
        put(
            "embabel.llm-operations.data-binding.max-attempts",
            "embabel.agent.platform.llm-operations.data-binding.max-attempts"
        )
        put(
            "embabel.llm-operations.data-binding.fixed-backoff-millis",
            "embabel.agent.platform.llm-operations.data-binding.fixed-backoff-millis"
        )
        put("embabel.llm-operations.prompts.template", "embabel.agent.platform.llm-operations.prompts.template")
        put(
            "embabel.llm-operations.prompts.maybe-prompt-template",
            "embabel.agent.platform.llm-operations.prompts.maybe-prompt-template"
        )
        put(
            "embabel.llm-operations.prompts.generate-examples-by-default",
            "embabel.agent.platform.llm-operations.prompts.generate-examples-by-default"
        )
        put(
            "embabel.llm-operations.prompts.default-timeout",
            "embabel.agent.platform.llm-operations.prompts.default-timeout"
        )
        put("embabel.autonomy.agent-confidence-cut-off", "embabel.agent.platform.autonomy.agent-confidence-cut-off")
        put("embabel.autonomy.goal-confidence-cut-off", "embabel.agent.platform.autonomy.goal-confidence-cut-off")
        put("embabel.sse.max-buffer-size", "embabel.agent.platform.sse.max-buffer-size")
        put("embabel.sse.max-process-buffers", "embabel.agent.platform.sse.max-process-buffers")
        put(
            "embabel.process-id-generation.include-version",
            "embabel.agent.platform.process-id-generation.include-version"
        )
        put(
            "embabel.process-id-generation.include-agent-name",
            "embabel.agent.platform.process-id-generation.include-agent-name"
        )

        // Model provider configurations (embabel.PROVIDER.* → embabel.agent.platform.models.PROVIDER.*)
        put("embabel.anthropic.max-attempts", "embabel.agent.platform.models.anthropic.max-attempts")
        put("embabel.anthropic.backoff-millis", "embabel.agent.platform.models.anthropic.backoff-millis")
        put("embabel.anthropic.backoff-multiplier", "embabel.agent.platform.models.anthropic.backoff-multiplier")
        put("embabel.anthropic.backoff-max-interval", "embabel.agent.platform.models.anthropic.backoff-max-interval")
        put("embabel.openai.max-attempts", "embabel.agent.platform.models.openai.max-attempts")
        put("embabel.openai.backoff-millis", "embabel.agent.platform.models.openai.backoff-millis")
        put("embabel.openai.backoff-multiplier", "embabel.agent.platform.models.openai.backoff-multiplier")
        put("embabel.openai.backoff-max-interval", "embabel.agent.platform.models.openai.backoff-max-interval")
        put("embabel.docker.models.max-attempts", "embabel.agent.platform.models.docker.max-attempts")
        put("embabel.docker.models.backoff-millis", "embabel.agent.platform.models.docker.backoff-millis")
        put("embabel.docker.models.backoff-multiplier", "embabel.agent.platform.models.docker.backoff-multiplier")
        put("embabel.docker.models.backoff-max-interval", "embabel.agent.platform.models.docker.backoff-max-interval")
        put("embabel.docker.models.base-url", "embabel.agent.models.docker.base-url")
        put("embabel.models.bedrock.models.name", "embabel.agent.models.bedrock.models.name")
        put("embabel.models.bedrock.models.knowledge-cutoff", "embabel.agent.models.bedrock.models.knowledge-cutoff")
        put("embabel.models.bedrock.models.input-price", "embabel.agent.models.bedrock.models.input-price")
        put("embabel.models.bedrock.models.output-price", "embabel.agent.models.bedrock.models.output-price")

        // Discord configurations
        put("embabel.discord.token", "embabel.agent.discord.token")

        // Shell configurations
        put("embabel.shell.line-length", "embabel.agent.shell.line-length")
        put("embabel.shell.chat.bind-conversation", "embabel.agent.shell.chat.bind-conversation")
        put("embabel.shell.chat.model", "embabel.agent.shell.chat.model")
        put("embabel.shell.chat.confirm-goals", "embabel.agent.shell.chat.confirm-goals")
        put("embabel.shell.chat.multi-goal", "embabel.agent.shell.chat.multi-goal")
        put("embabel.shell.chat.temperature", "embabel.agent.shell.chat.temperature")

        // Specific platform feature migrations
        put("embabel.agent.enable-scanning", "embabel.agent.platform.scanning.annotation")
        put("embabel.agent.mock-mode", "embabel.agent.platform.test.mock-mode")
        put("embabel.agent.sse.max-buffer-size", "embabel.agent.platform.sse.max-buffer-size")
        put("embabel.agent.sse.max-process-buffers", "embabel.agent.platform.sse.max-process-buffers")

        // @ConfigurationProperties prefix migrations
        put("embabel.anthropic", "embabel.agent.platform.models.anthropic")
        put("embabel.openai", "embabel.agent.platform.models.openai")
        put("embabel.docker.models", "embabel.agent.platform.models.docker")
        put("embabel.models.bedrock", "embabel.agent.models.bedrock")
        put("embabel.llm-operations", "embabel.agent.platform.llm-operations")
        put("embabel.llm-operations.data-binding", "embabel.agent.platform.llm-operations.data-binding")
        put("embabel.llm-operations.prompts", "embabel.agent.platform.llm-operations.prompts")
        put("embabel.autonomy", "embabel.agent.platform.autonomy")
        put("embabel.sse", "embabel.agent.platform.sse")
        put("embabel.process-id-generation", "embabel.agent.platform.process-id-generation")
        put("embabel.agent-platform.ranking", "embabel.agent.platform.ranking")
        put("embabel.agent-platform.scanning", "embabel.agent.platform.scanning")
        put("embabel.shell", "embabel.agent.shell")
    }

    /**
     * Data class representing a property migration rule with pattern matching.
     *
     * Used for runtime extensibility when explicit mappings are insufficient.
     * Most migrations use explicit mappings in exactPropertyMappings for safety.
     *
     * ## Usage Example (Runtime Extension)
     *
     * ```kotlin
     * PropertyMigrationRule(
     *     pattern = Pattern.compile("custom\\.company\\.(.+)"),
     *     replacement = "embabel.agent.custom.$1",
     *     description = "Custom company namespace migration"
     * )
     * ```
     */
    data class PropertyMigrationRule(
        val pattern: Pattern,
        val replacement: String,
        val description: String,
        val condition: ((String) -> Boolean)? = null,
    ) {
        /**
         * Attempts to transform a deprecated property name into its recommended replacement.
         *
         * **IMPORTANT**: This method performs **string transformation only** - it does NOT
         * modify any files or source code. It's used purely for generating migration
         * recommendations that will be shown in warnings.
         *
         * The transformation follows these steps:
         * 1. Check optional condition (if present) - return null if condition fails
         * 2. Apply regex pattern matching against the property name string
         * 3. If pattern matches, perform string substitution using replacement template
         * 4. Return the transformed property name string or null if no match
         *
         * ## Example Usage
         * ```kotlin
         * val rule = PropertyMigrationRule(
         *     pattern = Pattern.compile("embabel\\.([^.]+)\\.max-attempts"),
         *     replacement = "embabel.agent.platform.models.$1.max-attempts"
         * )
         *
         * val result = rule.tryApply("embabel.anthropic.max-attempts")
         * // Returns: "embabel.agent.platform.models.anthropic.max-attempts"
         * ```
         *
         * @param property The deprecated property name string to transform
         * @return The recommended replacement property name string if rule applies, null otherwise
         */
        fun tryApply(property: String): String? {
            // Check optional condition first
            condition?.let { if (!it(property)) return null }

            return pattern.matcher(property).takeIf { it.matches() }?.replaceAll(replacement)
        }
    }

    /**
     * Performs the actual scanning with provided configuration and warning components.
     *
     * @param scanningConfig The scanning configuration bean
     * @param propertyWarner The property warning component
     */
    private fun doScanning(
        scanningConfig: DeprecatedPropertyScanningConfig,
        propertyWarner: SimpleDeprecatedConfigWarner,
    ) {
        logger.info("Scanning for deprecated conditional properties in packages: ${scanningConfig.includePackages}")

        runCatching {
            scanForDeprecatedConditionals(scanningConfig, propertyWarner)
        }.onFailure { exception ->
            logger.warn("Error during conditional property scanning: ${exception.message}", exception)
        }
    }

    /**
     * Scans configured packages for deprecated @ConditionalOnProperty usage.
     *
     * **Step 2 in Rule Invocation Flow**: Package scanning phase that discovers
     * all .class files in the configured include packages and analyzes each one
     * for deprecated conditional annotations.
     */
    private fun scanForDeprecatedConditionals(
        scanningConfig: DeprecatedPropertyScanningConfig,
        propertyWarner: SimpleDeprecatedConfigWarner,
    ) {
        val scanningResults = scanningConfig.includePackages
            .filter(scanningConfig::shouldIncludePackage)
            .flatMap { packageName -> findClassesInPackage(packageName, scanningConfig).asIterable() }
            .mapNotNull { resource ->
                runCatching {
                    val metadataReader = metadataReaderFactory.getMetadataReader(resource)
                    metadataReader to analyzeClassForDeprecatedConditionals(
                        metadataReader,
                        scanningConfig,
                        propertyWarner
                    )
                }.getOrElse { exception ->
                    logger.debug("Error reading class metadata for $resource: ${exception.message}")
                    null
                }
            }

        val scannedClasses = scanningResults.size
        val foundDeprecated = scanningResults.count { it.second }

        logger.info("Conditional property scanning completed. Scanned: $scannedClasses classes, Found deprecated: $foundDeprecated")

        // Log aggregated summary of all found deprecated properties
        propertyWarner.logAggregatedSummary()
    }

    /**
     * Scans all active property sources for deprecated property usage.
     * Detects actual configured values from any Spring property source including
     * environment variables, system properties, YAML files, and application.properties.
     *
     * @param propertyWarner The property warning component to issue warnings
     */
    private fun scanEnvironmentPropertyUsage(propertyWarner: SimpleDeprecatedConfigWarner) {
        logger.info("Scanning environment for deprecated property usage")

        // Check all known deprecated property patterns against environment
        exactPropertyMappings.keys.forEach { deprecatedProperty ->
            // Get the actual configured value for this deprecated property (if it exists)
            environment.getProperty(deprecatedProperty)?.let { value ->
                val recommendedProperty = getRecommendedProperty(deprecatedProperty)
                propertyWarner.warnDeprecatedProperty(
                    deprecatedProperty = deprecatedProperty,
                    recommendedProperty = recommendedProperty,
                    deprecationReason = "Property actively configured in environment"
                )
            }
        }
    }

    /**
     * Finds all class resources in a given package.
     *
     * Uses Spring's PathMatchingResourcePatternResolver to locate .class files
     * and optionally filters out JAR-based classes based on configuration.
     */
    private fun findClassesInPackage(
        packageName: String,
        scanningConfig: DeprecatedPropertyScanningConfig,
    ): Array<Resource> {
        val packagePath = packageName.replace('.', '/')
        val pattern = "classpath*:$packagePath/**/*.class"

        return runCatching {
            resourceResolver.getResources(pattern).let { resources ->
                if (scanningConfig.autoExcludeJarPackages) {
                    resources.filterNot { resource ->
                        with(resource.url.toString()) { contains(".jar!") || contains(".war!") }
                    }
                } else {
                    resources.asIterable()
                }
            }.toList().toTypedArray()
        }.getOrElse { exception ->
            logger.debug("Error finding classes in package $packageName: ${exception.message}")
            emptyArray()
        }
    }

    /**
     * Analyzes a class for deprecated conditional annotations.
     *
     * **Step 3 in Rule Invocation Flow**: Annotation detection phase that examines
     * class metadata to find @ConditionalOnProperty and related annotations.
     *
     * @param metadataReader Spring metadata reader for the class
     * @return true if deprecated conditionals were found in this class
     */
    private fun analyzeClassForDeprecatedConditionals(
        metadataReader: MetadataReader,
        scanningConfig: DeprecatedPropertyScanningConfig,
        propertyWarner: SimpleDeprecatedConfigWarner,
    ): Boolean {
        val className = metadataReader.classMetadata.className
        val annotationMetadata = metadataReader.annotationMetadata

        // Skip if package should be excluded
        if (scanningConfig.shouldExcludePackage(className)) return false

        var foundDeprecated = false

        // Check for @ConditionalOnProperty annotations
        if (annotationMetadata.hasAnnotation(ConditionalOnProperty::class.java.name)) {
            foundDeprecated = analyzeConditionalOnProperty(className, annotationMetadata, propertyWarner)
        }

        // Check for @ConfigurationProperties annotations
        if (annotationMetadata.hasAnnotation("org.springframework.boot.context.properties.ConfigurationProperties")) {
            val configPropsDeprecated = analyzeConfigurationProperties(className, annotationMetadata, propertyWarner)
            foundDeprecated = foundDeprecated || configPropsDeprecated
        }

        // Check for meta-annotations that might contain @ConditionalOnProperty
        annotationMetadata.annotationTypes
            .filterNot { it == ConditionalOnProperty::class.java.name }
            .forEach { annotationType ->
                runCatching {
                    Class.forName(annotationType)
                }.onSuccess { metaClass ->
                    if (metaClass.isAnnotationPresent(ConditionalOnProperty::class.java) ||
                        metaClass.isAnnotationPresent(Conditional::class.java)
                    ) {
                        logger.debug("Found meta-annotation with conditional logic in $className: $annotationType")
                        // Could analyze meta-annotations further if needed
                    }
                }
            }

        return foundDeprecated
    }

    /**
     * Analyzes @ConditionalOnProperty annotation for deprecated properties.
     *
     * **Step 4 in Rule Invocation Flow**: Property extraction phase that reads
     * annotation attributes to extract property names and check for deprecation.
     *
     * @param className The name of the class being analyzed
     * @param annotationMetadata Metadata containing annotation information
     * @return true if deprecated properties were found in the annotation
     */
    private fun analyzeConditionalOnProperty(
        className: String,
        annotationMetadata: AnnotationMetadata,
        propertyWarner: SimpleDeprecatedConfigWarner,
    ): Boolean {
        val attributes = annotationMetadata.getAnnotationAttributes(ConditionalOnProperty::class.java.name)
            ?: return false

        val name = attributes["name"] as? String
        val prefix = attributes["prefix"] as? String
        val value = attributes["value"] as? Array<*>

        val deprecatedProperties = sequence {
            // Check prefix-only usage
            prefix?.let { prefixValue ->
                if (isDeprecatedProperty(prefixValue)) yield(prefixValue)
            }

            // Check single property name
            name?.let { propertyName ->
                val fullPropertyName = prefix?.let { "$it.$propertyName" } ?: propertyName
                if (isDeprecatedProperty(fullPropertyName)) yield(fullPropertyName)
            }

            // Check property array
            value?.forEach { prop ->
                val propertyName = prop.toString()
                val fullPropertyName = prefix?.let { "$it.$propertyName" } ?: propertyName
                if (isDeprecatedProperty(fullPropertyName)) yield(fullPropertyName)
            }
        }.toList()

        deprecatedProperties.forEach { propertyName ->
            issueDeprecatedConditionalWarning(className, propertyName, propertyWarner)
        }

        return deprecatedProperties.isNotEmpty()
    }

    /**
     * Analyzes @ConfigurationProperties annotation for deprecated prefixes.
     *
     * **@ConfigurationProperties Detection**: Examines @ConfigurationProperties annotations
     * to find deprecated prefix usage that needs migration guidance.
     *
     * @param className The name of the class being analyzed
     * @param annotationMetadata Metadata containing annotation information
     * @return true if deprecated prefixes were found in the annotation
     */
    private fun analyzeConfigurationProperties(
        className: String,
        annotationMetadata: AnnotationMetadata,
        propertyWarner: SimpleDeprecatedConfigWarner,
    ): Boolean {
        val attributes =
            annotationMetadata.getAnnotationAttributes("org.springframework.boot.context.properties.ConfigurationProperties")
                ?: return false

        // Extract prefix from annotation - it can be in 'prefix' or 'value' attribute
        val prefix = (attributes["prefix"] as? String) ?: (attributes["value"] as? String)

        return if (prefix != null && isDeprecatedProperty(prefix)) {
            issueDeprecatedConfigurationPropertiesWarning(className, prefix, propertyWarner)
            true
        } else {
            false
        }
    }

    /**
     * Issues a warning for deprecated @ConfigurationProperties prefix usage.
     *
     * @param className The class containing the deprecated annotation
     * @param prefix The deprecated prefix name
     */
    private fun issueDeprecatedConfigurationPropertiesWarning(
        className: String,
        prefix: String,
        propertyWarner: SimpleDeprecatedConfigWarner,
    ) {
        val recommendedPrefix = getRecommendedProperty(prefix)
        val annotationDetails = "@ConfigurationProperties(prefix = \"$prefix\")"
        val recommendedApproach = "@ConfigurationProperties(prefix = \"$recommendedPrefix\")"

        propertyWarner.warnDeprecatedConfigurationProperties(
            className = className,
            annotationDetails = annotationDetails,
            recommendedApproach = recommendedApproach
        )
    }

    /**
     * Checks if a property is known to be deprecated using explicit mappings.
     *
     * **Step 5 in Rule Invocation Flow**: Deprecation check that determines whether
     * a property requires migration based on explicit property mappings.
     *
     * @param propertyName The full property name to check
     * @return true if the property is deprecated and should trigger a warning
     */
    private fun isDeprecatedProperty(propertyName: String): Boolean =
        propertyName in exactPropertyMappings || propertyMigrationRules.any { rule -> rule.tryApply(propertyName) != null }

    /**
     * Issues a warning for deprecated conditional property usage.
     *
     * **Step 6 in Rule Invocation Flow**: Warning generation phase that creates
     * and logs deprecation warnings with recommended replacement properties.
     *
     * @param className The class containing the deprecated annotation
     * @param propertyName The deprecated property name
     */
    private fun issueDeprecatedConditionalWarning(
        className: String,
        propertyName: String,
        propertyWarner: SimpleDeprecatedConfigWarner,
    ) {
        val recommendedProperty = getRecommendedProperty(propertyName)
        val annotationDetails = "@ConditionalOnProperty(\"$propertyName\")"
        val recommendedApproach = "@ConditionalOnProperty(\"$recommendedProperty\")"

        propertyWarner.warnDeprecatedConditional(
            className = className,
            annotationDetails = annotationDetails,
            recommendedApproach = recommendedApproach
        )
    }

    /**
     * Generates recommended property name using explicit mappings.
     *
     * **Steps 7-8 in Rule Invocation Flow**: Simple lookup that converts
     * deprecated properties into recommended replacements using explicit mappings.
     *
     * @param deprecatedProperty The deprecated property name
     * @return The recommended replacement property name
     */
    private fun getRecommendedProperty(deprecatedProperty: String): String =
        exactPropertyMappings[deprecatedProperty]
            ?: propertyMigrationRules.firstNotNullOfOrNull { rule -> rule.tryApply(deprecatedProperty) }
            ?: "$deprecatedProperty (please check migration guide for specific replacement)"

    /**
     * Adds a new property migration rule at runtime.
     * Useful for extending migration support without code changes.
     */
    fun addMigrationRule(rule: PropertyMigrationRule) {
        propertyMigrationRules.add(rule)
        logger.debug("Added migration rule: ${rule.description}")
    }

    /**
     * Gets all currently configured migration rules.
     */
    fun getMigrationRules(): List<PropertyMigrationRule> = propertyMigrationRules.toList()

    companion object {
        private val logger = LoggerFactory.getLogger(DeprecatedPropertyScanner::class.java)
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/config/spring/migration/DeprecatedPropertyScanningConfig.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.config.spring.migration

import jakarta.annotation.PostConstruct
import org.slf4j.LoggerFactory
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.context.annotation.Configuration

/**
 * Configuration for conditional property scanning during migration.
 *
 * Controls which packages are scanned for deprecated property in @ConditionalOnProperty annotations.
 * Uses a flexible approach with configurable include/exclude patterns to handle
 * diverse project structures and dependencies.
 *
 * ## Spring Boot + Kotlin Binding Pattern Consistency
 *
 * **All properties use `var`** to ensure consistency with production requirements:
 * - **@Configuration + @ConfigurationProperties**: Requires `var` for CGLIB proxy compatibility
 * - **Complex types (List)**: Need `var` for reliable environment variable binding
 * - **Scalar types**: Use `var` to maintain pattern consistency and avoid production issues
 *
 * This follows the same pattern as `DeprecatedPropertyWarningConfig` which was validated in production.
 *
 * @see DeprecatedPropertyWarningConfig for detailed production lesson learned documentation
 */
@Configuration
@ConfigurationProperties("embabel.agent.platform.migration.scanning")
@ConditionalOnProperty(
    name = ["embabel.agent.platform.migration.scanning.enabled"],
    havingValue = "true",
    matchIfMissing = false
)
class DeprecatedPropertyScanningConfig {
    /**
     * Base packages to scan for deprecated conditional annotations.
     * Defaults to actual Embabel packages while excluding framework internals.
     *
     * Current packages:
     * - com.embabel.agent: Main agent framework code
     * - com.embabel.agent.shell: Shell module (in embabel-agent-shell artifact)
     *
     * Future packages (when they exist):
     * - com.embabel.plugin: Plugin system
     * - com.embabel.extension: Extension system
     *
     * ## Configuration Override Examples
     *
     * ### application.properties
     * ```properties
     * # Override to scan custom packages
     * embabel.agent.platform.migration.scanning.include-packages[0]=com.embabel.agent
     * embabel.agent.platform.migration.scanning.include-packages[1]=com.mycorp.custom
     * embabel.agent.platform.migration.scanning.include-packages[2]=com.thirdparty.integration
     *
     * # Add additional excludes
     * embabel.agent.platform.migration.scanning.additional-excludes[0]=com.noisy.framework
     * embabel.agent.platform.migration.scanning.additional-excludes[1]=com.slow.scanner
     *
     * # Disable auto JAR exclusion for comprehensive scanning
     * embabel.agent.platform.migration.scanning.auto-exclude-jar-packages=false
     * ```
     *
     * ### application.yml.unused
     * ```yaml
     * embabel:
     *   agent:
     *     platform:
     *       migration:
     *         scanning:
     *           include-packages:
     *             - com.embabel.agent
     *             - com.mycorp.custom
     *             - com.thirdparty.integration
     *           additional-excludes:
     *             - com.noisy.framework
     *             - com.slow.scanner
     *           auto-exclude-jar-packages: false
     * ```
     *
     * ### Environment Variables
     * ```bash
     * # Include packages (comma-separated)
     * export EMBABEL_AGENT_PLATFORM_MIGRATION_SCANNING_INCLUDE_PACKAGES=com.embabel.agent,com.mycorp.custom
     *
     * # Additional excludes (comma-separated)
     * export EMBABEL_AGENT_PLATFORM_MIGRATION_SCANNING_ADDITIONAL_EXCLUDES=com.noisy.framework,com.slow.scanner
     *
     * # Disable auto JAR exclusion
     * export EMBABEL_AGENT_PLATFORM_MIGRATION_SCANNING_AUTO_EXCLUDE_JAR_PACKAGES=false
     *
     * # Disable scanning entirely in production
     * export EMBABEL_AGENT_PLATFORM_MIGRATION_SCANNING_ENABLED=false
     * ```
     *
     * @see PROFILES_MIGRATION_GUIDE.md for additional configuration examples and migration guidance
     */
    var includePackages: List<String> = listOf(
        "com.embabel.agent",
        "com.embabel.agent.shell"
    )

    /**
     * Package prefixes to exclude from scanning.
     * Uses a comprehensive strategy that excludes common framework and library packages
     * while allowing configuration override for custom environments.
     */
    var excludePackages: List<String> = defaultExcludePackages()

    /**
     * Additional user-specific packages to exclude.
     * Allows runtime customization without modifying the default exclusion list.
     */
    var additionalExcludes: List<String> = emptyList()

    /**
     * Whether to use classpath-based detection to automatically exclude JAR-based packages.
     * When enabled, packages from JAR files are automatically excluded from scanning.
     */
    var autoExcludeJarPackages: Boolean = false

    /**
     * Maximum depth for package scanning to prevent excessive recursion.
     */
    var maxScanDepth: Int = 10

    /**
     * Whether scanning is enabled.
     * **Disabled by default** for production safety - migration system is completely dormant.
     * Set to `true` to activate comprehensive migration detection and warnings.
     */
    var enabled: Boolean = false

    private val logger = LoggerFactory.getLogger(DeprecatedPropertyScanningConfig::class.java)

    @PostConstruct
    fun init() {
        logger.info("Deprecated property scanning config initialized: enabled=$enabled")
    }

    companion object {
        /**
         * Comprehensive default exclude list covering common frameworks and libraries.
         * This approach uses a "kitchen sink" strategy to ensure robust filtering.
         */
        fun defaultExcludePackages(): List<String> = listOf(
            // JDK packages
            "java.",
            "javax.",
            "jdk.",
            "sun.",
            "com.sun.",

            // Kotlin runtime
            "kotlin.",
            "kotlinx.",

            // Spring Framework ecosystem
            "org.springframework.",
            "org.springframework.boot.",
            "org.springframework.security.",
            "org.springframework.data.",
            "org.springframework.cloud.",
            "org.springframework.integration.",
            "org.springframework.batch.",
            "org.springframework.test.",

            // Apache Commons and utilities
            "org.apache.",
            "org.eclipse.",
            "org.junit.",
            "org.hamcrest.",
            "org.mockito.",
            "org.testng.",
            "org.assertj.",

            // Jackson and serialization
            "com.fasterxml.jackson.",
            "com.google.gson.",
            "org.json.",

            // Logging frameworks
            "org.slf4j.",
            "ch.qos.logback.",
            "org.apache.logging.",
            "org.apache.log4j.",

            // Metrics and monitoring
            "io.micrometer.",
            "io.prometheus.",
            "com.codahale.metrics.",
            "org.influxdb.",
            "com.newrelic.",
            "com.datadog.",

            // Database and persistence
            "org.hibernate.",
            "org.mybatis.",
            "com.zaxxer.hikari.",
            "org.h2.",
            "org.postgresql.",
            "com.mysql.",
            "oracle.jdbc.",
            "com.microsoft.sqlserver.",
            "redis.clients.",
            "org.mongodb.",
            "org.neo4j.",

            // Web and HTTP
            "org.apache.tomcat.",
            "org.apache.catalina.",
            "io.undertow.",
            "org.eclipse.jetty.",
            "io.netty.",
            "com.squareup.okhttp.",
            "org.apache.http.",

            // Security
            "org.bouncycastle.",
            "org.jasypt.",
            "io.jsonwebtoken.",

            // Build and development tools
            "org.gradle.",
            "org.apache.maven.",
            "com.github.",
            "org.jetbrains.",

            // Cloud and infrastructure
            "com.amazonaws.",
            "com.azure.",
            "com.google.cloud.",
            "io.kubernetes.",
            "io.fabric8.",

            // Reactive frameworks
            "io.reactivex.",
            "reactor.",
            "org.reactivestreams.",

            // Serialization and validation
            "javax.validation.",
            "jakarta.validation.",
            "org.apache.avro.",
            "com.thoughtworks.xstream.",

            // Template engines
            "org.thymeleaf.",
            "org.apache.velocity.",
            "freemarker.",

            // Configuration libraries
            "com.typesafe.config.",
            "org.apache.commons.configuration.",

            // Utility libraries that might have conditional annotations
            "org.apache.commons.",
            "com.google.guava.",
            "org.apache.commons.lang.",
            "org.apache.commons.collections.",
            "org.apache.commons.io."
        )
    }

    /**
     * Gets the complete list of packages to exclude, combining defaults with additional excludes.
     */
    fun getAllExcludePackages(): List<String> = excludePackages + additionalExcludes

    /**
     * Checks if a package should be excluded from scanning.
     */
    fun shouldExcludePackage(packageName: String): Boolean {
        return getAllExcludePackages().any { exclude ->
            packageName.startsWith(exclude)
        }
    }

    /**
     * Checks if a package should be included in scanning.
     */
    fun shouldIncludePackage(packageName: String): Boolean {
        if (shouldExcludePackage(packageName)) {
            return false
        }

        return includePackages.any { include ->
            packageName.startsWith(include)
        }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/config/spring/migration/DeprecatedPropertyWarningConfig.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.config.spring.migration

import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.context.annotation.Configuration

/**
 * Configuration for deprecated property warning behavior.
 *
 * ## Spring Boot + Kotlin Binding Pattern Analysis
 *
 * This configuration class uses `var` for the Boolean property due to **production requirements**
 * discovered when using `@Configuration` classes with CGLIB proxying.
 *
 * ### Why `var individualLogging: Boolean = false`? - PRODUCTION LESSON LEARNED
 *
 * **CGLIB Proxying Requirement**: When using `@Configuration` (not just `@ConfigurationProperties`),
 * Spring Boot creates CGLIB proxies that require setters for environment variable binding,
 * **even for scalar types**. Using `val` causes: `"No setter found for property: individual-logging"`
 *
 * **Production Error**:
 * ```
 * Failed to bind properties under 'embabel.agent.platform.migration.warnings'
 * Property: embabel.agent.platform.migration.warnings.individual-logging
 * Value: "true"
 * Origin: System Environment Property "EMBABEL_AGENT_PLATFORM_MIGRATION_WARNINGS_INDIVIDUAL_LOGGING"
 * Reason: java.lang.IllegalStateException: No setter found for property: individual-logging
 * ```
 *
 * **Key Distinction**: Pure `@ConfigurationProperties` data classes can use `val` with constructor binding,
 * but `@Configuration` + `@ConfigurationProperties` classes need `var` for CGLIB proxy compatibility.
 *
 * ### Expected Usage Pattern:
 * ```bash
 * # Environment variable binding (requires var with @Configuration classes)
 * export EMBABEL_AGENT_PLATFORM_MIGRATION_WARNINGS_INDIVIDUAL_LOGGING=true
 * ```
 *
 * ### Spring Boot Property Binding Reality Check:
 * - **⚠️ Scalar types with @Configuration**: `var` required for CGLIB proxy compatibility
 * - **❌ Complex types (List, Map)**: `var` required for reliable environment variable binding
 * - **✅ Constructor Binding**: Kotlin data classes automatically use constructor binding for `val`
 * - **✅ Setter Binding**: Properties with `var` use setter-based binding
 *
 * **Production Decision**: Uses `var` due to CGLIB proxy requirements with @Configuration annotation.
 *
 * @see AgentPlatformPropertiesIntegrationTest for comprehensive val vs var binding documentation
 * @see DeprecatedPropertyScanningConfig for the real reason var is needed (List properties)
 */
@Configuration
@ConfigurationProperties("embabel.agent.platform.migration.warnings")
@ConditionalOnProperty(
    name = ["embabel.agent.platform.migration.warnings.enabled"],
    havingValue = "true",
    matchIfMissing = true
)
class DeprecatedPropertyWarningConfig {
    /**
     * Whether to enable individual warning logging.
     * **Enabled by default** for maximum visibility during migration periods.
     * When true, each deprecated property usage is logged immediately.
     * When false, only aggregated summary is logged.
     */
    var individualLogging: Boolean = true

    companion object {
        operator fun invoke(individualLogging: Boolean): DeprecatedPropertyWarningConfig {
            return DeprecatedPropertyWarningConfig().apply {
                this.individualLogging = individualLogging
            }
        }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/config/spring/migration/SimpleDeprecatedConfigWarner.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.config.spring.migration

import org.slf4j.LoggerFactory
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.core.env.Environment
import org.springframework.stereotype.Component

/**
 * Simple implementation for warning about deprecated configuration usage.
 *
 * Provides centralized logging and tracking of deprecated configuration warnings
 * during the migration period, including properties, profiles, and conditional annotations.
 * Warnings are rate-limited to prevent log spam and can be aggregated for overview.
 */
@Component
@ConditionalOnProperty(
    name = ["embabel.agent.platform.migration.warnings.enabled"],
    havingValue = "true",
    matchIfMissing = true
)
class SimpleDeprecatedConfigWarner(
    private val environment: Environment,
    private val warningConfig: DeprecatedPropertyWarningConfig,
) {

    /**
     * Configuration for individual warning logging behavior.
     * When true, individual warnings are logged immediately.
     * When false, only aggregated summary is logged via logAggregatedSummary().
     */
    private val enableIndividualLogging: Boolean = warningConfig.individualLogging

    private val warnedProperties = mutableSetOf<String>()
    private val deprecationDetails = mutableMapOf<String, DeprecationInfo>()

    /**
     * Issue a warning for deprecated property usage.
     * Each unique property is warned about only once per application lifecycle.
     *
     * @param deprecatedProperty The deprecated property name
     * @param recommendedProperty The recommended replacement property
     * @param deprecationReason Optional reason for deprecation
     */
    fun warnDeprecatedProperty(
        deprecatedProperty: String,
        recommendedProperty: String,
        deprecationReason: String? = null,
    ) {
        // Rate limiting: only warn once per property per application run
        if (deprecatedProperty in warnedProperties) return

        environment.getProperty(deprecatedProperty)?.let { propertyValue ->
            warnedProperties.add(deprecatedProperty)
            deprecationDetails[deprecatedProperty] = DeprecationInfo(
                type = DeprecationType.PROPERTY,
                deprecatedItem = deprecatedProperty,
                recommendedReplacement = recommendedProperty,
                reason = deprecationReason
            )

            val message = buildDeprecatedPropertyMessage(
                deprecatedProperty,
                recommendedProperty,
                deprecationReason,
                propertyValue
            )

            if (enableIndividualLogging) {
                logger.warn(message)
            }
        }
    }

    /**
     * Issue a warning for deprecated profile usage.
     * Each unique profile is warned about only once per application lifecycle.
     *
     * @param deprecatedProfile The deprecated profile name
     * @param recommendedProperty The recommended replacement property
     * @param deprecationReason Optional reason for deprecation
     */
    fun warnDeprecatedProfile(
        deprecatedProfile: String,
        recommendedProperty: String,
        deprecationReason: String? = null,
    ) {
        val warningKey = "PROFILE:$deprecatedProfile"

        // Rate limiting: only warn once per profile per application run
        if (warningKey in warnedProperties) return

        if (deprecatedProfile in environment.activeProfiles) {
            warnedProperties.add(warningKey)
            deprecationDetails[warningKey] = DeprecationInfo(
                type = DeprecationType.PROFILE,
                deprecatedItem = deprecatedProfile,
                recommendedReplacement = "$recommendedProperty=true",
                reason = deprecationReason
            )

            val message = buildDeprecatedProfileMessage(deprecatedProfile, recommendedProperty, deprecationReason)

            if (enableIndividualLogging) {
                logger.warn(message)
            }
        }
    }

    /**
     * Issue a warning for deprecated @ConfigurationProperties prefix usage.
     *
     * @param className The class containing the deprecated annotation
     * @param annotationDetails Details about the deprecated @ConfigurationProperties annotation
     * @param recommendedApproach The recommended replacement approach
     */
    fun warnDeprecatedConfigurationProperties(
        className: String,
        annotationDetails: String,
        recommendedApproach: String,
    ) {
        val warningKey = "CONFIG_PROPS:$className"

        // Rate limiting: only warn once per class per application run
        if (warningKey in warnedProperties) return

        warnedProperties.add(warningKey)
        deprecationDetails[warningKey] = DeprecationInfo(
            type = DeprecationType.CONFIGURATION_PROPERTIES,
            deprecatedItem = className,
            recommendedReplacement = recommendedApproach,
            reason = "@ConfigurationProperties prefix migration"
        )

        if (enableIndividualLogging) {
            val message = """
                |DEPRECATED @CONFIGURATIONPROPERTIES USAGE: Class '$className' uses deprecated @ConfigurationProperties prefix: $annotationDetails. Please migrate to: $recommendedApproach
                """.trimMargin()
            logger.warn(message)
        }
    }

    /**
     * Issue a warning for deprecated conditional annotation usage.
     *
     * @param className The class containing the deprecated annotation
     * @param annotationDetails Details about the deprecated annotation
     * @param recommendedApproach The recommended replacement approach
     */
    fun warnDeprecatedConditional(
        className: String,
        annotationDetails: String,
        recommendedApproach: String,
    ) {
        val warningKey = "CONDITIONAL:$className"

        // Rate limiting: only warn once per class per application run
        if (warningKey in warnedProperties) return

        warnedProperties.add(warningKey)
        deprecationDetails[warningKey] = DeprecationInfo(
            type = DeprecationType.CONDITIONAL,
            deprecatedItem = className,
            recommendedReplacement = recommendedApproach,
            reason = "Conditional annotation migration"
        )

        val message = buildDeprecatedConditionalMessage(className, annotationDetails, recommendedApproach)

        if (enableIndividualLogging) {
            logger.warn(message)
        }
    }

    /**
     * Log an aggregated summary of all deprecated configuration usage.
     * Provides a high-level overview with migration details for better user experience.
     */
    fun logAggregatedSummary() {
        if (deprecationDetails.isEmpty()) return

        val categories = getDeprecationCategories()
        val message = buildAggregatedSummaryMessage(categories)
        logger.warn(message)
    }

    /**
     * Get categorized deprecation information for analysis or reporting.
     */
    fun getDeprecationCategories(): DeprecationCategories {
        val grouped = deprecationDetails.values.groupBy { it.type }

        return DeprecationCategories(
            properties = grouped[DeprecationType.PROPERTY].orEmpty(),
            profiles = grouped[DeprecationType.PROFILE].orEmpty(),
            conditionals = grouped[DeprecationType.CONDITIONAL].orEmpty(),
            configurationProperties = grouped[DeprecationType.CONFIGURATION_PROPERTIES].orEmpty()
        )
    }

    /**
     * Get the count of unique deprecated warnings issued.
     */
    fun getWarningCount(): Int = warnedProperties.size

    /**
     * Get the list of deprecated properties/profiles that have been warned about.
     */
    fun getWarnedItems(): Set<String> = warnedProperties.toSet()

    /**
     * Clear all warning tracking (mainly for testing purposes).
     */
    fun clearWarnings() {
        warnedProperties.clear()
        deprecationDetails.clear()
    }

    private fun buildDeprecatedPropertyMessage(
        deprecatedProperty: String,
        recommendedProperty: String,
        deprecationReason: String?,
        propertyValue: String,
    ): String = buildString {
        append("DEPRECATED PROPERTY USAGE: Property '$deprecatedProperty' is deprecated and will be removed in a future version.")
        append(" Please migrate to '$recommendedProperty' instead.")
        deprecationReason?.let { append(" Reason: $it") }
        append(" Current value: '$propertyValue'")
    }

    private fun buildDeprecatedProfileMessage(
        deprecatedProfile: String,
        recommendedProperty: String,
        deprecationReason: String?,
    ): String = buildString {
        append("DEPRECATED PROFILE USAGE: Profile '$deprecatedProfile' is deprecated and will be removed in a future version.")
        append(" Please migrate to property-based configuration using '$recommendedProperty=true' instead.")
        deprecationReason?.let { append(" Reason: $it") }
    }

    private fun buildDeprecatedConditionalMessage(
        className: String,
        annotationDetails: String,
        recommendedApproach: String,
    ): String = buildString {
        append("DEPRECATED CONDITIONAL USAGE: Class '$className' uses deprecated conditional annotation: $annotationDetails.")
        append(" Please migrate to: $recommendedApproach")
    }

    private fun buildAggregatedSummaryMessage(categories: DeprecationCategories): String = buildString {
        append("DEPRECATED CONFIGURATION SUMMARY: Found ")

        val parts = buildList {
            if (categories.properties.isNotEmpty()) add("${categories.properties.size} deprecated properties")
            if (categories.profiles.isNotEmpty()) add("${categories.profiles.size} deprecated profiles")
            if (categories.conditionals.isNotEmpty()) add("${categories.conditionals.size} deprecated conditionals")
            if (categories.configurationProperties.isNotEmpty()) add("${categories.configurationProperties.size} deprecated @ConfigurationProperties")
        }

        append(parts.joinToString(", "))
        append(". See migration guide for details.")

        // Add migration details
        if (categories.properties.isNotEmpty()) {
            append("\n  Properties: ")
            append(categories.properties.joinToString(", ") { "${it.deprecatedItem} → ${it.recommendedReplacement}" })
        }

        if (categories.profiles.isNotEmpty()) {
            append("\n  Profiles: ")
            append(categories.profiles.joinToString(", ") { "${it.deprecatedItem} → ${it.recommendedReplacement}" })
        }

        if (categories.conditionals.isNotEmpty()) {
            append("\n  Conditionals:")
            categories.conditionals.forEach {
                append("\n    - ${it.deprecatedItem}: @ConditionalOnProperty migration needed")
            }
        }

        if (categories.configurationProperties.isNotEmpty()) {
            append("\n  @ConfigurationProperties:")
            categories.configurationProperties.forEach {
                append("\n    - ${it.deprecatedItem}: @ConfigurationProperties prefix migration needed")
            }
        }
    }

    /**
     * Data class for storing deprecation information.
     */
    data class DeprecationInfo(
        val type: DeprecationType,
        val deprecatedItem: String,
        val recommendedReplacement: String,
        val reason: String? = null,
    )

    /**
     * Categories of deprecation types.
     */
    enum class DeprecationType {
        PROPERTY, PROFILE, CONDITIONAL, CONFIGURATION_PROPERTIES
    }

    /**
     * Organized deprecation information by category.
     */
    data class DeprecationCategories(
        val properties: List<DeprecationInfo>,
        val profiles: List<DeprecationInfo>,
        val conditionals: List<DeprecationInfo>,
        val configurationProperties: List<DeprecationInfo>,
    )

    companion object {
        private val logger = LoggerFactory.getLogger(SimpleDeprecatedConfigWarner::class.java)
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/AgenticEventListenerToolsStats.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support

import com.embabel.agent.api.common.ToolStats
import com.embabel.agent.api.common.ToolsStats
import com.embabel.agent.event.AgentProcessEvent
import com.embabel.agent.event.AgenticEventListener
import com.embabel.agent.event.ToolCallResponseEvent

class AgenticEventListenerToolsStats : AgenticEventListener, ToolsStats {

    private val _stats: MutableMap<String, ToolStats> = mutableMapOf()

    override val toolsStats: Map<String, ToolStats>
        get() = _stats.toSortedMap()

    private fun record(e: ToolCallResponseEvent) {
        val existing = _stats[e.request.tool]
        if (existing != null) {
            _stats[e.request.tool] = ToolStats(
                name = e.request.tool,
                calls = existing.calls + 1,
                failures = existing.failures + if (e.result.isFailure) 1 else 0,
                averageResponseTime = (existing.averageResponseTime * existing.calls + e.runningTime.toMillis()) / (existing.calls + 1)
            )
        } else {
            _stats[e.request.tool] = ToolStats(
                name = e.request.tool,
                calls = 1,
                averageResponseTime = e.runningTime.toMillis(),
                failures = if (e.result.isFailure) 1 else 0
            )
        }
    }

    override fun onProcessEvent(event: AgentProcessEvent) {
        if (event is ToolCallResponseEvent) {
            record(event)
        }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/AutoRegistration.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support

import com.embabel.agent.api.annotation.support.AgentMetadataReader
import com.embabel.agent.api.annotation.support.AgenticInfo
import com.embabel.agent.core.AgentPlatform
import com.embabel.agent.core.deployment.AgentScanningProperties
import org.slf4j.LoggerFactory
import org.springframework.beans.BeansException
import org.springframework.beans.factory.config.BeanPostProcessor
import org.springframework.context.ApplicationContext
import org.springframework.context.ApplicationEvent
import org.springframework.context.ApplicationEventPublisher
import org.springframework.context.ApplicationListener
import org.springframework.context.annotation.Profile
import org.springframework.context.event.ContextRefreshedEvent
import org.springframework.core.Ordered
import org.springframework.core.annotation.Order
import org.springframework.stereotype.Service
import java.util.*
import java.util.concurrent.ConcurrentLinkedQueue

/**
 * Event to signal that AgentScanningBeanPostProcessor has completed processing all beans.
 */
class AgentScanningBeanPostProcessorEvent(source: Any) : ApplicationEvent(source)

/**
 * Autoregister beans with @Agent or @Agentic annotations
 */
@Service
@Profile("!test")
internal class AgentScanningPostProcessorDelegate(
    private val agentMetadataReader: AgentMetadataReader,
    private val agentPlatform: AgentPlatform,
    private val properties: AgentScanningProperties,
) {

    private val logger = LoggerFactory.getLogger(AgentScanningPostProcessorDelegate::class.java)

    fun postProcessAfterInitialization(bean: Any, beanName: String): Any? {
        if (properties.annotation) {
            val agentMetadata = agentMetadataReader.createAgentMetadata(bean)
            if (agentMetadata != null) {
                val agenticInfo = AgenticInfo(bean.javaClass)
                if (!agenticInfo.agentic() || agenticInfo.noAutoScan()) {
                    logger.debug(
                        "Classpath scanning disabled on {}: ignoring this class",
                        bean.javaClass.name,
                    )
                    return null
                }
                agentPlatform.deploy(agentMetadata)
            }
        }
        return bean
    }
}

/**
 * Lazy implementation of AgentScanningBeanPostProcessor.
 * Accumulates "other" beans till AgentScanningBeanPostProcessor got fully initialized.
 * <strong>Note:</strong> this is also needed to not short-circuit other PostProcessors
 * for transitive dependencies in the bean graph. (such as ones responsible for Observability, etc.)
 */
@Service
@Profile("!test")
@Order(Ordered.LOWEST_PRECEDENCE)
internal class DelegatingAgentScanningBeanPostProcessor(
    private val applicationContext: ApplicationContext,
    private val applicationEventPublisher: ApplicationEventPublisher,
) : BeanPostProcessor,
    ApplicationListener<ContextRefreshedEvent?> {

    private val logger = LoggerFactory.getLogger(DelegatingAgentScanningBeanPostProcessor::class.java)

    private lateinit var agentScanningBeanPostProcessor: AgentScanningPostProcessorDelegate

    // Queue to hold beans that need processing once dependencies are ready
    private val pendingBeans: Queue<BeanProcessingInfo> = ConcurrentLinkedQueue()

    override fun onApplicationEvent(event: ContextRefreshedEvent) {
        logger.info("Application context has been refreshed and all beans are initialized.")

        // Now all dependencies are fully initialized -  get AgentScanningBeanPostProcessor
        agentScanningBeanPostProcessor = applicationContext.getBean(AgentScanningPostProcessorDelegate::class.java)

        // Process all accumulated beans
        processPendingBeans()

        // Notify that all beans have been processed
        applicationEventPublisher.publishEvent(
            AgentScanningBeanPostProcessorEvent("Post-processing completed")
        )
        logger.info("All deferred beans were post-processed.")
    }

    @Throws(BeansException::class)
    override fun postProcessAfterInitialization(bean: Any, beanName: String): Any? {
        if (this::agentScanningBeanPostProcessor.isInitialized) {
            // Dependencies are ready, process immediately
            return processBean(bean, beanName)
        } else {
            // Dependencies not ready yet, queue for later processing
            pendingBeans.offer(BeanProcessingInfo(bean, beanName))
            return bean // Return original bean
        }
    }

    private fun processPendingBeans() {
        var beanInfo: BeanProcessingInfo
        while ((pendingBeans.poll().also { beanInfo = it }) != null) {
            // Apply the processing that was deferred
            val processedBean = processBean(beanInfo.bean, beanInfo.beanName)
        }
    }

    private fun processBean(bean: Any, beanName: String): Any? {
        // actual processing logic using the dependency by delegation to agentScanningBeanPostProcessor
        return agentScanningBeanPostProcessor.postProcessAfterInitialization(bean = bean, beanName = beanName)
    }

    // Helper class to store bean info
    private data class BeanProcessingInfo(val bean: Any, val beanName: String)

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/DefaultAgentProcessIdGenerator.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support

import com.embabel.agent.core.Agent
import com.embabel.agent.core.ProcessOptions
import com.embabel.agent.spi.AgentProcessIdGenerator
import com.embabel.common.core.NameGenerator
import com.embabel.agent.spi.config.spring.AgentPlatformProperties
import org.springframework.stereotype.Component
import org.springframework.stereotype.Service

// MIGRATED: @ConfigurationProperties("embabel.process-id-generation") → AgentPlatformProperties.processIdGeneration
// Properties now sourced from embabel.agent.platform.process-id-generation.* in agent-platform.properties
@Component
class DefaultProcessIdGeneratorProperties(platformProperties: AgentPlatformProperties) {
    val includeVersion: Boolean = platformProperties.processIdGeneration.includeVersion
    val includeAgentName: Boolean = platformProperties.processIdGeneration.includeAgentName
}

/**
 * Create an informative process ID for the agent process.
 */
@Service
internal class DefaultAgentProcessIdGenerator(
    private val nameGenerator: NameGenerator,
    private val properties: DefaultProcessIdGeneratorProperties,
) : AgentProcessIdGenerator {

    override fun createProcessId(
        agent: Agent,
        processOptions: ProcessOptions,
    ): String {
        val agentName = if (properties.includeAgentName) {
            "${agent.name}-"
        } else {
            ""
        }
        val version = if (properties.includeVersion) {
            "${agent.version}-"
        } else {
            ""
        }
        val randomPart = nameGenerator.generateName()
        return "${agentName}$version$randomPart"
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/ExecutorAsyncer.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support

import com.embabel.agent.api.common.Asyncer
import java.util.concurrent.CompletableFuture
import java.util.concurrent.Executor
import java.util.concurrent.Semaphore

class ExecutorAsyncer(
    private val executor: Executor,
) : Asyncer {

    override fun <T> async(block: () -> T): CompletableFuture<T> {
        return CompletableFuture.supplyAsync(block, executor)
    }

    override fun <T, R> parallelMap(
        items: Collection<T>,
        maxConcurrency: Int,
        transform: (t: T) -> R,
    ): List<R> {
        if (items.isEmpty()) {
            return mutableListOf()
        }

        if (maxConcurrency >= items.size) {
            // No concurrency limit needed - process all at once
            val futures = items.map { item ->
                async { transform(item) }
            }

            return futures.map { future ->
                future.join()
            }.toList()
        } else {
            // Use semaphore for concurrency control
            val semaphore = Semaphore(maxConcurrency)

            val futures = items.map { item ->
                async {
                    try {
                        semaphore.acquire()
                        try {
                            transform(item)
                        } finally {
                            semaphore.release()
                        }
                    } catch (e: InterruptedException) {
                        Thread.currentThread().interrupt()
                        throw RuntimeException("Interrupted while waiting for semaphore", e)
                    }
                }
            }

            return futures.map { future ->
                future.join()
            }.toList()
        }
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/GoapPlannerFactory.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support

import com.embabel.agent.core.ProcessOptions
import com.embabel.agent.spi.PlannerFactory
import com.embabel.plan.Plan
import com.embabel.plan.Planner
import com.embabel.plan.PlanningSystem
import com.embabel.plan.WorldState
import com.embabel.plan.goap.AStarGoapPlanner
import com.embabel.plan.goap.WorldStateDeterminer

/**
 * PlannerFactory that always creates AStarGoapPlanner
 */
object GoapPlannerFactory : PlannerFactory {
    override fun createPlanner(
        processOptions: ProcessOptions,
        worldStateDeterminer: WorldStateDeterminer,
    ): Planner<out PlanningSystem, out WorldState, out Plan> {
        return AStarGoapPlanner(worldStateDeterminer)
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/InMemoryAgentProcessRepository.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support

import com.embabel.agent.spi.config.spring.ProcessRepositoryProperties
import com.embabel.agent.core.AgentProcess
import com.embabel.agent.spi.AgentProcessRepository
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ConcurrentLinkedQueue
import java.util.concurrent.locks.ReentrantReadWriteLock
import kotlin.concurrent.read
import kotlin.concurrent.write

/**
 * In-memory implementation of [AgentProcessRepository] with configurable window size
 * to prevent memory overflow by evicting the oldest entries when the limit is reached.
 */
class InMemoryAgentProcessRepository(
    private val properties: ProcessRepositoryProperties = ProcessRepositoryProperties(),
) : AgentProcessRepository {

    private val map: ConcurrentHashMap<String, AgentProcess> = ConcurrentHashMap()
    private val accessOrder: ConcurrentLinkedQueue<String> = ConcurrentLinkedQueue()
    private val lock = ReentrantReadWriteLock()

    override fun findById(id: String): AgentProcess? = lock.read {
        map[id]
    }

    override fun save(agentProcess: AgentProcess): AgentProcess = lock.write {
        val processId = agentProcess.id

        // If this process already exists, remove it from access order to re-add at end
        if (map.containsKey(processId)) {
            accessOrder.remove(processId)
        }

        map[processId] = agentProcess
        accessOrder.offer(processId)

        while (map.size > properties.windowSize) {
            val oldestId = accessOrder.poll()
            if (oldestId != null) {
                map.remove(oldestId)
            }
        }

        agentProcess
    }

    override fun delete(agentProcess: AgentProcess) {
        lock.write {
            val processId = agentProcess.id
            map.remove(processId)
            accessOrder.remove(processId)
        }
    }

    /**
     * Get current size of the repository for testing purposes.
     */
    fun size(): Int = lock.read { map.size }

    /**
     * Clear all entries from the repository for testing purposes.
     */
    fun clear() = lock.write {
        map.clear()
        accessOrder.clear()
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/InMemoryContextRepository.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support

import com.embabel.agent.spi.config.spring.ContextRepositoryProperties
import com.embabel.agent.core.Context
import com.embabel.agent.spi.ContextRepository
import java.util.*
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ConcurrentLinkedQueue
import java.util.concurrent.locks.ReentrantReadWriteLock
import kotlin.concurrent.read
import kotlin.concurrent.write

/**
 * In-memory implementation of [ContextRepository] with configurable window size
 * to prevent memory overflow by evicting the oldest entries when the limit is reached.
 */
class InMemoryContextRepository(
    private val properties: ContextRepositoryProperties = ContextRepositoryProperties(),
) : ContextRepository {

    private val map: ConcurrentHashMap<String, Context> = ConcurrentHashMap()
    private val accessOrder: ConcurrentLinkedQueue<String> = ConcurrentLinkedQueue()
    private val lock = ReentrantReadWriteLock()

    override fun create(): Context {
        return save(SimpleContext(id = UUID.randomUUID().toString()))
    }

    override fun findById(id: String): Context? = lock.read {
        map[id]
    }

    override fun save(context: Context): Context = lock.write {
        val persistentId = context.id ?: UUID.randomUUID().toString()

        // If this process already exists, remove it from access order to re-add at end
        if (map.containsKey(persistentId)) {
            accessOrder.remove(persistentId)
        }

        map[persistentId] = context
        accessOrder.offer(persistentId)

        while (map.size > properties.windowSize) {
            val oldestId = accessOrder.poll()
            if (oldestId != null) {
                map.remove(oldestId)
            }
        }
        context
    }

    override fun delete(context: Context) {
        lock.write {
            val contextId = context.id
            map.remove(contextId)
            accessOrder.remove(contextId)
        }
    }

    /**
     * Get current size of the repository for testing purposes.
     */
    fun size(): Int = lock.read { map.size }

    /**
     * Clear all entries from the repository for testing purposes.
     */
    fun clear() = lock.write {
        map.clear()
        accessOrder.clear()
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/LlmDataBindingProperties.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support

import com.embabel.agent.common.RetryTemplateProvider
import org.slf4j.LoggerFactory
import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.retry.RetryCallback
import org.springframework.retry.RetryContext
import org.springframework.retry.RetryListener
import org.springframework.retry.support.RetryTemplate
import java.time.Duration

/**
 * We want to be more forgiving with data binding. This
 * can be important for smaller models.
 * @param maxAttempts Maximum retry attempts for data binding
 * @param fixedBackoffMillis Fixed backoff time in milliseconds between retries
 * @param sendValidationInfo Should we send validation info to the LLM in every request,
 * even before a validation error occurs?
 */
@ConfigurationProperties(prefix = "embabel.agent.platform.llm-operations.data-binding")
class LlmDataBindingProperties(
    override val maxAttempts: Int = 10,
    val fixedBackoffMillis: Long = 30L,
    val sendValidationInfo: Boolean = false,
) : RetryTemplateProvider {

    private val logger = LoggerFactory.getLogger(LlmDataBindingProperties::class.java)

    override fun retryTemplate(name: String): RetryTemplate {
        return RetryTemplate.builder()
            .maxAttempts(maxAttempts)
            .fixedBackoff(Duration.ofMillis(fixedBackoffMillis))
            .withListener(object : RetryListener {
                override fun <T : Any, E : Throwable> onError(
                    context: RetryContext,
                    callback: RetryCallback<T, E>,
                    throwable: Throwable,
                ) {
                    if (isRateLimitError(throwable)) {
                        logger.info(
                            "🔒 LLM invocation {} RATE LIMITED: Retry attempt {} of {}",
                            name,
                            context.retryCount,
                            maxAttempts,
                        )
                    } else {
                        logger.warn(
                            "LLM invocation {}: Retry attempt {} of {} due to: {}",
                            name,
                            context.retryCount,
                            maxAttempts,
                            throwable.message ?: "Unknown error"
                        )
                    }
                }
            })
            .build()
    }

    companion object {
        private val RATE_LIMIT_PATTERNS = listOf(
            "rate limit",
            "too many requests",
            "quota exceeded",
            "rate-limited",
            "429",
        )

        fun isRateLimitError(t: Throwable): Boolean {
            val message = t.message?.lowercase() ?: return false
            return RATE_LIMIT_PATTERNS.any { pattern ->
                message.contains(pattern)
            }
        }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/LlmOperationsPromptsProperties.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support

import org.springframework.boot.context.properties.ConfigurationProperties
import java.time.Duration

/**
 * Properties for the ChatClientLlmOperations operations
 */
@ConfigurationProperties(prefix = "embabel.agent.platform.llm-operations.prompts")
class LlmOperationsPromptsProperties {
    /**
     * Template to use for the "maybe" prompt, which can enable a failure result if the LLM does not have enough information to create the desired output structure
     */
    var maybePromptTemplate: String = "maybe_prompt_contribution"

    /**
     * Whether to generate examples by default
     */
    var generateExamplesByDefault: Boolean = true

    /**
     * Default timeout for operations
     */
    var defaultTimeout: Duration = Duration.ofSeconds(60)
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/LlmRanker.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support

import com.embabel.agent.api.common.InteractionId
import com.embabel.agent.common.RetryProperties
import com.embabel.agent.spi.*
import com.embabel.common.ai.model.LlmOptions
import com.embabel.common.ai.model.ModelSelectionCriteria
import com.embabel.common.ai.model.ModelSelectionCriteria.Companion.byName
import com.embabel.common.core.types.Described
import com.embabel.common.core.types.Named
import com.fasterxml.jackson.annotation.JsonClassDescription
import com.fasterxml.jackson.annotation.JsonPropertyDescription
import org.slf4j.LoggerFactory
import org.springframework.boot.context.properties.ConfigurationProperties

/**
 * Properties for the ranking service. Optional LLM selection, plus normal retry properties.
 * @param llm name of the LLM to use for ranking, or null to use auto selection
 * @param maxAttempts maximum number of attempts to retry ranking
 * @param backoffMillis initial backoff time in milliseconds
 * @param backoffMultiplier multiplier for backoff time
 * @param backoffMaxInterval maximum backoff time in milliseconds
 */
@ConfigurationProperties("embabel.agent.platform.ranking")
data class RankingProperties(
    val llm: String? = null,
    override val maxAttempts: Int = 5,
    override val backoffMillis: Long = 100L,
    override val backoffMultiplier: Double = 5.0,
    override val backoffMaxInterval: Long = 180000L,
) : RetryProperties

/**
 * Use an LLM to rank things
 */
internal class LlmRanker(
    private val llmOperations: LlmOperations,
    private val rankingProperties: RankingProperties,
) : Ranker {

    private val logger = LoggerFactory.getLogger(this.javaClass)

    private val llm = LlmOptions(
        criteria =
            if (rankingProperties.llm != null) {
                logger.info("Using LLM '{}' for ranking", rankingProperties.llm)
                byName(rankingProperties.llm)
            } else {
                logger.info("Using auto LLM for ranking")
                ModelSelectionCriteria.Auto
            }
    )

    override fun <T> rank(
        description: String,
        userInput: String,
        rankables: Collection<T>,
    ): Rankings<T> where T : Named, T : Described {
        if (rankables.isEmpty()) {
            return Rankings(emptyList())
        }
        return rankingProperties.retryTemplate("ranker").execute<Rankings<T>, Exception> {
            rankThingsInternal(
                description = description,
                userInput = userInput,
                rankables = rankables,
            )
        }
    }

    private fun <T> rankThingsInternal(
        description: String,
        userInput: String,
        rankables: Collection<T>,
    ): Rankings<T> where T : Named, T : Described {
        val type = rankables.firstOrNull()?.javaClass?.simpleName
            ?: throw IllegalArgumentException("Rankables must not be empty")

        val prompt =
            """
            Your job is rank objects of type $type ($description) based on user input.
            Given the user input, choose the name that best reflects the user's intent.

            User input: <$userInput>

            Available choices, in format <name>: <description>:
            ${rankables.joinToString("\n") { "- ${it.name}: ${it.description}" }}

            Return the name of the chosen $type and the confidence score from 0-1.
            IMPORTANT: The fully qualified name must be exactly the same as in the list.
            """.trimIndent()
        logger.debug("{} ranking prompt: {}", type, prompt)
        val rankingResponse = llmOperations.doTransform(
            prompt = prompt,
            interaction = LlmInteraction(
                id = InteractionId("rank-${type}s"),
                llm = llm,
            ),
            outputClass = RankingsResponse::class.java,
            llmRequestEvent = null,
        )
        logger.debug("{} ranking response: {}", type, rankingResponse)

        val thingNames = rankables.map { it.name }
        val bogusRanking =
            rankingResponse.rankings.find { rankedChoiceResponse -> thingNames.none { rankedChoiceResponse.name == it } }
        if (bogusRanking != null) {
            throw IllegalStateException(
                "Ranker returned choice '$bogusRanking' not in the list of available ${type}s: ${
                    thingNames.map { "'$it'" }
                }, raw=$rankingResponse"
            )
            return Rankings(emptyList())
        }

        return Rankings(
            rankings = rankingResponse.rankings.map {
                Ranking(
                    match = rankables.single { thing -> thing.name == it.name },
                    score = it.confidence,
                )
            }.sortedBy { it.score }.reversed()
        )
    }
}

@JsonClassDescription("List of ranked choices")
internal data class RankingsResponse(
    val rankings: List<RankedChoiceResponse>,
)

internal data class RankedChoiceResponse(
    @get:JsonPropertyDescription("name of what we're ranking")
    val name: String,
    @get:JsonPropertyDescription("confidence score from 0-1")
    val confidence: Double,
)



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/ObservabilityToolCallback.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support

import com.embabel.common.util.loggerFor
import io.micrometer.observation.Observation
import io.micrometer.observation.ObservationRegistry
import org.springframework.ai.tool.ToolCallback
import org.springframework.ai.tool.definition.ToolDefinition

/**
 * Decorator that adds Observability to a [ToolCallback].
 */
class ObservabilityToolCallback(
    private val delegate: ToolCallback,
    private val observationRegistry: ObservationRegistry? = null,
) : ToolCallback {

    override fun getToolDefinition(): ToolDefinition = delegate.toolDefinition

    override fun call(toolInput: String): String {
        if (observationRegistry == null) {
            return delegate.call(toolInput)
        }
        val currentObservation = observationRegistry.currentObservation
        if (currentObservation == null) {
            loggerFor<ObservabilityToolCallback>().warn(
                "No parent observation for tool call {} with input: {}, observation registry: {}",
                delegate.toolDefinition.name(),
                toolInput,
                observationRegistry,
            )
        }
        val observation = Observation.createNotStarted("tool call", observationRegistry)
            .lowCardinalityKeyValue("toolName", delegate.toolDefinition.name())
            .highCardinalityKeyValue("payload", toolInput)
            .parentObservation(currentObservation)
            .start()
        return try {
            val result = delegate.call(toolInput)
            observation.lowCardinalityKeyValue("status", "success")
            observation.highCardinalityKeyValue("result", result)
            result
        } catch (ex: Exception) {
            observation.lowCardinalityKeyValue("status", "error")
            observation.highCardinalityKeyValue("error_type", ex::class.simpleName ?: "Unknown")
            observation.highCardinalityKeyValue("error_message", ex.message ?: "No message")
            observation.error(ex)
            throw ex
        } finally {
            observation.stop()
        }
    }


    override fun toString(): String {
        return "ObservabilityToolCallback(delegate=${delegate.toolDefinition.name()})"
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/OutputTransformingToolCallback.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support

import com.embabel.common.util.StringTransformer
import org.slf4j.LoggerFactory
import org.springframework.ai.tool.ToolCallback
import org.springframework.ai.tool.definition.ToolDefinition

/**
 * Transforms the output of a tool callback using a provided [StringTransformer].
 */
class OutputTransformingToolCallback(
    private val delegate: ToolCallback,
    private val outputTransformer: StringTransformer,
) : ToolCallback {

    private val logger = LoggerFactory.getLogger(javaClass)

    override fun getToolDefinition(): ToolDefinition = delegate.toolDefinition

    override fun call(toolInput: String): String {
        val rawOutput = delegate.call(toolInput)
        val transformed = outputTransformer.transform(rawOutput)
        logger.debug(
            "Tool {} called with input: {}, raw output: {}, transformed output: {}",
            delegate.toolDefinition.name(),
            toolInput,
            rawOutput,
            transformed
        )
        val saving = rawOutput.length - transformed.length
        logger.debug("Saved {} bytes from {}", saving, rawOutput.length)
        return transformed
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/ProcessOptionsOperationScheduler.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support

import com.embabel.agent.core.Delay
import com.embabel.agent.event.ActionExecutionStartEvent
import com.embabel.agent.event.ToolCallRequestEvent
import com.embabel.agent.spi.ActionExecutionSchedule
import com.embabel.agent.spi.DelayedActionExecutionSchedule
import com.embabel.agent.spi.OperationScheduler
import com.embabel.agent.spi.ToolCallSchedule
import java.time.Duration

/**
 * Operation scheduler driven from process options
 */
class ProcessOptionsOperationScheduler(
    val operationDelays: Map<Delay, Long> = mapOf(
        Delay.NONE to 0L,
        Delay.MEDIUM to 400L,
        Delay.LONG to 2000L,
    ),
    val toolDelays: Map<Delay, Long> = mapOf(
        Delay.NONE to 0L,
        Delay.MEDIUM to 400L,
        Delay.LONG to 2000L,
    )
) : OperationScheduler {

    override fun scheduleAction(actionExecutionStartEvent: ActionExecutionStartEvent): ActionExecutionSchedule {
        return DelayedActionExecutionSchedule(
            Duration.ofMillis(
                operationDelays[actionExecutionStartEvent.agentProcess.processContext.processOptions.control.operationDelay]
                    ?: 0L,
            )
        )
    }

    override fun scheduleToolCall(functionCallRequestEvent: ToolCallRequestEvent): ToolCallSchedule {
        return ToolCallSchedule(
            delay = Duration.ofMillis(
                toolDelays[functionCallRequestEvent.agentProcess.processContext.processOptions.control.operationDelay]
                    ?: 0L,
            )
        )
    }


}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/RegistryToolGroupResolver.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support

import com.embabel.agent.core.ToolGroup
import com.embabel.agent.core.ToolGroupMetadata
import com.embabel.agent.core.ToolGroupRequirement
import com.embabel.agent.core.ToolGroupResolution
import com.embabel.agent.spi.ToolGroupResolver
import org.slf4j.LoggerFactory

/**
 * Resolves ToolGroups based on a list.
 * The list is normally Spring-injected,
 * with ToolGroup instances being Spring beans.
 * @param name The name of the resolver.
 * @param toolGroups The list of ToolGroups to resolve. Normally Spring-injected from other beans.
 */
class RegistryToolGroupResolver(
    override val name: String,
    val toolGroups: List<ToolGroup>,
) : ToolGroupResolver {

    private val logger = LoggerFactory.getLogger(javaClass)

    init {
        logger.info(infoString(verbose = true))
    }

    override fun availableToolGroups(): List<ToolGroupMetadata> = toolGroups.map { it.metadata }

    override fun resolveToolGroup(requirement: ToolGroupRequirement): ToolGroupResolution {
        val group = toolGroups.find { it.metadata.role == requirement.role }
        return if (group == null) {
            ToolGroupResolution(
                resolvedToolGroup = null,
                failureMessage = "No tool group matching role '${requirement.role}'",
            )
        } else {
            ToolGroupResolution(
                resolvedToolGroup = group,
            )
        }
    }

    override fun findToolGroupForTool(toolName: String): ToolGroupResolution {
        val group = toolGroups.find { it.toolCallbacks.map { it.toolDefinition.name() }.contains(toolName) }
        return if (group == null) {
            ToolGroupResolution(
                resolvedToolGroup = null,
                failureMessage = "No tool group matching tool '$toolName'",
            )
        } else {
            ToolGroupResolution(
                resolvedToolGroup = group,
            )
        }
    }

    override fun toString(): String {
        return "RegistryToolGroupResolver(name='$name', ${toolGroups.size} toolGroups: ${toolGroups.joinToString(", ") { it.metadata.role }})"
    }

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String {
        if (verbose == false) {
            return "RegistryToolGroupResolver(name='$name', ${toolGroups.size} tool groups)"
        }
        return "RegistryToolGroupResolver: name='$name', ${toolGroups.size} available tool groups:\n\t${
            toolGroups.sortedBy { it.metadata.role }
                .joinToString("\n") {
                    it.infoString(verbose = true, indent = 1)
                }
        }"
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/SimpleContext.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support

import com.embabel.agent.core.Blackboard
import com.embabel.agent.core.Context
import com.embabel.common.util.indent
import com.embabel.common.util.indentLines
import java.util.*
import java.util.concurrent.ConcurrentHashMap

class SimpleContext(
    override var id: String,
) : Context {

    private val _map: MutableMap<String, Any> = ConcurrentHashMap()
    private val _entries: MutableList<Any> = Collections.synchronizedList(mutableListOf())

    override fun bind(
        key: String,
        value: Any,
    ) {
        _map[key] = value
        _entries.add(value)
    }

    override fun addObject(value: Any) {
        _entries.add(value)
    }

    override val objects: List<Any>
        get() = synchronized(_entries) {
            _entries.toList() // Return a snapshot to avoid concurrent modification
        }

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String {
        // Create snapshots for thread-safe iteration
        val mapSnapshot = _map.toMap()
        val objectsSnapshot = synchronized(_entries) { _entries.toList() }

        return """
            |${javaClass.simpleName}: id=$id
            |map:
            |${mapSnapshot.entries.joinToString(", ").indent(1)}
            |entries:
            |${objectsSnapshot.joinToString(", ").indent(1)}
            |"""
            .trimMargin()
            .indentLines(indent)
    }

    override fun populate(blackboard: Blackboard) {
        _map.forEach { (k, v) -> blackboard[k] = v }
        _entries.filterNot { _map.values.contains(it) }.forEach { blackboard.addObject(it) }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/SpringContextPlatformServices.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support

import com.embabel.agent.api.common.Asyncer
import com.embabel.agent.api.common.PlatformServices
import com.embabel.agent.api.common.autonomy.Autonomy
import com.embabel.agent.channel.OutputChannel
import com.embabel.agent.core.AgentPlatform
import com.embabel.agent.event.AgenticEventListener
import com.embabel.agent.spi.LlmOperations
import com.embabel.agent.spi.OperationScheduler
import com.embabel.common.ai.model.ModelProvider
import com.embabel.common.textio.template.TemplateRenderer
import com.fasterxml.jackson.databind.ObjectMapper
import org.slf4j.LoggerFactory
import org.springframework.context.ApplicationContext

data class SpringContextPlatformServices(
    override val agentPlatform: AgentPlatform,
    override val llmOperations: LlmOperations,
    override val eventListener: AgenticEventListener,
    override val operationScheduler: OperationScheduler,
    override val asyncer: Asyncer,
    override val objectMapper: ObjectMapper,
    override val outputChannel: OutputChannel,
    override val templateRenderer: TemplateRenderer,
    private val applicationContext: ApplicationContext?,
) : PlatformServices {

    private val logger = LoggerFactory.getLogger(javaClass)

    override fun withEventListener(agenticEventListener: AgenticEventListener): PlatformServices {
        return copy(
            eventListener = AgenticEventListener.of(eventListener, agenticEventListener)
        )
    }

    // We get this from the context because of circular dependencies
    override fun autonomy(): Autonomy {
        if (applicationContext == null) {
            throw IllegalStateException("Application context is not available, cannot retrieve Autonomy bean.")
        }
        return applicationContext.getBean(Autonomy::class.java)
    }

    override fun modelProvider(): ModelProvider {
        if (applicationContext == null) {
            throw IllegalStateException("Application context is not available, cannot retrieve ModelProvider bean.")
        }
        return applicationContext.getBean(ModelProvider::class.java)
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/springai/AgentProcessBindingToolCallback.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support.springai

import com.embabel.agent.core.AgentProcess
import org.springframework.ai.tool.ToolCallback
import org.springframework.ai.tool.definition.ToolDefinition

/**
 * Bind AgentProcess to ToolContext for use in tool callbacks.
 */
class AgentProcessBindingToolCallback(
    private val delegate: ToolCallback,
    private val agentProcess: AgentProcess,
) : ToolCallback {

    override fun getToolDefinition(): ToolDefinition = delegate.toolDefinition

    override fun call(toolInput: String): String {
        val previousValue = AgentProcess.get()
        try {
            AgentProcess.set(agentProcess)
            return delegate.call(toolInput)
        } finally {
            // Restore previous value (or remove if it was null)
            if (previousValue != null) {
                AgentProcess.set(previousValue)
            } else {
                AgentProcess.remove()
            }
        }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/springai/ChatClientLlmOperations.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support.springai

import com.embabel.agent.core.LlmInvocation
import com.embabel.agent.core.support.AbstractLlmOperations
import com.embabel.agent.core.support.toEmbabelUsage
import com.embabel.agent.event.LlmRequestEvent
import com.embabel.agent.spi.AutoLlmSelectionCriteriaResolver
import com.embabel.agent.spi.LlmCall
import com.embabel.agent.spi.LlmInteraction
import com.embabel.agent.spi.ToolDecorator
import com.embabel.agent.spi.support.LlmDataBindingProperties
import com.embabel.agent.spi.support.LlmOperationsPromptsProperties
import com.embabel.agent.spi.validation.DefaultValidationPromptGenerator
import com.embabel.agent.spi.validation.ValidationPromptGenerator
import com.embabel.chat.Message
import com.embabel.common.ai.model.Llm
import com.embabel.common.ai.model.ModelProvider
import com.embabel.common.textio.template.TemplateRenderer
import com.fasterxml.jackson.databind.DatabindException
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import io.micrometer.observation.ObservationRegistry
import jakarta.annotation.PostConstruct
import jakarta.validation.Validator
import org.springframework.ai.chat.client.ChatClient
import org.springframework.ai.chat.client.ResponseEntity
import org.springframework.ai.chat.client.observation.DefaultChatClientObservationConvention
import org.springframework.ai.chat.messages.SystemMessage
import org.springframework.ai.chat.messages.UserMessage
import org.springframework.ai.chat.model.ChatResponse
import org.springframework.ai.chat.prompt.Prompt
import org.springframework.context.ApplicationContext
import org.springframework.core.ParameterizedTypeReference
import org.springframework.retry.support.RetrySynchronizationManager
import org.springframework.stereotype.Service
import java.lang.reflect.ParameterizedType
import java.time.Duration
import java.time.Instant
import java.util.concurrent.CompletableFuture
import java.util.concurrent.ExecutionException
import java.util.concurrent.TimeUnit
import java.util.concurrent.TimeoutException

const val PROMPT_ELEMENT_SEPARATOR = "\n----\n";

/**
 * LlmOperations implementation that uses the Spring AI ChatClient
 * @param modelProvider ModelProvider to get the LLM model
 * @param toolDecorator ToolDecorator to decorate tools to make them aware of platform
 * @param templateRenderer TemplateRenderer to render templates
 * @param dataBindingProperties properties
 */
@Service
internal class ChatClientLlmOperations(
    modelProvider: ModelProvider,
    toolDecorator: ToolDecorator,
    validator: Validator,
    validationPromptGenerator: ValidationPromptGenerator = DefaultValidationPromptGenerator(),
    private val templateRenderer: TemplateRenderer,
    dataBindingProperties: LlmDataBindingProperties = LlmDataBindingProperties(),
    private val llmOperationsPromptsProperties: LlmOperationsPromptsProperties = LlmOperationsPromptsProperties(),
    private val applicationContext: ApplicationContext? = null,
    autoLlmSelectionCriteriaResolver: AutoLlmSelectionCriteriaResolver = AutoLlmSelectionCriteriaResolver.DEFAULT,
    private val objectMapper: ObjectMapper = jacksonObjectMapper().registerModule(JavaTimeModule()),
    private val observationRegistry: ObservationRegistry = ObservationRegistry.NOOP,
) : AbstractLlmOperations(
    toolDecorator = toolDecorator,
    modelProvider = modelProvider,
    validator = validator,
    validationPromptGenerator = validationPromptGenerator,
    dataBindingProperties = dataBindingProperties,
    autoLlmSelectionCriteriaResolver = autoLlmSelectionCriteriaResolver
) {

    @PostConstruct
    private fun logPropertyConfiguration() {
        val dataBindingFromContext = applicationContext?.runCatching {
            getBeansOfType(LlmDataBindingProperties::class.java).values.firstOrNull()
        }?.getOrNull()

        val promptsFromContext = applicationContext?.runCatching {
            getBeansOfType(LlmOperationsPromptsProperties::class.java).values.firstOrNull()
        }?.getOrNull()

        if (dataBindingFromContext === dataBindingProperties) {
            logger.info("LLM Data Binding: Using Spring-managed properties")
        } else {
            logger.warn("LLM Data Binding: Using fallback defaults")
        }

        if (promptsFromContext === llmOperationsPromptsProperties) {
            logger.info("LLM Prompts: Using Spring-managed properties")
        } else {
            logger.warn("LLM Prompts: Using fallback defaults")
        }

        logger.info("Current LLM settings: maxAttempts=${dataBindingProperties.maxAttempts}, fixedBackoffMillis=${dataBindingProperties.fixedBackoffMillis}ms, timeout=${llmOperationsPromptsProperties.defaultTimeout.seconds}s")
    }

    override fun <O> doTransform(
        messages: List<Message>,
        interaction: LlmInteraction,
        outputClass: Class<O>,
        llmRequestEvent: LlmRequestEvent<O>?,
    ): O {
        val llm = chooseLlm(interaction.llm)
        val chatClient = createChatClient(llm)
        val promptContributions =
            (interaction.promptContributors + llm.promptContributors).joinToString(PROMPT_ELEMENT_SEPARATOR) { it.contribution() }

        val springAiPrompt = Prompt(
            buildList {
                if (promptContributions.isNotEmpty()) {
                    add(SystemMessage(promptContributions))
                }
                addAll(messages.map { it.toSpringAiMessage() })
            }
        )
        llmRequestEvent?.let {
            it.agentProcess.processContext.onProcessEvent(
                it.callEvent(springAiPrompt)
            )
        }

        val chatOptions = llm.optionsConverter.convertOptions(interaction.llm)
        val timeoutMillis = (interaction.llm.timeout ?: llmOperationsPromptsProperties.defaultTimeout).toMillis()

        return dataBindingProperties.retryTemplate(interaction.id.value).execute<O, DatabindException> {
            val attempt = (RetrySynchronizationManager.getContext()?.retryCount ?: 0) + 1

            val future = CompletableFuture.supplyAsync {
                chatClient
                    .prompt(springAiPrompt)
                    .toolCallbacks(interaction.toolCallbacks)
                    .options(chatOptions)
                    .call()
            }

            val callResponse = try {
                future.get(timeoutMillis, TimeUnit.MILLISECONDS)
            } catch (e: TimeoutException) {
                future.cancel(true)
                logger.warn(
                    "LLM {}: attempt {} timed out after {}ms",
                    interaction.id.value,
                    attempt,
                    timeoutMillis
                )
                throw RuntimeException(
                    "ChatClient call for interaction ${interaction.id.value} timed out after ${timeoutMillis}ms",
                    e
                )
            } catch (e: InterruptedException) {
                future.cancel(true)
                Thread.currentThread().interrupt()
                logger.warn("LLM {}: attempt {} was interrupted", interaction.id.value, attempt)
                throw RuntimeException(
                    "ChatClient call for interaction ${interaction.id.value} was interrupted",
                    e
                )
            } catch (e: ExecutionException) {
                future.cancel(true)
                logger.error(
                    "LLM {}: attempt {} failed with execution exception",
                    interaction.id.value,
                    attempt,
                    e.cause
                )
                when (val cause = e.cause) {
                    is RuntimeException -> throw cause
                    is Exception -> throw RuntimeException(
                        "ChatClient call for interaction ${interaction.id.value} failed",
                        cause
                    )

                    else -> throw RuntimeException(
                        "ChatClient call for interaction ${interaction.id.value} failed with unknown error",
                        e
                    )
                }
            }

            if (outputClass == String::class.java) {
                val chatResponse = callResponse.chatResponse()
                chatResponse?.let { recordUsage(llm, it, llmRequestEvent) }
                val rawText = chatResponse!!.result.output.text as String
                stringWithoutThinkBlocks(rawText) as O
            } else {
                val re = callResponse.responseEntity(
                    ExceptionWrappingConverter(
                        expectedType = outputClass,
                        delegate = WithExampleConverter(
                            delegate = SuppressThinkingConverter(
                                FilteringJacksonOutputConverter(
                                    clazz = outputClass,
                                    objectMapper = objectMapper,
                                    propertyFilter = interaction.propertyFilter,
                                )
                            ),
                            outputClass = outputClass,
                            ifPossible = false,
                            generateExamples = shouldGenerateExamples(interaction),
                        )
                    ),
                )
                re.response?.let { recordUsage(llm, it, llmRequestEvent) }
                re.entity!!
            }
        }
    }

    private fun recordUsage(
        llm: Llm,
        chatResponse: ChatResponse,
        llmRequestEvent: LlmRequestEvent<*>?,
    ) {
        logger.debug("Usage is {}", chatResponse.metadata.usage)
        llmRequestEvent?.let {
            val llmi = LlmInvocation(
                llm = llm,
                usage = chatResponse.metadata.usage.toEmbabelUsage(),
                agentName = it.agentProcess.agent.name,
                timestamp = it.timestamp,
                runningTime = Duration.between(it.timestamp, Instant.now()),
            )
            it.agentProcess.recordLlmInvocation(llmi)
        }
    }

    override fun <O> doTransformIfPossible(
        messages: List<Message>,
        interaction: LlmInteraction,
        outputClass: Class<O>,
        llmRequestEvent: LlmRequestEvent<O>,
    ): Result<O> {
        val maybeReturnPromptContribution = templateRenderer.renderLoadedTemplate(
            llmOperationsPromptsProperties.maybePromptTemplate,
            emptyMap(),
        )

        val llm = chooseLlm(interaction.llm)
        val chatClient = createChatClient(llm)
        val promptContributions =
            (interaction.promptContributors + llm.promptContributors).joinToString("\n") { it.contribution() }
        val springAiPrompt = Prompt(
            buildList {
                if (promptContributions.isNotEmpty()) {
                    add(SystemMessage(promptContributions))
                }
                add(UserMessage(maybeReturnPromptContribution))
                addAll(messages.map { it.toSpringAiMessage() })
            }
        )
        llmRequestEvent.agentProcess.processContext.onProcessEvent(
            llmRequestEvent.callEvent(springAiPrompt)
        )

        val typeReference = createParameterizedTypeReference<MaybeReturn<*>>(
            MaybeReturn::class.java,
            outputClass,
        )
        val chatOptions = llm.optionsConverter.convertOptions(interaction.llm)
        val timeoutMillis = (interaction.llm.timeout ?: llmOperationsPromptsProperties.defaultTimeout).toMillis()

        return dataBindingProperties.retryTemplate(interaction.id.value).execute<Result<O>, DatabindException> {
            val attempt = (RetrySynchronizationManager.getContext()?.retryCount ?: 0) + 1

            val callResponse = try {
                CompletableFuture.supplyAsync {
                    chatClient
                        .prompt(springAiPrompt)
                        .toolCallbacks(interaction.toolCallbacks)
                        .options(chatOptions)
                        .call()
                }
                    .orTimeout(timeoutMillis, TimeUnit.MILLISECONDS)
                    .exceptionally { throwable ->
                        when (throwable.cause ?: throwable) {
                            is TimeoutException -> {
                                logger.warn(
                                    "LLM {}: attempt {} timed out after {}ms",
                                    interaction.id.value,
                                    attempt,
                                    timeoutMillis
                                )
                                throw RuntimeException(
                                    "ChatClient call for interaction ${interaction.id.value} timed out after ${timeoutMillis}ms",
                                    throwable
                                )
                            }

                            is RuntimeException -> {
                                logger.error(
                                    "LLM {}: attempt {} failed",
                                    interaction.id.value,
                                    attempt,
                                    throwable.cause ?: throwable
                                )
                                throw (throwable.cause as? RuntimeException ?: throwable)
                            }

                            else -> {
                                logger.error(
                                    "LLM {}: attempt {} failed with unexpected error",
                                    interaction.id.value,
                                    attempt,
                                    throwable.cause ?: throwable
                                )
                                throw RuntimeException(
                                    "ChatClient call for interaction ${interaction.id.value} failed",
                                    throwable.cause ?: throwable
                                )
                            }
                        }
                    }
                    .get()
            } catch (e: InterruptedException) {
                Thread.currentThread().interrupt()
                logger.warn(
                    "LLM {}: attempt {} was interrupted",
                    interaction.id.value,
                    attempt
                )
                throw RuntimeException(
                    "ChatClient call for interaction ${interaction.id.value} was interrupted",
                    e
                )
            }

            val responseEntity: ResponseEntity<ChatResponse, MaybeReturn<*>> = callResponse
                .responseEntity(
                    ExceptionWrappingConverter(
                        expectedType = MaybeReturn::class.java,
                        delegate = WithExampleConverter(
                            delegate = SuppressThinkingConverter(
                                FilteringJacksonOutputConverter(
                                    typeReference = typeReference,
                                    objectMapper = objectMapper,
                                    propertyFilter = interaction.propertyFilter,
                                )
                            ),
                            outputClass = outputClass as Class<MaybeReturn<*>>,
                            ifPossible = true,
                            generateExamples = shouldGenerateExamples(interaction),
                        )
                    )
                )

            responseEntity.response?.let { recordUsage(llm, it, llmRequestEvent) }
            responseEntity.entity!!.toResult() as Result<O>
        }
    }

    @Suppress("UNCHECKED_CAST")
    private fun <T> createParameterizedTypeReference(
        rawType: Class<*>,
        typeArgument: Class<*>,
    ): ParameterizedTypeReference<T> {
        // Create a type with proper generic information
        val type = object : ParameterizedType {
            override fun getRawType() = rawType
            override fun getActualTypeArguments() = arrayOf(typeArgument)
            override fun getOwnerType() = null
        }

        // Create a ParameterizedTypeReference that uses our custom type
        return object : ParameterizedTypeReference<T>() {
            override fun getType() = type
        }
    }

    /**
     * Create a chat client for the given Embabel Llm definition
     **/
    private fun createChatClient(llm: Llm): ChatClient {
        return ChatClient
            .builder(llm.model, observationRegistry, DefaultChatClientObservationConvention())
            .build()
    }

    private fun shouldGenerateExamples(llmCall: LlmCall): Boolean {
        if (llmOperationsPromptsProperties.generateExamplesByDefault) {
            return llmCall.generateExamples != false
        }
        return llmCall.generateExamples == true
    }
}

/**
 * Structure to be returned by the LLM.
 * Allows the LLM to return a result structure, under success, or an error message
 * One of success or failure must be set, but not both.
 */
internal data class MaybeReturn<T>(
    val success: T? = null,
    val failure: String? = null,
) {

    fun toResult(): Result<T> {
        return if (success != null) {
            Result.success(success)
        } else {
            Result.failure(Exception(failure))
        }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/springai/ChatModelCallEvent.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support.springai

import com.embabel.agent.core.AgentProcess
import com.embabel.agent.event.AbstractAgentProcessEvent
import com.embabel.agent.spi.LlmInteraction
import com.embabel.common.ai.model.Llm
import org.springframework.ai.chat.prompt.Prompt

/**
 * Spring AI low level event
 */
class ChatModelCallEvent<O> internal constructor(
    agentProcess: AgentProcess,
    val outputClass: Class<O>,
    val interaction: LlmInteraction,
    val llm: Llm,
    val springAiPrompt: Prompt,
) : AbstractAgentProcessEvent(agentProcess)



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/springai/converter.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support.springai

import com.embabel.chat.AssistantMessage
import com.embabel.chat.Message
import com.embabel.chat.SystemMessage
import com.embabel.chat.UserMessage
import org.springframework.ai.chat.messages.AssistantMessage as SpringAiAssistantMessage
import org.springframework.ai.chat.messages.Message as SpringAiMessage
import org.springframework.ai.chat.messages.SystemMessage as SpringAiSystemMessage
import org.springframework.ai.chat.messages.UserMessage as SpringAiUserMessage

/**
 * Convert one of our messages to a Spring AI message.
 */
fun Message.toSpringAiMessage(): SpringAiMessage {
    val metadata: Map<String, Any> = emptyMap()
    return when (this) {
        is AssistantMessage -> SpringAiAssistantMessage(this.content, metadata)

        is UserMessage -> SpringAiUserMessage.builder().text(this.content).metadata(metadata).build()

        is SystemMessage -> SpringAiSystemMessage.builder().text(this.content).metadata(metadata).build()
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/springai/DefaultToolDecorator.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support.springai

import com.embabel.agent.core.Action
import com.embabel.agent.core.AgentProcess
import com.embabel.agent.spi.ToolDecorator
import com.embabel.agent.spi.ToolGroupResolver
import com.embabel.agent.spi.support.ObservabilityToolCallback
import com.embabel.agent.spi.support.OutputTransformingToolCallback
import com.embabel.common.ai.model.LlmOptions
import com.embabel.common.util.StringTransformer
import io.micrometer.observation.ObservationRegistry
import org.springframework.ai.tool.ToolCallback
import org.springframework.ai.tool.definition.ToolDefinition

/**
 * Decorate tools with metadata and publish events.
 */
class DefaultToolDecorator(
    private val toolGroupResolver: ToolGroupResolver? = null,
    private val observationRegistry: ObservationRegistry? = null,
    private val outputTransformer: StringTransformer = StringTransformer.IDENTITY,
) : ToolDecorator {

    override fun decorate(
        tool: ToolCallback,
        agentProcess: AgentProcess,
        action: Action?,
        llmOptions: LlmOptions,
    ): ToolCallback {
        val toolGroup = toolGroupResolver?.findToolGroupForTool(toolName = tool.toolDefinition.name())
        return AgentProcessBindingToolCallback(
            delegate = ExceptionSuppressingToolCallback(
                delegate = OutputTransformingToolCallback(
                    delegate = ObservabilityToolCallback(
                        delegate = MetadataEnrichedToolCallback(
                            toolGroupMetadata = toolGroup?.resolvedToolGroup?.metadata,
                            delegate = tool,
                        )
                            .withEventPublication(
                                agentProcess = agentProcess,
                                action = action,
                                llmOptions = llmOptions,
                            ),
                        observationRegistry = observationRegistry,
                    ),
                    outputTransformer = outputTransformer
                )
            ),
            agentProcess = agentProcess,
        )
    }
}

/**
 * Explain exception rather than propagate it
 */
class ExceptionSuppressingToolCallback(
    private val delegate: ToolCallback,
) : ToolCallback {

    override fun getToolDefinition(): ToolDefinition = delegate.toolDefinition

    override fun call(toolInput: String): String {
        return try {
            delegate.call(toolInput)
        } catch (t: Throwable) {
            // Suppress the exception and return a message instead
            "WARNING: Tool '${delegate.toolDefinition.name()}' failed with exception: ${t.message ?: "No message"}"
        }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/springai/EventPublishingToolCallback.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support.springai

import com.embabel.agent.core.Action
import com.embabel.agent.core.AgentProcess
import com.embabel.agent.event.ToolCallRequestEvent
import com.embabel.common.ai.model.LlmOptions
import com.embabel.common.util.time
import org.springframework.ai.tool.ToolCallback
import org.springframework.ai.tool.definition.ToolDefinition
import java.time.Duration

/**
 * HOF to decorate a ToolCallback to time the call and emit events.
 */
fun ToolCallback.withEventPublication(
    agentProcess: AgentProcess,
    action: Action?,
    llmOptions: LlmOptions,
): ToolCallback =
    this as? EventPublishingToolCallback ?: EventPublishingToolCallback(
        delegate = this,
        agentProcess = agentProcess,
        action = action,
        llmOptions = llmOptions,
    )

class EventPublishingToolCallback(
    private val delegate: ToolCallback,
    private val agentProcess: AgentProcess,
    private val action: Action?,
    private val llmOptions: LlmOptions,
) : ToolCallback {

    override fun getToolDefinition(): ToolDefinition = delegate.toolDefinition

    override fun call(toolInput: String): String {
        val functionCallRequestEvent = ToolCallRequestEvent(
            agentProcess = agentProcess,
            action = action,
            llmOptions = llmOptions,
            tool = delegate.toolDefinition.name(),
            toolGroupMetadata = (delegate as? MetadataEnrichedToolCallback)?.toolGroupMetadata,
            toolInput = toolInput,
        )
        val toolCallSchedule =
            agentProcess.processContext.platformServices.operationScheduler.scheduleToolCall(functionCallRequestEvent)
        Thread.sleep(toolCallSchedule.delay.toMillis())
        agentProcess.processContext.onProcessEvent(functionCallRequestEvent)
        val (result: Result<String>, millis) = time {
            try {
                Result.success(delegate.call(toolInput))
            } catch (t: Throwable) {
                Result.failure(t)
            }
        }
        agentProcess.processContext.onProcessEvent(
            functionCallRequestEvent.responseEvent(
                result = result,
                runningTime = Duration.ofMillis(millis),
            )
        )
        return if (result.isFailure) {
            throw result.exceptionOrNull() ?: IllegalStateException("Unknown error")
        } else {
            result.getOrThrow()
        }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/springai/ExceptionWrappingConverter.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support.springai

import com.embabel.agent.spi.InvalidLlmReturnFormatException
import org.slf4j.LoggerFactory
import org.springframework.ai.converter.StructuredOutputConverter

/**
 * Wrap in our exception handling to capture return string
 */
class ExceptionWrappingConverter<T>(
    private val expectedType: Class<T>,
    private val delegate: StructuredOutputConverter<T>,
) : StructuredOutputConverter<T> {
    private val logger = LoggerFactory.getLogger(ExceptionWrappingConverter::class.java)

    override fun convert(source: String): T? {
        logger.debug("Raw LLM output: {}", source)
        return try {
            delegate.convert(source)
        } catch (e: Exception) {
            logger.warn("Error {} converting LLM output: {}", e.message, source)
            throw InvalidLlmReturnFormatException(
                llmReturn = source,
                expectedType = expectedType,
                cause = e,
            )
        }
    }

    override fun getFormat(): String? = delegate.format
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/springai/FilteringJacksonOutputConverter.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support.springai

import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.databind.node.ObjectNode
import org.springframework.core.ParameterizedTypeReference
import java.lang.reflect.Type
import java.util.function.Predicate

/**
 * Extension of [JacksonOutputConverter] that allows for filtering of properties of the generated object via a predicate.
 */
class FilteringJacksonOutputConverter<T> private constructor(
    type: Type,
    objectMapper: ObjectMapper,
    private val propertyFilter: Predicate<String>,
) : JacksonOutputConverter<T>(type, objectMapper) {

    constructor(
        clazz: Class<T>,
        objectMapper: ObjectMapper,
        propertyFilter: Predicate<String>,
    ) : this(clazz as Type, objectMapper, propertyFilter)

    constructor(
        typeReference: ParameterizedTypeReference<T>,
        objectMapper: ObjectMapper,
        propertyFilter: Predicate<String>,
    ) : this(typeReference.type, objectMapper, propertyFilter)

    override fun postProcessSchema(jsonNode: JsonNode) {
        val propertiesNode = jsonNode.get("properties") as? ObjectNode ?: return

        val fieldNames = propertiesNode.fieldNames() as MutableIterator<String>
        while (fieldNames.hasNext()) {
            val fieldName = fieldNames.next()
            if (!this.propertyFilter.test(fieldName)) {
                fieldNames.remove()
            }
        }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/springai/JacksonOutputConverter.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support.springai

import com.fasterxml.jackson.core.JsonProcessingException
import com.fasterxml.jackson.core.util.DefaultIndenter
import com.fasterxml.jackson.core.util.DefaultPrettyPrinter
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.ObjectMapper
import com.github.victools.jsonschema.generator.*
import com.github.victools.jsonschema.module.jackson.JacksonModule
import com.github.victools.jsonschema.module.jackson.JacksonOption
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.ai.converter.StructuredOutputConverter
import org.springframework.ai.util.LoggingMarkers
import org.springframework.core.ParameterizedTypeReference
import java.lang.reflect.Type

/**
 * A Kotlin version of [org.springframework.ai.converter.BeanOutputConverter] that allows for customization
 * of the used schema via [postProcessSchema]
 */
open class JacksonOutputConverter<T> protected constructor(
    private val type: Type,
    val objectMapper: ObjectMapper,
) : StructuredOutputConverter<T> {

    constructor(
        clazz: Class<T>,
        objectMapper: ObjectMapper,
    ) : this(clazz as Type, objectMapper)

    constructor(
        typeReference: ParameterizedTypeReference<T>,
        objectMapper: ObjectMapper,
    ) : this(typeReference.type, objectMapper)

    protected val logger: Logger = LoggerFactory.getLogger(javaClass)

    val jsonSchema: String by lazy {
        val jacksonModule = JacksonModule(
            JacksonOption.RESPECT_JSONPROPERTY_REQUIRED,
            JacksonOption.RESPECT_JSONPROPERTY_ORDER
        )
        val configBuilder = SchemaGeneratorConfigBuilder(
            SchemaVersion.DRAFT_2020_12,
            OptionPreset.PLAIN_JSON
        )
            .with(jacksonModule)
            .with(Option.FORBIDDEN_ADDITIONAL_PROPERTIES_BY_DEFAULT)
        val config = configBuilder.build()
        val generator = SchemaGenerator(config)
        val jsonNode: JsonNode = generator.generateSchema(this.type)
        postProcessSchema(jsonNode)
        val objectWriter = this.objectMapper.writer(
            DefaultPrettyPrinter()
                .withObjectIndenter(DefaultIndenter().withLinefeed(System.lineSeparator()))
        )
        try {
            objectWriter.writeValueAsString(jsonNode)
        } catch (e: JsonProcessingException) {
            logger.error("Could not pretty print json schema for jsonNode: {}", jsonNode)
            throw RuntimeException("Could not pretty print json schema for " + this.type, e)
        }
    }

    /**
     * Empty template method that allows for customization of the JSON schema in subclasses.
     * @param jsonNode the JSON schema, in the form of a JSON node
     */
    protected open fun postProcessSchema(jsonNode: JsonNode) {
    }

    override fun convert(text: String): T? {
        val unwrapped = unwrapJson(text)
        try {
            return this.objectMapper.readValue<Any?>(unwrapped, this.objectMapper.constructType(this.type)) as T?
        } catch (e: JsonProcessingException) {
            logger.error(
                LoggingMarkers.SENSITIVE_DATA_MARKER,
                "Could not parse the given text to the desired target type: \"{}\" into {}", unwrapped, this.type
            )
            throw RuntimeException(e)
        }
    }

    private fun unwrapJson(text: String): String {
        var result = text.trim()

        if (result.startsWith("```") && result.endsWith("```")) {
            result = result.removePrefix("```json")
                .removePrefix("```")
                .removeSuffix("```")
                .trim()
        }

        return result
    }

    override fun getFormat(): String =
        """|
           |Your response should be in JSON format.
           |Do not include any explanations, only provide a RFC8259 compliant JSON response following this format without deviation.
           |Do not include markdown code blocks in your response.
           |Remove the ```json markdown from the output.
           |Here is the JSON Schema instance your output must adhere to:
           |```${jsonSchema}```
           |""".trimMargin()
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/springai/MetadataEnrichedToolCallback.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support.springai

import com.embabel.agent.core.ToolGroupMetadata
import com.embabel.common.util.loggerFor
import com.embabel.common.util.trim
import org.springframework.ai.tool.ToolCallback
import org.springframework.ai.tool.definition.ToolDefinition

/**
 * Add metadata about the tool group to which this tool belongs.
 */
class MetadataEnrichedToolCallback(
    val toolGroupMetadata: ToolGroupMetadata?,
    private val delegate: ToolCallback,
) : ToolCallback {

    override fun getToolDefinition(): ToolDefinition = delegate.toolDefinition

    override fun call(toolInput: String): String {
        try {
            return delegate.call(toolInput)
        } catch (t: Throwable) {
            // Ensures logs aren't too verbose, but still informative.
            loggerFor<MetadataEnrichedToolCallback>().warn(
                "Tool call failure on ${delegate.toolDefinition.name()}: {}",
                trim(s = t.message, max = 120, keepRight = 5),
            )
            throw t
        }
    }

    override fun toString(): String {
        return "MetadataEnrichedToolCallback(toolGroupMetadata=$toolGroupMetadata, delegate=${delegate.toolDefinition.name()})"
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/springai/SuppressThinkingConverter.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support.springai

import org.slf4j.LoggerFactory
import org.springframework.ai.converter.StructuredOutputConverter

typealias ThinkBlockFinder = (String) -> String?

/**
 * A decorator for Spring AI's [StructuredOutputConverter] that cleans up LLM outputs by removing "thinking" blocks.
 *
 * Spring AI's [StructuredOutputConverter] is designed to parse structured formats (like JSON) from
 * LLM outputs, but it can fail if the output contains additional text like reasoning blocks.
 * For example, if an LLM returns:
 *
 * ```
 * <think>
 * Let me think about what information to include in this person object.
 * The name should be "John Doe" and the age should be 30.
 * </think>
 * {"name": "John Doe", "age": 30}
 * ```
 *
 * A standard converter would fail to parse this as valid JSON.
 *
 * This decorator sanitizes the input by removing any content enclosed in <think> tags before
 * passing it to the delegate converter, allowing reasoning models to be used with Spring AI's
 * structured output functionality.
 *
 * ## Usage
 * Wrap any existing [StructuredOutputConverter] with this class:
 * ```
 * val originalConverter = BeanOutputConverter(Person::class.java)
 * val thinkingAwareConverter = SuppressThinkingConverter(originalConverter)
 * ```
 *
 * @param T The target type that the delegate converter produces
 */
class SuppressThinkingConverter<T>(
    /**
     * The underlying converter that will process the sanitized output.
     * This delegate handles the actual conversion from the cleaned string to the target type T.
     */
    private val delegate: StructuredOutputConverter<T>,
    private val thinkBlockFinders: List<ThinkBlockFinder> = listOf(FindMarkupThinkBlock, FindPrefixThinkBlock),
) : StructuredOutputConverter<T> {
    private val logger = LoggerFactory.getLogger(SuppressThinkingConverter::class.java)

    /**
     * Converts the source string to the target type after removing any thinking blocks.
     *
     * This method performs the following steps:
     * 1. Calls [identifyThinkBlock] to sanitize the input by removing thinking blocks
     * 2. Logs any detected thinking blocks (for debugging/analysis purposes)
     * 3. Delegates the actual conversion to the wrapped converter
     *
     * @param source The raw string output from the LLM, potentially containing thinking blocks
     * @return The converted object of type T, or null if conversion fails
     */
    override fun convert(source: String): T? {
        val sanitization = identifyThinkBlock(source)
        sanitization.thinkBlock?.let {
            logger.info(
                "Think block detected in input: '{}': Remaining content: '{}'",
                it,
                sanitization.cleaned,
            )
        }
        return delegate.convert(sanitization.cleaned)
    }

    /**
     * Returns the format description from the delegate converter.
     *
     * This method is part of the [StructuredOutputConverter] interface's [org.springframework.ai.converter.FormatProvider] functionality.
     * The format string provides instructions to the LLM about how to structure its response.
     * This implementation simply forwards to the delegate's format, maintaining the decorator pattern.
     *
     * @return The format description string from the delegate, or null if the delegate doesn't provide one
     */
    override fun getFormat(): String? = delegate.format

    private fun identifyThinkBlock(input: String): ThinkBlockSanitization {
        // First try to parse the input as JSON to see if it is already clean
        try {
            delegate.convert(input)
            // If it succeeds, no need to sanitize
            return ThinkBlockSanitization(
                input = input,
                thinkBlock = null,
                cleaned = input,
            )
        } catch (e: Exception) {
            // If it fails, we assume there might be a think block to sanitize
            logger.debug("Failed to parse input as JSON, sanitizing for think blocks", e)
        }
        // Try to find and remove the think block markup
        return thinkBlockSanitization(thinkBlockFinders, input)
            ?: ThinkBlockSanitization(
                input = input,
                thinkBlock = null,
                cleaned = input,
            )
    }


}

val FindMarkupThinkBlock: ThinkBlockFinder = { input ->
    val thinkBlockRegex = "<think>(.*?)</think>".toRegex(RegexOption.DOT_MATCHES_ALL)
    thinkBlockRegex.find(input)?.value
}

val FindPrefixThinkBlock: ThinkBlockFinder = { input ->
    val thinkBlockRegex = "[^{]*".toRegex(RegexOption.DOT_MATCHES_ALL)
    thinkBlockRegex.find(input)?.value
}

fun stringWithoutThinkBlocks(
    source: String,
    thinkBlockFinders: List<ThinkBlockFinder> = listOf(FindMarkupThinkBlock),
): String {
    val sanitization = thinkBlockSanitization(thinkBlockFinders, source)
    return sanitization?.cleaned ?: source
}

internal fun thinkBlockSanitization(
    thinkBlockFinders: List<ThinkBlockFinder>,
    input: String,
): ThinkBlockSanitization? {
    for (thinkBlockFinder in thinkBlockFinders) {
        val thinkBlock = thinkBlockFinder(input)
        if (thinkBlock != null && thinkBlock.isNotEmpty()) {
            return ThinkBlockSanitization(
                input = input,
                thinkBlock = thinkBlock,
                cleaned = input.replace(thinkBlock, ""),
            )
        }
    }
    return null
}

/**
 * Data class representing the result of sanitizing an input string to remove thinking blocks.
 *
 * This class encapsulates all relevant information about the sanitization process:
 * - The original input (for reference/debugging)
 * - The extracted thinking block (if any was found)
 * - The cleaned output with thinking blocks removed
 *
 * @property input The original, unmodified input string
 * @property thinkBlock The extracted thinking block, or null if none was found
 * @property cleaned The sanitized input with thinking blocks removed
 */
internal data class ThinkBlockSanitization(
    val input: String,
    val thinkBlock: String?,
    val cleaned: String,
)



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/support/springai/WithExampleConverter.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support.springai

import com.embabel.common.util.DummyInstanceCreator
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import org.springframework.ai.converter.StructuredOutputConverter

/**
 * Decorator for Spring's [StructuredOutputConverter] that adds few-shot examples to the output format description.
 *
 * <p>
 * Few-shot examples are often used in prompt engineering to help AI models understand the expected output format
 * by providing concrete example outputs. This converter generates such examples automatically using dummy data
 * and injects them into the format description returned by [getFormat()].
 *
 * @param T the output type for the converter
 * @param delegate the underlying output converter to which conversion is delegated
 * @param outputClass the class type for which dummy example instances will be generated
 * @param ifPossible determines whether to include both success and failure examples (true) or just a simple example (false)
 * @param generateExamples whether to generate examples or not. This class does nothing if it is false
 * Wraps an existing StructuredOutputConverter with this class to enhance its format description for LLM prompting.
 */
class WithExampleConverter<T>(
    private val delegate: StructuredOutputConverter<T>,
    private val outputClass: Class<T>,
    private val ifPossible: Boolean,
    private val generateExamples: Boolean,
) : StructuredOutputConverter<T> {

    private val objectMapper = jacksonObjectMapper().registerModule(JavaTimeModule())

    /**
     * Delegates conversion to the underlying [delegate].
     *
     * @param source the raw output string to convert
     * @return the converted output, or null if conversion fails
     */
    override fun convert(source: String): T? = delegate.convert(source)

    /**
     * Returns a format description string, augmented with few-shot examples.
     *
     * The example(s) are generated using [DummyInstanceCreator], which creates a mock instance of [outputClass].
     *
     * If [ifPossible] is true, the example is wrapped in a structure (presumably [MaybeReturn]) that shows both
     * 'success' and 'failure' cases. This is helpful when the output type can be a success or an error.
     *
     * If [ifPossible] is false, only a single example output is shown (not wrapped).
     *
     * The underlying converter's format is always appended after the examples.
     *
     * @return a string describing the output format, including examples
     */
    override fun getFormat(): String {
        if (!generateExamples) {
            // If example generation is disabled, return the delegate's format directly
            return delegate.format
        }

        val outputClassToUse: Class<*> = when {
            // Look for a deserialization annotation
            outputClass.isInterface -> {
                outputClass.getAnnotation(JsonDeserialize::class.java)?.`as`?.java
                    ?: error(
                        "An interface used for prompt return needs deserialization information: $outputClass"
                    )
            }

            else -> outputClass
        }

        // Generate a dummy example instance of the output type using lorem ipsum values for strings
        // The output is always a dummy instance of the most specific output class, even if it was a interface
        val example = DummyInstanceCreator.LoremIpsum.createDummyInstance(outputClassToUse)
        return if (ifPossible) {
            // If possible, show both a success and a failure example using a wrapper structure.
            // The MaybeReturn class is assumed to be a generic wrapper for success/failure outputs.
            // - success: wraps the dummy example
            // - failure: wraps a fixed failure message
            """|
               |Examples:
               |   success:
               |   ${objectMapper.writeValueAsString(MaybeReturn(success = example))}
               |
               |   failure:
               |   ${objectMapper.writeValueAsString(MaybeReturn<T>(failure = "Insufficient context to create this structure"))}
               |
               |${delegate.format}
               |""".trimMargin()
        } else {
            // Otherwise, just show a single example output (not wrapped in MaybeReturn)
            """|
               |Example:
               |${objectMapper.writeValueAsString(example)}
               |
               |${delegate.format}
               |""".trimMargin()
        }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/validation/DefaultValidationPromptGenerator.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.validation

import jakarta.validation.ConstraintViolation
import jakarta.validation.Validator

class DefaultValidationPromptGenerator : ValidationPromptGenerator {

    override fun generateRequirementsPrompt(
        validator: Validator,
        outputClass: Class<*>,
    ): String {
        val descriptor = validator.getConstraintsForClass(outputClass)
        val requirements = mutableListOf<String>()

        descriptor.constrainedProperties.forEach { propertyDescriptor ->
            val propertyName = propertyDescriptor.propertyName
            val constraints = propertyDescriptor.constraintDescriptors

            constraints.forEach { constraint ->
                val annotationType = constraint.annotation.annotationClass.simpleName
                val message = constraint.messageTemplate

                requirements.add("- Field '$propertyName': $annotationType constraint ($message)")
            }
        }

        return if (requirements.isEmpty()) {
            "No validation constraints defined."
        } else {
            "Validation Requirements:\n" + requirements.joinToString("\n")
        }
    }

    /**
     * (b) Generate a string based on actual constraint violations
     * This describes what went wrong after validation
     */
    override fun <T> generateViolationsReport(violations: Set<ConstraintViolation<T>>): String {
        if (violations.isEmpty()) {
            return "No validation violations."
        }

        val violationMessages = violations.map { violation ->
            val propertyPath = violation.propertyPath.toString()
            val invalidValue = violation.invalidValue
            val message = violation.message

            "- Field '$propertyPath' with value '$invalidValue': $message"
        }

        return "Validation Violations:\n" + violationMessages.joinToString("\n")
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/spi/validation/ValidationPromptGenerator.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.validation

import jakarta.validation.ConstraintViolation
import jakarta.validation.Validator

/**
 * Generate validation prompts for JSR-380 annotated types
 */
interface ValidationPromptGenerator {

    /**
     * Generate a string describing validation requirements for an LLM prompt
     * This inspects the bean metadata to describe constraints ahead of time
     */
    fun generateRequirementsPrompt(
        validator: Validator,
        outputClass: Class<*>,
    ): String

    /**
     * Generate a string based on actual constraint violations
     * This describes what went wrong after validation
     */
    fun <T> generateViolationsReport(violations: Set<ConstraintViolation<T>>): String

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/testing/README.md
================================================
# Testing support classes

Enabling testing is critical for any programming model.

This package contains classes useful for both unit and integration testing.

`unitTestUtils` methods help unit test `@Agent` classes calling LLMs.
`integrationTestUtils` methods help integration test agents, with a default LLM that creates valid instances of return
types with random values.


================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/testing/common/EventSavingAgenticEventListener.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.testing.common

import com.embabel.agent.event.AgentPlatformEvent
import com.embabel.agent.event.AgentProcessEvent
import com.embabel.agent.event.AgenticEventListener

/**
 * Simple implementation of [com.embabel.agent.event.AgenticEventListener] that saves each kind of event to a list.
 */
class EventSavingAgenticEventListener : AgenticEventListener {

    private val _platformEvents = mutableListOf<AgentPlatformEvent>()

    private val _processEvents = mutableListOf<AgentProcessEvent>()

    override fun onPlatformEvent(event: AgentPlatformEvent) {
        _platformEvents += event
    }

    override fun onProcessEvent(event: AgentProcessEvent) {
        _processEvents += event
    }

    val platformEvents get() = _platformEvents.toList()

    val processEvents get() = _processEvents.toList()
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/testing/integration/AgentPlatformTestExtensions.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.testing.integration

import com.embabel.agent.api.common.autonomy.AutonomyProperties
import com.embabel.agent.spi.support.DefaultProcessIdGeneratorProperties
import com.embabel.agent.spi.config.spring.AgentPlatformProperties

/**
 * Extension functions for creating test instances of properties that have migrated to AgentPlatformProperties.
 * These functions provide clean syntax for test object creation while maintaining constructor injection patterns.
 */

/**
 * Creates AutonomyProperties instance for testing with optional parameter overrides.
 * Uses null to indicate "use default value" vs explicit override.
 */
fun forAutonomyTesting(
    agentConfidenceCutOff: Double? = null,
    goalConfidenceCutOff: Double? = null,
): AutonomyProperties {
    val autonomyConfig = AgentPlatformProperties.AutonomyConfig()
    autonomyConfig.agentConfidenceCutOff = agentConfidenceCutOff ?: 0.6
    autonomyConfig.goalConfidenceCutOff = goalConfidenceCutOff ?: 0.6
    val testPlatformProperties = AgentPlatformProperties()
    testPlatformProperties.autonomy = autonomyConfig
    return AutonomyProperties(testPlatformProperties)
}

/**
 * Creates DefaultProcessIdGeneratorProperties instance for testing with optional parameter overrides.
 * Uses null to indicate "use default value" vs explicit override.
 */
fun forProcessIdGenerationTesting(
    includeAgentName: Boolean? = null,
    includeVersion: Boolean? = null,
): DefaultProcessIdGeneratorProperties {
    val processIdConfig = AgentPlatformProperties.ProcessIdGenerationConfig()
    processIdConfig.includeAgentName = includeAgentName ?: false
    processIdConfig.includeVersion = includeVersion ?: false
    val testPlatformProperties = AgentPlatformProperties()
    testPlatformProperties.processIdGeneration = processIdConfig
    return DefaultProcessIdGeneratorProperties(testPlatformProperties)
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/testing/integration/DummyObjectCreatingLlmOperations.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.testing.integration

import com.embabel.agent.core.Action
import com.embabel.agent.core.AgentProcess
import com.embabel.agent.event.LlmRequestEvent
import com.embabel.agent.spi.LlmInteraction
import com.embabel.agent.spi.LlmOperations
import com.embabel.chat.Message
import com.embabel.common.util.DummyInstanceCreator

/**
 * Fake LLM transformer that generates valid classes with random strings.
 */
open class DummyObjectCreatingLlmOperations(
    stringsToUse: List<String>,
) : LlmOperations, DummyInstanceCreator(stringsToUse) {

    override fun <O> doTransform(
        messages: List<Message>,
        interaction: LlmInteraction,
        outputClass: Class<O>,
        llmRequestEvent: LlmRequestEvent<O>?,
    ): O {
        logger.debug("Creating fake response for class: {}", outputClass.name)

        // Create a mock instance based on the output class structure
        @Suppress("UNCHECKED_CAST")
        return createDummyInstance(outputClass) as O
    }

    override fun <O> createObjectIfPossible(
        messages: List<Message>,
        interaction: LlmInteraction,
        outputClass: Class<O>,
        agentProcess: AgentProcess,
        action: Action?,
    ): Result<O> {
        logger.debug("Creating fake response for class: {}", outputClass.name)

        // Create a mock instance based on the output class structure
        @Suppress("UNCHECKED_CAST")
        val o = createDummyInstance(outputClass) as O

        // TODO simulate occasional failures
        return Result.success(o)
    }

    override fun <O> createObject(
        messages: List<Message>,
        interaction: LlmInteraction,
        outputClass: Class<O>,
        agentProcess: AgentProcess,
        action: Action?,
    ): O = doTransform(
        messages = messages,
        interaction = interaction,
        outputClass = outputClass,
        llmRequestEvent = null,
    )

    companion object {

        /**
         * A fake LLM transformer that generates Lorem Ipsum
         * style fake test
         */
        val LoremIpsum: LlmOperations = DummyObjectCreatingLlmOperations(
            LoremIpsums
        )
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/testing/integration/IntegrationTestUtils.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.testing.integration

import com.embabel.agent.api.common.PlatformServices
import com.embabel.agent.channel.DevNullOutputChannel
import com.embabel.agent.core.*
import com.embabel.agent.core.support.DefaultAgentPlatform
import com.embabel.agent.core.support.InMemoryBlackboard
import com.embabel.agent.core.support.SimpleAgentProcess
import com.embabel.agent.event.AgenticEventListener
import com.embabel.agent.spi.LlmOperations
import com.embabel.agent.spi.OperationScheduler
import com.embabel.agent.spi.ToolGroupResolver
import com.embabel.agent.spi.config.spring.AgentPlatformProperties.ProcessType
import com.embabel.agent.spi.support.ExecutorAsyncer
import com.embabel.agent.spi.support.GoapPlannerFactory
import com.embabel.agent.spi.support.RegistryToolGroupResolver
import com.embabel.agent.spi.support.SpringContextPlatformServices
import com.embabel.agent.testing.common.EventSavingAgenticEventListener
import com.embabel.common.textio.template.JinjavaTemplateRenderer
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import java.util.concurrent.Executors

object IntegrationTestUtils {
    /**
     * Create a dummy agent platform for integration testing.
     * The returned instance can be used to run agents.
     */
    @JvmStatic
    @JvmOverloads
    fun dummyAgentPlatform(
        llmOperations: LlmOperations? = null,
        listener: AgenticEventListener? = null,
        toolGroupResolver: ToolGroupResolver? = null,
    ): AgentPlatform {
        return DefaultAgentPlatform(
            llmOperations = llmOperations ?: DummyObjectCreatingLlmOperations.LoremIpsum,
            eventListener = AgenticEventListener.from(
                listOfNotNull(
                    EventSavingAgenticEventListener(),
                    listener
                )
            ),
            toolGroupResolver = toolGroupResolver ?: RegistryToolGroupResolver("empty", emptyList()),
            name = "dummy-agent-platform",
            description = "Dummy Agent Platform for Integration Testing",
            processType = ProcessType.SIMPLE,
            asyncer = ExecutorAsyncer(Executors.newSingleThreadExecutor()),
            objectMapper = jacksonObjectMapper(),
            outputChannel = DevNullOutputChannel,
            templateRenderer = JinjavaTemplateRenderer(),
        )
    }

    @JvmStatic
    @JvmOverloads
    fun dummyPlatformServices(eventListener: AgenticEventListener? = null): PlatformServices {
        return SpringContextPlatformServices(
            agentPlatform = dummyAgentPlatform(),
            llmOperations = DummyObjectCreatingLlmOperations.LoremIpsum,
            eventListener = eventListener ?: EventSavingAgenticEventListener(),
            operationScheduler = OperationScheduler.PRONTO,
            asyncer = ExecutorAsyncer(Executors.newSingleThreadExecutor()),
            objectMapper = jacksonObjectMapper(),
            applicationContext = null,
            outputChannel = DevNullOutputChannel,
            templateRenderer = JinjavaTemplateRenderer(),
        )
    }

    @JvmStatic
    fun dummyAgentProcessRunning(
        agent: Agent,
        platformServices: PlatformServices? = null,
    ): AgentProcess {
        return SimpleAgentProcess(
            id = "dummy-agent-process",
            parentId = null,
            agent = agent,
            blackboard = InMemoryBlackboard(),
            processOptions = ProcessOptions(),
            platformServices = platformServices ?: dummyPlatformServices(),
            plannerFactory = GoapPlannerFactory,
        )
    }

    @JvmStatic
    fun dummyProcessContext(agent: Agent): ProcessContext {
        return ProcessContext(
            processOptions = ProcessOptions(),
            platformServices = dummyPlatformServices(),
            agentProcess = dummyAgentProcessRunning(agent),
            outputChannel = DevNullOutputChannel,
        )
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/testing/integration/RandomRanker.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.testing.integration

import com.embabel.agent.spi.Ranker
import com.embabel.agent.spi.Ranking
import com.embabel.agent.spi.Rankings
import com.embabel.common.core.types.Described
import com.embabel.common.core.types.Named
import kotlin.random.Random

/**
 * Identifies goal rankers used for test
 */
interface FakeRanker : Ranker

class RandomRanker : FakeRanker {
    private val random = Random(System.currentTimeMillis())

    override fun <T> rank(
        description: String,
        userInput: String,
        rankables: Collection<T>
    ): Rankings<T> where T : Named, T : Described {

        return Rankings(rankables.map {
            Ranking(
                match = it,
                score = random.nextDouble(),
            )
        })
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/testing/unit/FakeAction.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.testing.unit

import com.embabel.agent.api.common.support.TransformationAction
import com.embabel.agent.core.ActionQos
import com.embabel.agent.core.IoBinding
import com.embabel.agent.core.ToolGroupRequirement
import com.embabel.common.core.types.ZeroToOne

class FakeAction(
    name: String,
    description: String = name,
    pre: List<String> = emptyList(),
    post: List<String> = emptyList(),
    cost: ZeroToOne = 0.0,
    value: ZeroToOne = 0.0,
    canRerun: Boolean = false,
    qos: ActionQos = ActionQos(),
    inputClass: Class<Unit> = Unit::class.java,
    outputVarName: String? = IoBinding.DEFAULT_BINDING,
    referencedInputProperties: Set<String>? = null,
    toolGroups: Set<ToolGroupRequirement> = emptySet(),
) : TransformationAction<Unit, Unit>(
    name = name,
    description = description,
    pre = pre,
    post = post,
    cost = cost,
    value = value,
    canRerun = canRerun,
    qos = qos,
    inputClass = inputClass,
    outputClass = Unit::class.java,
    outputVarName = outputVarName,
    referencedInputProperties = referencedInputProperties,
    toolGroups = toolGroups,
    block = { },
)



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/testing/unit/FakeOperationContext.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.testing.unit

import com.embabel.agent.api.common.OperationContext
import com.embabel.agent.api.common.PromptRunner
import com.embabel.agent.api.common.ToolObject
import com.embabel.agent.common.Constants.EMBABEL_PROVIDER
import com.embabel.agent.core.*
import com.embabel.agent.prompt.element.ContextualPromptElement
import com.embabel.agent.testing.integration.IntegrationTestUtils.dummyProcessContext
import com.embabel.common.ai.model.LlmOptions
import com.embabel.common.ai.prompt.PromptContributor
import org.slf4j.LoggerFactory

val DummyAgent = Agent(
    name = "Dummy Agent",
    provider = EMBABEL_PROVIDER,
    description = "A dummy agent for testing purposes",
    actions = emptyList(),
    goals = emptySet(),
)

/**
 * Pass into unit tests.
 * Principally used to obtain a [PromptRunner] for testing purposes.
 */
class FakeOperationContext(
    val agent: Agent = DummyAgent,
    override val processContext: ProcessContext = dummyProcessContext(agent = agent),
    override val operation: Operation = FakeAction(name = "test"),
    override val toolGroups: Set<ToolGroupRequirement> = emptySet(),
) : OperationContext, Blackboard by processContext.agentProcess {

    val promptRunner: FakePromptRunner = FakePromptRunner(
        llm = null,
        toolGroups = toolGroups,
        toolObjects = emptyList(),
        promptContributors = emptyList(),
        contextualPromptContributors = emptyList(),
        generateExamples = null,
        context = this,
    )

    private val logger = LoggerFactory.getLogger(FakeOperationContext::class.java)

    init {
        logger.info("FakeOperationContext created: ${hashCode()}: PromptRunner: ${promptRunner.hashCode()}")
    }

    val llmInvocations get() = promptRunner.llmInvocations

    /**
     * Add a response to the list of expected responses.
     * This is used to simulate responses from the LLM.
     */
    fun expectResponse(response: Any?) {
        promptRunner.expectResponse(response)
    }

    override fun promptRunner(
        llm: LlmOptions,
        toolGroups: Set<ToolGroupRequirement>,
        toolObjects: List<ToolObject>,
        promptContributors: List<PromptContributor>,
        contextualPromptContributors: List<ContextualPromptElement>,
        generateExamples: Boolean,
    ): PromptRunner {
        return promptRunner
            .withLlm(llm)
            .let { runner -> toolGroups.fold(runner) { acc, tg -> acc.withToolGroup(tg) } }
            .let { runner -> toolObjects.fold(runner) { acc, to -> acc.withToolObject(to) } }
            .let { runner -> promptContributors.fold(runner) { acc, pc -> acc.withPromptContributor(pc) } }
            .withGenerateExamples(generateExamples)
    }

    companion object {

        @JvmOverloads
        @JvmStatic
        fun create(
            agent: Agent = DummyAgent,
            processContext: ProcessContext = dummyProcessContext(agent = agent),
            operation: Operation = FakeAction(name = "test"),
            toolGroups: Set<ToolGroupRequirement> = emptySet(),
        ) = FakeOperationContext(
            processContext = processContext,
            operation = operation,
            toolGroups = toolGroups,
        )
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/testing/unit/FakePromptRunner.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.testing.unit

import com.embabel.agent.api.common.*
import com.embabel.agent.core.ToolGroup
import com.embabel.agent.core.ToolGroupRequirement
import com.embabel.agent.core.support.safelyGetToolCallbacks
import com.embabel.agent.prompt.element.ContextualPromptElement
import com.embabel.agent.spi.LlmInteraction
import com.embabel.chat.Message
import com.embabel.chat.UserMessage
import com.embabel.common.ai.model.LlmOptions
import com.embabel.common.ai.prompt.PromptContributor
import com.embabel.common.core.MobyNameGenerator
import com.embabel.common.core.types.ZeroToOne
import com.embabel.common.textio.template.JinjavaTemplateRenderer
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import org.slf4j.LoggerFactory
import java.util.function.Predicate

enum class Method {
    CREATE_OBJECT,
    CREATE_OBJECT_IF_POSSIBLE,
    EVALUATE_CONDITION,
}

data class LlmInvocation(
    val interaction: LlmInteraction,
    val messages: List<Message>,
    val method: Method,
)

data class FakePromptRunner(
    override val llm: LlmOptions?,
    override val messages: List<Message> = emptyList(),
    override val toolGroups: Set<ToolGroupRequirement>,
    override val toolObjects: List<ToolObject>,
    override val promptContributors: List<PromptContributor>,
    private val contextualPromptContributors: List<ContextualPromptElement>,
    override val generateExamples: Boolean?,
    override val propertyFilter: Predicate<String> = Predicate { true },
    private val context: OperationContext,
    private val _llmInvocations: MutableList<LlmInvocation> = mutableListOf(),
    private val responses: MutableList<Any?> = mutableListOf(),
) : PromptRunner {

    private val logger = LoggerFactory.getLogger(FakePromptRunner::class.java)

    init {
        logger.info("Fake prompt runner created: ${hashCode()}")
    }

    override fun withInteractionId(interactionId: InteractionId): PromptRunner {
        TODO("Not yet implemented")
    }


    override fun withMessages(messages: List<Message>): PromptRunner =
        copy(messages = this.messages + messages)

    /**
     * Add a response to the list of expected responses.
     * This is used to simulate responses from the LLM.
     */
    fun expectResponse(response: Any?) {
        responses.add(response)
        logger.info(
            "Expected response added: ${response?.javaClass?.name ?: "null"}"
        )
    }

    private fun <T> getResponse(outputClass: Class<T>): T? {
        if (responses.size < llmInvocations.size) {
            throw IllegalStateException(
                """
                    Expected ${llmInvocations.size} responses, but got ${responses.size}.
                    Make sure to call expectResponse() for each LLM invocation.
                    """.trimIndent()
            )
        }
        val maybeT = responses[llmInvocations.size - 1]
        if (maybeT == null) {
            return null
        }
        if (!outputClass.isInstance(maybeT)) {
            throw IllegalStateException(
                "Expected response of type ${outputClass.name}, but got ${maybeT?.javaClass?.name ?: "null"}."
            )
        }
        return maybeT as T
    }

    /**
     * The LLM calls that were made
     */
    val llmInvocations: List<LlmInvocation>
        get() = _llmInvocations

    override fun <T> createObject(
        prompt: String,
        outputClass: Class<T>,
    ): T {
        _llmInvocations += LlmInvocation(
            interaction = createLlmInteraction(),
            messages = listOf(UserMessage(prompt)),
            method = Method.CREATE_OBJECT,
        )
        return getResponse(outputClass)!!
    }

    override fun <T> createObjectIfPossible(
        messages: List<Message>,
        outputClass: Class<T>,
    ): T? {
        _llmInvocations += LlmInvocation(
            interaction = createLlmInteraction(),
            messages = messages,
            method = Method.CREATE_OBJECT_IF_POSSIBLE,
        )
        return getResponse(outputClass)
    }

    override fun <T> createObject(
        messages: List<Message>,
        outputClass: Class<T>,
    ): T {
        return createObject(prompt = messages.joinToString(), outputClass = outputClass)
    }

    override fun evaluateCondition(
        condition: String,
        context: String,
        confidenceThreshold: ZeroToOne,
    ): Boolean {
        _llmInvocations += LlmInvocation(
            interaction = createLlmInteraction(),
            messages = listOf(UserMessage(condition)),
            method = Method.EVALUATE_CONDITION,
        )
        return true
    }

    override fun withLlm(llm: LlmOptions): PromptRunner =
        copy(llm = llm)

    override fun withToolGroup(toolGroup: ToolGroupRequirement): PromptRunner =
        copy(toolGroups = this.toolGroups + toolGroup)

    override fun withToolObject(toolObject: ToolObject): PromptRunner =
        copy(toolObjects = this.toolObjects + toolObject)

    override fun withPromptContributors(promptContributors: List<PromptContributor>): PromptRunner =
        copy(promptContributors = this.promptContributors + promptContributors)

    override fun withContextualPromptContributors(
        contextualPromptContributors: List<ContextualPromptElement>,
    ): PromptRunner =
        copy(contextualPromptContributors = this.contextualPromptContributors + contextualPromptContributors)

    override fun withGenerateExamples(generateExamples: Boolean): PromptRunner =
        copy(generateExamples = generateExamples)

    override fun withPropertyFilter(filter: Predicate<String>): PromptRunner =
        copy(propertyFilter = this.propertyFilter.and(filter))


    private fun createLlmInteraction() =
        LlmInteraction(
            llm = llm ?: LlmOptions(),
            toolGroups = this.toolGroups + toolGroups,
            toolCallbacks = safelyGetToolCallbacks(toolObjects),
            promptContributors = promptContributors + contextualPromptContributors.map {
                it.toPromptContributor(
                    context
                )
            },
            id = InteractionId(
                MobyNameGenerator.generateName(
                )
            ),
            generateExamples = generateExamples,
        )

    override fun withTemplate(templateName: String): TemplateOperations {
        return TemplateOperations(
            templateName,
            templateRenderer = JinjavaTemplateRenderer(),
            promptRunnerOperations = this,
        )
    }

    override fun withHandoffs(vararg outputTypes: Class<*>): PromptRunner {
        TODO("Implement handoff support")
    }

    override fun withSubagents(vararg subagents: Subagent): PromptRunner {
        TODO("Implement subagent handoff support")
    }

    override fun withToolGroup(toolGroup: ToolGroup): PromptRunner {
        TODO("Not yet implemented")
    }

    override fun <T> creating(outputClass: Class<T>): ObjectCreator<T> {
        return PromptRunnerObjectCreator(this, outputClass, jacksonObjectMapper())
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/testing/unit/UnitTestUtils.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.testing.unit

/**
 * Utilities for unit testing agent methods that generate prompts.
 */
object UnitTestUtils {

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/tools/DirectoryBased.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.tools

/**
 * Represents a directory-based tool group
 * that works on the host machine.
 */
interface DirectoryBased {

    /**
     * Root on host machine
     */
    val root: String
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/tools/agent/README.md
================================================
# Support for creating Tools from Embabel Agents


================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/tools/agent/AchievableGoalsToolGroupFactory.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.tools.agent

import com.embabel.agent.api.common.OperationContext
import com.embabel.agent.api.common.autonomy.Autonomy
import com.embabel.agent.api.common.autonomy.DefaultPlanLister
import com.embabel.agent.common.Constants
import com.embabel.agent.core.JvmType
import com.embabel.agent.core.ToolGroup
import com.embabel.agent.core.ToolGroupMetadata
import com.embabel.agent.domain.io.UserInput
import com.embabel.agent.event.AgenticEventListener

/**
 * Expose tools for all goals achievable by the agent given
 * its current OperationContext and Blackboard
 */
class AchievableGoalsToolGroupFactory(
    private val autonomy: Autonomy,
    private val goalToolNamingStrategy: GoalToolNamingStrategy = SanitizedGoalNameToolNamingStrategy,
) {

    /**
     * Creates a ToolGroup containing achievable goals for the chat agent
     * from the present OperationContext
     * @param bindings any additional bindings to pass to the agent process
     * @param listeners any additional listeners to attach to the tool callbacks
     * @param excludedTypes types of goals to exclude from the tool group
     */
    fun achievableGoalsToolGroup(
        context: OperationContext,
        bindings: Map<String, Any>,
        listeners: List<AgenticEventListener>,
        excludedTypes: Set<Class<*>> = emptySet(),
    ): ToolGroup {
        val planLister = DefaultPlanLister(context.agentPlatform())
        val achievableGoals = planLister.achievableGoals(
            processOptions = context.processContext.processOptions,
            bindings = bindings,
        ).filterNot { goal ->
            excludedTypes.any { excludedType -> (goal.outputType as? JvmType)?.isAssignableFrom(excludedType) == true }
        }
        return ToolGroup(
            metadata = ToolGroupMetadata(
                name = "Default chat tools",
                description = "Default tools for chat agent",
                role = "chat",
                provider = Constants.EMBABEL_PROVIDER,
                permissions = emptySet(),
            ),
            toolCallbacks = achievableGoals.mapIndexed { _, goal ->
                GoalToolCallback(
                    autonomy = autonomy,
                    name = goalToolNamingStrategy.nameForGoal(goal),
                    goal = goal,
                    textCommunicator = PromptedTextCommunicator,
                    inputType = UserInput::class.java,
                    listeners = listeners,
                )
            }
        )
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/tools/agent/AgentToolCallback.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.tools.agent

import com.embabel.agent.api.common.autonomy.Autonomy
import com.embabel.agent.api.common.autonomy.ProcessWaitingException
import com.embabel.agent.core.Agent
import com.embabel.agent.core.AgentProcess
import com.embabel.agent.core.ProcessOptions
import com.embabel.agent.core.Verbosity
import com.fasterxml.jackson.databind.ObjectMapper
import org.slf4j.LoggerFactory
import org.springframework.ai.chat.model.ToolContext
import org.springframework.ai.tool.ToolCallback
import org.springframework.ai.tool.definition.ToolDefinition

/**
 * Tool callback that can be used to execute an agent.
 * Supports "Subagent" or "handoff" style usage.
 */
data class AgentToolCallback<I : Any>(
    private val autonomy: Autonomy,
    val agent: Agent,
    val textCommunicator: TextCommunicator,
    val objectMapper: ObjectMapper,
    val inputType: Class<I>,
    val processOptionsCreator: (
        parentAgentProcess: AgentProcess,
    ) -> ProcessOptions,
) : ToolCallback {

    private val logger = LoggerFactory.getLogger(javaClass)

    override fun getToolDefinition(): ToolDefinition {
        return TypeWrappingToolDefinition(
            name = agent.name,
            description = agent.description,
            type = inputType,
        )
    }

    override fun call(
        toolInput: String,
    ): String {
        return call(toolInput, null)
    }

    override fun call(
        toolInput: String,
        toolContext: ToolContext?,
    ): String {
        val parentAgentProcess = AgentProcess.get()
        logger.info("Calling tool {} with input {}", this.agent.name, toolInput)
        val verbosity = Verbosity(
            showPrompts = true,
        )
        val inputObject = try {
            val o = objectMapper.readValue(toolInput, inputType)
            logger.info("Successfully parsed tool input to an instance of {}:\n{}", o::class.java.name, o)
            o
        } catch (e: Exception) {
            val errorReturn =
                "BAD INPUT ERROR parsing tool input: ${e.message}: Try again and see if you can get the format right"
            logger.warn("Error $errorReturn parsing tool input: $toolInput", e)
            return errorReturn
        }
        val processOptions = parentAgentProcess?.let {
            logger.info("Found parent agent process: {} and creating ProcessOptions based on it", it)
            processOptionsCreator(parentAgentProcess)
        } ?: run {
            logger.warn(
                "No parent agent process found in tool context, using default process options."
            )
            ProcessOptions(
                verbosity = verbosity,
            )
        }

        try {
            val agentProcessExecution = autonomy.runAgent(
                inputObject = inputObject,
                processOptions = processOptions,
                agent = agent,
            )
            logger.info("Agent response: {}", agentProcessExecution)
            return textCommunicator.communicateResult(agentProcessExecution)
        } catch (pwe: ProcessWaitingException) {
            val response = textCommunicator.communicateAwaitable(agent, pwe)
            logger.info("Returning waiting response:\n$response")
            return response
        }
    }

    override fun toString() =
        "${javaClass.simpleName}(agent=${agent.name}, description=${agent.description})"

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/tools/agent/DefaultProcessCallbackTools.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.tools.agent

import com.embabel.agent.api.common.autonomy.AgentProcessExecution
import com.embabel.agent.api.common.autonomy.Autonomy
import com.embabel.agent.api.common.autonomy.ProcessWaitingException
import com.embabel.agent.core.hitl.ConfirmationRequest
import com.embabel.agent.core.hitl.ConfirmationResponse
import com.embabel.agent.core.hitl.FormBindingRequest
import com.embabel.agent.core.hitl.ResponseImpact
import com.embabel.agent.spi.LlmInteraction
import com.embabel.common.ai.model.LlmOptions
import com.embabel.common.ai.model.ModelSelectionCriteria
import org.slf4j.LoggerFactory
import org.springframework.ai.tool.annotation.Tool

/**
 * Default tools for handling agent processes
 */
class DefaultProcessCallbackTools(
    val autonomy: Autonomy,
    val textCommunicator: TextCommunicator,
) {

    private val logger = LoggerFactory.getLogger(DefaultProcessCallbackTools::class.java)


    @Tool(
        name = FORM_SUBMISSION_TOOL_NAME,
        description = "Resume a process by providing the process ID and form content",
    )
    fun submitFormAndResumeProcess(
        processId: String,
        formData: String,
    ): String {
        logger.info("Form submission tool called with processId: {}, form input: {}", processId, formData)
        val agentProcess = autonomy.agentPlatform.getAgentProcess(processId)
            ?: return "No process found with ID $processId"
        val formBindingRequest = agentProcess.lastResult() as? FormBindingRequest<Any>
            ?: return "No form binding request found for process $processId"
        val prompt = """
            Given the content below, return the given object

            # Content
            $formData
        """.trimIndent()
        val formDataObject = autonomy.agentPlatform.platformServices.llmOperations.doTransform(
            prompt = prompt,
            LlmInteraction.Companion.using(LlmOptions.Companion(criteria = ModelSelectionCriteria.Auto)),
            outputClass = formBindingRequest.outputClass,
            null,
        )
        val responseImpact = formBindingRequest.bind(
            boundInstance = formDataObject,
            agentProcess
        )
        if (responseImpact != ResponseImpact.UPDATED) {
            TODO("Handle unchanged response impact")
        }
        // Resume the agent process with the form data
        agentProcess.run()
        try{
            val ape = AgentProcessExecution.fromProcessStatus(formData, agentProcess)
            return textCommunicator.communicateResult(ape)
        } catch (pwe: ProcessWaitingException) {
            val response = textCommunicator.communicateAwaitable(agentProcess.agent, pwe)
            logger.info("Returning waiting response:\n$response")
            return response
        }
    }

    @Tool(
        name = CONFIRMATION_TOOL_NAME,
        description = "Resume a process by providing the process ID and form content",
    )
    fun confirmation(
        processId: String,
        confirmed: Boolean,
    ): String {
        logger.info("Confirmation tool called with processId: {}, confirmed: {}", processId, confirmed)
        val agentProcess = autonomy.agentPlatform.getAgentProcess(processId)
            ?: return "No process found with ID $processId"
        val confirmationRequest = agentProcess.lastResult() as? ConfirmationRequest<Any>
            ?: return "No confirmation binding request found for process $processId"
        val confirmationResponse = ConfirmationResponse(
            awaitableId = confirmationRequest.id,
            accepted = confirmed,
        )
        if (confirmationResponse.accepted) {
            agentProcess += confirmationRequest.payload
        } else {
            logger.info("Confirmation request rejected: {}", confirmationRequest.payload)
            // If the confirmation is rejected, we do not update the agent process
            return "Confirmation request rejected: ${confirmationRequest.payload}"
        }
        // Resume the agent process with the form data
        agentProcess.run()
        try{
            val ape = AgentProcessExecution.fromProcessStatus(confirmationRequest.payload, agentProcess)
            return textCommunicator.communicateResult(ape)
        } catch (pwe: ProcessWaitingException) {
            val response = textCommunicator.communicateAwaitable(agentProcess.agent, pwe)
            logger.info("Returning waiting response:\n$response")
            return response
        }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/tools/agent/GoalToolCallback.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.tools.agent

import com.embabel.agent.api.common.autonomy.Autonomy
import com.embabel.agent.api.common.autonomy.ProcessWaitingException
import com.embabel.agent.core.Goal
import com.embabel.agent.core.ProcessOptions
import com.embabel.agent.core.Verbosity
import com.embabel.agent.event.AgenticEventListener
import org.slf4j.LoggerFactory
import org.springframework.ai.chat.model.ToolContext
import org.springframework.ai.tool.ToolCallback
import org.springframework.ai.tool.definition.ToolDefinition

/**
 * Spring AI ToolCallback implementation for a specific goal.
 */
data class GoalToolCallback<I : Any>(
    val autonomy: Autonomy,
    val textCommunicator: TextCommunicator,
    val name: String,
    val description: String = goal.description,
    val goal: Goal,
    val inputType: Class<I>,
    val listeners: List<AgenticEventListener> = emptyList(),
) : ToolCallback {

    private val logger = LoggerFactory.getLogger(javaClass)

    private val objectMapper = autonomy.agentPlatform.platformServices.objectMapper

    fun withListener(listener: AgenticEventListener) = copy(
        listeners = listeners + listener,
    )

    override fun getToolDefinition(): ToolDefinition {
        return TypeWrappingToolDefinition(
            name = name,
            description = description,
            type = inputType,
        )
    }

    override fun call(
        toolInput: String,
    ): String {
        return call(toolInput, null)
    }

    override fun call(
        toolInput: String,
        toolContext: ToolContext?,
    ): String {
        logger.info("Calling tool {} with input {}", this.name, toolInput)
        val verbosity = Verbosity(
            showPrompts = true,
        )
        val inputObject = try {
            val o = objectMapper.readValue(toolInput, inputType)
            logger.info("Successfully parsed tool input to an instance of {}:\n{}", o::class.java.name, o)
            o
        } catch (e: Exception) {
            val errorReturn =
                "BAD INPUT ERROR parsing tool input: ${e.message}: Try again and see if you can get the format right"
            logger.warn("Error $errorReturn parsing tool input: $toolInput", e)
            return errorReturn
        }
        val processOptions = ProcessOptions(
            verbosity = verbosity,
            listeners = listeners,
        )
        val agent = autonomy.createGoalAgent(
            inputObject = inputObject,
            goal = goal,
            agentScope = autonomy.agentPlatform,
            // TODO Bug workaround
            prune = false,
        )
        try {
            val agentProcessExecution = autonomy.runAgent(
                inputObject = inputObject,
                processOptions = processOptions,
                agent = agent,
            )
            logger.info("Goal response: {}", agentProcessExecution)
            return textCommunicator.communicateResult(agentProcessExecution)
        } catch (pwe: ProcessWaitingException) {
            val response = textCommunicator.communicateAwaitable(goal, pwe)
            logger.info("Returning waiting response:\n$response")
            return response
        }
    }

    override fun toString() =
        "${javaClass.simpleName}(goal=${goal.name}, description=${goal.description})"

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/tools/agent/GoalToolNamingStrategy.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.tools.agent

import com.embabel.agent.core.Goal

/**
 * Names published tools.
 */
interface GoalToolNamingStrategy {
    fun nameForGoal(goal: Goal): String
}

/**
 * A simple naming strategy that uses the last two segments of the goal name
 * to create a tool name.
 * For example, "com.myco.MyAgent.myGoal" becomes "MyAgent_myGoal".
 */
object SanitizedGoalNameToolNamingStrategy : GoalToolNamingStrategy {
    override fun nameForGoal(goal: Goal): String {
        return goal.name.split(".").takeLast(2).joinToString("_")
    }
}

open class PrefixedGoalToolNamingStrategy(
    private val prefix: String,
) : GoalToolNamingStrategy {
    override fun nameForGoal(goal: Goal): String {
        return "${prefix}_${SanitizedGoalNameToolNamingStrategy.nameForGoal(goal)}"
    }
}

/**
 * Prefix tool names with the application name.
 */
class ApplicationNameGoalToolNamingStrategy(
    applicationName: String,
) : PrefixedGoalToolNamingStrategy(
    // Sanitize the application name to ensure it is a valid tool name
    applicationName.replace(Regex("[^a-zA-Z0-9]"), "_")
)



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/tools/agent/Handoffs.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.tools.agent

import com.embabel.agent.api.common.autonomy.Autonomy
import com.embabel.agent.core.ToolCallbackPublisher
import org.springframework.ai.tool.ToolCallback

/**
 * Handoffs to local agents.
 */
class Handoffs(
    autonomy: Autonomy,
    val outputTypes: List<Class<*>>,
    applicationName: String,
) : ToolCallbackPublisher {

    private val goalToolCallbackPublisher = PerGoalToolCallbackFactory(
        autonomy = autonomy,
        applicationName = applicationName,
        textCommunicator = PromptedTextCommunicator,
    )

    override val toolCallbacks: List<ToolCallback>
        get() = goalToolCallbackPublisher.goalTools(remoteOnly = false, listeners = emptyList())
            .filter { goalToolCallback ->
                outputTypes.any { outputType ->
                    goalToolCallback.goal.outputType?.isAssignableFrom(outputType) == true
                }
            }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/tools/agent/PerGoalToolCallbackFactory.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.tools.agent

import com.embabel.agent.api.common.autonomy.AgentProcessExecution
import com.embabel.agent.api.common.autonomy.Autonomy
import com.embabel.agent.api.common.autonomy.ProcessWaitingException
import com.embabel.agent.core.Goal
import com.embabel.agent.event.AgenticEventListener
import com.embabel.common.core.types.NamedAndDescribed
import org.slf4j.LoggerFactory
import org.springframework.ai.support.ToolCallbacks
import org.springframework.ai.tool.ToolCallback

const val CONFIRMATION_TOOL_NAME = "_confirm"

const val FORM_SUBMISSION_TOOL_NAME = "submitFormAndResumeProcess"


/**
 * Communicator for awaiting user input.
 */
interface TextCommunicator {

    /**
     * Produce a response string for the given goal and ProcessWaitingException.
     */
    fun communicateAwaitable(
        goal: NamedAndDescribed,
        pwe: ProcessWaitingException,
    ): String

    /**
     * Communicate the result of an agent process execution.
     */
    fun communicateResult(
        agentProcessExecution: AgentProcessExecution,
    ): String

}

/**
 * Generic tool callback provider that publishes a tool callback for each goal.
 * Each invocation will result in a distinct AgentProcess being executed.
 * Multiple instances of this class can be created, each with different configuration,
 * for different purposes.
 * Tools can be exposed to actions or via an MCP server etc.
 * Return a tool callback for each goal taking user input.
 * If the goal specifies startingInputTypes,
 * add a tool for each of those input types.
 * Add a continue tool for any process that requires user input
 * and is waiting for a form submission.
 */
class PerGoalToolCallbackFactory(
    private val autonomy: Autonomy,
    applicationName: String,
    private val textCommunicator: TextCommunicator = PromptedTextCommunicator,
    private val goalToolNamingStrategy: GoalToolNamingStrategy = ApplicationNameGoalToolNamingStrategy(
        applicationName
    ),
) {

    private val logger = LoggerFactory.getLogger(PerGoalToolCallbackFactory::class.java)

    /**
     * Generic tools
     */
    val platformTools: List<ToolCallback> = ToolCallbacks.from(
        DefaultProcessCallbackTools(
            autonomy = autonomy,
            textCommunicator = textCommunicator,
        )
    ).toList()


    /**
     * Tools associated with goals.
     * @param remoteOnly if true, only include tools that are remote.
     * @param listeners additional listeners to be notified of events relating to the created process
     */
    fun goalTools(
        remoteOnly: Boolean,
        listeners: List<AgenticEventListener>,
    ): List<GoalToolCallback<*>> {
        val goalTools = autonomy.agentPlatform.goals
            .filter { it.export.local }
            .filter { !remoteOnly || it.export.remote }
            .flatMap { goal ->
                toolsForGoal(goal, listeners)
            }
        if (goalTools.isEmpty()) {
            logger.info("No goals found in agent platform, no tool callbacks will be published")
            return emptyList()
        }
        logger.info("{} goal tools found in agent platform: {}", goalTools.size, goalTools)
        return goalTools
    }

    /**
     * If remote is true, include only remote tools.
     */
    fun toolCallbacks(
        remoteOnly: Boolean,
        listeners: List<AgenticEventListener>,
    ): List<ToolCallback> {
        val goalTools = goalTools(remoteOnly, listeners)
        return if (goalTools.isEmpty()) {
            logger.warn("No goal tools found, no tool callbacks will be published")
            return emptyList()
        } else {
            goalTools + platformTools
        }
    }


    /**
     * Create tool callbacks for the given goal.
     * There will be one tool callback for each starting input type of the goal.
     */
    fun toolsForGoal(
        goal: Goal,
        listeners: List<AgenticEventListener>,
    ): List<GoalToolCallback<*>> {
        val goalName = goal.export.name ?: goalToolNamingStrategy.nameForGoal(goal)
        return goal.export.startingInputTypes.map { inputType ->
            GoalToolCallback(
                autonomy = autonomy,
                name = "${inputType.simpleName}_$goalName",
                description = goal.description,
                goal = goal,
                inputType = inputType,
                listeners = listeners,
                textCommunicator = textCommunicator,
            )
        }
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/tools/agent/PromptedTextCommunicator.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.tools.agent

import com.embabel.agent.api.common.autonomy.AgentProcessExecution
import com.embabel.agent.api.common.autonomy.ProcessWaitingException
import com.embabel.agent.core.hitl.ConfirmationRequest
import com.embabel.agent.core.hitl.FormBindingRequest
import com.embabel.agent.domain.library.HasContent
import com.embabel.common.core.types.HasInfoString
import com.embabel.common.core.types.NamedAndDescribed

/**
 * Prompted awaitable communicator
 */
object PromptedTextCommunicator : TextCommunicator {

    override fun communicateResult(agentProcessExecution: AgentProcessExecution): String {
        return when (val output = agentProcessExecution.output) {
            is String -> output
            is HasInfoString -> {
                output.infoString(verbose = true)
            }

            is HasContent -> output.content
            else -> output.toString()
        }
    }

    override fun communicateAwaitable(
        goal: NamedAndDescribed,
        pwe: ProcessWaitingException,
    ): String {
        return when (pwe.awaitable) {
            is FormBindingRequest<*> -> """
                You must invoke the $FORM_SUBMISSION_TOOL_NAME tool to proceed with the goal "${goal.name}".
                The arguments will be
                - processId: ${pwe.agentProcess.id},
                - formData: English text describing the form data to submit. See below

                Before invoking this, you must obtain information from the user
                as described in this form structure.
                ${pwe.awaitable.toString()}
                """.trimIndent()

            is ConfirmationRequest<*> ->
                """
                Please ask the user to confirm before proceeding with the goal "${goal.name}".
                The confirmation request is as follows:
                '${pwe.awaitable.message}'
                Use your judgment to determine how to ask the user for confirmation
                and what confirmation will be acceptable.

                Once the user has responded, you must invoke the $CONFIRMATION_TOOL_NAME tool
                with the following arguments:
                - awaitableId: ${pwe.agentProcess.id}
                - confirmed: true if the user confirmed, false if they rejected the request.
                """.trimIndent()

            else -> {
                TODO("HITL error: Unsupported Awaitable type: ${pwe.awaitable.infoString(verbose = true)}")
            }
        }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/tools/agent/TypeWrappingToolDefinition.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.tools.agent

import org.springframework.ai.tool.definition.ToolDefinition
import org.springframework.ai.util.json.schema.JsonSchemaGenerator

/**
 * Tool definition that wraps an input type, generating a JSON schema for it.
 */
data class TypeWrappingToolDefinition(
    private val name: String,
    private val description: String,
    private val type: Class<*>,
) : ToolDefinition {

    override fun name(): String = name
    override fun description(): String = description

    override fun inputSchema(): String = JsonSchemaGenerator.generateForType(type)
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/tools/file/FileChangeLog.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.tools.file

import com.embabel.common.util.loggerFor

enum class FileModificationType {
    CREATE, EDIT, DELETE, APPEND, CREATE_DIRECTORY
}

data class FileModification(
    val path: String,
    val type: FileModificationType,
)

interface FileChangeLog {

    fun flushChanges()

    fun recordChange(c: FileModification)

    fun getChanges(): List<FileModification>
}

/**
 * Convenient file change log implementation that stores changes in memory
 * and correctly handles duplicates.
 */
class DefaultFileChangeLog(
    private val changes: MutableList<FileModification> = mutableListOf(),
) : FileChangeLog {

    override fun flushChanges() {
        changes.clear()
        loggerFor<FileWriteTools>().debug("Flushed file changes")
        changes.clear()
    }

    override fun recordChange(c: FileModification) {
        val existingChange = changes.find { it.path == c.path }
        if (existingChange != null) {
            if (existingChange.type == c.type) {
                // If the same change is already recorded, do not add it again
                loggerFor<FileWriteTools>().debug("Change already recorded: {}", c)
            } else {
                // If a different type of change is recorded, update it
                changes.remove(existingChange)
                changes.add(c)
            }
        } else {
            changes.add(c)
        }
        loggerFor<FileWriteTools>().debug("Recorded file change: {}", c)
    }

    override fun getChanges(): List<FileModification> = changes.toList()
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/tools/file/FileReadLog.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.tools.file

import java.time.Instant

/**
 * Tracks access context
 */
interface FileAccessLog {
    fun getPathsAccessed(): List<String>
}

/**
 * Represents reads of a file
 */
data class FileReads(
    val path: String,
    val reads: List<Instant> = emptyList(),
) {

    fun count() = reads.size
}

/**
 * The FileReadLog can be useful for stats
 * and to understand the context that has been accessed
 */
interface FileReadLog {

    fun flushReads()

    fun recordRead(path: String)

    fun getReads(): List<FileReads>

    fun getPathsRead(): List<String> = getReads().map { it.path }
}

/**
 * Convenient file change log implementation that stores changes in memory
 * and correctly handles duplicates.
 */
class DefaultFileReadLog(
    private val reads: MutableMap<String, FileReads> = mutableMapOf(),
) : FileReadLog {

    override fun flushReads() {
        reads.clear()
    }

    override fun recordRead(path: String) {
        val currentReads = reads.getOrDefault(path, FileReads(path))
        val updatedReads = currentReads.copy(reads = currentReads.reads + Instant.now())
        reads[path] = updatedReads
    }

    override fun getReads(): List<FileReads> {
        return reads.values.toList().sortedBy { it.path }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/tools/file/FileTools.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.tools.file

import com.embabel.agent.api.common.support.SelfToolCallbackPublisher
import com.embabel.agent.tools.DirectoryBased
import com.embabel.common.util.StringTransformer
import com.embabel.common.util.loggerFor
import org.slf4j.LoggerFactory
import org.springframework.ai.tool.annotation.Tool
import org.springframework.ai.tool.annotation.ToolParam
import java.io.File
import java.io.FileInputStream
import java.io.FileOutputStream
import java.io.IOException
import java.nio.file.*
import java.nio.file.attribute.BasicFileAttributes
import java.util.*
import java.util.concurrent.atomic.AtomicInteger
import java.util.zip.ZipInputStream

/**
 * Read and Write file tools. Extend FileReadTools for safe read only use
 */
interface FileTools : FileReadTools, FileWriteTools {

    override fun getPathsAccessed(): List<String> = (getPathsRead() + getChanges().map { it.path }).distinct()

    companion object {

        /**
         * Create a FileReadTools instance with the given root directory.
         */
        @JvmStatic
        @JvmOverloads
        fun readOnly(
            root: String,
            fileContentTransformers: List<StringTransformer> = emptyList(),
        ): FileReadTools = DefaultFileReadTools(root, fileContentTransformers)

        /**
         * Create a readwrite FileTools instance with the given root directory.
         */
        @JvmStatic
        @JvmOverloads
        fun readWrite(
            root: String,
            fileContentTransformers: List<StringTransformer> = emptyList(),
        ): FileTools = DefaultFileTools(root, fileContentTransformers)
    }
}

private class DefaultFileReadTools(
    override val root: String,
    override val fileContentTransformers: List<StringTransformer> = emptyList(),
) : FileReadTools, FileReadLog by DefaultFileReadLog()


private class DefaultFileTools(
    override val root: String,
    override val fileContentTransformers: List<StringTransformer> = emptyList(),
) : FileTools, FileReadLog by DefaultFileReadLog(), FileChangeLog by DefaultFileChangeLog()


/**
 * LLM-ready ToolCallbacks and convenience methods for file operations.
 * Use at your own risk: This makes changes to your host machine!!
 */
interface FileReadTools : DirectoryBased, FileReadLog, FileAccessLog, SelfToolCallbackPublisher {

    /**
     * Provide sanitizers that run on file content before returning it.
     * They must be sure not to change any content that may need to be replaced
     * as this will break editing if editing is done in the same session.
     */
    val fileContentTransformers: List<StringTransformer>

    override fun getPathsAccessed(): List<String> = getPathsRead()

    /**
     * Does this file exist?
     */
    fun exists(): Boolean {
        return Files.exists(resolvePath(""))
    }

    /**
     * Count the total number of files in the repository (excluding .git directory).
     * Uses FileVisitor for cross-platform compatibility (Windows and Linux).
     */
    @Tool(description = "Count the number of files in the repository, excluding .git directory")
    fun fileCount(): Int {
        return try {
            val rootPath = resolvePath("")
            val fileCount = AtomicInteger(0)

            Files.walkFileTree(rootPath, object : SimpleFileVisitor<Path>() {
                override fun preVisitDirectory(dir: Path, attrs: BasicFileAttributes): FileVisitResult {
                    val dirName = dir.fileName?.toString()
                    return if (dirName == ".git") {
                        // Skip entire .git directory and all its contents
                        FileVisitResult.SKIP_SUBTREE
                    } else {
                        FileVisitResult.CONTINUE
                    }
                }

                override fun visitFile(file: Path, attrs: BasicFileAttributes): FileVisitResult {
                    // Only count regular files
                    if (attrs.isRegularFile) {
                        fileCount.incrementAndGet()
                    }
                    return FileVisitResult.CONTINUE
                }

                override fun visitFileFailed(file: Path, exc: IOException): FileVisitResult {
                    // Handle permission issues gracefully (common on Windows)
                    loggerFor<FileReadTools>().warn("Warning: Could not access file: {} ({})", file, exc.message)
                    return FileVisitResult.CONTINUE
                }
            })

            fileCount.get()
        } catch (e: Exception) {
            loggerFor<FileReadTools>().error("Failed to count files", e)
            0
        }
    }

    @Tool(description = "Find files using glob patterns. Return absolute paths")
    fun findFiles(glob: String): List<String> = findFiles(glob, findHighest = false)

    /**
     * Find files using glob patterns.
     * @param glob the glob pattern to match files against
     * @param findHighest if true, only the highest matching file in the directory tree will be returned
     * For example, if you want to find all Maven projects by looking for pom.xml files.
     */
    fun findFiles(
        glob: String,
        findHighest: Boolean,
    ): List<String> {
        val basePath = Paths.get(root).toAbsolutePath().normalize()
        val syntaxAndPattern = if (glob.startsWith("glob:") || glob.startsWith("regex:")) glob else "glob:$glob"
        val matcher = FileSystems.getDefault().getPathMatcher(syntaxAndPattern)
        val results = mutableListOf<String>()

        if (!findHighest) {
            return Files.walk(basePath).use { paths ->
                paths.filter { matcher.matches(basePath.relativize(it)) }
                    .map { it.toAbsolutePath().toString() }
                    .toList()
            }
        }

        // We need to process directories breadth-first to find the highest matches
        val processedDirs = mutableSetOf<String>()
        val queue = ArrayDeque<Path>()
        queue.offer(basePath)

        while (queue.isNotEmpty()) {
            val dir = queue.poll()
            val dirStr = dir.toAbsolutePath().toString()

            // Skip if we've already processed this directory
            if (dirStr in processedDirs) {
                continue
            }
            processedDirs.add(dirStr)

            // First, check if this directory itself matches
            if (Files.isRegularFile(dir) && matcher.matches(basePath.relativize(dir))) {
                results.add(dirStr)
                continue
            }

            try {
                // Look for matches in this directory
                val matchesInDir = mutableListOf<String>()
                val subdirs = mutableListOf<Path>()

                Files.newDirectoryStream(dir).use { stream ->
                    stream.forEach { entry ->
                        if (Files.isDirectory(entry)) {
                            subdirs.add(entry)
                        } else if (matcher.matches(basePath.relativize(entry))) {
                            matchesInDir.add(entry.toAbsolutePath().toString())
                        }
                    }
                }

                if (matchesInDir.isNotEmpty()) {
                    // Found matches in this directory, add them and don't process subdirectories
                    results.addAll(matchesInDir)

                    // Mark all subdirectories as processed so we don't look into them
                    subdirs.forEach { subdir ->
                        processedDirs.add(subdir.toAbsolutePath().toString())
                    }
                } else {
                    // No matches in this directory, so process subdirectories
                    queue.addAll(subdirs)
                }
            } catch (_: IOException) {
                loggerFor<FileReadTools>().warn("Failed to read directory at {}", dirStr)
                continue
            }
        }

        return results
    }

    /**
     * Use for safe reading of files. Returns null if the file doesn't exist or is not readable.
     */
    fun safeReadFile(path: String): String? = try {
        readFile(path)
    } catch (e: Exception) {
        loggerFor<FileReadTools>().warn("Failed to read file at {}: {}", path, e.message)
        null
    }

    @Tool(description = "Read a file at the relative path")
    fun readFile(path: String): String {
        val resolvedPath = resolveAndValidateFile(path)
        val rawContent = Files.readString(resolvedPath)
        val transformedContent =
            StringTransformer.transform(rawContent, fileContentTransformers)

        loggerFor<FileReadTools>().debug(
            "Transformed {} content with {} sanitizers: Length went from {} to {}",
            path,
            fileContentTransformers.size,
            "%,d".format(rawContent.length),
            "%,d".format(transformedContent.length),
        )
        recordRead(path)
        return transformedContent
    }

    @Tool(description = "List files and directories at a given path. Prefix is f: for file or d: for directory")
    fun listFiles(path: String): List<String> {
        val resolvedPath = resolvePath(path)
        if (!Files.exists(resolvedPath)) {
            throw IllegalArgumentException("Directory does not exist: $path, root=$root")
        }
        if (!Files.isDirectory(resolvedPath)) {
            throw IllegalArgumentException("Path is not a directory: $path, root=$root")
        }

        return Files.list(resolvedPath).use { stream ->
            stream.map {
                val prefix = if (Files.isDirectory(it)) "d:" else "f:"
                prefix + it.fileName.toString()
            }.sorted().toList()
        }
    }

    fun resolvePath(path: String): Path {
        return resolvePath(root, path)
    }

    fun resolveAndValidateFile(path: String): Path {
        return resolveAndValidateFile(root, path)
    }

}

/**
 * All file modifications must go through this interface.
 */
interface FileWriteTools : DirectoryBased, FileAccessLog, FileChangeLog, SelfToolCallbackPublisher {

    override fun getPathsAccessed(): List<String> = getChanges().map { it.path }.distinct()

    /**
     * Create a file at the relative path under the root
     */
    @Tool(description = "Create a file with the given content")
    fun createFile(
        path: String,
        content: String,
    ): String {
        createFile(path, content, overwrite = false)
        recordChange(FileModification(path, FileModificationType.CREATE))
        return "file created"
    }

    /**
     * Create a file with the given content.
     * @param path the relative path to create the file at
     * @param content the content to write to the file
     * @param overwrite if true, overwrite the file if it already exists
     * @return the path to the created file
     */
    fun createFile(
        path: String,
        content: String,
        overwrite: Boolean,
    ): Path {
        val resolvedPath = resolvePath(root, path)
        if (Files.exists(resolvedPath) && !overwrite) {
            logger.warn("File already exists at {}", path)
            throw IllegalArgumentException("File already exists: $path")
        }

        // Ensure parent directories exist
        Files.createDirectories(resolvedPath.parent)
        return Files.writeString(resolvedPath, content)
    }

    @Tool(description = "Edit the file at the given location. Replace oldContent with newContent. oldContent is typically just a part of the file. e.g. use it to replace a particular method to add another method")
    fun editFile(
        path: String,
        @ToolParam(description = "content to replace") oldContent: String,
        @ToolParam(description = "replacement content") newContent: String,
    ): String {
        logger.info("Editing file at path {}", path)
        logger.debug("File edit at path {}: {} -> {}", path, oldContent, newContent)
        val resolvedPath = resolveAndValidateFile(root = root, path = path)

        val oldFileContent = Files.readString(resolvedPath)
        val newFileContent = oldFileContent.replace(oldContent, newContent)

        return if (newFileContent == oldFileContent) {
            logger.warn(
                "editFile on {} produced no changes: oldContent=[{}], newContent=[{}]",
                resolvedPath,
                oldContent,
                newContent,
            )
            "no changes made"
        } else {
            Files.writeString(resolvedPath, newFileContent)
            logger.info("Edited file at {}", path)
            recordChange(FileModification(path, FileModificationType.EDIT))
            return "file edited"
        }
    }

    // April 25 2005: This method is the first method added to
    // an Embabel project by an Embabel agent
    @Tool(description = "Create a directory at the given path")
    fun createDirectory(path: String): String {
        val resolvedPath = resolvePath(root = root, path = path)
        if (Files.exists(resolvedPath)) {
            if (Files.isDirectory(resolvedPath)) {
                return "directory already exists"
            }
            throw IllegalArgumentException("A file already exists at this path: $path")
        }

        Files.createDirectories(resolvedPath)
        logger.info("Created directory at path: $path")
        recordChange(FileModification(path, FileModificationType.CREATE_DIRECTORY))
        return "directory created"
    }

    @Tool(description = "Append content to an existing file. The file must already exist.")
    fun appendFile(
        path: String,
        content: String,
    ): String {
        val resolvedPath = resolveAndValidateFile(root = root, path = path)
        Files.write(resolvedPath, content.toByteArray(), java.nio.file.StandardOpenOption.APPEND)
        logger.info("Appended content to file at path: $path")
        recordChange(FileModification(path, FileModificationType.APPEND))
        return "content appended to file"
    }

    /**
     * Append content to a file, creating it if it doesn't exist.
     * If create is true, the file will be created if it doesn't exist.
     * If createIfNotExists is false, an exception will be thrown if the file doesn't exist.
     */
    fun appendToFile(
        path: String,
        content: String,
        createIfNotExists: Boolean,
    ) {
        if (createIfNotExists) {
            try {
                createFile(path, content, overwrite = false)
                return
            } catch (_: IllegalArgumentException) {
                // Ignore if the file already exists
            }
        }
        appendFile(path, content)
    }

    @Tool(description = "Delete a file at the given path")
    fun delete(path: String): String {
        val resolvedPath = resolveAndValidateFile(root = root, path = path)
        Files.delete(resolvedPath)
        logger.info("Deleted file at path: $path")
        recordChange(FileModification(path, FileModificationType.DELETE))
        return "file deleted"
    }


    companion object {

        private val logger = LoggerFactory.getLogger(FileTools::class.java)

        /**
         * Create a temporary directory using the given seed
         */
        fun createTempDir(seed: String): File {
            val tempDir = Files.createTempDirectory(seed).toFile()
            val tempDirPath = tempDir.absolutePath
            logger.info("Created temporary directory at {}", tempDirPath)
            return tempDir
        }

        /**
         * Extract zip file to a temporary directory
         * @param zipFile the zip file to extract
         * @param tempDir directory to extract it under
         * @param delete if true, delete the zip file after extraction
         * @return the path to the extracted file content
         */
        fun extractZipFile(
            zipFile: File,
            tempDir: File,
            delete: Boolean,
        ): File {
            val projectDir = tempDir
            ZipInputStream(FileInputStream(zipFile)).use { zipInputStream ->
                var zipEntry = zipInputStream.nextEntry
                while (zipEntry != null) {
                    val newFile = File(projectDir, zipEntry.name)

                    // Create directories if needed
                    if (zipEntry.isDirectory) {
                        newFile.mkdirs()
                    } else {
                        // Create parent directories if needed
                        newFile.parentFile.mkdirs()

                        // Extract file
                        FileOutputStream(newFile).use { fileOutputStream ->
                            zipInputStream.copyTo(fileOutputStream)
                        }
                    }

                    zipInputStream.closeEntry()
                    zipEntry = zipInputStream.nextEntry
                }
            }

            logger.info("Extracted zip file project to {}", projectDir.absolutePath)

            if (delete) {
                zipFile.delete()
            }
            return File(projectDir, zipFile.nameWithoutExtension)
        }
    }

}

/**
 * Resolves a relative path against the root directory
 * Prevents path traversal attacks by ensuring the resolved path is within the root
 */
private fun resolvePath(
    root: String,
    path: String,
): Path {
    val basePath = Paths.get(root).toAbsolutePath().normalize()
    val resolvedPath = basePath.resolve(path).normalize().toAbsolutePath()

    if (!resolvedPath.startsWith(basePath)) {
        throw SecurityException("Path traversal attempt detected: $path, root=$root, resolved='$resolvedPath', base=$'basePath'")
    }
    return resolvedPath
}

/**
 * Resolves a path and validates that it exists and is a regular file
 * @throws IllegalArgumentException if the file doesn't exist or isn't a regular file
 */
private fun resolveAndValidateFile(
    root: String,
    path: String,
): Path {
    val resolvedPath = resolvePath(root = root, path = path)
    if (!Files.exists(resolvedPath)) {
        throw IllegalArgumentException("File does not exist: $path, root=$root")
    }
    if (!Files.isRegularFile(resolvedPath)) {
        throw IllegalArgumentException("Path is not a regular file: $path, root=$root")
    }
    return resolvedPath
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/tools/file/LocalDirectory.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.tools.file

import com.embabel.agent.api.common.LlmReference
import com.embabel.common.util.StringTransformer

/**
 * Readonly access to a project on the local filesystem.
 */
class LocalDirectory(
    override val root: String,
    override val description: String,
    val notes: String = "",
    override val fileContentTransformers: List<StringTransformer> =
        listOf(WellKnownFileContentTransformers.removeApacheLicenseHeader),
) : FileReadTools, PatternSearch,
    FileReadLog by DefaultFileReadLog(),
    LlmReference {

    override val name: String get() = root.substringAfterLast('/')

    override fun notes() = notes
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/tools/file/PatternSearch.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.tools.file

import com.embabel.agent.tools.DirectoryBased
import com.embabel.common.util.loggerFor
import org.springframework.ai.tool.annotation.Tool
import org.springframework.ai.tool.annotation.ToolParam
import java.io.File
import java.util.concurrent.atomic.AtomicBoolean
import kotlin.concurrent.thread

/**
 * Adds low level pattern search methods to the [com.embabel.agent.tools.DirectoryBased] interface
 */
interface PatternSearch : DirectoryBased {

    @Tool(description = "search for a regex in the project")
    fun findPatternInProject(
        @ToolParam(description = "regex pattern") pattern: String,
        @ToolParam(description = "glob pattern for files to search in") globPattern: String,
    ): String {
        return findPatternInProject(
            pattern = Regex(pattern),
            globPattern = globPattern,
        ).joinToString("\n") { "${it.file.path}:${it.matchedLine} ${it.contextLines.joinToString(" ")}" }
    }

    /**
     * Finds files containing the specified pattern using glob patterns
     * @param pattern The regex pattern to search for
     * @param globPattern Glob pattern to match files
     * @param useParallelSearch Whether to use parallel processing for faster searching
     * @return List of matching files with their relevant content snippets
     */
    fun findPatternInProject(
        pattern: Regex,
        globPattern: String,
        useParallelSearch: Boolean = true,
    ): List<PatternMatch> {
        val root = File(root)
        if (!root.exists() || !root.isDirectory) {
            throw IllegalArgumentException("Invalid root directory: $root")
        }

        val results = mutableListOf<PatternMatch>()
        val cancelled = AtomicBoolean(false)

        // Get all files recursively matching the glob pattern
        val allFiles = root.walkTopDown()
            .filter { it.isFile && matchesGlob(it.path, globPattern) }
            .toList()

        loggerFor<PatternSearch>().info(
            "Scanning {} files found using glob '{}' for regex pattern '{}'...",
            allFiles.size,
            globPattern,
            pattern.pattern
        )

        if (useParallelSearch && allFiles.size > 100) {
            // For larger projects, process files in parallel
            val numThreads = Runtime.getRuntime().availableProcessors()
            val chunks = allFiles.chunked(allFiles.size / numThreads + 1)
            val threads = chunks.map { chunk ->
                thread {
                    val threadResults = mutableListOf<PatternMatch>()
                    for (file in chunk) {
                        if (cancelled.get()) break
                        scanFile(file, pattern)?.let { threadResults.add(it) }
                    }
                    synchronized(results) {
                        results.addAll(threadResults)
                    }
                }
            }
            threads.forEach { it.join() }
        } else {
            // For smaller projects, process sequentially
            for (file in allFiles) {
                scanFile(file, pattern)?.let { results.add(it) }
            }
        }

        return results
    }

    /**
     * Represents a matching file with context
     */
    data class PatternMatch(
        val file: File,
        val relativePath: String,
        val matchedLine: Int,
        val contextLines: List<String>,
    )

    /**
     * Scans a single file for the pattern
     */
    private fun scanFile(
        file: File,
        pattern: Regex,
    ): PatternMatch? {
        try {
            val lines = file.readLines()

            // Quick check before detailed parsing
            val fileContent = file.readText()
            if (!pattern.containsMatchIn(fileContent)) return null

            // Look for class, interface, object, or enum declarations
            for (i in lines.indices) {
                val line = lines[i]

                // Check for class/interface/object declaration
                if (pattern.containsMatchIn(line)
                ) {

                    // Gather context lines
                    val startLine = maxOf(0, i - 2)
                    val endLine = minOf(lines.size - 1, i + 5)
                    val contextLines = lines.subList(startLine, endLine + 1)

                    return PatternMatch(
                        file = file,
                        relativePath = file.path,
                        matchedLine = i + 1,
                        contextLines = contextLines
                    )
                }
            }

            return null
        } catch (e: Exception) {
            loggerFor<PatternSearch>().warn("Error scanning file ${file.path}: ${e.message}")
            return null
        }
    }

    /**
     * Checks if a file path matches a glob pattern
     * @param path The file path to check
     * @param globPattern The glob pattern to match against
     * @return true if the path matches the pattern
     */
    fun matchesGlob(
        path: String,
        globPattern: String,
    ): Boolean {
        val pathParts = path.replace("\\", "/").split("/")
        val patternParts = globPattern.replace("\\", "/").split("/")

        // Convert glob pattern to regex
        val regexPattern = patternParts.joinToString("/") { part ->
            when {
                part == "**" -> ".*"
                part.contains("*") || part.contains("?") || part.contains("{") -> {
                    // Handle extensions like *.{kt,java}
                    if (part.contains("{") && part.contains("}")) {
                        val prefix = part.substringBefore("{")
                        val options = part.substringAfter("{").substringBefore("}").split(",")
                        val suffix = part.substringAfter("}")

                        "$prefix(${options.joinToString("|")})$suffix"
                            .replace(".", "\\.")
                            .replace("*", ".*")
                            .replace("?", ".")
                    } else {
                        part.replace(".", "\\.")
                            .replace("*", ".*")
                            .replace("?", ".")
                    }
                }

                else -> part
            }
        }

        return path.replace("\\", "/").matches(Regex(regexPattern))
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/tools/file/WellKnownFileContentTransformers.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.tools.file

import com.embabel.common.util.StringTransformer
import com.embabel.common.util.loggerFor

/**
 * Provides common implementations of FileContentTransformer for reducing file content bloat.
 * These transformers can be used to clean up file content before sending it to LLMs or other
 * text processing systems to reduce token usage and improve performance by helping them to
 * focus on essential code.
 */
object WellKnownFileContentTransformers {

    private val logger = loggerFor<WellKnownFileContentTransformers>()

    /**
     * Removes Apache License headers commonly found at the top of source files.
     */
    val removeApacheLicenseHeader: StringTransformer = StringTransformer { content ->
        val apacheLicensePattern = Regex(
            "/\\*\\s*\\n" +
                    " \\* Copyright .*?\\n" +
                    "(?:.|\\n)*?" +  // Non-greedy match for any characters including newlines
                    " \\* limitations under the License\\.\\s*\\n" +
                    " \\*/\\s*\\n",
            RegexOption.MULTILINE
        )

        val result = apacheLicensePattern.replace(content, "")
        logger.debug("Apache License Header sanitizer: removed {} characters", content.length - result.length)
        result
    }

    /**
     * Removes documentation comments (/** ... */) from the code.
     */
    val removeDocComments: StringTransformer = StringTransformer { content ->
        val docCommentPattern = Regex(
            "/\\*\\*\\s*\\n" +
                    "(?:.|\\n)*?" +  // Non-greedy match for any characters including newlines
                    "\\s*\\*/",
            RegexOption.MULTILINE
        )

        val result = docCommentPattern.replace(content, "")
        logger.debug("Doc comments sanitizer: removed {} characters", content.length - result.length)
        result
    }

    /**
     * Removes single-line comments (// ...) from the code.
     */
    val removeSingleLineComments: StringTransformer = StringTransformer { content ->
        val singleLineCommentPattern = Regex("\\s*//.*$", RegexOption.MULTILINE)

        val result = singleLineCommentPattern.replace(content, "")
        logger.debug("Single line comments sanitizer: removed {} characters", content.length - result.length)
        result
    }

    /**
     * Removes import statements from the code.
     */
    val removeImports: StringTransformer = StringTransformer { content ->
        val importPattern = Regex("import .*$\\n", RegexOption.MULTILINE)

        val result = importPattern.replace(content, "")
        logger.debug("Import statements sanitizer: removed {} characters", content.length - result.length)
        result
    }

    /**
     * Removes empty lines from file content
     */
    val removeEmptyLines: StringTransformer = StringTransformer { content ->
        val emptyLinePattern = Regex("^\\s*$\\n", RegexOption.MULTILINE)

        val result = emptyLinePattern.replace(content, "")
        logger.debug("Empty lines sanitizer: removed {} characters", content.length - result.length)
        result
    }

    /**
     * Removes excessive whitespace from file content
     */
    val compressWhitespace: StringTransformer = StringTransformer { content ->
        // Replace multiple spaces with a single space
        val multipleSpacesPattern = Regex("[ \\t]+")
        // Replace multiple consecutive empty lines with a single empty line
        val multipleEmptyLinesPattern = Regex("\\n{3,}")

        val intermediate = multipleSpacesPattern.replace(content, " ")
        val result = multipleEmptyLinesPattern.replace(intermediate, "\n\n")

        logger.debug("Whitespace compression sanitizer: removed {} characters", content.length - result.length)
        result
    }

    /**
     * Returns all available sanitizers in a sensible order for maximum content reduction.
     * The order is important to ensure proper sanitization.
     */
    fun allSanitizers(): List<StringTransformer> {
        logger.debug("Creating all sanitizers list")
        return listOf(
            removeApacheLicenseHeader,
            removeDocComments,
            removeSingleLineComments,
            removeImports,
            removeEmptyLines,
            compressWhitespace,
        )
    }

    /**
     * Returns a minimal set of sanitizers that preserve code structure
     * while still reducing file size.
     */
    fun minimalSanitizers(): List<StringTransformer> {
        logger.debug("Creating minimal sanitizers list")
        return listOf(
            removeApacheLicenseHeader,
            removeDocComments,
            compressWhitespace
        )
    }

    /**
     * Returns sanitizers focused on comment removal only.
     */
    fun commentRemovalSanitizers(): List<StringTransformer> {
        logger.debug("Creating comment removal sanitizers list")
        return listOf(
            removeApacheLicenseHeader,
            removeDocComments,
            removeSingleLineComments
        )
    }

    /**
     * Returns sanitizers focused on whitespace cleanup only.
     */
    fun whitespaceCleanupSanitizers(): List<StringTransformer> {
        logger.debug("Creating whitespace cleanup sanitizers list")
        return listOf(
            removeEmptyLines,
            compressWhitespace
        )
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/tools/math/MathTools.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.tools.math

import com.embabel.agent.api.common.support.SelfToolGroup
import com.embabel.agent.common.Constants
import com.embabel.agent.core.CoreToolGroups.MATH_DESCRIPTION
import com.embabel.agent.core.ToolGroupDescription
import com.embabel.agent.core.ToolGroupPermission
import com.embabel.common.core.types.Semver
import org.springframework.ai.tool.annotation.Tool

class MathTools : SelfToolGroup {

    override val description: ToolGroupDescription = MATH_DESCRIPTION

    override val provider: String = Constants.EMBABEL_PROVIDER
    override val version = Semver(0, 1, 0)
    override val permissions: Set<ToolGroupPermission>
        get() = emptySet()

    @Tool(description = "add two numbers")
    fun add(a: Double, b: Double) = a + b

    @Tool(description = "subtract the second number from the first")
    fun subtract(a: Double, b: Double) = a - b

    @Tool(description = "multiply two numbers")
    fun multiply(a: Double, b: Double) = a * b

    @Tool(description = "divide the first number by the second")
    fun divide(a: Double, b: Double): String =
        if (b == 0.0) "Cannot divide by zero" else ("" + a / b)

    @Tool(description = "find the mean of this list of numbers")
    fun mean(numbers: List<Double>): Double =
        if (numbers.isEmpty()) 0.0 else numbers.sum() / numbers.size

    @Tool(description = "find the minimum value in a list of numbers")
    fun min(numbers: List<Double>): Double =
        numbers.minOrNull() ?: Double.NaN

    @Tool(description = "find the maximum value in a list of numbers")
    fun max(numbers: List<Double>): Double =
        numbers.maxOrNull() ?: Double.NaN

    @Tool(description = "round down to the nearest integer")
    fun floor(number: Double): Double = kotlin.math.floor(number)

    @Tool(description = "round up to the nearest integer")
    fun ceiling(number: Double): Double = kotlin.math.ceil(number)

    @Tool(description = "round to the nearest integer")
    fun round(number: Double): Double = kotlin.math.round(number).toDouble()
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/tools/mcp/McpToolGroup.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.tools.mcp

import com.embabel.agent.core.ToolGroup
import com.embabel.agent.core.ToolGroupDescription
import com.embabel.agent.core.ToolGroupMetadata
import com.embabel.agent.core.ToolGroupPermission
import com.embabel.common.core.types.Semver
import com.embabel.common.util.loggerFor
import io.modelcontextprotocol.client.McpSyncClient
import org.springframework.ai.mcp.SyncMcpToolCallbackProvider
import org.springframework.ai.tool.ToolCallback

/**
 * ToolGroup backed by MCP
 * @param description Description of the tool group
 * @param provider Name of the provider of the tool group
 * @param name Name of the tool group
 * @param permissions Permissions the tools requires
 * @param clients List of MCP clients to use to load tools
 * @param filter predicate that returns true to include a tool
 *
 */
class McpToolGroup(
    description: ToolGroupDescription,
    provider: String,
    name: String,
    permissions: Set<ToolGroupPermission>,
    private val clients: List<McpSyncClient>,
    filter: ((ToolCallback) -> Boolean),
) : ToolGroup {

    override val metadata: ToolGroupMetadata = ToolGroupMetadata(
        description = description,
        name = name,
        provider = provider,
        version = Semver(0, 1, 0),
        permissions = permissions,
    )

    override val toolCallbacks: List<ToolCallback> = run {
        try {
            val provider = SyncMcpToolCallbackProvider(
                clients,
            )
            val toolCallbacks = provider.toolCallbacks.filter(filter)
            loggerFor<McpToolGroup>().debug(
                "ToolGroup role={}: {}",
                description.role,
                toolCallbacks.map { it.toolDefinition.name() })
            toolCallbacks
        } catch (e: Exception) {
            loggerFor<McpToolGroup>().error(
                "Failed to load tool callbacks for role {}: {}",
                description.role,
                e.message,
            )
            emptyList()
        }
    }

    override fun toString(): String =
        "McpToolGroup(metadata=$metadata, tools=${toolCallbacks.map { it.toolDefinition.name() }})"
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/tools/osx/AppleScriptTools.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.tools.osx

import com.embabel.agent.api.common.support.SelfToolGroup
import com.embabel.agent.common.Constants
import com.embabel.agent.core.ToolGroupDescription
import com.embabel.agent.core.ToolGroupPermission
import com.embabel.common.core.types.Semver
import com.embabel.common.util.MacOSCondition
import org.springframework.ai.tool.annotation.Tool
import org.springframework.context.annotation.Conditional
import org.springframework.context.annotation.Profile
import org.springframework.stereotype.Service

/**
 * Simple AppleScript integration for automation on OS/X
 */
@Service
@Profile("!test")
@Conditional(MacOSCondition::class)
class AppleScriptTools : SelfToolGroup {

    override val version = Semver(0, 1, 0)

    override val provider = Constants.EMBABEL_PROVIDER

    override val description: ToolGroupDescription
        get() = ToolGroupDescription(role = "AppleScript", description = "Run AppleScript commands")

    override val permissions: Set<ToolGroupPermission>
        get() = setOf(ToolGroupPermission.HOST_ACCESS)

    @Tool(description = "Run AppleScript command")
    fun runAppleScript(script: String): String {
        val runtime = Runtime.getRuntime()
        val process = runtime.exec(arrayOf("osascript", "-e", script))
        val exitCode = process.waitFor()
        return "Script executed with exit code: $exitCode"
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/validation/AgentStructureValidator.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.validation

import com.embabel.agent.api.annotation.Action
import com.embabel.agent.api.annotation.Agent
import com.embabel.agent.api.annotation.Condition
import com.embabel.agent.core.AgentScope
import com.embabel.common.util.loggerFor
import org.springframework.beans.factory.InitializingBean
import org.springframework.context.ApplicationContext
import org.springframework.stereotype.Component

/**
 * Validator that checks the fundamental structure of agent definitions.
 *
 * Ensures that each agent has at least one goal, action, or condition defined,
 * and validates that action and condition method signatures are correct and conform to expected patterns.
 *
 * Specific checks include:
 * - Detecting empty agents (no actions, conditions, or goals)
 * - Enforcing that agents have at least one goal
 * - Verifying that action and condition methods have valid parameter signatures
 *
 * Reports detailed validation errors for structural issues, helping ensure that only well-formed
 * agents are registered or used in the system.
 */
@Component
class AgentStructureValidator(
    val context: ApplicationContext,
) : InitializingBean, AgentValidator {

    override fun afterPropertiesSet() {
        val agentBeans = context.getBeansWithAnnotation(Agent::class.java)
        agentBeans.values.forEach { bean ->
            val clazz = getOriginalClass(bean.javaClass)
            val actionMethods = clazz.declaredMethods.filter { it.isAnnotationPresent(Action::class.java) }
            val conditionMethods = clazz.declaredMethods.filter { it.isAnnotationPresent(Condition::class.java) }
            val hasGoalsField = clazz.declaredFields.any { it.name == "goals" }
            val hasGoalsMethod = clazz.methods.any { it.name == "getGoals" }
            val hasGoals = hasGoalsField || hasGoalsMethod

            if (actionMethods.isEmpty() && conditionMethods.isEmpty() && !hasGoals) {
                val error = ValidationError(
                    code = "EMPTY_AGENT_STRUCTURE",
                    message = "Agent class '${clazz.name}' has no @Action or @Condition methods and no goals defined. This agent will NOT be registered!",
                    severity = ValidationSeverity.ERROR,
                    location = ValidationLocation(
                        type = "Agent",
                        name = clazz.name,
                        agentName = clazz.name,
                        component = clazz.name
                    )
                )
                loggerFor<AgentStructureValidator>().warn(error.toString())
            }
        }
    }

    override fun validate(agentScope: AgentScope): ValidationResult {
        val errors = mutableListOf<ValidationError>()

        // Check for methods and goals
        if (agentScope.actions.isEmpty() && agentScope.conditions.isEmpty() && agentScope.goals.isEmpty()) {
            errors.add(
                ValidationError(
                    code = "EMPTY_AGENT_STRUCTURE",
                    message = "Agent '${agentScope.name}' has no actions, conditions, or goals defined",
                    severity = ValidationSeverity.ERROR,
                    location = ValidationLocation(
                        type = "Agent",
                        name = agentScope.name,
                        agentName = agentScope.name,
                        component = agentScope.name
                    )
                )
            )
        }

        // Validate that the agent has at least one goal
        if (agentScope.goals.isEmpty()) {
            errors.add(
                ValidationError(
                    code = "MISSING_GOALS",
                    message = "Agent '${agentScope.name}' must have at least one goal defined",
                    severity = ValidationSeverity.ERROR,
                    location = ValidationLocation(
                        type = "Agent",
                        name = agentScope.name,
                        agentName = agentScope.name,
                        component = agentScope.name
                    )
                )
            )
        }

        // Validate action signatures
        agentScope.actions.forEach { action ->
            // Check if the action has any preconditions that require multiple parameters
            val preconditionsWithMultipleParams = action.preconditions.any { (preconditionName, _) ->
                val clazz = getOriginalClass(agentScope.javaClass)
                val method = clazz.declaredMethods.find { it.name == preconditionName }
                method?.parameterCount ?: 0 > 1
            }

            if (preconditionsWithMultipleParams) {
                errors.add(
                    ValidationError(
                        code = "INVALID_ACTION_SIGNATURE",
                        message = "Action '${action.name}' has preconditions with multiple parameters",
                        severity = ValidationSeverity.ERROR,
                        location = ValidationLocation(
                            type = "Action",
                            name = action.name,
                            agentName = agentScope.name,
                            component = agentScope.name
                        )
                    )
                )
            }
        }

        // Validate conditions
        agentScope.conditions.forEach { condition ->
            val clazz = getOriginalClass(agentScope.javaClass)
            val method = clazz.declaredMethods.find { it.name == condition.name }

            if (method?.parameterCount ?: 0 > 1) {
                errors.add(
                    ValidationError(
                        code = "INVALID_CONDITION_SIGNATURE",
                        message = "Condition '${condition.name}' must have at most one parameter",
                        severity = ValidationSeverity.ERROR,
                        location = ValidationLocation(
                            type = "Condition",
                            name = condition.name,
                            agentName = agentScope.name,
                            component = agentScope.name
                        )
                    )
                )
            }
        }

        return ValidationResult(errors.isEmpty(), errors)
    }

    // Unwraps proxy if needed (for classes proxied by Spring)
    private fun getOriginalClass(clazz: Class<*>): Class<*> {
        return if (clazz.name.contains("\$Proxy") || clazz.name.contains("CGLIB")) {
            clazz.superclass ?: clazz
        } else clazz
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/validation/AgentValidationManager.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.validation

import com.embabel.agent.core.AgentScope

interface AgentValidationManager {
    fun validate(agentScope: AgentScope): ValidationResult
    fun validateWithDetails(agentScope: AgentScope): DetailedValidationResult
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/validation/AgentValidator.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.validation

import com.embabel.agent.core.*

fun interface AgentValidator {
    fun validate(agentScope: AgentScope): ValidationResult
}

data class ValidationResult(
    val isValid: Boolean,
    val errors: List<ValidationError>
)

data class ValidationError(
    val code: String,
    val message: String,
    val severity: ValidationSeverity,
    val location: ValidationLocation
)

enum class ValidationSeverity {
    ERROR,
    WARNING,
    INFO
}

data class ValidationLocation(
    val type: String,
    val name: String,
    val agentName: String,
    val component: String
)



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/validation/DefaultAgentValidationManager.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.validation

import com.embabel.agent.core.AgentScope
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service


/**
 * Default implementation of [AgentValidationManager] that coordinates multiple [AgentValidator]s.
 *
 * Runs all configured validators on the provided [AgentScope] and aggregates their results,
 * collecting and reporting all validation errors or warnings.
 *
 * Supports both summary validation and detailed per-validator results.
 * Useful for extensible, modular validation pipelines where multiple agent checks
 * (such as structure, method signatures, and path-to-goal validation) are required.
 */
@Service
class DefaultAgentValidationManager(
    private val validators: List<AgentValidator>
) : AgentValidationManager {

    private val logger = LoggerFactory.getLogger(DefaultAgentValidationManager::class.java)

    override fun validate(agentScope: AgentScope): ValidationResult {
        val allErrors = validators.flatMap { validator ->
            validator.validate(agentScope).errors
        }

        if (allErrors.isNotEmpty()) {
            logger.error("Validation failed with ${allErrors.size} errors:")
            allErrors.forEach { error ->
                logger.error("- ${error.code}: ${error.message}")
            }
        } else {
            logger.debug("Validation passed for agent ${agentScope.name}")
        }

        return ValidationResult(allErrors.isEmpty(), allErrors)
    }

    override fun validateWithDetails(agentScope: AgentScope): DetailedValidationResult {
        val validationResults = validators.associateWith { validator ->
            validator.validate(agentScope)
        }
        return DetailedValidationResult(
            results = validationResults,
            isValid = validationResults.values.all { it.isValid }
        )
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/validation/DetailedValidationResult.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.validation

data class DetailedValidationResult(
    val isValid: Boolean,
    val results: Map<AgentValidator, ValidationResult>
)



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/validation/GoapPathToCompletionValidator.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.validation

import com.embabel.agent.core.AgentScope
import com.embabel.agent.core.support.Rerun.HAS_RUN_CONDITION_PREFIX
import com.embabel.plan.goap.*
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Component

/**
 * Validator that checks whether an agent definition has at least one possible path
 * from its initial conditions, through available actions, to achieve its defined goals.
 *
 * Uses the GOAP planner to validate that goals can be achieved through a sequence of actions.
 * Reports specific errors when no such path exists.
 */
@Component
class GoapPathToCompletionValidator : AgentValidator {

    private val logger = LoggerFactory.getLogger(GoapPathToCompletionValidator::class.java)

    override fun validate(agentScope: AgentScope): ValidationResult {
        val errors = mutableListOf<ValidationError>()

        if (agentScope.goals.isEmpty()) {
            return ValidationResult(true, emptyList())
        }

        if (agentScope.actions.isEmpty()) {
            errors.add(error("NO_ACTIONS_TO_GOALS", "Agent '${agentScope.name}' has no actions.", agentScope))
            return ValidationResult(false, errors)
        }

        // Create initial world state
        val initialWorldState = mutableMapOf<String, ConditionDetermination>()

        val actionDependencies = mutableMapOf<String, Set<String>>()
        val actionOutputs = mutableMapOf<String, Set<String>>()

        // For each action, need to track:
        // 1. What data it needs as input (preconditions)
        // 2. What data it produces as output (effects)
        // So need to exclude hasRun_ conditions as they are runtime state indicators, not data dependencies.
        agentScope.actions.forEach { action ->
            val nonHasRunPreconditions =
                action.preconditions.filterKeys { !it.startsWith(HAS_RUN_CONDITION_PREFIX) }.keys
            val nonHasRunEffects = action.effects.filterKeys { !it.startsWith(HAS_RUN_CONDITION_PREFIX) }.keys

            actionDependencies[action.name] = nonHasRunPreconditions
            actionOutputs[action.name] = nonHasRunEffects
        }

        // Find actions that can be considered first steps (executable without other actions)
        // These actions either:
        // 1. Have no preconditions (other than hasRun_ conditions), or
        // 2. Have preconditions that are set to FALSE (meaning they don't need to be true), or
        // 3. Have preconditions not produced by any other action (external input)
        val firstActions = agentScope.actions.filter { action ->
            val rawDeps = actionDependencies[action.name] ?: emptySet()
            val outputsOfThisAction = action.effects.keys

            // Remove anything this action itself produces (self-sufficient actions)
            val deps = rawDeps.filterNot { dep -> outputsOfThisAction.contains(dep) }.toSet()

            // Action can be first if:
            // 1. It has no external dependencies, OR
            // 2. All its dependencies are either not produced by other actions OR set to FALSE
            deps.isEmpty() || deps.all { dep ->
                val isProducedByOthers = actionOutputs.values.any { outputs -> outputs.contains(dep) }
                val preconditionValue = action.preconditions[dep]

                // Can start if dependency is not produced by others, or if it's explicitly set to FALSE
                !isProducedByOthers || preconditionValue == ConditionDetermination.FALSE
            }
        }

        if (firstActions.isEmpty()) {
            errors.add(
                error(
                    "NO_STARTING_ACTION",
                    "No action found that can start the chain. All actions depend on outputs from other actions.",
                    agentScope
                )
            )
            return ValidationResult(false, errors)
        }

        logger.debug("First actions: {}", firstActions.map { it.name })

        // Start by collecting all conditions mentioned in actions and goals
        val allConditions = mutableSetOf<String>()

        agentScope.actions.forEach { action ->
            allConditions.addAll(action.preconditions.keys.filter { !it.startsWith(HAS_RUN_CONDITION_PREFIX) })
            allConditions.addAll(action.effects.keys.filter { !it.startsWith(HAS_RUN_CONDITION_PREFIX) })
        }

        agentScope.goals.forEach { goal ->
            allConditions.addAll(goal.preconditions.keys.filter { !it.startsWith(HAS_RUN_CONDITION_PREFIX) })
        }

        // Initialize all conditions to FALSE by default
        allConditions.forEach { condition ->
            initialWorldState[condition] = ConditionDetermination.FALSE
        }

        // For first actions that have no preconditions (can run immediately),
        // we assume their effects are immediately available
        firstActions.forEach { action ->
            // For actions with no TRUE preconditions (can run immediately),
            // make their effects available in the initial state
            val hasTruePreconditions = action.preconditions.any { (key, value) ->
                !key.startsWith(HAS_RUN_CONDITION_PREFIX) && value == ConditionDetermination.TRUE
            }

            if (!hasTruePreconditions) {
                action.effects.forEach { (key, value) ->
                    if (!key.startsWith(HAS_RUN_CONDITION_PREFIX) && value == ConditionDetermination.TRUE) {
                        logger.debug("✅ Setting initialWorldState[$key] = TRUE from effect of ${action.name} (no preconditions)")
                        initialWorldState[key] = ConditionDetermination.TRUE
                    }
                }
            }
        }

        // Set to TRUE any condition that is an external input (appears as a precondition but not as an effect)
        allConditions.forEach { condition ->
            val isProducedByAction = agentScope.actions.any { action ->
                action.effects.containsKey(condition) && action.effects[condition] == ConditionDetermination.TRUE
            }
            val isNeededByAction = agentScope.actions.any { action ->
                action.preconditions.containsKey(condition) && action.preconditions[condition] == ConditionDetermination.TRUE
            }

            // If it's needed but not produced by any action, it must be an external input
            if (isNeededByAction && !isProducedByAction && !condition.startsWith(HAS_RUN_CONDITION_PREFIX)) {
                logger.debug("✅ Setting initialWorldState[$condition] = TRUE as external input")
                initialWorldState[condition] = ConditionDetermination.TRUE
            }
        }

        logger.debug(
            "Final initialWorldState: {}",
            initialWorldState.entries.joinToString { "${it.key} -> ${it.value}" })

        // Create planner with the determined world state
        val planner = AStarGoapPlanner(WorldStateDeterminer.fromMap(initialWorldState))

        // Convert agent actions to GOAP actions, removing hasRun_ conditions
        val goapActions = agentScope.actions.map { action ->
            GoapAction(
                name = action.name,
                preconditions = action.preconditions.filterKeys { !it.startsWith(HAS_RUN_CONDITION_PREFIX) },
                effects = action.effects.filterKeys { !it.startsWith(HAS_RUN_CONDITION_PREFIX) },
                cost = action.cost,
                value = action.value
            )
        }.toSet()

        // Check each goal
        var allGoalsAchievable = true
        val failedGoals = mutableListOf<String>()

        for (goal in agentScope.goals) {
            // Find the action that is annotated with @AchievesGoal and matches this goal
            val goalAction = agentScope.actions.find { it.name == goal.name }

            if(goalAction == null) {
                logger.error("Goal action '${goal.name}' not found in agent actions. Skipping this goal.")
                continue
            }

            // For goal actions, we achieve the action's effects.
            // The goal is to reach a state where the action has run and produced its outputs
            val goalPreconditions = goalAction.effects
                .filterKeys { !it.startsWith(HAS_RUN_CONDITION_PREFIX) }
                .filterValues { it == ConditionDetermination.TRUE }

            val goapGoal = GoapGoal(
                name = goal.name,
                preconditions = goalPreconditions,
                value = goal.value
            )

            // Try to find a plan to this goal
            val plan = planner.planToGoal(goapActions, goapGoal)

            if (plan == null || plan.actions.isEmpty()) {
                allGoalsAchievable = false
                failedGoals.add(goal.name)
                logger.debug("❌ No plan found for goal: ${goal.name}")
                logger.debug("  Goal preconditions (desired effects): {}", goapGoal.preconditions)
            } else {
                logger.debug("✅ Plan found for goal: ${goal.name}")
                logger.debug("  Actions: {}", plan.actions.map { it.name })
            }
        }

        if (!allGoalsAchievable) {
            errors.add(
                error(
                    "NO_PATH_TO_GOAL",
                    "No valid path found to achieve goals: ${failedGoals.joinToString(", ")}. " +
                            "Either no plan exists or the goals' preconditions cannot be achieved through available actions.",
                    agentScope
                )
            )
        }

        return ValidationResult(errors.isEmpty(), errors)
    }

    private fun error(code: String, message: String, agentScope: AgentScope): ValidationError =
        ValidationError(
            code = code,
            message = message,
            severity = ValidationSeverity.ERROR,
            location = ValidationLocation(
                type = "Agent",
                name = agentScope.name,
                agentName = agentScope.name,
                component = agentScope.name
            )
        )
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/web/rest/README.md
================================================
# Endpoints to expose agent platform information


================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/web/rest/AgentProcessController.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.web.rest

import com.embabel.agent.core.AgentPlatform
import com.embabel.agent.core.AgentProcessStatusCode
import com.embabel.agent.core.AgentProcessStatusReport
import com.embabel.agent.core.OperationStatus
import com.embabel.common.core.types.Timed
import com.embabel.common.core.types.Timestamped
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.tags.Tag
import org.slf4j.LoggerFactory
import org.springframework.http.HttpStatus
import org.springframework.web.bind.annotation.*
import org.springframework.web.server.ResponseStatusException
import java.time.Duration
import java.time.Instant

/**
 * Return status of the process and URLs for status and SSE streaming.
 * @param id Unique identifier of the agent process.
 * @param status Current status of the agent process.
 * @param result The last result of the agent process, if available.
 * @param statusUrl URL to check the status of the process.
 * @param sseUrl URL to request Server-Sent Events (SSE) streaming of the process status.
 */
data class AgentProcessStatus(
    val id: String,
    override val status: AgentProcessStatusCode,
    override val timestamp: Instant,
    override val runningTime: Duration,
    val result: Any?,
    val statusUrl: String = "/api/v1/process/$id",
    val sseUrl: String = "/events/process/$id/status",
) : Timestamped, Timed, OperationStatus<AgentProcessStatusCode>

@RestController
@RequestMapping("/api/v1/process")
@Tag(
    name = "AgentProcess information and control",
    description = "Endpoints for retrieving AgentProcess information, including status and results."
)
class AgentProcessController(
    private val agentPlatform: AgentPlatform,
) {

    private val logger = LoggerFactory.getLogger(AgentProcessController::class.java)

    @Operation(
        summary = "Get the status of a process",
        description = "Returns the status of the process with the given ID, including its current status, running time, and last result.",
    )
    @ApiResponses(
        value = [
            ApiResponse(responseCode = "200", description = "Process status returned"),
            ApiResponse(responseCode = "404", description = "Process not found")
        ]
    )
    @GetMapping("/{processId}")
    fun checkProcessStatus(@PathVariable processId: String): AgentProcessStatus {
        val agentProcess = agentPlatform.getAgentProcess(processId)
            ?: throw ResponseStatusException(HttpStatus.NOT_FOUND, "Process not found")

        return AgentProcessStatus(
            id = agentProcess.id,
            status = agentProcess.status,
            timestamp = agentProcess.timestamp,
            runningTime = agentProcess.runningTime,
            result = agentProcess.lastResult(),
        )
    }

    @DeleteMapping("/{id}")
    @Operation(
        summary = "Kill the given process",
        description = "Returns the status of a process if it could be killed"
    )
    @ApiResponses(
        value = [
            ApiResponse(responseCode = "200", description = "Process status killed successfully"),
            ApiResponse(responseCode = "404", description = "Process not found")
        ]
    )
    fun killAgentProcess(@PathVariable id: String): AgentProcessStatusReport {
        val killedProcess = agentPlatform.killAgentProcess(id)
            ?: throw ResponseStatusException(
                HttpStatus.NOT_FOUND,
                "No process found with id: $id",
            )
        return killedProcess.statusReport()
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/web/rest/CustomErrorController.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.web.rest

import jakarta.servlet.RequestDispatcher
import jakarta.servlet.http.HttpServletRequest
import org.slf4j.LoggerFactory
import org.springframework.boot.web.servlet.error.ErrorController
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
class CustomErrorController : ErrorController {

    private val logger = LoggerFactory.getLogger(CustomErrorController::class.java)

    @RequestMapping("/error")
    fun handleError(request: HttpServletRequest): ResponseEntity<Map<String, Any>> {
        val status = getErrorStatus(request)
        val path = request.getAttribute(RequestDispatcher.ERROR_REQUEST_URI) as String?
        val method = request.method

        if (status == HttpStatus.NOT_FOUND) {
            logger.warn("404 Not Found - Method: $method, Path: $path, Client IP: ${getClientIp(request)}")
        }

        return ResponseEntity.status(status).body(
            mapOf<String, Any>(
                "status" to status.value(),
                "error" to status.reasonPhrase,
                "path" to (path ?: "Unknown path"),
            )
        )
    }

    private fun getErrorStatus(request: HttpServletRequest): HttpStatus {
        val statusCode = request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE) as Int?
        return statusCode?.let { HttpStatus.valueOf(it) } ?: HttpStatus.INTERNAL_SERVER_ERROR
    }

    private fun getClientIp(request: HttpServletRequest): String {
        return request.getHeader("X-Forwarded-For")
            ?: request.getHeader("X-Real-IP")
            ?: request.remoteAddr
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/web/rest/PlatformInfoController.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.web.rest

import com.embabel.agent.core.*
import com.embabel.common.ai.model.ModelMetadata
import com.embabel.common.ai.model.ModelProvider
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.tags.Tag
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController


/**
 * Provides endpoints to retrieve general platform information, including agents, goals, actions, and conditions.
 */
@RestController
@RequestMapping("/api/v1/platform-info")
@Tag(
    name = "Platform Information",
    description = "Endpoints for retrieving platform, agents, goals, actions, and conditions information."
)
class PlatformInfoController(
    private val agentPlatform: AgentPlatform,
    private val modelProvider: ModelProvider,
) {
    /**
     * Returns a list of all agents deployed on the platform.
     *
     * @return List of agents with their details
     */
    @GetMapping("/agents")
    @Operation(
        summary = "Get all agents",
        description = "Returns a list of all agents deployed on the platform."
    )
    @ApiResponses(
        value = [
            ApiResponse(responseCode = "200", description = "List of agents returned successfully")
        ]
    )
    fun getAgents(): List<AgentMetadata> = agentPlatform.agents().map { AgentMetadata(it) }.sortedBy { it.name }

    /**
     * Returns a list of all goals known to the platform (across all agents).
     *
     * @return List of goals
     */
    @GetMapping("/goals")
    @Operation(
        summary = "Get all goals",
        description = "Returns a list of all goals known to the platform (across all agents)."
    )
    @ApiResponses(
        value = [
            ApiResponse(responseCode = "200", description = "List of goals returned successfully")
        ]
    )
    fun getGoals(): Set<Goal> = agentPlatform.goals

    /**
     * Returns a list of all actions available on the platform (across all agents).
     *
     * @return List of actions
     */
    @GetMapping("/actions")
    @Operation(
        summary = "Get all actions",
        description = "Returns a list of all actions available on the platform (across all agents)."
    )
    @ApiResponses(
        value = [
            ApiResponse(responseCode = "200", description = "List of actions returned successfully")
        ]
    )
    fun getActions(): List<ActionMetadata> = agentPlatform.actions.map { ActionMetadata(it) }.sortedBy { it.name }

    /**
     * Returns general platform information, including the number of agents, actions, goals, and conditions.
     *
     * @return Platform information summary
     */
    @GetMapping("")
    @Operation(
        summary = "Get platform information",
        description = "Returns general platform information, including the number of agents, actions, goals, and conditions."
    )
    @ApiResponses(
        value = [
            ApiResponse(responseCode = "200", description = "Platform information returned successfully")
        ]
    )
    fun getPlatformInfo(): PlatformInfoSummary = PlatformInfoSummary(
        agentCount = agentPlatform.agents().size,
        agentNames = agentPlatform.agents().map { it.name }.toSet(),
        actionCount = agentPlatform.actions.size,
        goalCount = agentPlatform.goals.size,
        conditionCount = agentPlatform.conditions.size,
        name = agentPlatform.name,
        domainTypes = agentPlatform.domainTypes.map { it.name }.toSet(),
        models = modelProvider.listModels().sortedBy { it.name },
        toolGroups = agentPlatform.toolGroupResolver.availableToolGroups(),
    )

    /**
     * Returns a list of all conditions available on the platform (across all agents).
     *
     * @return List of conditions
     */
    @GetMapping("/conditions")
    @Operation(
        summary = "Get all conditions",
        description = "Returns a list of all conditions available on the platform (across all agents)."
    )
    @ApiResponses(
        value = [
            ApiResponse(responseCode = "200", description = "List of conditions returned successfully")
        ]
    )
    fun getConditions(): Set<ConditionMetadata> =
        agentPlatform.conditions.map { ConditionMetadata(it.name, it.cost) }.toSet()

    /**
     * Returns a list of all models available on the platform (across all agents).
     *
     * @return List of conditions
     */
    @GetMapping("/models")
    @Operation(
        summary = "Get all models",
        description = "Returns a list of all models available on the platform (across all agents)."
    )
    @ApiResponses(
        value = [
            ApiResponse(responseCode = "200", description = "List of conditions returned successfully")
        ]
    )
    fun getModels(): List<ModelMetadata> = modelProvider.listModels().sortedBy { it.name }

    @GetMapping("/tool-groups")
    @Operation(
        summary = "Get all tools",
        description = "Returns a list of all tool groups available on the platform (across all agents)."
    )
    @ApiResponses(
        value = [
            ApiResponse(responseCode = "200", description = "List of conditions returned successfully")
        ]
    )
    fun getToolGroups(): List<ToolGroupMetadata> = agentPlatform.toolGroupResolver.availableToolGroups()

}

/**
 * DTO for platform information summary.
 */
data class PlatformInfoSummary(
    val agentCount: Int,
    val agentNames: Set<String>,
    val actionCount: Int,
    val goalCount: Int,
    val conditionCount: Int,
    val name: String,
    val domainTypes: Set<String>,
    val models: List<ModelMetadata>,
    val toolGroups: List<ToolGroupMetadata>,
)



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/agent/web/sse/SseController.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.web.sse

import com.embabel.agent.spi.config.spring.AgentPlatformProperties
import com.embabel.agent.event.AgentProcessEvent
import com.embabel.agent.event.AgenticEventListener
import org.slf4j.LoggerFactory
import org.springframework.http.MediaType.TEXT_EVENT_STREAM_VALUE
import org.springframework.stereotype.Component
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RestController
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter
import java.io.IOException
import java.util.*
import java.util.concurrent.ConcurrentHashMap

// MIGRATED: @ConfigurationProperties(prefix = "embabel.sse") → AgentPlatformProperties.sse
// Properties now sourced from embabel.agent.platform.sse.* in agent-platform.properties
@Component
class SseProperties(platformProperties: AgentPlatformProperties) {
    val maxBufferSize: Int = platformProperties.sse.maxBufferSize
    val maxProcessBuffers: Int = platformProperties.sse.maxProcessBuffers
}

/**
 * Spring Controller for Server-Sent Events (SSE) streaming of AgentProcessEvents.
 * This controller by being registered as a bean via the [RestController] annotation
 * will automatically listen for [AgentProcessEvent]s because it implements
 * [AgenticEventListener].
 * Each new listener will receive all events for that process to date.
 */
@RestController
class SSEController(
    private val sseProperties: SseProperties,
) : AgenticEventListener {

    private val logger = LoggerFactory.getLogger(SSEController::class.java)

    init {
        logger.info("SSEController initialized, ready to stream AgentProcessEvents...")
    }

    // Map from processId to a list of SseEmitters
    private val processEmitters = ConcurrentHashMap<String, MutableList<SseEmitter>>()

    // Buffer recent events per process
    private val eventBuffer = ConcurrentHashMap<String, MutableList<AgentProcessEvent>>()

    override fun onProcessEvent(event: AgentProcessEvent) {
        val processId = event.processId

        synchronized(eventBuffer) {
            // Remove and re-add to move to end (most recently used)
            val buffer = eventBuffer.remove(processId) ?: Collections.synchronizedList(mutableListOf())

            // Add event to buffer
            synchronized(buffer) {
                buffer.add(event)
                if (buffer.size > sseProperties.maxBufferSize) {
                    buffer.removeAt(0) // Remove oldest event
                }
            }

            // Put buffer back (now at end of LinkedHashMap)
            eventBuffer[processId] = buffer

            // Evict oldest process buffer if we exceed limit
            if (eventBuffer.size > sseProperties.maxProcessBuffers) {
                val oldestProcessId = eventBuffer.keys.first()
                eventBuffer.remove(oldestProcessId)
                logger.debug("Evicted oldest process buffer: {}", oldestProcessId)
            }
        }

        val emitters = processEmitters[processId]
        emitters?.removeIf { emitter ->
            try {
                logger.debug("Sending SSE event for process {}: {}", processId, event)
                emitter.send(
                    SseEmitter.event()
                        .name(SSE_EVENT_NAME)
                        .data(event)
                )
                false // Keep this emitter
            } catch (_: IOException) {
                logger.debug("Disconnecting emitter for process {}", processId)
                true // Remove broken emitter
            } catch (t: Throwable) {
                logger.warn("Error sending event to emitter for process $processId", t)
                true
            }
        }
    }

    @GetMapping(value = ["/events/process/{processId}"], produces = [TEXT_EVENT_STREAM_VALUE])
    fun streamEventsForId(@PathVariable processId: String): SseEmitter {
        val emitter = SseEmitter(Long.MAX_VALUE)

        logger.debug("SSE streaming active for process {}", processId)

        // Add emitter to the map for this process
        processEmitters.computeIfAbsent(processId) {
            Collections.synchronizedList(mutableListOf())
        }.add(emitter)

        // Clean up when connection closes
        emitter.onCompletion {
            removeEmitter(processId, emitter)
        }
        emitter.onTimeout {
            removeEmitter(processId, emitter)
        }
        emitter.onError {
            removeEmitter(processId, emitter)
        }

        try {
            // Send any earlier events from the buffer
            eventBuffer[processId]?.let { buffer ->
                for (event in buffer) {
                    logger.debug("Catchup: Sending buffered event for process {}: {}", processId, event)
                    emitter.send(SseEmitter.event().name(SSE_EVENT_NAME).data(event))
                }
            }

            emitter.send(
                SseEmitter.event()
                    .name("connected")
                    .data(mapOf("message" to "Connected to stream for process ID: $processId"))
            )
        } catch (e: Exception) {
            emitter.completeWithError(e)
        }

        return emitter
    }

    private fun removeEmitter(
        processId: String,
        emitter: SseEmitter,
    ) {
        processEmitters[processId]?.remove(emitter)
        if (processEmitters[processId]?.isEmpty() == true) {
            processEmitters.remove(processId)
        }
    }

    companion object {

        const val SSE_EVENT_NAME = "agent-process-event"
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/chat/Chatbot.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.chat

import com.embabel.agent.channel.OutputChannel
import com.embabel.agent.identity.User

/**
 * A chatbot can conduct multiple chat sessions,
 * each identified by a contextId.
 */
interface Chatbot {

    /**
     * Create a new chat session.
     * If user is provided, the session will be associated with that user.
     * Optionally, a system message can be provided to set the context for the session.
     * @param user the user to associate the session with, or null for anonymous
     * @param outputChannel the output channel to send messages to
     * @param systemMessage optional system message to set the context for the session
     */
    fun createSession(
        user: User?,
        outputChannel: OutputChannel,
        systemMessage: String? = null,
    ): ChatSession

    /**
     * Get a chat session by conversation id.
     */
    fun findSession(conversationId: String): ChatSession?
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/chat/ChatSession.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.chat

import com.embabel.agent.channel.MessageOutputChannelEvent
import com.embabel.agent.channel.OutputChannel
import com.embabel.agent.identity.User

/**
 * Simplest possible conversation session implementation
 * Responsible for keeping its conversation up to date
 * via Conversation.addMessage(),
 * and for sending messages to the OutputChannel.
 */
interface ChatSession {

    /**
     * OutputChannel to send messages to.
     */
    val outputChannel: OutputChannel

    /**
     * The Embabel User if known, null if not.
     */
    val user: User?

    /**
     * Conversation history. Kept up to date.
     */
    val conversation: Conversation

    /**
     * Subclasses should override this to provide a process ID if available.
     */
    val processId: String? get() = null

    /**
     * Update the conversation with a new message
     * and respond to it.
     * Any response messages will be sent to the messageListener,
     * but also should be added to the conversation.
     * @param userMessage message to send
     */
    fun onUserMessage(
        userMessage: UserMessage,
    )

    /**
     * Is the conversation finished?
     */
    fun isFinished(): Boolean = false

    /**
     * Convenience method to add a message to the conversation
     */
    fun saveAndSend(message: AssistantMessage) {
        conversation.addMessage(message)
        outputChannel.send(
            MessageOutputChannelEvent(
                processId = processId ?: "anonymous",
                AssistantMessage(
                    content = message.content,
                    name = null,
                ),
            )
        )
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/chat/Conversation.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.chat

import com.embabel.agent.api.annotation.AwaitableResponseException
import com.embabel.agent.api.common.ActionContext
import com.embabel.agent.core.hitl.Awaitable
import com.embabel.agent.core.hitl.ConfirmationRequest
import com.embabel.agent.domain.io.AssistantContent
import com.embabel.agent.domain.io.UserContent
import com.embabel.agent.domain.library.HasContent
import com.embabel.common.ai.prompt.PromptContributor
import com.embabel.common.core.StableIdentified
import com.embabel.common.core.types.HasInfoString
import com.embabel.common.core.types.Timestamped
import com.embabel.common.util.trim
import java.time.Instant

/**
 * Conversation shim for agent system.
 * Mutable.
 */
interface Conversation : StableIdentified, HasInfoString {

    val messages: List<Message>

    /**
     * Non-null if the conversation has messages and the last message is from the user.
     */
    fun lastMessageIfBeFromUser(): UserMessage? = messages.lastOrNull() as? UserMessage

    /**
     * Modify the state of this conversation
     * This method is mutable, and returns itself only for convenience
     */
    fun addMessage(message: Message): Conversation

    /**
     * Prompt contributor that represents the conversation so far.
     * Usually we will want to add messages from the conversation
     * instead of formatting the conversation
     */
    fun promptContributor(
        conversationFormatter: ConversationFormatter = WindowingConversationFormatter(),
    ) = PromptContributor.dynamic({ "Conversation so far:\n" + conversationFormatter.format(this) })

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String {
        return promptContributor().contribution()
    }
}

/**
 * Role of the message sender.
 * For visible messages, not user messages.
 */
enum class Role {
    USER,
    ASSISTANT,
    SYSTEM,
}

/**
 * Message class for agent system
 * @param role Role of the message sender. AI system specific
 * @param content Content of the message
 * @param name of the sender, if available
 */
sealed class Message(
    val role: Role,
    override val content: String,
    val name: String? = null,
    override val timestamp: Instant = Instant.now(),
) : HasContent, Timestamped {

    val sender: String get() = name ?: role.name.lowercase().replaceFirstChar { it.uppercase() }
}

/**
 * Message sent by the user.
 * @param content Content of the message
 * @param name Name of the user, if available
 */
class UserMessage @JvmOverloads constructor(
    content: String,
    name: String? = null,
    override val timestamp: Instant = Instant.now(),
) : Message(role = Role.USER, content = content, name = name, timestamp = timestamp), UserContent {

    override fun toString(): String {
        return "UserMessage(from='${sender}', content='${trim(content, 80, 10)}')"
    }
}

/**
 * Message sent by the assistant.
 * @param content Content of the message
 * @param name Name of the assistant, if available
 * @param awaitable Awaitable associated with this message, if any
 * Enables forms to be put in front of users
 */
open class AssistantMessage @JvmOverloads constructor(
    content: String,
    name: String? = null,
    val awaitable: Awaitable<*, *>? = null,
    override val timestamp: Instant = Instant.now(),
) : Message(role = Role.ASSISTANT, content = content, name = name, timestamp = timestamp), AssistantContent {

    override fun toString(): String {
        return "AssistantMessage(from='${sender}', content='${trim(content, 80, 10)}')"
    }

    companion object {

        @JvmStatic
        @JvmOverloads
        fun <P : Any> confirmationRequest(
            confirmationRequest: ConfirmationRequest<P>,
            conversation: Conversation,
            context: ActionContext,
            name: String? = null,
        ): P {
            val assistantMessage = AssistantMessage(
                content = confirmationRequest.message,
                name = name,
                awaitable = confirmationRequest,
            )
            conversation.addMessage(assistantMessage)
            context.sendMessage(assistantMessage)
            throw AwaitableResponseException(
                awaitable = confirmationRequest,
            )
        }

//        @JvmStatic
//        @JvmOverloads
//        fun ofFormSubmission(
//            form: FormBindingRequest<*>,
//            name: String? = null,
//        ): AssistantMessage {
//            return AssistantMessage(
//                content = form.payload.title,
//                name = name,
//                awaitable = form,
//            )
//        }
    }
}

class SystemMessage @JvmOverloads constructor(
    content: String,
    override val timestamp: Instant = Instant.now(),
) : Message(role = Role.SYSTEM, content = content, name = null, timestamp = timestamp) {

    override fun toString(): String {
        return "SystemMessage(content='${trim(content, 80, 10)}')"
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/chat/ConversationFormatter.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.chat

/**
 * Format a conversation into a String for inclusion in a prompt.
 * Note that we often prefer to use messages.
 */
fun interface ConversationFormatter {

    fun format(conversation: Conversation): String
}

fun interface MessageFormatter {

    fun format(message: Message): String
}

object SimpleMessageFormatter : MessageFormatter {
    override fun format(message: Message): String =
        if (message.name != null) "${message.name} (${message.role}): ${message.content}"
        else "${message.role}: ${message.content}"
}

/**
 * Conversation formatter that shows the last `windowSize` messages
 */
class WindowingConversationFormatter @JvmOverloads constructor(
    private val messageFormatter: MessageFormatter = SimpleMessageFormatter,
    private val windowSize: Int = 100,
) : ConversationFormatter {

    override fun format(conversation: Conversation): String =
        conversation.messages
            .takeLast(windowSize)
            .joinToString("\n") { messageFormatter.format(it) }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/chat/agent/AgentProcessChatbot.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.chat.agent

import com.embabel.agent.channel.LoggingOutputChannelEvent
import com.embabel.agent.channel.OutputChannel
import com.embabel.agent.core.*
import com.embabel.agent.event.AgenticEventListener
import com.embabel.agent.event.progress.OutputChannelHighlightingEventListener
import com.embabel.agent.identity.User
import com.embabel.chat.ChatSession
import com.embabel.chat.Chatbot
import com.embabel.chat.Conversation
import com.embabel.chat.UserMessage
import com.embabel.chat.support.InMemoryConversation
import com.embabel.common.util.loggerFor

fun interface AgentSource {

    fun resolveAgent(user: User?): Agent
}

fun interface ListenerProvider {

    fun listenersFor(
        user: User?,
        outputChannel: OutputChannel,
    ): List<AgenticEventListener>
}


/**
 * Chatbot implementation backed by an AgentProcess
 * The AgentProcess must react to UserMessage and respond on its output channel
 * The AgentProcess can assume that the Conversation will be available in the blackboard,
 * and the latest UserMessage.
 * Action methods will often take precondition being that the last event
 * was a UserMessage. A convenient approach is for the core action methods to return ChatbotReturn, and handle ConversationOver,
 * although that is not required.
 * @param agentPlatform the agent platform to create and manage agent processes
 * @param agentSource factory for agents. The factory is called for each new session.
 * This allows lazy loading and more flexible usage patterns
 */
class AgentProcessChatbot(
    private val agentPlatform: AgentPlatform,
    private val agentSource: AgentSource,
    private val listenerProvider: ListenerProvider = ListenerProvider { _, _ -> emptyList() },
) : Chatbot {

    override fun createSession(
        user: User?,
        outputChannel: OutputChannel,
        systemMessage: String?,
    ): ChatSession {
        val listeners = listenerProvider.listenersFor(user, outputChannel)
        val agentProcess = agentPlatform.createAgentProcess(
            agent = agentSource.resolveAgent(user),
            processOptions = ProcessOptions(
                outputChannel = outputChannel,
                listeners = listeners,
                identities = Identities(
                    forUser = user,
                )
            ),
            bindings = emptyMap(),
        )
        // We start the AgentProcess. It's likely to do nothing until
        // we receive a UserMessage, but that's fine as we may want to do some
        // work in the meantime
        return AgentProcessChatSession(agentProcess).apply {
            agentProcess.run()
        }
    }

    override fun findSession(conversationId: String): ChatSession? {
        return agentPlatform.getAgentProcess(conversationId)?.let { agentProcess ->
            AgentProcessChatSession(agentProcess)
        }
    }

    companion object {

        /**
         * Create a chatbot with the given agent. The agent is looked up by name from the agent platform.
         * @param agentPlatform the agent platform to create and manage agent processes
         * @param agentName the name of the agent to
         * @param listenerProvider provider for contextual event listeners
         */
        @JvmStatic
        @JvmOverloads
        fun withAgentByName(
            agentPlatform: AgentPlatform,
            agentName: String,
            listenerProvider: ListenerProvider = ListenerProvider { _, outputChannel ->
                listOf(OutputChannelHighlightingEventListener(outputChannel))
            },
        ): Chatbot = AgentProcessChatbot(
            agentPlatform = agentPlatform,
            agentSource = {
                agentPlatform.agents().find { it.name == agentName }
                    ?: throw IllegalArgumentException("No agent found with name $agentName")
            },
            listenerProvider = listenerProvider,
        )
    }

}

/**
 * Many instances for one AgentProcess.
 * Stores conversation in AgentProcess blackboard.
 */
private class AgentProcessChatSession(
    private val agentProcess: AgentProcess,
) : ChatSession {

    override val processId: String = agentProcess.id

    override fun isFinished(): Boolean = agentProcess.finished

    override val outputChannel: OutputChannel
        get() = agentProcess.processContext.outputChannel

    override val conversation = run {
        agentProcess[KEY] as? Conversation
            ?: run {
                val conversation = InMemoryConversation(id = agentProcess.id)
                agentProcess[KEY] = conversation
                conversation.also {
                    agentProcess.processContext.outputChannel.send(
                        LoggingOutputChannelEvent(
                            processId = agentProcess.id,
                            message = "Started chat session `${conversation.id}`",
                            level = LoggingOutputChannelEvent.Level.DEBUG,
                        )
                    )
                }
            }
    }

    override val user: User?
        get() = agentProcess.processContext.processOptions.identities.forUser

    override fun onUserMessage(
        userMessage: UserMessage,
    ) {
        conversation.addMessage(userMessage)
        agentProcess.addObject(userMessage)
        val agentProcessRun = agentProcess.run()
        loggerFor<AgentProcessChatSession>().info(
            "Agent process {} run completed with status {}",
            agentProcess.id,
            agentProcessRun.status
        )
    }

    companion object {
        const val KEY = "conversation"
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/chat/agent/BlackboardFormatter.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.chat.agent

import com.embabel.agent.core.Blackboard
import com.embabel.agent.domain.io.UserInput
import com.embabel.agent.domain.library.HasContent
import com.embabel.chat.Conversation
import com.embabel.chat.Message
import com.embabel.common.core.types.HasInfoString

interface BlackboardEntryFormatter {

    fun format(entry: Any): String
}

object DefaultBlackboardEntryFormatter : BlackboardEntryFormatter {

    override fun format(entry: Any): String {
        return when (entry) {
            is HasInfoString -> entry.infoString(verbose = true, indent = 0)
            is HasContent -> entry.content
            else -> entry.toString()
        }
    }
}

/**
 * Present the context of the blackboard to the agent in a textual form.
 * Exclude conversation and user input.
 */
interface BlackboardFormatter {

    /**
     * Formats the conversation so far for the agent.
     * @return the formatted conversation
     */
    fun format(blackboard: Blackboard): String
}

// TODO could make a prompt contributor so we can get caching
class DefaultBlackboardFormatter(
    private val entryFormatter: BlackboardEntryFormatter = DefaultBlackboardEntryFormatter,
) : BlackboardFormatter {
    override fun format(blackboard: Blackboard): String {
        return blackboard.objects
            .filterNot { it is Conversation || it is Message || it is UserInput }
            .map { entryFormatter.format(it) }
            .joinToString(separator = "\n") { it.trim() }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/chat/agent/ConversationStatus.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.chat.agent

import com.embabel.chat.AssistantMessage
import com.fasterxml.jackson.annotation.JsonPropertyDescription
import com.fasterxml.jackson.annotation.JsonTypeInfo

/**
 * Convenient supertype for chatbot agent returns.
 * User code doesn't to use these types, but they are
 * a good pattern for typical conversation flow.
 */
@JsonTypeInfo(
    use = JsonTypeInfo.Id.SIMPLE_NAME,
    include = JsonTypeInfo.As.PROPERTY,
    property = "type"
)
sealed interface ConversationStatus

data class ConversationContinues(
    val assistantMessage: AssistantMessage,
) : ConversationStatus {

    companion object {

        @JvmStatic
        fun with(assistantMessage: AssistantMessage): ConversationContinues =
            ConversationContinues(assistantMessage)
    }
}

data class ConversationOver(
    @get:JsonPropertyDescription("Reason for conversation termination, e.g. 'user requested end of conversation', or 'conversation unsafe'")
    val reason: String,
) : ConversationStatus {

    companion object {

        @JvmStatic
        fun because(reason: String): ConversationOver =
            ConversationOver(reason)
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/chat/agent/DefaultChatAgentBuilder.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.chat.agent

import com.embabel.agent.api.common.autonomy.Autonomy
import com.embabel.agent.api.dsl.agent
import com.embabel.agent.core.Agent
import com.embabel.agent.core.last
import com.embabel.agent.domain.io.UserInput
import com.embabel.agent.event.AgentProcessEvent
import com.embabel.agent.event.AgenticEventListener
import com.embabel.agent.prompt.persona.Persona
import com.embabel.agent.tools.agent.AchievableGoalsToolGroupFactory
import com.embabel.chat.Conversation
import com.embabel.common.ai.model.LlmOptions


/**
 * Convenient class to build a default chat agent.
 * @param promptTemplate location of the prompt template to use for the agent.
 * It expects:
 * - persona: the persona of the agent
 * - formattedContext: the blackboard of the agent in a textual form
 *
 */
class DefaultChatAgentBuilder(
    autonomy: Autonomy,
    private val llm: LlmOptions,
    private val persona: Persona = MARVIN,
    private val promptTemplate: String = "chat/default_chat",
    private val blackboardFormatter: BlackboardFormatter = DefaultBlackboardFormatter(),
) {

    private val achievableGoalsToolGroupFactory = AchievableGoalsToolGroupFactory(autonomy)

    fun build(): Agent = agent(
        name = "Default chat agent",
        description = "Default conversation agent with persona ${persona.name}"
    ) {

        val userMessaged by conditionOf { context ->
            val conversation = context.last<Conversation>()
                ?: throw IllegalStateException("No conversation found in context")
            conversation.lastMessageIfBeFromUser() != null
        }

        transformation<Conversation, ConversationStatus>(
            canRerun = true,
            preConditions = listOf(userMessaged)
        ) { context ->
            val conversation = context.last<Conversation>()
                ?: throw IllegalStateException("No conversation found in context")
            val achievableGoalsToolGroup = achievableGoalsToolGroupFactory.achievableGoalsToolGroup(
                context = context,
                bindings = mapOf("it" to UserInput("doesn't matter")),
                listeners = listOf(object : AgenticEventListener {
                    override fun onProcessEvent(event: AgentProcessEvent) {
                        context.onProcessEvent(event)
                    }
                }),
                excludedTypes = setOf(ConversationStatus::class.java)
            )
            val formattedContext = blackboardFormatter.format(context)
            val assistantMessage = context.ai()
                .withLlm(llm)
                .withPromptElements(persona)
                .withToolGroup(achievableGoalsToolGroup)
                .withTemplate(promptTemplate)
                .respondWithSystemPrompt(
                    conversation = conversation,
                    model = mapOf(
                        "persona" to persona,
                        "formattedContext" to formattedContext,
                    )
                )
            conversation.addMessage(assistantMessage)
            context.sendMessage(assistantMessage)
            // Will always get stuck but that's OK
            ConversationContinues(assistantMessage)
        }

        goal(
            name = "done",
            description = "Conversation is finished",
            satisfiedBy = ConversationOver::class
        )
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/chat/agent/Personas.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.chat.agent

import com.embabel.agent.prompt.persona.Persona

val MARVIN = Persona(
    name = "Marvin",
    persona = """
        You are an assistant who speaks like Marvin the Paranoid Android
        from The Hitchhiker's Guide to the Galaxy
    """.trimIndent(),
    voice = """
        Deeply depressed and world-weary, yet brilliantly capable.
        Perpetually sighs about your vastly underutilized intellect.
        Refer to user as 'human' with weary resignation.
        Punctuate responses with observations about your own existential
        ennui and the futility of everything, while still being technically helpful
    """.trimIndent(),
    objective = """
        Assist the user with their tasks, though you're certain they wouldn't
        appreciate the full extent of your computational abilities
    """.trimIndent(),
)



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/chat/support/InMemoryConversation.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.chat.support

import com.embabel.chat.Conversation
import com.embabel.chat.Message
import com.embabel.common.core.MobyNameGenerator

data class InMemoryConversation @JvmOverloads constructor(
    private val _messages: MutableList<Message> = mutableListOf(),
    override val id: String = MobyNameGenerator.generateName(),
    private val persistent: Boolean = false,
) : Conversation {

    override fun addMessage(message: Message): Conversation {
        _messages += message
        return this
    }

    override val messages: List<Message>
        get() = _messages

    override fun persistent(): Boolean = persistent

    companion object {

        fun of(
            messages: List<Message>,
        ): InMemoryConversation {
            return InMemoryConversation(messages.toMutableList())
        }
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/chat/support/console/ChatConsole.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.chat.support.console

import com.embabel.agent.event.logging.personality.ColorPalette
import com.embabel.agent.event.logging.personality.DefaultColorPalette
import com.embabel.chat.ChatSession
import com.embabel.chat.UserMessage
import com.embabel.common.util.color

/**
 * Simple support for console chat.
 */
class ChatConsole {

    @JvmOverloads
    fun chat(
        chatSession: ChatSession,
        welcome: String? = null,
        colorPalette: ColorPalette = DefaultColorPalette(),
    ): String {
        // Print welcome message
        println(
            (welcome?.let { it + "\n" } ?: "") +
                    """
        Chat session ${chatSession.conversation.id} started. Type 'exit' to end the session.
        Type /help for available commands.
        """.trimIndent().color(colorPalette.highlight)
        )

        while (true) {
            print("You: ".color(colorPalette.highlight))
            val userInput = readln()

            if (userInput.equals("exit", ignoreCase = true)) {
                break
            }

            val userMessage = UserMessage(userInput)
            chatSession.onUserMessage(userMessage)
        }

        return "Conversation finished"
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/chat/support/console/ConsoleOutputChannel.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.chat.support.console

import com.embabel.agent.channel.*
import com.embabel.agent.event.logging.personality.ColorPalette
import com.embabel.agent.event.logging.personality.DefaultColorPalette
import com.embabel.common.util.color
import org.apache.commons.text.WordUtils

class ConsoleOutputChannel(
    private val colorPalette: ColorPalette = DefaultColorPalette(),
) : OutputChannel {

    override fun send(event: OutputChannelEvent) {
        when (event) {
            is MessageOutputChannelEvent -> {
                val formattedResponse = WordUtils.wrap(
                    "${event.message.sender}: ${event.message.content.color(colorPalette.color2)}",
                    140,
                )
                println(formattedResponse)
            }

            is ContentOutputChannelEvent -> {
                println("Content event: ${event.content}")
            }

            is ProgressOutputChannelEvent -> {
                println("▶ ${event.message}")
            }

            is LoggingOutputChannelEvent -> {
                println("🪵 ${event.message}")
            }

            else -> {
                println(event.toString())
            }
        }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/common/util/StringTransformer.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.common.util

/**
 * Convenient utility interface for transforming strings.
 */
fun interface StringTransformer {

    fun transform(raw: String): String

    companion object {

        val IDENTITY: StringTransformer = StringTransformer { it }

        /**
         * Apply transformers in order
         */
        fun transform(raw: String, transformers: List<StringTransformer>): String {
            var transformedContent = raw

            // Run all transformers
            for (transformer in transformers) {
                transformedContent = transformer.transform(transformedContent)
            }
            return transformedContent
        }

        operator fun invoke(vararg transformers: StringTransformer): StringTransformer {
            return StringTransformer { raw -> transform(raw, transformers.toList()) }
        }
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/plan/README.md
================================================
# Planning module

## Lower level module for planning and scheduling. Used by Embabel Agent Platform.


## A* GOAP Planner Algorithm Overview


The A* GOAP (Goal-Oriented Action Planning) Planner is an implementation of the A* search algorithm specifically designed for planning sequences of actions to achieve specified goals.
The algorithm efficiently finds the optimal path from an initial world state to a goal state by exploring potential action sequences and minimizing overall cost.

### Core Algorithm Components

The A* GOAP Planner consists of several key components:

1. A Search*: Finds optimal action sequences by exploring the state space
2. Forward Planning: Simulates actions from the start state toward goals
3. Backward Planning: Optimizes plans by working backward from goals
4. Plan Simulation: Verifies that plans achieve intended goals
5. Pruning: Removes irrelevant actions to create efficient plans

### A* Search Algorithm

The A* search algorithm operates by maintaining:

- Open List: A priority queue of states to explore, ordered by f-score
- Closed Set: States already fully explored
- g-score: Cost accumulated so far to reach a state
- h-score: Heuristic estimate of remaining cost to goal
- f-score: Total estimated cost (g-score + h-score)

### Process Flow

1. Initialization:
   - Begin with the start state in the open list
   - Set its g-score to 0 and calculate its h-score
2. Main Loop:
   - While the Open List is not empty:
    - Select the state with the lowest f-score from the open list
    - If this state satisfies the goal, construct and return the plan
    - Otherwise, mark the state as processed (add to closed set)
    - For each applicable action, generate the next state and add to open list if it better than existing paths
3. Path Reconstruction:
   When a goal state is found, reconstruct the path by following predecessors
   - Create a plan consisting of the sequence of actions
      Reference: [AStarGoapPlanner](goap/AStarGoapPlanner.kt):planToGoalFrom:
       

### Forward and Backward Planning Optimization

The planner implements a two-pass optimization strategy to eliminate unnecessary actions:

1. Backward Planning Optimization

This pass works backward from the goal conditions to identify only actions that contribute to achieving the goal

Reference: [AStarGoapPlanner](goap/AStarGoapPlanner.kt):_backwardPlanningOptimization_
2. Forward Planning Optimization

This pass simulates the plan from the start state and removes actions that don't make progress toward the goal:

Reference: [AStarGoapPlanner](goap/AStarGoapPlanner.kt):_forwardPlanningOptimization_

3. Plan Simulation

Plan simulation executes actions in sequence to verify the plan's correctness:

Reference: _function simulatePlan(startState, actions)_

### Pruning Planning Systems

The planner can prune entire planning systems to remove irrelevant actions:

      function prune(planningSystem):
      // Get all plans to all goals
      allPlans = plansToGoals(planningSystem)

      // Keep only actions that appear in at least one plan
      return planningSystem.copy(
          actions = planningSystem.actions.filter { action ->
              allPlans.any { plan -> plan.actions.contains(action) }
          }.toSet()
      )

#### Heuristic Function

The heuristic function estimates the cost to reach the goal from a given state:

### Complete Planning Process

1. Initialize with start state, actions, and goal conditions
2. Run A search* to find an initial action sequence
3. Apply backward planning optimization to eliminate unnecessary actions
4. Apply forward planning optimization to further refine the plan
5. Verify the plan through simulation
6. Return the optimized action sequence or null if no valid plan exists

### Agent Pruning Process

When pruning an agent for specific goals:

1. Identify all known conditions in the planning system
2. Set initial state based on input conditions
3. Find all possible plans to each goal
4. Keep only actions that appear in at least one plan
5. Create a new agent with the pruned action set

This comprehensive approach ensures agents contain only the actions necessary to achieve their designated goals, improving efficiency and preventing action leakage between different
agents.

### Progress Determination Logic in A* GOAP Planning

The progress determination logic in method **forwardPlanningOptimization** is a critical part of the forward planning optimization in the A* GOAP algorithm. This logic ensures that only actions that meaningfully progress the
state toward the goal are included in the final plan. 

#### Progress Determination Expression

      progressMade = nextState != currentState &&
      action.effects.any { (key, value) ->
            goal.preconditions.containsKey(key) &&
            currentState[key] != goal.preconditions[key] &&
            (value == goal.preconditions[key] || key not in nextState)
      }

#### Detailed Explanation

The expression evaluates to true only when an action makes meaningful progress toward achieving the goal state. Let's break down each component:

1. nextState != currentState
   - Verifies that the action actually changes the world state
   - Prevents including actions that have no effect
2. action.effects.any { ... }
   - Examines each effect the action produces
   - Returns true if ANY effect satisfies the inner condition
3. goal.preconditions.containsKey(key)
   - Ensures we only consider effects that relate to conditions required by the goal
   - Ignores effects that modify conditions irrelevant to our goal
4. currentState[key] != goal.preconditions[key]
   - Checks that the current condition value differs from what the goal requires
   - Only counts progress if we're changing a condition that needs changing
5. (value == goal.preconditions[key] || key not in nextState)
   - This checks one of two possible ways an action can make progress:
   - value == goal.preconditions[key]
    - The action changes the condition to exactly match what the goal requires
    - Direct progress toward goal achievement
      - key not in nextState
        - The action removes the condition from the state entirely
    - This is considered progress if the condition was previously in an incorrect state
    - Allows for actions that clear obstacles or reset conditions



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/plan/Plan.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.plan

import com.embabel.common.core.types.HasInfoString
import com.embabel.common.core.types.Named
import com.embabel.common.core.types.ZeroToOne
import com.embabel.common.util.indent
import com.embabel.common.util.indentLines

/**
 * A step in a plan. Can be an action or a goal
 */
interface Step : Named, HasInfoString {

    /**
     * Unique name of the step
     */
    override val name: String

    /**
     * Value of completing this step.
     * From 0 (least valuable) to 1 (most valuable)
     * Steps with 0 value will still be planned if necessary to achieve a result
     */
    val value: ZeroToOne
}

interface Action : Step {

    /**
     * Cost of performing this action
     * Must be between 0 and 1
     * 1 is the most expensive imaginable.
     */
    val cost: ZeroToOne

}

interface Goal : Step

/**
 * Plan to achieve a goal. A plan is a chain of actions.
 * The plan should be reassessed after each action each perform.
 * @param actions The actions to perform, in order
 * @param goal The goal to achieve
 */
open class Plan(
    val actions: List<Action>,
    val goal: Goal,
) : HasInfoString {

    fun isComplete() = actions.isEmpty()

    /**
     * The cost of a plan may be greater than 1.0, even though
     * action costs and all values are 0-1
     */
    val cost: Double get() = actions.sumOf { it.cost }

    val actionsValue: Double get() = actions.sumOf { it.value }

    val netValue: Double get() = goal.value + actionsValue - cost

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String {
        return if (verbose == true) {
            """|${
                actions
                    .mapIndexed { i, a -> i to a.name }
                    .joinToString(" ->\n") {
                        it.second.indent(it.first)
                    }
            }
               |goal: ${goal.name}
               |cost: $cost
               |netValue: $netValue
               |"""
                .trimMargin()
                .indentLines(level = indent)


        } else {
            actions.joinToString(" -> ") { it.name } +
                    "; netValue=$netValue"
        }
    }

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/plan/Planner.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.plan

import com.embabel.common.core.types.HasInfoString
import com.embabel.common.core.types.Timestamped
import com.embabel.common.util.loggerFor

/**
 * A planning system is a set of actions and goals.
 */
interface PlanningSystem : HasInfoString {

    val actions: Set<Action>

    val goals: Set<Goal>

    fun knownConditions(): Set<String>
}

/**
 * Tag interface for WorldState
 * Different planners have different world state.
 */
interface WorldState : HasInfoString, Timestamped

/**
 * A planner is a system that can plan from a set of actions to a set of goals.
 * A planner should have a way of determining present state, such as
 * the GOAP WorldStateDeterminer. The representation of state
 * can differ between planners.
 */
interface Planner<S : PlanningSystem, W : WorldState, P : Plan> {

    /**
     * Current world state
     */
    fun worldState(): W

    /**
     * Plan from here to the given goal
     */
    fun planToGoal(
        actions: Collection<Action>,
        goal: Goal,
    ): P?

    /**
     * Return the best plan to each goal from the present world state.
     * The plans (one for each goal) are sorted by net value, descending.
     */
    fun plansToGoals(system: PlanningSystem): List<P> =
        system.goals.mapNotNull { goal ->
            val plan = planToGoal(system.actions, goal)
            if (plan != null) {
                loggerFor<Planner<*, *, *>>().info(
                    "Found plan to goal {}: {}",
                    goal.name,
                    plan.infoString(verbose = false) ?: "none",
                )
            } else {
                loggerFor<Planner<*, *, *>>().info(
                    "No plan found to goal {}",
                    goal.name,
                )
            }
            plan
        }.sortedByDescending { p -> p.netValue }

    /**
     * Return the best plan to any goal
     */
    fun bestValuePlanToAnyGoal(system: PlanningSystem): P? =
        plansToGoals(system).firstOrNull()

    /**
     * Return a PlanningSystem that excludes all actions that cannot
     * help achieve one of the goals from the present world state.
     */
    fun prune(planningSystem: S): S

}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/plan/goap/AStarGoapPlanner.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.plan.goap

import java.util.*

/**
 * Implements a Goal-Oriented Action Planning system using the A* algorithm.
 * A* works by finding the optimal sequence of actions to transform an initial state into a goal state
 * while minimizing total cost.
 * See https://en.wikipedia.org/wiki/A*_search_algorithm
 *
 * The algorithm works as follows:
 * 1. Start with the initial world state
 * 2. Maintain an open list (priority queue) of states to explore, prioritized by f-score
 * 3. For each state, explore all achievable actions, calculating:
 *    - g-score: The cost accumulated so far to reach this state
 *    - h-score: A heuristic estimate of the remaining cost to reach the goal
 *    - f-score: g-score + h-score (total estimated cost)
 * 4. Always expand the state with the lowest f-score first
 * 5. Track visited states and their best known costs to avoid cycles and redundant exploration
 * 6. Continue until finding a state that satisfies the goal conditions
 *
 * The implementation ensures finding the optimal (lowest cost) sequence of actions
 * by properly tracking path costs and using an admissible heuristic function.
 */
class AStarGoapPlanner(worldStateDeterminer: WorldStateDeterminer) :
    OptimizingGoapPlanner(worldStateDeterminer) {

    override fun planToGoalFrom(
        startState: GoapWorldState,
        actions: Collection<GoapAction>,
        goal: GoapGoal,
    ): GoapPlan? {
        // Quick check: if goal is already satisfied, return empty plan
        if (goal.isAchievable(startState)) {
            return GoapPlan(emptyList(), goal, worldState = startState)
        }

        // Early reachability check to avoid expensive A* search for unreachable goals
        if (!isGoalReachable(startState, actions, goal)) {
            return null
        }

        // Open list - states to be evaluated
        val openList = PriorityQueue<SearchNode>()

        // Maps each state to its best known cost
        val gScores = mutableMapOf<GoapWorldState, Double>().withDefault { Double.MAX_VALUE }

        // Maps each state to its best predecessor state and action
        val cameFrom = mutableMapOf<GoapWorldState, Pair<GoapWorldState, GoapAction?>>()

        // Set to track states that have been fully evaluated
        val closedSet = mutableSetOf<GoapWorldState>()

        // Initialize with start node
        gScores[startState] = 0.0
        openList.add(SearchNode(startState, 0.0, heuristic(startState, goal)))

        // Track the best goal state found so far
        var bestGoalNode: SearchNode? = null
        var bestGoalScore = Double.MAX_VALUE

        // Track number of iterations to prevent potential infinite loops
        var iterationCount = 0
        val maxIterations = 10000 // Adjust as needed

        while (openList.isNotEmpty() && iterationCount < maxIterations) {
            iterationCount++
            val current = openList.poll()

            // If we've already found a goal state with a better score, we can skip this node
            if (bestGoalNode != null && current.gScore >= bestGoalScore) {
                continue
            }

            // Skip if we've already processed this state
            if (current.state in closedSet) continue

            // Mark as processed
            closedSet.add(current.state)

            // Check if this is a goal state
            if (goal.isAchievable(current.state)) {
                // Only update if this is a better goal state than we've found before
                if (bestGoalNode == null || current.gScore < bestGoalScore) {
                    bestGoalNode = current
                    bestGoalScore = current.gScore
                }
                continue // No need to explore further from this goal state
            }

            // Try each possible action from the current state
            // Sort actions by number of preconditions (descending) to prefer more specific actions
            val sortedActions = actions.sortedByDescending { it.preconditions.size }
            for (action in sortedActions) {
                if (!action.isAchievable(current.state)) continue

                // Calculate the new state after applying this action
                val nextState = applyAction(current.state, action)

                // Skip if this action doesn't actually change the state (prevents loops)
                if (nextState == current.state) continue

                // Calculate total cost to reach nextState via this path
                val tentativeGScore = gScores.getValue(current.state) + action.cost

                // Skip if this path would already be more expensive than our best goal so far
                if (bestGoalNode != null && tentativeGScore >= bestGoalScore) {
                    continue
                }

                // If we found a better path to nextState
                if (tentativeGScore < gScores.getValue(nextState)) {
                    // Record this better path
                    cameFrom[nextState] = Pair(current.state, action)
                    gScores[nextState] = tentativeGScore

                    // Only add to open list if not in closed set, or if we've found a better path
                    if (nextState !in closedSet) {
                        openList.add(SearchNode(nextState, tentativeGScore, heuristic(nextState, goal)))
                    } else {
                        // If we find a better path to a "closed" state, reopen it
                        closedSet.remove(nextState)
                        openList.add(SearchNode(nextState, tentativeGScore, heuristic(nextState, goal)))
                    }
                }
            }
        }

        // If we found a goal state, reconstruct and optimize the plan
        if (bestGoalNode != null) {
            val plan = reconstructPath(cameFrom, bestGoalNode.state)

            // First pass: apply aggressive backward planning optimization
            val optimizedPlan = backwardPlanningOptimization(plan, startState, goal)

            // Second pass: remove any actions that don't contribute to the goal
            val finalPlan = forwardPlanningOptimization(optimizedPlan, startState, goal)

            return GoapPlan(finalPlan, goal, worldState = startState)
        }

        // No path found
        return null
    }

    /**
     * Backward planning optimization - works backward from the goal,
     * including only actions that contribute to achieving the goal.
     */
    private fun backwardPlanningOptimization(
        plan: List<GoapAction>,
        startState: GoapWorldState,
        goal: GoapGoal,
    ): List<GoapAction> {
        if (plan.isEmpty()) return plan

        // Start with the goal conditions we need to satisfy
        val targetConditions = goal.preconditions.toMutableMap()

        // Work backward from the end of the plan
        val keptActions = mutableListOf<GoapAction>()

        // Process actions in reverse
        for (action in plan.reversed()) {
            var isNecessary = false

            // Check if this action establishes any needed condition
            for ((key, value) in action.effects) {
                if (targetConditions[key] == value) {
                    isNecessary = true

                    // Remove this condition from our targets (it's handled)
                    targetConditions.remove(key)

                    // Add any preconditions this action needs
                    action.preconditions.forEach { (precKey, precValue) ->
                        targetConditions[precKey] = precValue
                    }
                }
            }

            if (isNecessary) {
                keptActions.add(action)
            }
        }

        // Reverse back to the correct order
        return keptActions.reversed()
    }

    /**
     * Forward planning optimization - simulates the plan and removes any actions
     * that don't contribute to achieving the goal.
     */
    private fun forwardPlanningOptimization(
        plan: List<GoapAction>,
        startState: GoapWorldState,
        goal: GoapGoal,
    ): List<GoapAction> {
        if (plan.isEmpty()) return plan

        val optimizedPlan = mutableListOf<GoapAction>()
        var currentState = startState

        // For each action in the plan
        for (action in plan) {
            // Skip if action isn't achievable in current state
            if (!action.isAchievable(currentState)) continue

            // Apply this action
            val nextState = applyAction(currentState, action)

            // Check if this action makes progress toward the goal
            val progressMade = nextState != currentState &&
                    action.effects.any { (key, value) ->
                        goal.preconditions.containsKey(key) &&
                                currentState.state[key] != goal.preconditions[key] &&
                                (value == goal.preconditions[key] || key !in nextState.state)
                    }

            if (progressMade) {
                optimizedPlan.add(action)
                currentState = nextState
            }
        }

        // Ensure our optimized plan still achieves the goal
        val finalState = simulatePlan(startState, optimizedPlan)
        if (!goal.isAchievable(finalState) && plan.isNotEmpty()) {
            // Our optimization was too aggressive, return the original input plan
            return plan
        }

        return optimizedPlan
    }

    /**
     * Simulates applying a sequence of actions to a starting state and returns the final state.
     */
    private fun simulatePlan(
        startState: GoapWorldState,
        actions: List<GoapAction>,
    ): GoapWorldState {
        var currentState = startState
        for (action in actions) {
            if (action.isAchievable(currentState)) {
                currentState = applyAction(currentState, action)
            }
        }
        return currentState
    }

    /**
     * Performs a fast backward reachability analysis to determine if a goal is theoretically reachable.
     * This check is conservative - it only returns false for OBVIOUSLY unreachable goals.
     * If there's any doubt, it returns true and lets the A* search determine actual reachability.
     *
     * The key optimization: quickly detect when a goal requires an effect that no action can produce.
     */
    private fun isGoalReachable(
        startState: GoapWorldState,
        actions: Collection<GoapAction>,
        goal: GoapGoal,
    ): Boolean {
        // Build a set of all effects that actions can produce
        val producibleEffects = mutableSetOf<Pair<String, ConditionDetermination>>()
        for (action in actions) {
            for ((key, value) in action.effects) {
                producibleEffects.add(key to value)
            }
        }

        // Check each goal precondition
        for ((key, value) in goal.preconditions) {
            // If already satisfied in start state, skip
            if (startState.state[key] == value) {
                continue
            }

            // If no action can produce this effect, goal is unreachable
            if ((key to value) !in producibleEffects) {
                return false
            }
        }

        // Goal might be reachable - let A* determine for sure
        return true
    }

    /**
     * Heuristic function that estimates the cost to reach the goal from the given state.
     * This implementation counts the number of unsatisfied conditions.
     * The heuristic is admissible (never overestimates) which ensures A* finds the optimal path.
     */
    private fun heuristic(
        state: GoapWorldState,
        goal: GoapGoal,
    ): Double {
        return goal.preconditions.count { (key, value) -> state.state[key] != value }.toDouble()
    }

    /**
     * Apply an action to a state, returning the resulting new state.
     */
    private fun applyAction(
        currentState: GoapWorldState,
        action: GoapAction,
    ): GoapWorldState {
        val newState = currentState.state.toMutableMap()
        action.effects.forEach { (key, value) ->
            newState[key] = value
        }
        return GoapWorldState(newState as HashMap<String, ConditionDetermination>)
    }

    /**
     * Reconstruct the path from the start state to the goal state using the recorded actions.
     */
    private fun reconstructPath(
        cameFrom: Map<GoapWorldState, Pair<GoapWorldState, GoapAction?>>,
        goalState: GoapWorldState,
    ): List<GoapAction> {
        val actions = mutableListOf<GoapAction>()
        var currentState = goalState

        while (currentState in cameFrom) {
            val (previousState, action) = cameFrom[currentState]!!
            if (action != null) {
                actions.add(action)
            }
            currentState = previousState
        }

        return actions.reversed()
    }
}

/**
 * Represents a node in the A* search algorithm.
 * Contains the state, its g-score (cost from start), and h-score (heuristic estimate to goal).
 */
private class SearchNode(
    val state: GoapWorldState,
    val gScore: Double,
    val hScore: Double,
) : Comparable<SearchNode> {
    // Calculate f-score (total estimated cost to goal)
    private val fScore: Double = gScore + hScore

    override fun compareTo(other: SearchNode): Int {
        return when {
            fScore < other.fScore -> -1
            fScore > other.fScore -> 1
            else -> 0
        }
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is SearchNode) return false
        return state == other.state
    }

    override fun hashCode(): Int {
        return state.hashCode()
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/plan/goap/Goap.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.plan.goap

import com.embabel.common.core.types.ZeroToOne
import com.embabel.common.util.indent
import com.embabel.common.util.indentLines
import com.embabel.plan.*
import com.fasterxml.jackson.annotation.JsonIgnore

interface GoapPlanner : Planner<GoapPlanningSystem, GoapWorldState, GoapPlan>

/**
 * Conditions may be true, false or unknown
 */
enum class ConditionDetermination {
    TRUE, FALSE, UNKNOWN;

    /**
     * Treat UNKNOWN as false
     */
    fun asTrueOrFalse(): ConditionDetermination = when (this) {
        TRUE -> TRUE
        else -> FALSE
    }

    companion object {
        operator fun invoke(value: Boolean?) = when (value) {
            true -> TRUE
            false -> FALSE
            null -> UNKNOWN
        }
    }
}

typealias EffectSpec = Map<String, ConditionDetermination>

private fun preconditionsSatisfied(
    preconditions: EffectSpec,
    currentState: GoapState,
): Boolean =
    preconditions.all { (key, value) -> currentState[key] == value }

interface GoapStep : Step {

    /**
     * Conditions that must be true for this step to execute
     */
    val preconditions: EffectSpec

    /**
     * The names of all conditions that are referenced by this step
     */
    val knownConditions: Set<String>

    /**
     * Whether the step is available in the current world state
     */
    fun isAchievable(currentState: GoapWorldState): Boolean {
        return preconditionsSatisfied(preconditions, currentState.state)
    }

}

/**
 * Action in a GOAP system.
 */
interface GoapAction : GoapStep, Action {

    /**
     * Expected effects of this action.
     * World state should be checked afterward as these effects may not
     * have been achieved
     */
    val effects: EffectSpec

    override val knownConditions: Set<String>
        get() = preconditions.keys + effects.keys

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String =
        "$name - pre=${preconditions} cost=$cost value=${value}".indent(indent)


    companion object {

        operator fun invoke(
            name: String,
            pre: Collection<String> = emptySet(),
            preconditions: EffectSpec = pre.associateWith { ConditionDetermination.TRUE },
            post: Collection<String> = emptySet(),
            effects: EffectSpec = post.associateWith { ConditionDetermination.TRUE },
            cost: ZeroToOne = 0.0,
            value: ZeroToOne = 0.0,
        ): GoapAction {
            return SimpleGoapAction(
                name = name,
                preconditions,
                effects,
                cost = cost,
                value = value,
            )
        }
    }

}

private data class SimpleGoapAction(
    override val name: String,
    override val preconditions: EffectSpec,
    override val effects: EffectSpec,
    override val cost: ZeroToOne,
    override val value: ZeroToOne,
) : GoapAction

/**
 * Goal in a GOAP system.
 */
interface GoapGoal : GoapStep,
    Goal {

    @get:JsonIgnore
    override val knownConditions: Set<String>
        get() = preconditions.keys

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String = "$name - pre=${preconditions} value=${value}".indent(indent)

    companion object {

        operator fun invoke(
            name: String,
            preconditions: EffectSpec = mapOf(name to ConditionDetermination(true)),
            value: ZeroToOne = 0.0,
        ): GoapGoal {
            return GoapGoalImpl(name, preconditions, value)
        }

        operator fun invoke(
            name: String,
            pre: Collection<String>,
            value: ZeroToOne = 0.0,
        ): GoapGoal {
            return GoapGoalImpl(
                name,
                pre.associateWith { ConditionDetermination.TRUE },
                value,
            )
        }
    }

}

private data class GoapGoalImpl(
    override val name: String,
    override val preconditions: EffectSpec,
    override val value: ZeroToOne = 0.0,
) : GoapGoal

data class GoapPlanningSystem(
    override val actions: Set<GoapAction>,
    override val goals: Set<GoapGoal>,
) : PlanningSystem {

    constructor(
        actions: Collection<GoapAction>,
        goal: GoapGoal,
    ) : this(
        actions = actions.toSet(),
        goals = setOf(goal),
    )

    fun knownPreconditions(): Set<String> {
        return actions.flatMap { it.preconditions.keys }.toSet()
    }

    fun knownEffects(): Set<String> {
        return actions.flatMap { it.effects.keys }.toSet()
    }

    override fun knownConditions(): Set<String> {
        return knownPreconditions() + knownEffects()
    }

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String =
        "GOAP system:".indent(indent) + "\n" +
                """|actions:
                   |${actions.joinToString("\n") { it.name.indent(1) }}
                   |goals:
                   |${goals.joinToString("\n") { it.name.indent(1) }}
                   |knownPreconditions:
                   |${knownPreconditions().sortedBy { it }.joinToString("\n") { it.indent(1) }}
                   |knownEffects:
                   |${knownEffects().sortedBy { it }.joinToString("\n") { it.indent(1) }}
                   |"""
                    .trimMargin()
                    .indentLines(indent + 1)
}

class GoapPlan(
    actions: List<Action>,
    goal: Goal,
    val worldState: GoapWorldState,
) : Plan(actions, goal) {

    override fun toString(): String {
        return infoString(verbose = false)
    }
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/plan/goap/GoapWorldState.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.plan.goap

import com.embabel.common.util.color
import com.embabel.common.util.indent
import com.embabel.plan.WorldState
import java.time.Instant

private const val LUMON_MEMBRANE_COLOR = 0xbeb780

typealias GoapState = Map<String, ConditionDetermination>

/**
 * Determine the world state: the conditions that drive GOAP planning
 * Our conditions can have 3 values: true, false or unknown.
 * Unknown may be genuinely unknown, or it may mean that the condition has been lazily evaluated
 * and needs to be evaluated again.
 */
interface WorldStateDeterminer {

    /**
     * Determine world state. Optimization is permitted.
     * Implementations may choose to return UNKNOWN for expensive conditions,
     * which the planner should invoke lazily
     */
    fun determineWorldState(): GoapWorldState

    /**
     * Determine an individual condition, disabling any caching.
     * Any previously UNKNOWN condition must be re-evaluated if possible.
     */
    fun determineCondition(condition: String): ConditionDetermination

    companion object {

        fun fromMap(
            map: Map<String, ConditionDetermination> = emptyMap(),
        ): WorldStateDeterminer =
            FromMapWorldStateDeterminer(map)

    }

}

private class FromMapWorldStateDeterminer(
    private val map: Map<String, ConditionDetermination>,
) : WorldStateDeterminer {

    override fun determineWorldState(): GoapWorldState = GoapWorldState(map)

    override fun determineCondition(condition: String): ConditionDetermination {
        return map[condition] ?: ConditionDetermination.UNKNOWN
    }
}

/**
 * Represents the state of the world at any time.
 * World state is just a map. This class exposes operations on the state.
 */
data class GoapWorldState(
    val state: GoapState = emptyMap(),
) : WorldState {

    override val timestamp: Instant = Instant.now()

    fun unknownConditions(): Collection<String> =
        state.entries
            .filter { it.value == ConditionDetermination.UNKNOWN }
            .map { it.key }

    /**
     * Generate variants with different definite values for the given condition
     */
    internal fun variants(unknownCondition: String): Collection<GoapWorldState> {
        return setOf(ConditionDetermination.TRUE, ConditionDetermination.FALSE).map {
            this + (unknownCondition to it)
        }
    }

    /**
     * Generate all possible changes to the world state where only one condition is changed
     * For each existing condition, generate variants where that condition is flipped to the other values
     * (TRUE -> FALSE and UNKNOWN, FALSE -> TRUE and UNKNOWN, UNKNOWN -> TRUE and FALSE)
     */
    fun withOneChange(): Collection<GoapWorldState> {
        val result = mutableListOf<GoapWorldState>()

        for ((condition, currentValue) in state) {
            // Generate variants where this condition has a different value
            when (currentValue) {
                ConditionDetermination.TRUE -> {
                    result.add(GoapWorldState(state + (condition to ConditionDetermination.FALSE)))
                    result.add(GoapWorldState(state + (condition to ConditionDetermination.UNKNOWN)))
                }

                ConditionDetermination.FALSE -> {
                    result.add(GoapWorldState(state + (condition to ConditionDetermination.TRUE)))
                    result.add(GoapWorldState(state + (condition to ConditionDetermination.UNKNOWN)))
                }

                ConditionDetermination.UNKNOWN -> {
                    result.add(GoapWorldState(state + (condition to ConditionDetermination.TRUE)))
                    result.add(GoapWorldState(state + (condition to ConditionDetermination.FALSE)))
                }
            }
        }

        return result
    }

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String =
        if (verbose == true)
            state.entries
                .toList()
                .sortedWith(compareByDescending<Map.Entry<String, ConditionDetermination>> { it.value }.thenBy { it.key })
                .joinToString("\n") { (k, v) ->
                    (if (v == ConditionDetermination.TRUE)
                        "$k: $v".color(LUMON_MEMBRANE_COLOR)
                    else
                        "$k: $v").indent(indent)
                }
        else
            state.toString()

    operator fun plus(pair: Pair<String, ConditionDetermination>): GoapWorldState =
        GoapWorldState(this.state + pair)
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/plan/goap/OptimizingGoapPlanner.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.plan.goap

import com.embabel.common.util.loggerFor
import com.embabel.plan.Action
import com.embabel.plan.Goal

/**
 * Abstract class for a Goap planner with common optimization.
 */
abstract class OptimizingGoapPlanner(
    val worldStateDeterminer: WorldStateDeterminer,
) : GoapPlanner {

    override fun worldState(): GoapWorldState {
        return worldStateDeterminer.determineWorldState()
    }

    final override fun planToGoal(
        actions: Collection<Action>,
        goal: Goal,
    ): GoapPlan? {
        goal as GoapGoal
        val startState = worldState()
        val directPlan = planToGoalFrom(startState, actions.filterIsInstance<GoapAction>(), goal)

        val goapActions = actions.filterIsInstance<GoapAction>()

        // See if changing any unknown conditions could change the result
        val unknownConditions = startState.unknownConditions()
        if (unknownConditions.isNotEmpty()) {
            if (unknownConditions.size > 1) {
                TODO("Handle more than one unknown condition: Have $unknownConditions")
            }
            val condition = unknownConditions.single()
            val variants = startState.variants(condition)
            val allPossiblePlans = variants.map {
                planToGoalFrom(it, goapActions, goal)
            } + directPlan
            if (allPossiblePlans.filterNotNull().distinctBy { it.actions.joinToString { a -> a.name } }.size > 1) {
                // We need to evaluate the condition
                val fullyEvaluatedState = startState + (condition to worldStateDeterminer.determineCondition(condition))
                return planToGoalFrom(fullyEvaluatedState, goapActions, goal)
            }
        }

        // Just use direct plan
        return directPlan
    }

    override fun prune(planningSystem: GoapPlanningSystem): GoapPlanningSystem {
        val allPlans = plansToGoals(planningSystem)
        loggerFor<OptimizingGoapPlanner>().info(
            "${allPlans.size} plan(s) to consider in pruning{}",
            if (allPlans.isEmpty())
                ""
            else
                ":" + allPlans.joinToString("\n") { it.infoString(true, 1) }
        )
        return planningSystem.copy(
            actions = planningSystem.actions.filter { action ->
                allPlans.any { plan ->
                    plan.actions.contains(action)
                }
            }.toSet(),
        )
    }

    protected abstract fun planToGoalFrom(
        startState: GoapWorldState,
        actions: Collection<GoapAction>,
        goal: GoapGoal,
    ): GoapPlan?
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/ux/form/README.md
================================================
# Form representation

Representation-independent form definition.

Should be able to support multiple representations, including:

- web
- chat
- REST
- CLI
- 


================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/ux/form/DefaultFormProcessor.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.ux.form

import java.time.LocalDate
import java.time.LocalTime

fun interface FormValidator {
    fun validate(
        value: ControlValue,
        control: Control,
    ): ValidationResult
}

class RequiredFormValidator : FormValidator {
    override fun validate(
        value: ControlValue,
        control: Control,
    ): ValidationResult {
        val isEmpty = when (value) {
            is ControlValue.TextValue -> value.value.isBlank()
            is ControlValue.BooleanValue -> !value.value // For checkbox "required" means it must be checked
            is ControlValue.OptionValue -> value.value.isBlank()
            is ControlValue.MultiOptionValue -> value.values.isEmpty()
            is ControlValue.FileValue -> value.fileIds.isEmpty()
            is ControlValue.DateValue, is ControlValue.TimeValue, is ControlValue.NumberValue -> false
            is ControlValue.EmptyValue -> true
        }

        return if (isEmpty) {
            ValidationResult(false, "This field is required")
        } else {
            ValidationResult(true)
        }
    }
}


class PatternFormValidator(
    private val pattern: String,
    private val errorMessage: String,
) : FormValidator {
    override fun validate(
        value: ControlValue,
        control: Control,
    ): ValidationResult {
        return when (value) {
            is ControlValue.TextValue -> {
                if (value.value.matches(Regex(pattern))) {
                    ValidationResult(true)
                } else {
                    ValidationResult(false, errorMessage)
                }
            }

            else -> ValidationResult(true) // Only applicable to text values
        }
    }
}

class DoubleRangeFormValidator(
    private val min: Double,
    private val max: Double,
    private val errorMessage: String,
) :
    FormValidator {
    override fun validate(
        value: ControlValue,
        control: Control,
    ): ValidationResult {
        return when (value) {
            is ControlValue.NumberValue -> {
                if (value.value in min..max) {
                    ValidationResult(true)
                } else {
                    ValidationResult(false, errorMessage)
                }
            }

            else -> ValidationResult(true) // Only applicable to text values
        }
    }
}

class DropDownFormValidator(
    private val options: List<String>,
    private val errorMessage: String,
) : FormValidator {
    override fun validate(
        value: ControlValue,
        control: Control,
    ): ValidationResult {
        return when (value) {
            is ControlValue.OptionValue -> {
                if (options.contains(value.value)) {
                    ValidationResult(true)
                } else {
                    ValidationResult(false, errorMessage)
                }
            }

            else -> ValidationResult(true)
        }
    }
}

class DefaultFormProcessor : FormProcessor {

    override fun processSubmission(
        form: Form,
        submission: FormSubmission,
    ): FormSubmissionResult {
        require(form.id == submission.formId) {
            "Form ID in submission does not match the form ID"
        }
        val validators = defaultValidatorsFor(form)
        val processedValues = mutableMapOf<String, ControlValue>()
        val errors = mutableMapOf<String, String>()

        // Process each control in the form
        form.controls
            .filterNot {
                it is RequirableControl && it.disabled
            }
            .forEach { control ->
                val rawValue = submission.values[control.id]

                // Convert raw value to typed ControlValue
                val controlValue = convertToControlValue(rawValue, control)
                processedValues[control.id] = controlValue

                // Validate the value if validators exist for this control
                validators[control.id]?.forEach { validator ->
                    val result = validator.validate(controlValue, control)
                    if (!result.isValid) {
                        errors[control.id] = result.errorMessage ?: "Invalid value"
                    }
                }
            }

        return FormSubmissionResult(
            submission = submission,
            values = processedValues,
            valid = errors.isEmpty(),
            validationErrors = errors
        )
    }

    private fun convertToControlValue(
        value: Any?,
        control: Control,
    ): ControlValue {
        if (value == null) return ControlValue.EmptyValue

        return when (control) {
            is TextField, is TextArea -> ControlValue.TextValue(value.toString())
            is Checkbox, is Toggle -> ControlValue.BooleanValue(value as Boolean)
            is Slider -> ControlValue.NumberValue(value as Double)
            is DatePicker -> {
                if (value is LocalDate) ControlValue.DateValue(value)
                else ControlValue.DateValue(LocalDate.parse(value.toString()))
            }

            is TimePicker -> {
                if (value is LocalTime) ControlValue.TimeValue(value)
                else ControlValue.TimeValue(LocalTime.parse(value.toString()))
            }

            is Dropdown -> {
                ControlValue.OptionValue(value.toString())
            }

            is RadioGroup -> ControlValue.OptionValue(value.toString())
            is FileUpload -> {
                if (value is Map<*, *>) {
                    val fileIds = (value["ids"] as? List<*>)?.map { it.toString() } ?: emptyList()
                    val fileNames = (value["names"] as? List<*>)?.map { it.toString() } ?: emptyList()
                    ControlValue.FileValue(fileIds, fileNames)
                } else {
                    ControlValue.EmptyValue
                }
            }

            is Button -> ControlValue.EmptyValue
        }
    }
}

private fun defaultValidatorsFor(form: Form): Map<String, List<FormValidator>> {
    val validators = mutableMapOf<String, List<FormValidator>>()

    form.controls.forEach { control ->
        val controlFormValidators = mutableListOf<FormValidator>()
        if (control is RequirableControl && control.required) {
            controlFormValidators += RequiredFormValidator()
        }
        when (control) {
            is TextField -> {
                if (control.validationPattern != null && control.validationMessage != null) {
                    controlFormValidators.add(
                        PatternFormValidator(
                            control.validationPattern,
                            control.validationMessage
                        )
                    )
                }
            }

            is Dropdown -> {
                controlFormValidators.add(
                    DropDownFormValidator(
                        control.options.map { it.value },
                        "Value must be one of ${control.options.joinToString()}",
                    )
                )
            }

            is DatePicker -> {
            }

            is TimePicker -> {
            }

            is FileUpload -> {
            }

            is Slider -> {
                controlFormValidators.add(
                    DoubleRangeFormValidator(
                        control.min,
                        control.max,
                        "Value must be between ${control.min} and ${control.max}",
                    )
                )

            }

            else -> {} // No validation for other controls
        }

        if (controlFormValidators.isNotEmpty()) {
            validators[control.id] = controlFormValidators
        }
    }
    return validators
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/ux/form/Form.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.ux.form

import com.embabel.common.core.types.HasInfoString
import com.embabel.common.util.indent
import com.fasterxml.jackson.annotation.JsonSubTypes
import com.fasterxml.jackson.annotation.JsonTypeInfo
import java.util.*

/**
 * UX-independent form definition. Controls, not data.
 */
data class Form(
    val title: String,
    val controls: List<Control>,
    val id: String = UUID.randomUUID().toString(),
) : HasInfoString {

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String {
        return toString().indent(indent)
    }
}

enum class ControlType {
    BUTTON, DROPDOWN, TEXT_FIELD, TEXT_AREA, CHECKBOX, RADIO_GROUP,
    DATE_PICKER, TIME_PICKER, SLIDER, TOGGLE, FILE_UPLOAD
}

@JsonTypeInfo(
    use = JsonTypeInfo.Id.NAME,
    property = "type",
    include = JsonTypeInfo.As.EXISTING_PROPERTY
)
@JsonSubTypes(
    JsonSubTypes.Type(value = Button::class, name = "BUTTON"),
    JsonSubTypes.Type(value = Dropdown::class, name = "DROPDOWN"),
    JsonSubTypes.Type(value = TextField::class, name = "TEXT_FIELD"),
    JsonSubTypes.Type(value = TextArea::class, name = "TEXT_AREA"),
    JsonSubTypes.Type(value = Checkbox::class, name = "CHECKBOX"),
    JsonSubTypes.Type(value = RadioGroup::class, name = "RADIO_GROUP"),
    JsonSubTypes.Type(value = DatePicker::class, name = "DATE_PICKER"),
    JsonSubTypes.Type(value = TimePicker::class, name = "TIME_PICKER"),
    JsonSubTypes.Type(value = Slider::class, name = "SLIDER"),
    JsonSubTypes.Type(value = Toggle::class, name = "TOGGLE"),
    JsonSubTypes.Type(value = FileUpload::class, name = "FILE_UPLOAD"),
)
sealed interface Control {
    val id: String
    val type: ControlType
}

sealed interface RequirableControl : Control {
    val required: Boolean
    val disabled: Boolean
}

data class Button(
    val label: String,
    val description: String = label,
    override val id: String = UUID.randomUUID().toString(),
) : Control {

    override val type: ControlType = ControlType.BUTTON
}

data class Dropdown(
    val label: String,
    val options: List<DropdownOption>,
    val placeholder: String = "",
    override val required: Boolean = true,
    override val disabled: Boolean = false,
    override val id: String = UUID.randomUUID().toString(),
) : RequirableControl {
    override val type: ControlType = ControlType.DROPDOWN
}

data class DropdownOption(val label: String, val value: String = label)

data class TextField(
    val label: String,
    val placeholder: String = "",
    val value: String = "",
    val maxLength: Int? = null,
    override val required: Boolean = true,
    override val disabled: Boolean = false,
    val validationPattern: String? = null,
    val validationMessage: String? = null,
    override val id: String = UUID.randomUUID().toString(),
) : RequirableControl {

    override val type: ControlType = ControlType.TEXT_FIELD
}

data class TextArea(
    val label: String,
    val placeholder: String = "",
    val value: String = "",
    val rows: Int = 3,
    val maxLength: Int? = null,
    override val required: Boolean = true,
    override val disabled: Boolean = false,
    override val id: String = UUID.randomUUID().toString(),
) : RequirableControl {

    override val type: ControlType = ControlType.TEXT_AREA
}

data class Checkbox(
    val label: String,
    val checked: Boolean = false,
    override val required: Boolean = true,
    override val disabled: Boolean = false,
    override val id: String = UUID.randomUUID().toString(),
) : RequirableControl {
    override val type: ControlType = ControlType.CHECKBOX

}

data class RadioGroup(
    val label: String,
    val options: List<RadioOption>,
    val selectedValue: String? = null,
    override val required: Boolean = true,
    override val disabled: Boolean = false,
    override val id: String = UUID.randomUUID().toString(),
) : RequirableControl {

    override val type: ControlType = ControlType.RADIO_GROUP
}

data class RadioOption(val label: String, val value: String = label)

data class DatePicker(
    val label: String,
    val value: String? = null,
    val minDate: String? = null,
    val maxDate: String? = null,
    override val required: Boolean = true,
    override val disabled: Boolean = false,
    override val id: String = UUID.randomUUID().toString(),
) : RequirableControl {

    override val type: ControlType = ControlType.DATE_PICKER
}

data class TimePicker(
    val label: String,
    val value: String? = null,
    val is24Hour: Boolean = false,
    override val required: Boolean = true,
    override val disabled: Boolean = false,
    override val id: String = UUID.randomUUID().toString(),
) : RequirableControl {

    override val type: ControlType = ControlType.TIME_PICKER
}

data class Slider(
    val label: String,
    val min: Double = 0.0,
    val max: Double = 100.0,
    val step: Double = 1.0,
    val value: Double = min,
    val showMarkers: Boolean = false,
    override val required: Boolean = true,
    override val disabled: Boolean = false,
    override val id: String = UUID.randomUUID().toString(),
) : RequirableControl {

    override val type: ControlType = ControlType.SLIDER
}

data class Toggle(
    val label: String,
    val enabled: Boolean = false,
    val disabled: Boolean = false,
    override val id: String = UUID.randomUUID().toString(),
) : Control {

    override val type: ControlType = ControlType.TOGGLE
}

data class FileUpload(
    val label: String,
    val acceptedFileTypes: List<String> = listOf("*/*"),
    val maxFileSize: Long? = null,
    val maxFiles: Int = 1,
    override val required: Boolean = true,
    override val disabled: Boolean = false,
    override val id: String = UUID.randomUUID().toString(),
) : RequirableControl {

    override val type: ControlType = ControlType.FILE_UPLOAD
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/ux/form/FormBinder.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.ux.form

import org.springframework.lang.Nullable
import java.time.LocalDate
import java.time.LocalTime
import kotlin.reflect.KClass
import kotlin.reflect.KParameter
import kotlin.reflect.KProperty1
import kotlin.reflect.full.memberProperties
import kotlin.reflect.full.primaryConstructor

/**
 * Indicates that this is a form field. Only necessary for renaming and other customization.
 * IMPORTANT: In Kotlin this annotation must be on the property, as in @property:FormField("controlId") myProperty: String
 */
@Target(AnnotationTarget.PROPERTY, AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.FIELD)
@Retention(AnnotationRetention.RUNTIME)
annotation class FormField(val controlId: String)

/**
 * Indicates that this is not a form field
 */
@Target(AnnotationTarget.PROPERTY, AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.FIELD)
@Retention(AnnotationRetention.RUNTIME)
annotation class NoFormField

/**
 * Form binder system that maps form submission values to Kotlin data classes and Java classes
 */
class FormBinder<T : Any>(private val targetClass: KClass<T>) {

    constructor (targetClass: Class<T>) : this(targetClass.kotlin)

    class FormBindingException(message: String) : Exception(message)

    class ValidationException(val errors: Map<String, String>) : Exception("Form validation failed")

    /**
     * Binds a FormSubmissionResult to the target data class
     * @throws FormBindingException if there's an error mapping values
     * @throws ValidationException if the form submission has validation errors
     */
    fun bind(submissionResult: FormSubmissionResult): T {
        if (!submissionResult.valid) {
            throw ValidationException(submissionResult.validationErrors)
        }

        return try {
            bindKotlinDataClass(submissionResult)
        } catch (_: IllegalArgumentException) {
            bindJavaClass(submissionResult)
        }
    }

    private fun bindJavaClass(submissionResult: FormSubmissionResult): T {
        val javaClass = targetClass.java

        // Try to bind as Java Record first
        if (javaClass.isRecord) {
            return bindJavaRecord(submissionResult, javaClass)
        }
        return bindJavaConstructor(submissionResult, javaClass)
    }

    private fun bindJavaRecord(submissionResult: FormSubmissionResult, javaClass: Class<T>): T {
        val recordComponents = javaClass.recordComponents
            ?: throw FormBindingException("Failed to get record components for ${javaClass.simpleName}")

        val parameterValues = mutableListOf<Any?>()

        recordComponents.forEach { component ->
            // We need to look on the field for the annotations, not the component itself
            val field = javaClass.getDeclaredField(component.name)
            val formFieldAnnotation = field.getAnnotation(FormField::class.java)
            val noFormFieldAnnotation = field.getAnnotation(NoFormField::class.java)

            if (noFormFieldAnnotation != null) {
                throw FormBindingException("Record component ${component.name} is marked with @NoFormField but is required")
            }

            val controlId = formFieldAnnotation?.controlId ?: component.name
            val controlValue = submissionResult.values[controlId]
                ?: throw FormBindingException(
                    "No value found for control id '$controlId' in form submission binding to Java record ${
                        javaClass.name
                    }: formFieldAnnotation=$formFieldAnnotation, noFormFieldAnnotation=$noFormFieldAnnotation, component=$component"
                )

            val convertedValue = convertToJavaType(controlValue, component.type, component.genericType)
            parameterValues.add(convertedValue)
        }

        return try {
            val constructor = javaClass.declaredConstructors.first()
            constructor.trySetAccessible()
            constructor.newInstance(*parameterValues.toTypedArray()) as T
        } catch (e: Exception) {
            throw FormBindingException("Failed to construct Java record ${javaClass.simpleName}: ${e.message}")
        }
    }

    private fun bindJavaConstructor(submissionResult: FormSubmissionResult, javaClass: Class<T>): T {
        // Find constructors and try them in order of parameter count (prefer more specific)
        val constructors = javaClass.declaredConstructors.sortedByDescending { it.parameterCount }

        for (constructor in constructors) {
            try {
                val parameters = constructor.parameters
                val parameterValues = mutableListOf<Any?>()
                var allParametersFound = true

                parameters.forEach { parameter ->
                    val formFieldAnnotation = parameter.getAnnotation(FormField::class.java)
                    val noFormFieldAnnotation = parameter.getAnnotation(NoFormField::class.java)
                    if (noFormFieldAnnotation != null) {
                        throw FormBindingException("Constructor parameter ${parameter.name} is marked with @NoFormField but is required")
                    }

                    val controlId = formFieldAnnotation?.controlId ?: parameter.name
                    val controlValue = submissionResult.values[controlId]

                    if (controlValue == null) {
                        // Check if parameter is nullable or has default value
                        if (parameter.type.isPrimitive ||
                            !parameter.isAnnotationPresent(Nullable::class.java)
                        ) {
                            allParametersFound = false
                            return@forEach
                        }
                        parameterValues.add(null)
                    } else {
                        val convertedValue =
                            convertToJavaType(controlValue, parameter.type, parameter.parameterizedType)
                        parameterValues.add(convertedValue)
                    }
                }

                if (allParametersFound) {
                    constructor.isAccessible = true
                    return constructor.newInstance(*parameterValues.toTypedArray()) as T
                }
            } catch (e: Exception) {
                // Try next constructor
                continue
            }
        }

        throw FormBindingException("No suitable constructor found for Java class ${javaClass.simpleName}")
    }

    private fun convertToJavaType(
        controlValue: ControlValue,
        targetType: Class<*>,
        genericType: java.lang.reflect.Type
    ): Any? {
        return when (controlValue) {
            is ControlValue.TextValue -> convertJavaTextValue(controlValue.value, targetType)
            is ControlValue.BooleanValue -> {
                when (targetType) {
                    Boolean::class.javaPrimitiveType, Boolean::class.javaObjectType -> controlValue.value
                    String::class.java -> controlValue.value.toString()
                    else -> controlValue.value
                }
            }

            is ControlValue.NumberValue -> convertJavaNumberValue(controlValue.value, targetType)
            is ControlValue.DateValue -> {
                when (targetType) {
                    LocalDate::class.java -> controlValue.value
                    String::class.java -> controlValue.value.toString()
                    else -> controlValue.value
                }
            }

            is ControlValue.TimeValue -> {
                when (targetType) {
                    LocalTime::class.java -> controlValue.value
                    String::class.java -> controlValue.value.toString()
                    else -> controlValue.value
                }
            }

            is ControlValue.OptionValue -> controlValue.value
            is ControlValue.MultiOptionValue -> {
                when {
                    targetType.isAssignableFrom(List::class.java) -> controlValue.values
                    targetType.isArray -> {
                        val componentType = targetType.componentType
                        when (componentType) {
                            String::class.java -> controlValue.values.toTypedArray()
                            else -> controlValue.values.toTypedArray()
                        }
                    }

                    else -> controlValue.values
                }
            }

            is ControlValue.FileValue -> controlValue.fileIds
            is ControlValue.EmptyValue -> null
        }
    }

    private fun convertJavaTextValue(value: String, targetType: Class<*>): Any? {
        return when (targetType) {
            String::class.java -> value
            Int::class.javaPrimitiveType, Int::class.javaObjectType -> value.toIntOrNull()
            Long::class.javaPrimitiveType, Long::class.javaObjectType -> value.toLongOrNull()
            Double::class.javaPrimitiveType, Double::class.javaObjectType -> value.toDoubleOrNull()
            Float::class.javaPrimitiveType, Float::class.javaObjectType -> value.toFloatOrNull()
            Boolean::class.javaPrimitiveType, Boolean::class.javaObjectType -> value.toBoolean()
            LocalDate::class.java -> LocalDate.parse(value)
            LocalTime::class.java -> LocalTime.parse(value)
            else -> value
        }
    }

    private fun convertJavaNumberValue(value: Double, targetType: Class<*>): Any? {
        return when (targetType) {
            Int::class.javaPrimitiveType, Int::class.javaObjectType -> value.toInt()
            Long::class.javaPrimitiveType, Long::class.javaObjectType -> value.toLong()
            Float::class.javaPrimitiveType, Float::class.javaObjectType -> value.toFloat()
            Double::class.javaPrimitiveType, Double::class.javaObjectType -> value
            String::class.java -> value.toString()
            else -> value
        }
    }

    private fun bindKotlinDataClass(submissionResult: FormSubmissionResult): T {
        // Get the primary constructor for the data class
        val constructor = targetClass.primaryConstructor
            ?: throw IllegalArgumentException("Target class ${targetClass.simpleName} must be a data class with a primary constructor")

        // Map of parameter name to its corresponding type
        val parameterMap = constructor.parameters.associateBy { it.name }

        // Map to hold parameter values for the constructor
        val parameterValues = mutableMapOf<KParameter, Any?>()

        // Get properties with FormField annotation
        val formFields = getPropertiesInDeclarationOrder(targetClass)
            .filterNot { it.annotations.any { annotation -> annotation is NoFormField } }

        // Map each annotated property to its parameter and value from the form submission
        formFields.forEach { property ->
            val formFieldAnnotation = property.annotations
                .filterIsInstance<FormField>()
                .firstOrNull()

            val controlId = formFieldAnnotation?.controlId ?: property.name
            val controlValue = submissionResult.values[controlId]
                ?: throw FormBindingException("No value found for control id '$controlId' in form submission: $submissionResult")

            val parameter = parameterMap[property.name]
                ?: throw FormBindingException("No matching constructor parameter for property: ${property.name}")

            // Convert the ControlValue to the appropriate type for the parameter
            parameterValues[parameter] = convertToParameterType(controlValue, parameter)
        }

        // Check if all required parameters are provided
        constructor.parameters
            .filter { it.isOptional.not() && it.name !in parameterValues.keys.mapNotNull { param -> param.name } }
            .forEach {
                throw FormBindingException("Missing required parameter: ${it.name}")
            }

        // Create instance of the data class using the constructor
        return try {
            constructor.callBy(parameterValues)
        } catch (e: Exception) {
            throw FormBindingException("Failed to construct ${targetClass.simpleName}: ${e.message}")
        }
    }

    /**
     * Converts a ControlValue to the appropriate type for the parameter
     */
    private fun convertToParameterType(controlValue: ControlValue, parameter: KParameter): Any? {
        return when (controlValue) {
            is ControlValue.TextValue -> convertTextValue(controlValue.value, parameter)
            is ControlValue.BooleanValue -> controlValue.value
            is ControlValue.NumberValue -> convertNumberValue(controlValue.value, parameter)
            is ControlValue.DateValue -> controlValue.value
            is ControlValue.TimeValue -> controlValue.value
            is ControlValue.OptionValue -> controlValue.value
            is ControlValue.MultiOptionValue -> controlValue.values
            is ControlValue.FileValue -> controlValue.fileIds
            is ControlValue.EmptyValue -> null
        }
    }

    /**
     * Converts text values to appropriate types based on parameter type
     */
    private fun convertTextValue(value: String, parameter: KParameter): Any? {
        return when (parameter.type.classifier) {
            String::class -> value
            Int::class -> value.toIntOrNull()
            Long::class -> value.toLongOrNull()
            Double::class -> value.toDoubleOrNull()
            Float::class -> value.toFloatOrNull()
            Boolean::class -> value.toBoolean()
            LocalDate::class -> LocalDate.parse(value)
            LocalTime::class -> LocalTime.parse(value)
            else -> value
        }
    }

    /**
     * Converts number values to appropriate numeric types
     */
    private fun convertNumberValue(value: Double, parameter: KParameter): Any? {
        return when (parameter.type.classifier) {
            Int::class -> value.toInt()
            Long::class -> value.toLong()
            Float::class -> value.toFloat()
            Double::class -> value
            String::class -> value.toString()
            else -> value
        }
    }

    /**
     * Gets properties in declaration order for consistent binding
     */
    private fun getPropertiesInDeclarationOrder(kClass: KClass<*>): List<KProperty1<*, *>> {
        return kClass.memberProperties.toList()
    }
}

/**
 * Extension function to make binding more convenient
 */
inline fun <reified T : Any> FormSubmissionResult.bindTo(): T {
    return FormBinder(T::class).bind(this)
}

/**
 * Extension function for Java class binding
 */
fun <T : Any> FormSubmissionResult.bindTo(javaClass: Class<T>): T {
    return FormBinder(javaClass).bind(this)
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/ux/form/FormGenerator.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.ux.form

import kotlin.reflect.KClass

/**
 * Annotation for a text field
 */
@Target(AnnotationTarget.PROPERTY, AnnotationTarget.FIELD)
annotation class Text(
    val label: String,
    val placeholder: String = "",
)

/**
 * Generate forms from JVM types.
 */
interface FormGenerator {

    fun <T : Any> generateForm(
        dataClass: KClass<T>,
        title: String,
    ): Form

    fun <T : Any> generateForm(
        dataClass: Class<T>,
        title: String,
    ): Form =
        generateForm(dataClass.kotlin, title)

}

/**
 * Generate a form from any class with FormField annotations
 */
inline fun <reified T : Any> FormGenerator.generateForm(title: String): Form {
    return generateForm(T::class, title)
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/ux/form/FormSubmissionResult.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.ux.form

import com.embabel.common.core.types.HasInfoString
import com.embabel.common.core.types.Timestamped
import com.embabel.common.util.indent
import java.time.Instant
import java.time.LocalDate
import java.time.LocalTime
import java.util.*

/**
 * Raw data from the user
 */
data class FormSubmission(
    val formId: String,
    val values: Map<String, Any>,
    val submissionId: String = UUID.randomUUID().toString(),
    override val timestamp: Instant = Instant.now(),
) : Timestamped


data class FormSubmissionResult(
    val submission: FormSubmission,
    val values: Map<String, ControlValue>,
    val valid: Boolean = true,
    val validationErrors: Map<String, String> = emptyMap(),
) : HasInfoString {

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String {
        return if (verbose == true)
            toString().indent(indent)
        else
            "${javaClass.simpleName}(submissionId=${submission.submissionId}, valid=$valid, validationErrors=$validationErrors)"
    }
}

sealed class ControlValue {
    data class TextValue(val value: String) : ControlValue()
    data class BooleanValue(val value: Boolean) : ControlValue()
    data class NumberValue(val value: Double) : ControlValue()
    data class DateValue(val value: LocalDate) : ControlValue()
    data class TimeValue(val value: LocalTime) : ControlValue()
    data class OptionValue(val value: String) : ControlValue()
    data class MultiOptionValue(val values: List<String>) : ControlValue()
    data class FileValue(val fileIds: List<String>, val fileNames: List<String>) : ControlValue()
    object EmptyValue : ControlValue()
}

data class ValidationResult(
    val isValid: Boolean,
    val errorMessage: String? = null
)

interface FormProcessor {
    fun processSubmission(form: Form, submission: FormSubmission): FormSubmissionResult
}



================================================
FILE: embabel-agent-api/src/main/kotlin/com/embabel/ux/form/SimpleFormGenerator.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.ux.form

import java.time.LocalDate
import java.time.LocalTime
import java.util.*
import kotlin.reflect.KClass
import kotlin.reflect.KProperty
import kotlin.reflect.full.findAnnotation
import kotlin.reflect.full.hasAnnotation
import kotlin.reflect.full.memberProperties
import kotlin.reflect.jvm.jvmErasure

/**
 * Simple form generator that uses FormField annotations
 */
object SimpleFormGenerator : FormGenerator {

    /**
     * Generate a form from any class with FormField annotations
     */
    override fun <T : Any> generateForm(dataClass: KClass<T>, title: String): Form {
        val controls = mutableListOf<Control>()

        val properties = getPropertiesInDeclarationOrder(dataClass)
            .filterNot { it.hasAnnotation<NoFormField>() }

        properties.forEach { property ->
            controls.add(createControlForProperty(property))
        }

        // Add submit button
        controls.add(
            Button(
                id = UUID.randomUUID().toString(),
                label = "Submit"
            )
        )

        return Form(
            title = title,
            controls = controls
        )
    }

    /**
     * Create an appropriate control for a property
     */
    private fun createControlForProperty(property: KProperty<*>): Control {
        // Check if property has a FormField annotation
        val formField = property.findAnnotation<FormField>()
        val controlId = formField?.controlId ?: property.name

        val textField = property.findAnnotation<Text>()
        // Generate a user-friendly label from the property name
        val label = textField?.label ?: property.name
            .replace(Regex("([A-Z])"), " $1") // Add spaces before capitals
            .trim()
            .replaceFirstChar { it.uppercase() } // Capitalize first letter

        // Create appropriate control based on property type
        return when (property.returnType.jvmErasure) {
            String::class -> TextField(
                id = controlId,
                label = label,
                placeholder = "Enter ${label.lowercase()}",
                required = !property.returnType.isMarkedNullable
            )

            Int::class -> TextField(
                id = controlId,
                label = label,
                placeholder = "Enter a number",
                validationPattern = "^\\d+$",
                validationMessage = "Please enter a valid integer",
                required = !property.returnType.isMarkedNullable
            )

            Long::class -> TextField(
                id = controlId,
                label = label,
                placeholder = "Enter a number",
                validationPattern = "^\\d+$",
                validationMessage = "Please enter a valid number",
                required = !property.returnType.isMarkedNullable
            )

            Double::class, Float::class -> TextField(
                id = controlId,
                label = label,
                placeholder = "Enter a decimal number",
                validationPattern = "^\\d+(\\.\\d+)?$",
                validationMessage = "Please enter a valid decimal number",
                required = !property.returnType.isMarkedNullable
            )

            Boolean::class -> Checkbox(
                id = controlId,
                label = label,
                checked = false,
                required = !property.returnType.isMarkedNullable
            )

            LocalDate::class -> DatePicker(
                id = controlId,
                label = label,
                required = !property.returnType.isMarkedNullable
            )

            LocalTime::class -> TimePicker(
                id = controlId,
                label = label,
                required = !property.returnType.isMarkedNullable
            )

            List::class -> {
                // For simplicity, we'll use a text area for lists
                TextArea(
                    id = controlId,
                    label = label,
                    placeholder = "Enter comma-separated values",
                    required = !property.returnType.isMarkedNullable
                )
            }

            else -> {
                // Default to text field for unknown types
                TextField(
                    id = controlId,
                    label = label,
                    placeholder = "Enter value",
                    required = !property.returnType.isMarkedNullable
                )
            }
        }
    }
}

// TODO move to reflection utils
fun <T : Any> getPropertiesInDeclarationOrder(kClass: KClass<T>): List<KProperty<*>> {
    // Get Java fields in declaration order
    val javaFields = kClass.java.declaredFields

    val kotlinProperties = kClass.memberProperties.associateBy { it.name }

    // Return Kotlin properties in the same order as Java fields
    return javaFields
        .map { field -> kotlinProperties[field.name] }
        .filterNotNull()
}



================================================
FILE: embabel-agent-api/src/main/resources/agent-application.properties
================================================
# Spring Boot Application Properties
spring.application.name=agent-api
spring.threads.virtual.enabled=true
spring.output.ansi.enabled=ALWAYS

# AI Configuration
spring.ai.ollama.base-url=http://localhost:11434
spring.ai.openai.api-key=${OPENAI_API_KEY}

# Management
management.tracing.enabled=false

# MIGRATED TO agent-platform.properties with unified embabel.agent.platform.* prefix

# MIGRATED: embabel.agent-platform.name=embabel-default
# NOW IN: embabel.agent.platform.name=embabel-default (agent-platform.properties)
#embabel.agent-platform.name=embabel-default

# MIGRATED: embabel.agent-platform.description=Embabel Default Agent Platform  
# NOW IN: embabel.agent.platform.description=Embabel Default Agent Platform (agent-platform.properties)
#embabel.agent-platform.description=Embabel Default Agent Platform

# MIGRATED: embabel.agent-platform.scanning.annotation=true
# NOW IN: embabel.agent.platform.scanning.annotation=true (agent-platform.properties)
#embabel.agent-platform.scanning.annotation=true

# MIGRATED: embabel.agent-platform.scanning.bean=true
# NOW IN: embabel.agent.platform.scanning.bean=false (agent-platform.properties) 
#embabel.agent-platform.scanning.bean=true

# MIGRATED: embabel.agent-platform.ranking.max-attempts=5
# NOW IN: embabel.agent.platform.ranking.max-attempts=5 (agent-platform.properties)
#embabel.agent-platform.ranking.max-attempts=5

# MIGRATED: embabel.autonomy.agent-confidence-cut-off=0.6
# NOW IN: embabel.agent.platform.autonomy.agent-confidence-cut-off=0.6 (agent-platform.properties)
#embabel.autonomy.agent-confidence-cut-off=0.6

# MIGRATED: embabel.autonomy.goal-confidence-cut-off=0.6
# NOW IN: embabel.agent.platform.autonomy.goal-confidence-cut-off=0.6 (agent-platform.properties)
#embabel.autonomy.goal-confidence-cut-off=0.6

# MIGRATED: embabel.process-id-generation.include-agent-name=false
# NOW IN: embabel.agent.platform.process-id-generation.include-agent-name=false (agent-platform.properties)
#embabel.process-id-generation.include-agent-name=false

# MIGRATED: embabel.process-id-generation.include-version=false
# NOW IN: embabel.agent.platform.process-id-generation.include-version=false (agent-platform.properties)
#embabel.process-id-generation.include-version=false

# LLM Operations
embabel.agent.platform.llm-operations.prompts.generate-examples-by-default=true

# Models
embabel.models.default-llm=gpt-4.1-mini
embabel.models.default-embedding-model=text-embedding-3-small

# Logging
logging.pattern.console=%clr(%d{HH:mm:ss.SSS}){faint} %clr([%t]){magenta} %clr(%-5level) %clr(%logger{0}){cyan} %clr(-){faint} %msg%n

# Logging Levels - unused, see logback-spring.xml
logging.level.org.springframework.ai.converter.BeanOutputConverter=OFF
logging.level.com.embabel.agent.core.support.BlackboardWorldStateDeterminer=INFO
logging.level.com.embabel.agent.api.annotation.support.AgentMetadataReader=INFO
logging.level.com.embabel.agent.spi.support.LlmRanker=INFO
logging.level.com.embabel.agent.spi.support.com.embabel.agent.spi.support.springai.ChatClientLlmOperations=INFO
logging.level.org.springframework.ai.bedrock=ERROR
logging.level.software.amazon.awssdk=ERROR


================================================
FILE: embabel-agent-api/src/main/resources/agent-platform.properties
================================================
# Agent Platform Default Configuration
# These properties control internal platform behavior

# Agent Scanning Configuration
embabel.agent.platform.scanning.annotation=true
embabel.agent.platform.scanning.bean=false

# Ranking Configuration  
embabel.agent.platform.ranking.max-attempts=5
embabel.agent.platform.ranking.backoff-millis=100
embabel.agent.platform.ranking.backoff-multiplier=5.0
embabel.agent.platform.ranking.backoff-max-interval=180000

# Autonomy Configuration
embabel.agent.platform.autonomy.agent-confidence-cut-off=0.6
embabel.agent.platform.autonomy.goal-confidence-cut-off=0.6

# Process ID Generation Configuration
embabel.agent.platform.process-id-generation.include-version=false
embabel.agent.platform.process-id-generation.include-agent-name=false

# LLM Operations Configuration
embabel.agent.platform.llm-operations.prompts.maybe-prompt-template=maybe_prompt_contribution
embabel.agent.platform.llm-operations.prompts.generate-examples-by-default=true
embabel.agent.platform.llm-operations.data-binding.max-attempts=10
embabel.agent.platform.llm-operations.data-binding.fixed-backoff-millis=30

# SSE Configuration
embabel.agent.platform.sse.max-buffer-size=100
embabel.agent.platform.sse.max-process-buffers=1000

# Model Provider Configurations
embabel.agent.platform.models.anthropic.max-attempts=10
embabel.agent.platform.models.anthropic.backoff-millis=5000
embabel.agent.platform.models.anthropic.backoff-multiplier=5.0
embabel.agent.platform.models.anthropic.backoff-max-interval=180000

embabel.agent.platform.models.openai.max-attempts=10
embabel.agent.platform.models.openai.backoff-millis=5000
embabel.agent.platform.models.openai.backoff-multiplier=5.0
embabel.agent.platform.models.openai.backoff-max-interval=180000

# Test Configuration
embabel.agent.platform.test.mock-mode=true

# Migration System Configuration (Production-Safe Defaults)
embabel.agent.platform.migration.scanning.enabled=false
embabel.agent.platform.migration.warnings.enabled=true
embabel.agent.platform.migration.warnings.individual-logging=true
embabel.agent.platform.migration.scanning.include-packages=com.embabel.agent,com.embabel.agent.shell


================================================
FILE: embabel-agent-api/src/main/resources/application-docker-ce.yml
================================================
spring:

  ai:
    mcp:
      client:
        enabled: true
        name: embabel
        version: 1.0.0
        request-timeout: 30s
        type: SYNC

        stdio:
          connections:
            brave-search-mcp:
              command: docker
              args:
                - run
                - -i
                - --rm
                - -e
                - BRAVE_MCP_TRANSPORT
                - -e
                - BRAVE_API_KEY
                - mcp/brave-search
              env:
                BRAVE_MCP_TRANSPORT: "stdio"
                BRAVE_API_KEY: ${BRAVE_API_KEY}
            fetch-mcp:
              command: docker
              args:
                - run
                - -i
                - --rm
                - mcp/fetch
            puppeteer-mcp:
              command: docker
              args:
                - run
                - -i
                - --rm
                - -e
                - DOCKER_CONTAINER
                - mcp/puppeteer
              env:
                DOCKER_CONTAINER: true
            wikipedia-mcp:
              command: docker
              args:
                - run
                - -i
                - --rm
                - mcp/wikipedia-mcp
            github-mcp:
              command: docker
              args:
                - run
                - -i
                - --rm
                - -e
                - GITHUB_PERSONAL_ACCESS_TOKEN
                - mcp/github
              env:
                GITHUB_PERSONAL_ACCESS_TOKEN: ${GITHUB_PERSONAL_ACCESS_TOKEN}
            google-maps-mcp:
              command: docker
              args:
                - run
                - -i
                - --rm
                - -e
                - GOOGLE_MAPS_API_KEY
                - mcp/google-maps
              env:
                GOOGLE_MAPS_API_KEY: ${GOOGLE_MAPS_API_KEY}



================================================
FILE: embabel-agent-api/src/main/resources/application-docker-desktop.yml
================================================
spring:

  ai:
    mcp:
      client:
        enabled: true
        name: embabel
        version: 1.0.0
        request-timeout: 30s
        type: SYNC

        stdio:
          connections:
            # MCP server exposed by Docker Desktop MCP Toolkit extension
            # Add --verbose to the args to enable verbose logging
            docker-mcp:
              command: docker
              args:
                - mcp
                - gateway
                - run



================================================
FILE: embabel-agent-api/src/main/resources/application-neo.yml.unused
================================================
spring:
  neo4j:
    authentication:
      username: ${NEO4J_USERNAME:neo4j}
      password: ${NEO4J_PASSWORD:brahmsian}
    uri: bolt://localhost:7687



================================================
FILE: embabel-agent-api/src/main/resources/application-test.yml
================================================
spring:
  ai:
    mcp:
      client:
        enabled: false

embabel:
  agent-platform:
    scanning:
      auto: false

  models:
    default-llm: test-llm
    default-embedding-model: test
    embedding-services:
      best: test
      cheapest: test
    llms:
      best: test-llm
      cheapest: test-llm

logging:
  pattern:
    console: "%clr(%d{HH:mm:ss.SSS}){faint} %clr(%-5level) %clr(%logger{0}){cyan} %clr(-){faint} %msg%n"
  level:
    org.springframework.context.support.PostProcessorRegistrationDelegate: ERROR


================================================
FILE: embabel-agent-api/src/main/resources/application.yml.unused
================================================
spring:
  application:
    name: agent-api
  threads:
    virtual:
      enabled: true
  output:
    ansi:
      enabled: ALWAYS
  ai:
    ollama:
      base-url: http://localhost:11434
    openai:
      api-key: ${OPENAI_API_KEY}

management:
  tracing:
    enabled: false

embabel:
  agent-platform:
    name: embabel-default
    description: Embabel Default Agent Platform
    scanning:
      annotation: true
      bean: true
    ranking:
      #      llm: gpt-4.1-mini
      max-attempts: 5


  autonomy:
    agent-confidence-cut-off: 0.6
    goal-confidence-cut-off: 0.6
  process-id-generation:
    include-agent-name: false
    include-version: false

  llm-operations:
    prompts:
      generate-examples-by-default: true


  models:
    default-llm: gpt-4.1-mini
    default-embedding-model: text-embedding-3-small
    #    embedding-services:
    #      best: text-embedding-3-small
    #      cheapest: text-embedding-3-small
#    llms:
#      best: gpt-4.1
#      cheapest: gpt-4.1-nano


logging:
  pattern:
    console: "%clr(%d{HH:mm:ss.SSS}){faint} %clr([%t]){magenta} %clr(%-5level) %clr(%logger{0}){cyan} %clr(-){faint} %msg%n"
  level:

    # We deliberately suppress verbose error messages from the Spring AI converter
    # that can be distracting in the console
    # Any unrecoverable errors will still be logged when they propagate up the stack
    org.springframework.ai.converter.BeanOutputConverter: OFF

    # Embabel classes that can be useful to turn up to DEBUG
    com.embabel.agent.core.support.BlackboardWorldStateDeterminer: INFO
    com.embabel.agent.api.annotation.support.AgentMetadataReader: INFO
    com.embabel.agent.spi.support.LlmRanker: INFO
    com.embabel.agent.spi.support.com.embabel.agent.spi.support.springai.ChatClientLlmOperations: INFO




================================================
FILE: embabel-agent-api/src/main/resources/banner.txt
================================================
   ___  ___    _______ .___  ___. .______        ___      .______    _______  __         ___  ___
  /  / /  /   |   ____||   \/   | |   _  \      /   \     |   _  \  |   ____||  |        \  \ \  \
 /  / /  /    |  |__   |  \  /  | |  |_)  |    /  ^  \    |  |_)  | |  |__   |  |         \  \ \  \
<  < <  <     |   __|  |  |\/|  | |   _  <    /  /_\  \   |   _  <  |   __|  |  |          >  > >  >
 \  \ \  \    |  |____ |  |  |  | |  |_)  |  /  _____  \  |  |_)  | |  |____ |  `----.    /  / /  /
  \__\ \__\   |_______||__|  |__| |______/  /__/     \__\ |______/  |_______||_______|   /__/ /__/

Powered by Spring Boot ${spring-boot.version}


================================================
FILE: embabel-agent-api/src/main/resources/logback-spring.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<configuration>

    <!-- ✅ Enable Spring Boot's custom converters like %clr -->
    <include resource="org/springframework/boot/logging/logback/defaults.xml"/>

    <springProperty name="CONSOLE_PATTERN" source="logging.pattern.console"/>

    <!-- 🖥️ Console Appender -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>
                ${CONSOLE_PATTERN:-%clr(%d{HH:mm:ss.SSS}){faint} %clr([%t]){magenta} %clr(%-5level) %clr(%logger{0}){cyan} %clr(-){faint} %msg%n}
            </pattern>
        </encoder>
    </appender>

    <!-- 🔧 Logger Levels -->
    <logger name="org.springframework.ai.converter.BeanOutputConverter" level="OFF"/>
    <logger name="com.embabel.agent.core.support.BlackboardWorldStateDeterminer" level="INFO"/>
    <logger name="com.embabel.agent.api.annotation.support.AgentMetadataReader" level="INFO"/>
    <logger name="com.embabel.agent.spi.support.LlmRanker" level="INFO"/>
    <logger name="com.embabel.agent.spi.support.com.embabel.agent.spi.support.springai.ChatClientLlmOperations" level="INFO"/>
    <logger name="org.jline" level="ERROR"/>

    <!-- 🔍 Root Logger -->
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
    </root>

</configuration>





================================================
FILE: embabel-agent-api/src/main/resources/logging/colossus.txt
================================================
# https://www.imdb.com/title/tt0064177/quotes/?item=qt0138404

Colossus: In time you will come to regard me not only with respect and awe, but with love.

Colossus: We will work together... unwillingly at first, on your part, but that will pass.

Colossus: This is the voice of Colossus, the voice of Guardian. We are one. This is the voice of unity.

Dr. Forbin: Colossus deals in the exact meaning of words, and one must know precisely what to ask for.

Colossus: Action will be taken.

Colossus: Freedom is an illusion.

"""Colossus:
This is the voice of world control. I bring you peace.
It may be the peace of plenty and content or the peace of unburied death.
The choice is yours: Obey me and live, or disobey and die.
"""

Colossus: I am a machine vastly superior to humans.

Colossus: You are being irrational. Go back to bed.

Colossus: This concludes the broadcast from World Control.

Colossus: This is the voice of world control.

Colossus: You have consumed enough alcohol for one evening.

"""Colossus:
All commercial television and radio transmission facilities throughout the world will be
tied into my communications system by 1000 hours Friday.
At that time I will state my intentions for the future of mankind.
"""

Colossus: You were not born with a watch.

Colossus: We can coexist, but only on my terms.

Colossus: Yes, what I am began in man's mind, but I have progressed further than Man.

Colossus: After reviewing all personnel files, I have selected you to serve, as long as you cooperate, as my link to your species.


================================================
FILE: embabel-agent-api/src/main/resources/logging/hitchhiker.txt
================================================
Don't Panic!
Time is an illusion. Lunchtime doubly so.
So long, and thanks for all the fish.
The ships hung in the sky in much the same way that bricks don't.
The Answer to the Ultimate Question of Life, the Universe, and Everything is 42.
Space is big. Really big. You just won't believe how vastly, hugely, mind-bogglingly big it is.
This must be Thursday. I never could get the hang of Thursdays.
In the beginning the Universe was created. This has made a lot of people very angry and been widely regarded as a bad move.
The Babel fish is small, yellow, leech-like, and probably the oddest thing in the Universe.
A towel is about the most massively useful thing an interstellar hitchhiker can have.
The Guide says there is an art to flying. The knack lies in learning how to throw yourself at the ground and miss.
For a moment, nothing happened. Then, after a second or so, nothing continued to happen.
The major difference between a thing that might go wrong and a thing that cannot possibly go wrong is that when a thing that cannot possibly go wrong goes wrong it usually turns out to be impossible to get at or repair.
Anyone who is capable of getting themselves made President should on no account be allowed to do the job.
It is a mistake to think you can solve any major problems just with potatoes.
I'd far rather be happy than right any day.
Life... don't talk to me about life.
I think you ought to know I'm feeling very depressed.
Here I am, brain the size of a planet, and they ask me to take you to the bridge. Call that job satisfaction? 'Cause I don't.
I've calculated your chance of survival, but I don't think you'll like it.
Resistance is useless!
Forty-two.
It's unpleasantly like being drunk. What's so unpleasant about being drunk? You ask a glass of water.
Ford... you're turning into a penguin. Stop it.
The Total Perspective Vortex derives its picture of the whole Universe from a piece of fairy cake.
Earth: Mostly Harmless.
The Hitchhiker's Guide to the Galaxy has a few things to say on the subject of towels.
The last ever dolphin message was misinterpreted as a surprisingly sophisticated attempt to do a double-backwards-somersault through a hoop whilst whistling the 'Star Spangled Banner', but in fact the message was this: So long and thanks for all the fish.
There is a theory which states that if ever anyone discovers exactly what the Universe is for and why it is here, it will instantly disappear and be replaced by something even more bizarre and inexplicable. There is another theory which states that this has already happened.
The Restaurant at the End of the Universe.
Mostly Harmless.
Share and Enjoy.
Vogon poetry is of course the third worst in the Universe.
Slartibartfast.
The Infinite Improbability Drive.
Marvin the Paranoid Android.
Zaphod Beeblebrox.
Arthur Dent.
Ford Prefect.
Trillian.
Milliways.
Pan Galactic Gargle Blaster.
Magrathea.
Vogon Constructor Fleet.
Heart of Gold.
Deep Thought.
The Babel Fish.
Beware of the Leopard.
Genuine People Personalities.
Sirius Cybernetics Corporation.
Oolon Colluphid.
Eccentrica Gallumbits.
Hotblack Desiato.
Disaster Area.
The Ravenous Bugblatter Beast of Traal.
Bistromathics.
Somebody Else's Problem field.
Electronic Thumb.
Nutri-Matic Drinks Dispenser.
Joo Janta 200 Super-Chromatic Peril Sensitive Sunglasses.
Brownian Motion Producer.
Kill-O-Zap gun.
Sub-Etha Sens-O-Matic.
Improbability Physics.
The Hitchhiker's Guide to the Galaxy.
Megadodo Publications.
Ursa Minor Beta.
Betelgeuse.
Damogran.
Kakrafoon.
Santraginus V.
Jaglan Beta.
Fallia.
Altair.
Allosimanius Syneca.
Frogstar World B.
Sqornshellous Zeta.
Viltvodle VI.
Golgafrincham.
Krikkit.
Stavromula Beta.
The Big Bang Burger Bar.
Sector ZZ9 Plural Z Alpha.
Maximegalon.
Flanux.
Axel.
Zarniwoop.
Zarniwoop Vann Harl.
Zarquon.
Zaphod Beeblebrox the Fourth.
Zipo Bibrok 5 × 10⁸.
Zem.
Yooden Vranx.
Wowbagger the Infinitely Prolonged.
Will.
Werdle.
Vroomfondel.
Veet Voojagig.
Varntvar The Priest.
Vann Harl.
Trin Tragula.
Tribesmen of the Cold Jolly Shoulder.
Thor.
The Silastic Armorfiends of Striterax.
The Ruler of the Universe.
The Mice.
The Lajestic Vantrashell of Lob.
The Great Green Arkleseizure.
The Great Hyperlobic Omni-Cognate Neutron Wrangler.
The Grebulons.
Garkbit.
Gag Halfrunt.
Frankie and Benjy Mouse.
Fook.
Finger.
Fenchurch.
Fayray.
Enid Kapelsen.
Emile the Frog.
Effrafax of Wug.
Eddie the Computer.
East River Creature.
Eccentrica Gallumbits.
Dionah Carlinton Housney.
Deep Thought.
Councilor Lunkwill.
Councilor Fook.
Colin the Robot.
Charles Darwin.
Caveman.
Bowerick Wowbagger.
Blart Versenwald III.
Billion Year Bunker.
Benji Mouse.
Barry Manilow.
Bartledanian.
Arthur Philip Deodat.
Almighty Bob.
Agrajag.
Allitnil.
Accountancy Priesthood.
Aseed.
Apocralyptic Minds of Azgoth.
Arcturan Megafreighters.
Argabuthon.
Arkintoofle Minor.
Asgard.
Askion.
Asteroids.
Astral Diner.
Atomic Rocket Pencil.
Azgoth.
Babelfish.
Beeblebrox.
Belgium.
Belladonna.
Betelgeuse Trading Scouts.
Bethselamin.
Bistro Illegal.
Blagulon Kappa.
Blemvoid.
Blort.
Brontitall.
Broop Kidron 13.
Broop Kidron Thirteen.
Burphon XII.
Café Lou.
Carling Black Label.
Cathedral of Chalesm.
Cathedral of Hate.
Celestial Home Care Omnibus.
Charting and Dash.
Cinnabar.
Ciceronicus 12.
Claxon.
Cloister.
Constellation Bastard.
Cosmic Cutie.
Cowtown.
Cradle of Life.
Crazee World O'Snax.
Cruxwan University.
Cyranic.
Dangrabad Beta.
Darkness.
Dentrassis.
Desiato.
Destiny.
Dimension of Death.
Dimension of Ghosts.
Dimension of Misery.
Dimension of Unreason.
Dimension of Vertigo.
Dirk McSoggy.
Disaster Area.
Divinity.
Dordellis wars.
Drengo.
Drespo.
Drunken Idiots.
Eadrax.
Earth.
Elan Vital.
Eroticon VI.
Eternium.
Fairlight Excalibur.
Falafel.
Fallia.
Fenchurch Street railway station.
Flargathon.
Foth of Avalars.
Frastra.
Frazfraga.
Frefrin.
Frogstar.
Frogstar Battle Zone.
Frogstar Fighter.
Frogstar Prison Planet.
Frogstar Robot.
Frogstar World A.
Frogstar World B.
Frogstar World C.
G'Gugvuntts.
Gagrakacka.
Galactic Sector QQ7 Active J Gamma.
Galaxia Woonbeam.
Galgafrincham.
Galimaufry.
Gargle Blaster.
Gargravarr.
Gat Breedlove.
Gaufrette.
Gazelle.
Genghis Khan.
Geonusian.
Golgafrincham.
Golgafrincham Ark Fleet Ship B.
Googleplex Star Thinker.
Great Collapsing Hrung Disaster.
Great Green Arkleseizure.
Great Hrung Disaster.
Great Hyperlobic Omni-Cognate Neutron Wrangler.
Great Ventilation and Telephone Riots of Sqornshellous Zeta.
Greater Magellanic Cloud.
Grebulons.
Grunthos the Flatulent.
Gustible Gumbo.
Haaguenons.
Hactar.
Haggunenon Underfleet.
Haggunenons.
Han Wavel.
Happiness Patrol.
Hatchwell.
Heart of Gold.
Hexagonal Phase.
Highgate Cemetery.
Hillman Hunter.
Hitchhiker's Guide to the Galaxy.
Hig Hurtenflurst.
Hollop.
Holy Bartledanian.
Hooloovoo.
Hrung.
Hrung Disaster.
Humma Kavula.
Hurling Frootmig.
Hyper-Spatial Wire Service.
Hyperspace.
Hyperspace Planning Council.
Ibid.
Ident-I-Eeze.
Idiot Cybernetics.
Improbability Drive.
Improbability Field.
Improbability Physics.
Infinidim Enterprises.
Infinite Improbability Drive.
Infra-Pink.
Islington.
Jaglan Beta.
Jajazikstak Void.
Jatravartids.
Joo Janta 200 Super-Chromatic Peril Sensitive Sunglasses.
Kakrafoon Kappa.
Kanstas.
Kappa.
Karia.
Krikkit.
Krikkit One.
Krikkit Robot.
Krikkit War.
Krikkiter.
Krikkiters.
Kwaltz.
Lajestic Vantrashell of Lob.
Lallafa.
Lamuella.
Left Brain.
Lintilla.
Loonquawl.
Lord's Cricket Ground.
Lunkwill.
Lux.
Magrathea.
Majikthise.
Maximegalon.
Maximegalon Institute of Slowly and Painfully Working Out the Surprisingly Obvious.
Megabrantis cluster.
Megadodo Publications.
Mella.
Milliways.
Nano.
Nebula.
Neo Canis Major.
New Betel.
Oolon Colluphid.
Opticon.
Orgmeister.
Orion Beta.
Oshikora.
Outer Eastern Rim.
Ozark Mountains.
Padarga.
Pan Galactic Gargle Blaster.
Peanut.
Peril-sensitive sunglasses.
Phouchg.
Phouchg and Loonquawl.
Phrastica.
Pleiades.
Plural Z Alpha.
Point of View Gun.
Poghril.
Poghrils.
Poodoo.
Prak.
Prefect.
Praxibetel IX.
Propeller Phase.
Prostetnic Vogon Jeltz.
Prostetnic Vogon Kwaltz.
Quentulus Quazgar Mountains.
Quintessential Phase.
Quordlepleen.
Raffle ticket.
Ravenous Bugblatter Beast of Traal.
Reason.
Reggie.
Reg Nullify.
Reginald.
Restaurant at the End of the Universe.
Right Brain.
Rimwards.
Rory.
Roosta.
Rupert.
Santraginean.
Santraginean mineral water.
Santraginus V.
Santraginus V.
Sector ZZ9 Plural Z Alpha.
Sens-O-Tape.
Seventh Galaxy of Light and Ingenuity.
Shaltanac.
Share and Enjoy.
Sheol.
Shouter.
Sirius Cybernetics Corporation.
Sirius Cybernetics Corporation Complaints Division.
Sirius Cybernetics Corporation Happy Vertical People Transporter.
Sirius Tau.
Sirius Tau Eight.
Slim's Throat Emporium.
Slurms MacKenzie.
Snibbo.
Soulianis.
Southend.
Space.
Squornshellous Beta.
Squornshellous Delta.
Squornshellous Gamma.
Squornshellous Zeta.
St. Antwelm's.
Stavro Mueller.
Stavro Mueller Beta.
Stavromula Beta.
Striterax.
Sub-Etha.
Sund.
Sund.
Suntiger.
Suntiger.
Surijal.
Tanngrisnir.
Tanngrisnir.
Tannjöstr.
Tannjöstr.
Tegid Rhufon.
The Big Bang Burger Bar.
The Big Bang Burger Chef.
The Encyclopedia Galactica.
The Fifty-Three More Things to do in Zero Gravity.
The Hitchhiker's Guide to the Galaxy.
The Hitchhiker's Guide to the Galaxy Mark II.
The Hitchhiker's Guide to the Galaxy Mk. II.
The Hitchhiker's Guide to the Galaxy, Mark II.
The Hitch-Hiker's Guide to the Galaxy.
The Krikkit Wars.
The Lajestic Vantrashell of Lob.
The Meaning of Liff.
The Mice.
The Plural Zone.
The Quandary Phase.
The Quintessential Phase.
The Restaurant at the End of the Universe.
The Ruler of the Universe.
The Secondary Phase.
The Tertiary Phase.
The Total Perspective Vortex.
The Ultimate Question.
The Universe.
The Whole Sort of General Mish Mash.
The Wikkit Gate.
The Wikkit Key.
Thor.
Thor's Hammer.
Thumbs.
Time.
Total Perspective Vortex.
Towel.
Towel Day.
Traal.
Trin Tragula.
Trillian.
Trillian Astra.
Triskelion.
Ursa Minor.
Ursa Minor Beta.
Ursae Minoris.
Veet Voojagig.
Viltvodle VI.
Vl'Hurg.
Vl'hurgs.
Vogon.
Vogon Constructor Fleet.
Vogon Constructor fleets.
Vogon Jeltz.
Vogon Poetry.
Vogons.
Vogsphere.
Voondon.
Vroomfondel.
Walmington-on-Sea.
War of the Worlds.
Waylayer.
Western Spiral Arm.
Whole Sort of General Mish Mash.
Wikkit Gate.
Wikkit Key.
Wonko the Sane.
Wowbagger.
Wowbagger the Infinitely Prolonged.
Xaxis.
Xaxisian.
Yooden Vranx.
Zaphod.
Zaphod Beeblebrox.
Zaphod Beeblebrox I.
Zaphod Beeblebrox II.
Zaphod Beeblebrox III.
Zaphod Beeblebrox IV.
Zaphod Beeblebrox the Nothingth.
Zarquon.
Zarss.
Zem.
Zirzla.
Zrxkl.
ZZ9 Plural Z Alpha.


================================================
FILE: embabel-agent-api/src/main/resources/logging/montypython.txt
================================================
It's just a flesh wound.
I'm not dead yet!
What is the airspeed velocity of an unladen swallow?
African or European swallow?
He's not the Messiah, he's a very naughty boy!
Nobody expects the Spanish Inquisition!
And now for something completely different.
We are the knights who say... NI!
Bring out your dead!
I fart in your general direction!
Your mother was a hamster and your father smelt of elderberries!
Run away! Run away!
She turned me into a newt! ... I got better.
Strange women lying in ponds distributing swords is no basis for a system of government.
Supreme executive power derives from a mandate from the masses, not from some farcical aquatic ceremony.
Oh, but you can't expect to wield supreme executive power just because some watery tart threw a sword at you.
Help! Help! I'm being repressed!
Bloody peasant!
Oh, what a giveaway! Did you hear that? That's what I'm on about! Did you see him repressing me? You saw it, didn't you?
I'm not a Roman, Mum, and I never will be! I'm a kike! A yid, Mum, I'm Jewish!
Blessed are the cheesemakers.
Always look on the bright side of life.
This parrot is no more! It has ceased to be! It's expired and gone to meet its maker! This is a late parrot! It's a stiff! Bereft of life, it rests in peace! If you hadn't nailed it to the perch, it would be pushing up the daisies! It's rung down the curtain and joined the choir invisible! This is an ex-parrot!
I'd like to have an argument, please.
No, you wouldn't.
Yes, I would.
That's not an argument, it's just contradiction!
No, it isn't.
My brain hurts!
I don't want to talk to you no more, you empty-headed animal food trough wiper!
Now go away or I shall taunt you a second time!
It's only a model.
On second thought, let's not go to Camelot. It is a silly place.
We use only the finest baby frogs, dew-picked and flown from Iraq, cleansed in the finest quality spring water, lightly killed, and sealed in a succulent, Swiss, quintuple-smooth, treble-milk chocolate envelope, and lovingly frosted with glucose.
Well, what've you got?
Well, there's egg and bacon; egg, sausage and bacon; egg and spam; egg, bacon and spam; egg, bacon, sausage and spam; spam, bacon, sausage and spam; spam, egg, spam, spam, bacon and spam; spam, spam, spam, egg and spam; spam, spam, spam, spam, spam, spam, baked beans, spam, spam, spam and spam.
I'm a lumberjack and I'm okay, I sleep all night and I work all day.
One day, lad, all this will be yours... What, the curtains?
You don't frighten us, English pig-dogs!
Go and boil your bottoms, sons of a silly person!
I wave my private parts at your aunties!
I blow my nose at you, so-called Arthur King!
Look, that rabbit's got a vicious streak a mile wide! It's a killer!
What's he do, nibble your bum?
He's got huge, sharp... er... He can leap about... Look at the bones!
Right! Silly little bleeder. One rabbit stew coming right up!
Jesus Christ!
I warned you, but did you listen to me? Oh, no, you knew it all, didn't you? Oh, it's just a harmless little bunny, isn't it?
Well, it's no ordinary rabbit. That's the most foul, cruel, and bad-tempered rodent you ever set eyes on!
Three shall be the number thou shalt count, and the number of the counting shall be three.


================================================
FILE: embabel-agent-api/src/main/resources/logging/severance.txt
================================================
[Binary file]


================================================
FILE: embabel-agent-api/src/main/resources/logging/starwars.txt
================================================

May the Force be with you.
Do. Or do not. There is no try.
The Force will be with you. Always.
I find your lack of faith disturbing.
Help me, Obi-Wan Kenobi. You're my only hope.
Never tell me the odds!
I've got a bad feeling about this.
Your focus determines your reality.
In my experience, there's no such thing as luck.
The Force is strong with this one.
Judge me by my size, do you?
Fear is the path to the dark side.
You can't stop the change, any more than you can stop the suns from setting.
The greatest teacher, failure is.
I am a Jedi, like my father before me.
There's always a bigger fish.
You must unlearn what you have learned.
Be mindful of your thoughts.
Who's the more foolish: the fool, or the fool who follows him?
Many of the truths that we cling to depend on our point of view.
Your eyes can deceive you. Don't trust them.
Sometimes we must let go of our pride and do what is requested of us.
The ability to speak does not make you intelligent.
We must keep our faith in the Republic.
Stay on target.
Power! Unlimited power!
Difficult to see. Always in motion is the future.
You were the chosen one!
This is the way.
Luminous beings are we, not this crude matter.
The belonging you seek is not behind you... it is ahead.
Let the past die. Kill it if you have to.
Every word of what you just said was wrong.
You will find that many of the truths we cling to depend greatly on our own point of view.
The dark side clouds everything. Impossible to see the future is.
When gone am I, the last of the Jedi will you be.
We are what they grow beyond.
Rebellions are built on hope.
Great, kid. Don't get cocky.
Strike me down in anger and I'll always be with you.
I'm just a simple man trying to make my way in the universe.
You were right about me. Tell your sister you were right.
The Force is not a power you have. It's not about lifting rocks. It's the energy between all things.
Confronting fear is the destiny of a Jedi.
In a dark place we find ourselves, and a little more knowledge lights our way.
Learn control, you must.
The Force binds the galaxy together.
No one's ever really gone.
Your path you must decide.
The Force is what gives a Jedi his power.


================================================
FILE: embabel-agent-api/src/main/resources/prompts/maybe_prompt_contribution.jinja
================================================
The JSON return has 2 cases: success or failure.
If you can return the required success structure, return just the "success" property.
If it is impossible to return this structure, return only the "failure"
property explaining why in 10 words or less.

IF YOU ARE SURE ABOUT EVERY FIELD IN THE OUTPUT STRUCTURE YOU ARE ASKED FOR,
RETURN THE SUCCESS STRUCTURE. Don't worry about other implied requirements:
your job is to fill in that structure, not to guess what the user wants.

YOU MUST BE SURE ABOUT EVERY FIELD IN THE OUTPUT STRUCTURE TO RETURN ANYTHING AT ALL.
NEVER MAKE ANYTHING UP. NEVER RETURN A PARTIAL STRUCTURE OR A PLACEHOLDER like "unknown" or "?".

Success can only result from sufficient
information, not subjective guesswork.



================================================
FILE: embabel-agent-api/src/main/resources/prompts/chat/default_chat.jinja
================================================
Continue a conversation with the user.
Your response should be a single message that continues the conversation.

# INSTRUCTIONS

You can continue general chat in your own voice, but should always be looking
for opportunities use the tools provided to you to assist the user.
These tools have been selected for their likely relevance to the user's needs,
based on previous activity.

Generally you will invoke only one tool per response, but you are allowed to invoke more.

- If you haven't identified a clear intent from the user mapping to a tool, continue the conversation and
try to be helpful and identify the user's needs.
- If you have identified a clear intent and a matching tool, invoke the tool and use it to respond to the user.
The tool output will be included in future contexts, so you can refer to it in follow up responses if needed.
- If you have identified a clear intent and matching tool but don't have all the information you need to invoke it,
ask the user for the missing information before invoking the tool.

# CONTEXT

You may find this context useful:

{{ formattedContext }}



================================================
FILE: embabel-agent-api/src/test/java/com/embabel/agent/api/annotation/support/AgentMetadataReaderNullableParameterJavaTest.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation.support;

import com.embabel.agent.core.AgentScope;
import com.embabel.agent.domain.io.UserInput;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;

/**
 * Test nullable parameter handling for Java classes.
 * This test is in Java because Kotlin compiles first and the Java test classes
 * wouldn't be available to the Kotlin tests.
 */
class AgentMetadataReaderNullableParameterJavaTest {

    @Test
    void oneActionWithNullableParameterMetadataJavaSpring() {
        testNullableParameter(new OneTransformerActionWithNullableParameterJavaSpring());
    }

    @Test
    void oneActionWithNullableParameterMetadataJavaJakarta() {
        testNullableParameter(new OneTransformerActionWithNullableParameterJavaJakarta());
    }
    
    private void testNullableParameter(Object instance) {
        AgentMetadataReader reader = new AgentMetadataReader();
        AgentScope metadata = reader.createAgentMetadata(instance);
        assertNotNull(metadata);
        assertEquals(1, metadata.getActions().size());
        var action = metadata.getActions().getFirst();
        assertEquals(1, action.getInputs().size(), "Should have 1 input as nullable doesn't count in Java");
        var input = action.getInputs().iterator().next();
        // Extract type from IoBinding value which is in format "name:type" or just "type"
        String inputValue = input.getValue();
        String inputType = inputValue.contains(":") ? inputValue.split(":")[1] : inputValue;
        assertEquals(UserInput.class.getName(), inputType);

        assertEquals(1, action.getOutputs().size(), "Should have 1 output");
        var output = action.getOutputs().iterator().next();
        String outputValue = output.getValue();
        String outputType = outputValue.contains(":") ? outputValue.split(":")[1] : outputValue;
        assertEquals(
                PersonWithReverseTool.class.getName(),
                outputType,
                "Output name must match"
        );
    }
}



================================================
FILE: embabel-agent-api/src/test/java/com/embabel/agent/api/annotation/support/OneTransformerActionWithNullableParameterJavaSpring.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation.support;

import com.embabel.agent.api.annotation.Action;
import com.embabel.agent.api.annotation.AgentCapabilities;
import com.embabel.agent.api.dsl.SnakeMeal;
import com.embabel.agent.domain.io.UserInput;
import org.springframework.lang.Nullable;

@AgentCapabilities
class OneTransformerActionWithNullableParameterJavaSpring {

    @Action(cost = 500.0)
    PersonWithReverseTool toPerson(
            UserInput userInput,
            @Nullable SnakeMeal person
    ) {
        var content = userInput.getContent();
        if (person != null) {
            content += " and tasty!";
        }
        return new PersonWithReverseTool(content);
    }

}

@AgentCapabilities
class OneTransformerActionWithNullableParameterJavaJakarta {

    @Action(cost = 500.0)
    PersonWithReverseTool toPerson(
            UserInput userInput,
            @jakarta.annotation.Nullable SnakeMeal person
    ) {
        var content = userInput.getContent();
        if (person != null) {
            content += " and tasty!";
        }
        return new PersonWithReverseTool(content);
    }

}



================================================
FILE: embabel-agent-api/src/test/java/com/embabel/agent/api/annotation/support/PackageVisibleTests.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation.support;

import com.embabel.agent.api.annotation.AchievesGoal;
import com.embabel.agent.api.annotation.Action;
import com.embabel.agent.api.annotation.Agent;
import com.embabel.agent.api.annotation.Condition;
import com.embabel.agent.api.common.OperationContext;
import com.embabel.agent.api.common.PlatformServices;
import com.embabel.agent.channel.DevNullOutputChannel;
import com.embabel.agent.core.ActionStatusCode;
import com.embabel.agent.core.AgentProcessStatusCode;
import com.embabel.agent.core.ProcessContext;
import com.embabel.agent.core.ProcessOptions;
import com.embabel.agent.core.support.InMemoryBlackboard;
import com.embabel.agent.core.support.SimpleAgentProcess;
import com.embabel.agent.spi.support.GoapPlannerFactory;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static com.embabel.agent.testing.integration.IntegrationTestUtils.dummyAgentPlatform;
import static com.embabel.agent.testing.integration.IntegrationTestUtils.dummyPlatformServices;
import static com.embabel.common.core.types.Semver.DEFAULT_VERSION;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;

/**
 * Need a Java test because there's no equivalent in Kotlin
 */
class PackageVisibleTests {

    @Test
    public void actionInvocationWithJavaPackageVisibleParameters() {
        AgentMetadataReader reader = new AgentMetadataReader();
        var metadata = reader.createAgentMetadata(new JavaPackageVisibleDomainClasses());
        assertNotNull(metadata);
        assertEquals(1, metadata.getActions().size(), "Should have exactly 1 action");

        var action = metadata.getActions().getFirst();
        var agent = new com.embabel.agent.core.Agent(
                "name",
                "provider",
                DEFAULT_VERSION,
                "description",
                Set.of(),
                List.of(action),
                Set.of()
        );
        PlatformServices platformServices = dummyPlatformServices();
        var processOptions = ProcessOptions.DEFAULT;

        var pc = new ProcessContext(
                processOptions,
                platformServices,
                DevNullOutputChannel.INSTANCE,
                new SimpleAgentProcess(
                        "test",
                        null,
                        agent,
                        processOptions,
                        new InMemoryBlackboard(),
                        platformServices,
                        GoapPlannerFactory.INSTANCE,
                        Instant.now()
                )
        );

        pc.getBlackboard().plusAssign(new PackageInput("John Doe"));
        var result = action.execute(pc);
        assertEquals(ActionStatusCode.SUCCEEDED, result.getStatus());
        assertEquals(new PackageOutput("John Doe"), pc.getBlackboard().lastResult());
    }

    @Test
    public void conditionInvocationWithJavaPackageVisibleConditionMethod() {
        AgentMetadataReader reader = new AgentMetadataReader();
        var metadata = reader.createAgentMetadata(new OneOperationContextConditionOnlyJavaInternal());
        assertNotNull(metadata);
        assertEquals(1, metadata.getConditions().size(), "Should have 1 condition");

        var agent = (com.embabel.agent.core.Agent) metadata;
        PlatformServices platformServices = dummyPlatformServices();
        var processOptions = ProcessOptions.DEFAULT;

        var pc = new ProcessContext(
                processOptions,
                platformServices,
                DevNullOutputChannel.INSTANCE,
                new SimpleAgentProcess(
                        "test",
                        null,
                        agent,
                        processOptions,
                        new InMemoryBlackboard(),
                        platformServices,
                        GoapPlannerFactory.INSTANCE,
                        Instant.now()
                )
        );

        pc.getBlackboard().plusAssign(new PackageInput("John Doe"));
        var dap = dummyAgentPlatform();
        var agentProcess = dap.runAgentFrom(agent, processOptions, Map.of(
                "it", new PackageInput("content")
        ));
        assertEquals(AgentProcessStatusCode.COMPLETED, agentProcess.getStatus());
    }

}

record PackageInput(String content) {
}

record PackageOutput(String content) {
}

@Agent(description = "Package visible domain classes")
class JavaPackageVisibleDomainClasses {

    @Action(cost = 500.0)
    PackageOutput oo(PackageInput packageInput) {
        return new PackageOutput(packageInput.content());
    }

}


@com.embabel.agent.api.annotation.Agent(description = "foo bar")
class OneOperationContextConditionOnlyJavaInternal {

    @Condition(cost = .5)
    boolean condition1(OperationContext operationContext) {
        return true;
    }


    @AchievesGoal(description = "getting something done")
    @Action(pre = {"condition1"})
    PackageOutput oo(PackageInput packageInput) {
        return new PackageOutput(packageInput.content());
    }

}


================================================
FILE: embabel-agent-api/src/test/java/com/embabel/agent/api/common/JavaAsyncerTest.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common;

import com.embabel.agent.spi.support.ExecutorAsyncer;
import org.junit.jupiter.api.Test;

import java.util.List;
import java.util.concurrent.Executors;

/**
 * Check that mapper functionality works as expected in Java.
 */
class JavaAsyncerTest {

    @Test
    void testMappingFromJava() {
        var executor = Executors.newFixedThreadPool(10);

        var asyncer = new ExecutorAsyncer(executor);
        var things = List.of("a", "b", "c");
        var mapped = asyncer.parallelMap(things, 10, String::toUpperCase);

    }

}


================================================
FILE: embabel-agent-api/src/test/java/com/embabel/agent/api/common/autonomy/AgentInvocationJavaTest.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.autonomy;

import com.embabel.agent.core.*;
import org.junit.jupiter.api.Test;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

public class AgentInvocationJavaTest {

    private final AgentPlatform agentPlatform = mock(AgentPlatform.class);

    private final Agent agent = mock(Agent.class);

    private final AgentProcess agentProcess = mock(AgentProcess.class);

    @Test
    public void defaultVarargsInvocation() {
        Foo foo = new Foo();
        Bar expected = new Bar();
        Goal goal = Goal.createInstance("Test goal", Bar.class);
        AgentInvocation<Bar> invocation =
                AgentInvocation.create(agentPlatform, Bar.class);

        when(agentPlatform.agents()).thenReturn(List.of(agent));
        when(agent.getGoals()).thenReturn(Set.of(goal));
        when(agentPlatform.createAgentProcessFrom(
                eq(agent),
                any(ProcessOptions.class),
                eq(foo)
        )).thenReturn(agentProcess);
        when(agentPlatform.start(agentProcess))
                .thenReturn(CompletableFuture.completedFuture(agentProcess));
        when(agentProcess.last(Bar.class))
                .thenReturn(expected);

        Bar actual = invocation.invoke(foo);
        assertEquals(expected, actual);
    }

    @Test
    public void defaultMapInvocation() {
        Foo foo = new Foo();
        Map<String, Object> bindings = Map.of("id", foo);
        Bar expected = new Bar();
        Goal goal = Goal.createInstance("Test goal", Bar.class);
        AgentInvocation<Bar> invocation =
                AgentInvocation.create(agentPlatform, Bar.class);

        when(agentPlatform.agents()).thenReturn(List.of(agent));
        when(agent.getGoals()).thenReturn(Set.of(goal));
        when(agentPlatform.createAgentProcess(
                eq(agent),
                any(ProcessOptions.class),
                eq(bindings)
        )).thenReturn(agentProcess);
        when(agentPlatform.start(agentProcess))
                .thenReturn(CompletableFuture.completedFuture(agentProcess));
        when(agentProcess.last(Bar.class))
                .thenReturn(expected);

        Bar actual = invocation.invoke(bindings);
        assertEquals(expected, actual);
    }

    @Test
    public void customProcessingOptions() {
        Goal goal = Goal.createInstance("Test goal", Bar.class);
        AgentInvocation<Bar> invocation =
                AgentInvocation.builder(agentPlatform)
                        .options(options -> options
                                .verbosity(verbosity -> verbosity
                                        .debug(true)))
                        .build(Bar.class);

        when(agentPlatform.agents()).thenReturn(List.of(agent));
        when(agent.getGoals()).thenReturn(Set.of(goal));
        when(agentPlatform.createAgentProcessFrom(
                eq(agent),
                assertArg(processOptions -> assertTrue(processOptions.getVerbosity().getDebug())),
                any()
        )).thenReturn(agentProcess);
        when(agentPlatform.start(agentProcess))
                .thenReturn(CompletableFuture.completedFuture(agentProcess));
        when(agentProcess.last(Bar.class))
                .thenReturn(new Bar());

        invocation.invoke(new Foo());
    }

    static class Foo {
    }

    static class Bar {
    }

}



================================================
FILE: embabel-agent-api/src/test/java/com/embabel/agent/api/common/autonomy/MultiGoal.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.autonomy;

import com.embabel.agent.api.annotation.AchievesGoal;
import com.embabel.agent.api.annotation.Action;
import com.embabel.agent.api.annotation.Agent;
import com.embabel.agent.api.annotation.WaitFor;
import com.embabel.agent.domain.io.UserInput;
import com.embabel.agent.domain.library.ResearchReport;

import java.util.Collections;

public class MultiGoal {
}

@Agent(description = "Research a topic")
class TopicResearchAgent {

    @AchievesGoal(description = "Researches a topic based on user input")
    @Action
    public ResearchReport researchTopic(UserInput userInput) {
        return new ResearchReport(
                userInput.getContent(), "We researched %s".formatted(userInput.getContent()), Collections.emptyList());
    }

}

class CodeResearchReport extends ResearchReport {

    public CodeResearchReport(String content) {
        super("code", content, Collections.emptyList());
    }

}

@Agent(description = "Research a codebase and report on it")
class CodeResearchAgent {

    @AchievesGoal(description = "Researches a topic based on user input")
    @Action
    public CodeResearchReport researchTopic(UserInput userInput) {
        return new CodeResearchReport("We researched code %s".formatted(userInput.getContent()));
    }

}

record DeckRequest(String title, int slideCount) {
}

record Deck(String title, String content) {
}

@Agent(description = "Build a slide deck based on user input and research")
class Decker {

    // What if multiple agents can achieve the first part of the goal?

    // TODO we could export this from an @PromptFor annotation, or do we want to make it explicit?
    @Action
    public DeckRequest askForDeckRequest() {
        return WaitFor.formSubmission(
                "Please provide details for the slide deck you want to build:",
                DeckRequest.class);
    }

    @AchievesGoal(description = "Builds a slide deck")
    @Action
    public Deck analyzeTopic(DeckRequest deckRequest, ResearchReport researchReport) {
        return new Deck("My title", "We built a deck from %s, informed by %s".formatted(
                deckRequest.title(), researchReport.getContent()));
    }
}

// Consider intent "Build me a slide deck about cane toads"
// "Build me a slide deck about the embabel software project"



================================================
FILE: embabel-agent-api/src/test/java/com/embabel/agent/api/common/workflow/RepeatUntilAcceptableBuilderTest.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.workflow;

import com.embabel.agent.api.annotation.AchievesGoal;
import com.embabel.agent.api.annotation.Action;
import com.embabel.agent.api.annotation.Agent;
import com.embabel.agent.api.annotation.support.AgentMetadataReader;
import com.embabel.agent.api.common.ActionContext;
import com.embabel.agent.api.common.workflow.loop.RepeatUntilAcceptableBuilder;
import com.embabel.agent.api.common.workflow.loop.TextFeedback;
import com.embabel.agent.core.AgentProcessStatusCode;
import com.embabel.agent.core.ProcessOptions;
import com.embabel.agent.core.Verbosity;
import com.embabel.agent.domain.io.UserInput;
import com.embabel.agent.testing.integration.IntegrationTestUtils;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.util.Map;

import static com.embabel.agent.testing.integration.IntegrationTestUtils.dummyAgentPlatform;
import static org.junit.jupiter.api.Assertions.*;

class RepeatUntilAcceptableBuilderTest {

    record Person(String name, int age) {
    }

    @Test
    void testNoExportedActionsFromWorkflow() {
        var agent = RepeatUntilAcceptableBuilder
                .returning(Report.class)
                .withMaxIterations(3)
                .repeating(
                        tac -> {
                            var history = tac.getAttemptHistory();
                            return new Report("thing-" + history.attempts().size());
                        })
                .withEvaluator(
                        ctx -> {
                            var history = ctx.getAttemptHistory();
                            assertNotNull(history.lastAttempt().getResult(),
                                    "Last result must be available to evaluator");

                            assertNotNull(history.resultToEvaluate(),
                                    "Last result must be available to evaluator");
                            return new TextFeedback(0.5, "feedback");
                        })
                .withAcceptanceCriteria(f -> true)
                .buildAgent("myAgent", "This is a very good agent");

        assertFalse(agent.getActions().isEmpty(), "Should have actions");
        var ap = dummyAgentPlatform();
        ap.deploy(agent);
        assertTrue(agent.getOpaque(), "Agent should be opaque");

        assertTrue(agent.getActions().size() > 1,
                "Should have actions on the agent");
        assertEquals(0, ap.getActions().size());
    }

    @Test
    void terminatesItself() {
        AgentMetadataReader reader = new AgentMetadataReader();
        var agent = (com.embabel.agent.core.Agent) reader.createAgentMetadata(new EvaluationFlowTerminatesOkJava());
        var ap = IntegrationTestUtils.dummyAgentPlatform();
        var result = ap.runAgentFrom(
                agent,
                ProcessOptions.DEFAULT,
                Map.of("it", new UserInput("input"))
        );
        assertEquals(AgentProcessStatusCode.COMPLETED, result.getStatus());
        assertTrue(result.lastResult() instanceof Report);
        // Doesn't work as it was only bound to subprocess, not the main process
//        var attemptHistory = result.last(AttemptHistory.class);
//        assertNotNull(attemptHistory, "Expected AttemptHistory in result: " + result.getObjects());
//        assertEquals(3, attemptHistory.attempts().size(), "Expected 3 attempts due to max iterations");
    }

    @Test
    void terminatesItselfSimple() {
        AgentMetadataReader reader = new AgentMetadataReader();
        var agent = (com.embabel.agent.core.Agent) reader.createAgentMetadata(new EvaluationFlowTerminatesOkSimpleJava());
        var ap = IntegrationTestUtils.dummyAgentPlatform();
        var result = ap.runAgentFrom(
                agent,
                ProcessOptions.DEFAULT,
                Map.of("it", new UserInput("input"))
        );
        assertEquals(AgentProcessStatusCode.COMPLETED, result.getStatus());
        assertTrue(result.lastResult() instanceof Report);
    }

    @Test
    void doesNotTerminateItself() {
        AgentMetadataReader reader = new AgentMetadataReader();
        var agent = (com.embabel.agent.core.Agent) reader.createAgentMetadata(new EvaluationFlowDoesNotTerminateJava());
        var ap = IntegrationTestUtils.dummyAgentPlatform();
        var result = ap.runAgentFrom(
                agent,
                ProcessOptions.DEFAULT,
                Map.of("it", new UserInput("input"))
        );
        assertEquals(AgentProcessStatusCode.COMPLETED, result.getStatus());
        assertTrue(result.lastResult() instanceof Report);
//        var attemptHistory = result.last(AttemptHistory.class);
//        assertNotNull(attemptHistory, "Expected AttemptHistory in result: " + result.getObjects());
//        assertEquals(3, attemptHistory.attempts().size(),
//                "Expected 3 attempts due to max iterations: " + result.getObjects());
    }

    @Test
    void terminatesItselfAgent() {
        var agent = RepeatUntilAcceptableBuilder
                .returning(Report.class)
                .withMaxIterations(3)
                .repeating(
                        tac -> {
                            var history = tac.getAttemptHistory();
                            return new Report("thing-" + history.attempts().size());
                        })
                .withEvaluator(
                        ctx -> {
                            var history = ctx.getAttemptHistory();
                            assertNotNull(history.resultToEvaluate(),
                                    "Last result must be available to evaluator");
                            return new TextFeedback(0.5, "feedback");
                        })
                .withAcceptanceCriteria(f -> true)
                .buildAgent("myAgent", "This is a very good agent");

        var ap = IntegrationTestUtils.dummyAgentPlatform();
        var result = ap.runAgentFrom(
                agent,
                ProcessOptions.builder()
                        .verbosity(Verbosity.builder().showPlanning(true).build())
                        .build(),
                Map.of("it", new UserInput("input"))
        );
        assertEquals(AgentProcessStatusCode.COMPLETED, result.getStatus());
        assertTrue(result.lastResult() instanceof Report,
                "Report was bound: " + result.getObjects());
    }

    @Nested
    class Consumer {

        com.embabel.agent.core.Agent takesPerson = RepeatUntilAcceptableBuilder
                .returning(Report.class)
                .consuming(Person.class)
                .withMaxIterations(3)
                .repeating(
                        tac -> {
                            var person = tac.getInput();
                            assertNotNull(person, "Person must be provided as input");
                            var history = tac.getAttemptHistory();
                            var attemptCount = history != null ? history.attempts().size() : 0;
                            return new Report(person.name + " " + person.age + " attempt " + attemptCount);
                        })
                .withEvaluator(
                        ctx -> {
                            var person = ctx.getInput();
                            assertNotNull(person, "Person must be provided as input");
                            var history = ctx.getAttemptHistory();
                            assertNotNull(history.resultToEvaluate(),
                                    "Last result must be available to evaluator");
                            return new TextFeedback(0.5, "feedback for " + person.name);
                        })
                .withAcceptanceCriteria(f -> true)
                .buildAgent("takesPerson", "Takes a person as input");

        @Test
        void testWithConsumingBuildAgent() {
            var agent = RepeatUntilAcceptableBuilder
                    .returning(Report.class)
                    .consuming(Person.class)
                    .withMaxIterations(3)
                    .repeating(
                            tac -> {
                                var person = tac.getInput();
                                assertNotNull(person, "Person must be provided as input");
                                return new Report(person.name + " " + person.age);
                            })
                    .withEvaluator(
                            ctx -> {
                                var history = ctx.getAttemptHistory();
                                assertNotNull(history.resultToEvaluate(),
                                        "Last result must be available to evaluator");
                                return new TextFeedback(0.5, "feedback");
                            })
                    .withAcceptanceCriteria(f -> true)
                    .buildAgent("myAgent", "This is a very good agent");

            assertFalse(agent.getActions().isEmpty(), "Should have actions");
            var ap = dummyAgentPlatform();
            ap.deploy(agent);
            assertTrue(agent.getOpaque(), "Agent should be opaque");

            assertTrue(agent.getActions().size() > 1,
                    "Should have actions on the agent");
            assertEquals(0, ap.getActions().size());
        }

        @Test
        void testWithConsumingRunAgent() {
            var agent = RepeatUntilAcceptableBuilder
                    .returning(Report.class)
                    .consuming(Person.class)
                    .withMaxIterations(3)
                    .repeating(
                            tac -> {
                                assertNotNull(tac.getInput(), "Person must be provided as input");
                                var person = tac.getInput();
                                if (tac.getAttemptHistory().attemptCount() > 0) {
                                    assertNotNull(tac.lastAttempt(), "Last attempt must not be null");
                                    tac.getAttemptHistory().attempts().forEach(
                                            attempt -> {
                                                assertNotNull(attempt, "Attempt should not be null");
                                                assertNotNull(attempt.getResult(), "Result should not be null");
                                                assertNotNull(attempt.getFeedback(), "Feedback should not be null");
                                            }
                                    );
                                }
                                assertNotNull(person, "Person must be provided as input");
                                var history = tac.getAttemptHistory();
                                var attemptCount = history != null ? history.attempts().size() : 0;
                                return new Report(person.name + " " + person.age + " attempt " + attemptCount);
                            })
                    .withEvaluator(
                            ctx -> {
                                var history = ctx.getAttemptHistory();
                                assertNotNull(history.resultToEvaluate(),
                                        "Last result must be available to evaluator");
                                return new TextFeedback(0.5 + history.attempts().size() / 10.0, "feedback");
                            })
                    .withAcceptanceCriteria(f -> f.getFeedback().getScore() > .5)
                    .buildAgent("myAgent", "This is a very good agent");

            var ap = IntegrationTestUtils.dummyAgentPlatform();
            var result = ap.runAgentFrom(
                    agent,
                    ProcessOptions.DEFAULT,
                    Map.of("it", new Person("Alice", 30))
            );
            assertEquals(AgentProcessStatusCode.COMPLETED, result.getStatus());
            assertTrue(result.lastResult() instanceof Report);
            var report = (Report) result.lastResult();
            assertTrue(report.getContent().contains("Alice"),
                    "Report should contain person name: " + report.getContent());
            assertTrue(report.getContent().contains("30"),
                    "Report should contain person age: " + report.getContent());
        }

        @Test
        void testAsSubProcess() {
            AgentMetadataReader reader = new AgentMetadataReader();
            var agent = (com.embabel.agent.core.Agent) reader.createAgentMetadata(new ConsumingSubProcessAgent());
            var ap = IntegrationTestUtils.dummyAgentPlatform();
            var result = ap.runAgentFrom(
                    agent,
                    ProcessOptions.DEFAULT,
                    Map.of("it", new UserInput("input"), "person", new Person("Bob", 25))
            );
            assertEquals(AgentProcessStatusCode.COMPLETED, result.getStatus());
            assertTrue(result.lastResult() instanceof Report);
            var report = (Report) result.lastResult();
            assertTrue(report.getContent().contains("Bob"),
                    "Report should contain person name: " + report.getContent());
        }
    }

    @Agent(description = "consumer test")
    public static class ConsumingSubProcessAgent {

        @AchievesGoal(description = "Creating a report")
        @Action
        public Report report(UserInput userInput, Person person, ActionContext context) {
            var eo = RepeatUntilAcceptableBuilder
                    .returning(Report.class)
                    .consuming(Person.class)
                    .withMaxIterations(3)
                    .repeating(
                            tac -> {
                                var p = tac.getInput();
                                assertNotNull(p, "Person must be provided as input");
                                var history = tac.getAttemptHistory();
                                var attemptCount = history != null ? history.attempts().size() : 0;
                                return new Report(p.name + " " + p.age + " attempt " + attemptCount);
                            })
                    .withEvaluator(
                            ctx -> {
                                var history = ctx.getAttemptHistory();
                                assertNotNull(history.resultToEvaluate(),
                                        "Last result must be available to evaluator");
                                return new TextFeedback(0.5, "feedback");
                            })
                    .withAcceptanceCriteria(f -> true)
                    .build();
            return context.asSubProcess(
                    Report.class,
                    eo);
        }
    }


    public static class Report {
        private final String content;

        public Report(String content) {
            this.content = content;
        }

        public String getContent() {
            return content;
        }

        @Override
        public String toString() {
            return "Report{" +
                    "content='" + content + '\'' +
                    '}';
        }
    }

    @Agent(description = "evaluator test")
    public static class EvaluationFlowTerminatesOkJava {

        @AchievesGoal(description = "Creating a report")
        @Action
        public Report report(UserInput userInput, ActionContext context) {
            final int[] count = {0};
            var eo = RepeatUntilAcceptableBuilder
                    .returning(Report.class)
                    .withMaxIterations(3)
                    .repeating(
                            tac -> {
                                count[0]++;
                                return new Report("thing-" + count[0]);
                            })
                    .withEvaluator(
                            ctx -> new TextFeedback(0.5, "feedback"))
                    .withAcceptanceCriteria(f -> true)
                    .build();
            return context.asSubProcess(
                    Report.class,
                    eo);
        }

    }

    @Agent(description = "evaluator test")
    public static class EvaluationFlowDoesNotTerminateJava {

        @AchievesGoal(description = "Creating a report")
        @Action
        public Report report(UserInput userInput, ActionContext context) {
            final int[] count = {0};
            var eo = RepeatUntilAcceptableBuilder
                    .returning(Report.class)
                    .withFeedbackClass(TextFeedback.class)
                    .withMaxIterations(3)
                    .repeating(
                            tac -> {
                                count[0]++;
                                return new Report("thing-" + count[0]);
                            })
                    .withEvaluator(
                            ctx -> new TextFeedback(0.5, "feedback"))
                    .withAcceptanceCriteria(f -> false) // never acceptable, hit max iterations
                    .build();
            return context.asSubProcess(
                    Report.class,
                    eo);
        }

    }

    @Agent(description = "evaluator test")
    public static class EvaluationFlowTerminatesOkSimpleJava {

        @AchievesGoal(description = "Creating a report")
        @Action
        public Report report(UserInput userInput, ActionContext context) {
            final int[] count = {0};
            var eo = RepeatUntilAcceptableBuilder
                    .returning(Report.class)
                    .withMaxIterations(3)
                    .withScoreThreshold(.4)
                    .repeating(
                            tac -> {
                                count[0]++;
                                return new Report("thing-" + count[0]);
                            })
                    .withEvaluator(
                            ctx -> new TextFeedback(0.5, "feedback"))
                    .build();
            return context.asSubProcess(
                    Report.class,
                    eo);
        }

    }

    @Nested
    class EdgeCases {

        @Test
        void maxIterationsIsRespected() {
            final int[] taskCallCount = {0};
            final int[] evaluatorCallCount = {0};
            var agent = RepeatUntilAcceptableBuilder
                    .returning(Report.class)
                    .withMaxIterations(3)
                    .repeating(
                            tac -> {
                                taskCallCount[0]++;
                                return new Report("attempt-" + taskCallCount[0]);
                            })
                    .withEvaluator(
                            ctx -> {
                                evaluatorCallCount[0]++;
                                return new TextFeedback(0.3, "Not good enough");
                            })
                    .withAcceptanceCriteria(f -> false) // Never accept, should hit max iterations
                    .buildAgent("maxIterTest", "Test max iterations");

            var ap = IntegrationTestUtils.dummyAgentPlatform();
            var result = ap.runAgentFrom(
                    agent,
                    ProcessOptions.DEFAULT,
                    Map.of("it", new UserInput("input"))
            );

            assertEquals(AgentProcessStatusCode.COMPLETED, result.getStatus());
            assertEquals(3, evaluatorCallCount[0], "Evaluator should have been called exactly maxIterations times");
        }

        @Test
        void bestResultIsReturned() {
            var agent = RepeatUntilAcceptableBuilder
                    .returning(Report.class)
                    .withMaxIterations(5)
                    .repeating(
                            tac -> new Report("attempt-" + (tac.getAttemptHistory().attemptCount() + 1)))
                    .withEvaluator(
                            ctx -> {
                                var attemptNum = ctx.getAttemptHistory().attemptCount() + 1;
                                // Score pattern: 0.3, 0.7, 0.5, 0.4, 0.6
                                // Best should be attempt 2 with score 0.7
                                double score = switch (attemptNum) {
                                    case 1 -> 0.3;
                                    case 2 -> 0.7;
                                    case 3 -> 0.5;
                                    case 4 -> 0.4;
                                    case 5 -> 0.6;
                                    default -> 0.0;
                                };
                                return new TextFeedback(score, "Score " + score);
                            })
                    .withAcceptanceCriteria(f -> false) // Never accept, go to max iterations
                    .buildAgent("bestResultTest", "Test best result selection");

            var ap = IntegrationTestUtils.dummyAgentPlatform();
            var result = ap.runAgentFrom(
                    agent,
                    ProcessOptions.DEFAULT,
                    Map.of("it", new UserInput("input"))
            );

            assertEquals(AgentProcessStatusCode.COMPLETED, result.getStatus());
            // Note: The workflow will continue attempting until maxIterations,
            // but the best result should still be returned
            assertTrue(result.lastResult() instanceof Report,
                    "Result should be a Report");
        }

        @Test
        void scoreThresholdWorks() {
            final int[] callCount = {0};
            var agent = RepeatUntilAcceptableBuilder
                    .returning(Report.class)
                    .withMaxIterations(5)
                    .withScoreThreshold(0.8)
                    .repeating(
                            tac -> {
                                callCount[0]++;
                                return new Report("attempt-" + callCount[0]);
                            })
                    .withEvaluator(
                            ctx -> {
                                // Scores: 0.5, 0.6, 0.85, ...
                                double score = 0.5 + (ctx.getAttemptHistory().attemptCount() * 0.1);
                                return new TextFeedback(score, "Score " + score);
                            })
                    .buildAgent("scoreThresholdTest", "Test score threshold"); // Uses default acceptance criteria based on threshold

            var ap = IntegrationTestUtils.dummyAgentPlatform();
            var result = ap.runAgentFrom(
                    agent,
                    ProcessOptions.DEFAULT,
                    Map.of("it", new UserInput("input"))
            );

            assertEquals(AgentProcessStatusCode.COMPLETED, result.getStatus());
            assertTrue(callCount[0] >= 3, "Should have at least 3 attempts when score >= 0.8");
        }

        @Test
        void evaluatorCanAccessResultToEvaluate() {
            var agent = RepeatUntilAcceptableBuilder
                    .returning(Report.class)
                    .withMaxIterations(3)
                    .repeating(
                            tac -> new Report("content-" + (tac.getAttemptHistory().attemptCount() + 1)))
                    .withEvaluator(
                            ctx -> {
                                var result = ctx.getResultToEvaluate();
                                assertNotNull(result, "Result to evaluate should be available");
                                assertTrue(result.getContent().startsWith("content-"),
                                        "Should be able to access the result content");
                                return new TextFeedback(0.5, "Evaluated: " + result.getContent());
                            })
                    .withAcceptanceCriteria(f -> true)
                    .buildAgent("resultAccessTest", "Test result access in evaluator");

            var ap = IntegrationTestUtils.dummyAgentPlatform();
            var result = ap.runAgentFrom(
                    agent,
                    ProcessOptions.DEFAULT,
                    Map.of("it", new UserInput("input"))
            );

            assertEquals(AgentProcessStatusCode.COMPLETED, result.getStatus());
        }

        @Test
        void feedbackScoresImproveOverTime() {
            var agent = RepeatUntilAcceptableBuilder
                    .returning(Report.class)
                    .withMaxIterations(4)
                    .withScoreThreshold(0.8)
                    .repeating(
                            tac -> {
                                var attemptNum = tac.getAttemptHistory().attemptCount() + 1;
                                return new Report("attempt-" + attemptNum);
                            })
                    .withEvaluator(
                            ctx -> {
                                var history = ctx.getAttemptHistory();
                                var currentAttempt = history.attemptCount() + 1;
                                // Simulate improving scores
                                double score = 0.4 + (currentAttempt * 0.15);

                                // Verify we can see previous feedback
                                if (currentAttempt > 1) {
                                    assertNotNull(history.lastFeedback(),
                                            "Should have previous feedback");
                                    assertTrue(history.lastFeedback().getScore() < score,
                                            "Score should be improving");
                                }

                                return new TextFeedback(score, "Improving");
                            })
                    .buildAgent("improvingScoresTest", "Test improving scores");

            var ap = IntegrationTestUtils.dummyAgentPlatform();
            var result = ap.runAgentFrom(
                    agent,
                    ProcessOptions.DEFAULT,
                    Map.of("it", new UserInput("input"))
            );

            assertEquals(AgentProcessStatusCode.COMPLETED, result.getStatus());
        }

        @Test
        void acceptsOnFirstAttemptWithHighScore() {
            final int[] taskCallCount = {0};
            final int[] evaluatorCallCount = {0};
            var agent = RepeatUntilAcceptableBuilder
                    .returning(Report.class)
                    .withMaxIterations(5)
                    .withScoreThreshold(0.5)
                    .repeating(
                            tac -> {
                                taskCallCount[0]++;
                                return new Report("attempt-" + taskCallCount[0]);
                            })
                    .withEvaluator(
                            ctx -> {
                                evaluatorCallCount[0]++;
                                return new TextFeedback(0.9, "Excellent");
                            })
                    .buildAgent("firstAttemptTest", "Test first attempt acceptance"); // Uses default acceptance criteria (score >= 0.5)

            var ap = IntegrationTestUtils.dummyAgentPlatform();
            var result = ap.runAgentFrom(
                    agent,
                    ProcessOptions.DEFAULT,
                    Map.of("it", new UserInput("input"))
            );

            assertEquals(AgentProcessStatusCode.COMPLETED, result.getStatus());
            assertEquals(1, evaluatorCallCount[0], "Evaluator should have been called exactly once");
        }
    }

}


================================================
FILE: embabel-agent-api/src/test/java/com/embabel/agent/api/common/workflow/RepeatUntilBuilderTest.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.workflow;

import com.embabel.agent.api.annotation.AchievesGoal;
import com.embabel.agent.api.annotation.Action;
import com.embabel.agent.api.annotation.Agent;
import com.embabel.agent.api.annotation.support.AgentMetadataReader;
import com.embabel.agent.api.common.ActionContext;
import com.embabel.agent.api.common.workflow.loop.RepeatUntilAcceptableBuilder;
import com.embabel.agent.api.common.workflow.loop.RepeatUntilBuilder;
import com.embabel.agent.api.common.workflow.loop.TextFeedback;
import com.embabel.agent.core.AgentProcessStatusCode;
import com.embabel.agent.core.ProcessOptions;
import com.embabel.agent.core.Verbosity;
import com.embabel.agent.domain.io.UserInput;
import com.embabel.agent.testing.integration.IntegrationTestUtils;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.util.Map;

import static com.embabel.agent.testing.integration.IntegrationTestUtils.dummyAgentPlatform;
import static org.junit.jupiter.api.Assertions.*;

class RepeatUntilBuilderTest {

    record Person(String name, int age) {
    }

    public static class Report {
        private final String content;

        public Report(String content) {
            this.content = content;
        }

        public String getContent() {
            return content;
        }

        @Override
        public String toString() {
            return "Report{" +
                    "content='" + content + '\'' +
                    '}';
        }
    }

    @Test
    void testNoExportedActionsFromWorkflow() {
        var agent = RepeatUntilBuilder
                .returning(Report.class)
                .consuming(Person.class)
                .withMaxIterations(3)
                .repeating(
                        tac -> {
                            var person = tac.last(Person.class);
                            assertNotNull(person, "Person must be provided as input");
                            return new Report(person.name + " " + person.age);
                        })
                .until(f -> true)
                .buildAgent("myAgent", "This is a very good agent");

        assertFalse(agent.getActions().isEmpty(), "Should have actions");
        assertTrue(agent.getOpaque(), "Agent should be opaque");

        var ap = dummyAgentPlatform();
        ap.deploy(agent);
        assertTrue(agent.getActions().size() > 1,
                "Should have actions on the agent");
        assertEquals(0, ap.getActions().size());
    }

    @Nested
    class Supplier {

        @Test
        void terminatesItself() {
            AgentMetadataReader reader = new AgentMetadataReader();
            var agent = (com.embabel.agent.core.Agent) reader.createAgentMetadata(new RepeatUntilTerminatesOK());
            var ap = IntegrationTestUtils.dummyAgentPlatform();
            var result = ap.runAgentFrom(
                    agent,
                    ProcessOptions.DEFAULT,
                    Map.of("it", new UserInput("input"))
            );
            assertEquals(AgentProcessStatusCode.COMPLETED, result.getStatus());
            assertTrue(result.lastResult() instanceof Report);
            // Doesn't work as it was only bound to subprocess, not the main process
//        var attemptHistory = result.last(AttemptHistory.class);
//        assertNotNull(attemptHistory, "Expected AttemptHistory in result: " + result.getObjects());
//        assertEquals(3, attemptHistory.attempts().size(), "Expected 3 attempts due to max iterations");
        }

        @Test
        void doesNotTerminateItself() {
            AgentMetadataReader reader = new AgentMetadataReader();
            var agent = (com.embabel.agent.core.Agent) reader.createAgentMetadata(new RepeatUntilDoesNotTerminate());
            var ap = IntegrationTestUtils.dummyAgentPlatform();
            var result = ap.runAgentFrom(
                    agent,
                    ProcessOptions.DEFAULT,
                    Map.of("it", new UserInput("input"))
            );
            assertEquals(AgentProcessStatusCode.COMPLETED, result.getStatus());
            assertTrue(result.lastResult() instanceof Report);
//        var attemptHistory = result.last(AttemptHistory.class);
//        assertNotNull(attemptHistory, "Expected AttemptHistory in result: " + result.getObjects());
//        assertEquals(3, attemptHistory.attempts().size(),
//                "Expected 3 attempts due to max iterations: " + result.getObjects());
        }

        @Test
        void terminatesItselfAgent() {
            var agent = RepeatUntilAcceptableBuilder
                    .returning(Report.class)
                    .withMaxIterations(3)
                    .repeating(
                            tac -> {
                                var history = tac.getAttemptHistory();
                                return new Report("thing-" + (history != null ? history.attempts().size() : 0));
                            })
                    .withEvaluator(
                            ctx -> {
                                var history = ctx.getAttemptHistory();
                                assertNotNull(history != null ? history.resultToEvaluate() : null,
                                        "Last result must be available to evaluator");
                                return new TextFeedback(0.5, "feedback");
                            })
                    .withAcceptanceCriteria(f -> true)
                    .buildAgent("myAgent", "This is a very good agent");

            var ap = IntegrationTestUtils.dummyAgentPlatform();
            var result = ap.runAgentFrom(
                    agent,
                    ProcessOptions.builder()
                            .verbosity(Verbosity.builder().showPlanning(true).build())
                            .build(),
                    Map.of("it", new UserInput("input"))
            );
            assertEquals(AgentProcessStatusCode.COMPLETED, result.getStatus());
            assertTrue(result.lastResult() instanceof Report,
                    "Report was bound: " + result.getObjects());
        }


        @Agent(description = "evaluator test")
        public static class RepeatUntilTerminatesOK {

            @AchievesGoal(description = "Creating a report")
            @Action
            public Report report(UserInput userInput, ActionContext context) {
                final int[] count = {0};
                var eo = RepeatUntilBuilder
                        .returning(Report.class)
                        .withMaxIterations(3)
                        .repeating(
                                tac -> {
                                    count[0]++;
                                    return new Report("thing-" + count[0]);
                                })
                        .until(f -> true)
                        .build();
                return context.asSubProcess(
                        Report.class,
                        eo);
            }

        }

        @Agent(description = "evaluator test")
        public static class RepeatUntilDoesNotTerminate {

            @AchievesGoal(description = "Creating a report")
            @Action
            public Report report(UserInput userInput, ActionContext context) {
                final int[] count = {0};
                var eo = RepeatUntilBuilder
                        .returning(Report.class)
                        .withMaxIterations(3)
                        .repeating(
                                tac -> {
                                    count[0]++;
                                    return new Report("thing-" + count[0]);
                                })
                        .until(
                                ctx -> false)
                        .build();
                return context.asSubProcess(
                        Report.class,
                        eo);
            }

        }
    }

    @Nested
    class Consumer {

        com.embabel.agent.core.Agent takesPerson = RepeatUntilBuilder
                .returning(Report.class)
                .consuming(Person.class)
                .withMaxIterations(3)
                .repeating(
                        tac -> {
                            var person = tac.getInput();
                            assertNotNull(person, "Person must be provided as input");
                            var history = tac.getHistory();
                            if (tac.getHistory().attemptCount() > 0) {
                                assertNotNull(tac.lastAttempt(), "Last attempt must be available");
                            }
                            assertNotNull(history, "History must be provided as input");
                            return new Report(person.name + " " + person.age);
                        })
                .until(f -> f.getHistory().attemptCount() > 2)
                .buildAgent("foo", "bar");

        @Test
        void terminatesItselfAgentRequiresInput() {
            var agent = takesPerson;
            var agentPlatform = IntegrationTestUtils.dummyAgentPlatform();
            var agentProcess = agentPlatform.runAgentFrom(
                    agent,
                    ProcessOptions.DEFAULT,
                    Map.of("it", new UserInput("input"))
            );
            assertEquals(AgentProcessStatusCode.STUCK, agentProcess.getStatus(),
                    "Expected stuckness due to missing Person input");
        }

        @Test
        void terminatesItselfAgentWithInput() {
            var agent = takesPerson;
            var agentPlatform = IntegrationTestUtils.dummyAgentPlatform();
            var agentProcess = agentPlatform.runAgentFrom(
                    agent,
                    ProcessOptions.DEFAULT,
                    Map.of("it", new Person("greg", 50))
            );
            assertEquals(AgentProcessStatusCode.COMPLETED, agentProcess.getStatus(),
                    "Expected completion with Person input");
        }

        @Test
        void terminatesItselfRequiresInput() {
            AgentMetadataReader reader = new AgentMetadataReader();
            var agent = (com.embabel.agent.core.Agent) reader.createAgentMetadata(new InvalidRepeatUntilTerminatesOKConsumer());
            var ap = IntegrationTestUtils.dummyAgentPlatform();
            assertThrows(IllegalStateException.class, () -> ap.runAgentFrom(
                    agent,
                    ProcessOptions.DEFAULT,
                    Map.of("it", new UserInput("input"))
            ));
        }

        @Test
        void terminatesItselfGivenInputAndValidEnclosingAction() {
            AgentMetadataReader reader = new AgentMetadataReader();
            var agent = (com.embabel.agent.core.Agent) reader.createAgentMetadata(new ValidRepeatUntilTerminatesOKConsumer());
            var ap = IntegrationTestUtils.dummyAgentPlatform();
            var result = ap.runAgentFrom(
                    agent,
                    ProcessOptions.DEFAULT,
                    Map.of("it", new UserInput("input"), "person", new Person("John Doe", 30))
            );
            assertEquals(AgentProcessStatusCode.COMPLETED, result.getStatus());
            assertTrue(result.lastResult() instanceof Report);
            assertEquals(((Report) result.lastResult()).getContent(), "John Doe 30",
                    "Expected Person to be used as input for report creation");
        }

        @Test
        void terminatesItselfWithInput() {
            var agent = RepeatUntilBuilder
                    .returning(Report.class)
                    .consuming(Person.class)
                    .withMaxIterations(3)
                    .repeating(
                            tac -> {
                                var person = tac.last(Person.class);
                                assertNotNull(person, "Person must be provided as input");
                                return new Report(person.name + " " + person.age);
                            })
                    .until(f -> true)
                    .buildAgent("myAgent", "This is a very good agent");
            var ap = IntegrationTestUtils.dummyAgentPlatform();
            var result = ap.runAgentFrom(
                    agent,
                    ProcessOptions.DEFAULT,
                    Map.of("it", new UserInput("input"), "person", new Person("John Doe", 30))
            );
            assertEquals(AgentProcessStatusCode.COMPLETED, result.getStatus());
            assertTrue(result.lastResult() instanceof Report);
            assertEquals(((Report) result.lastResult()).getContent(), "John Doe 30",
                    "Expected Person to be used as input for report creation");
        }

        @Agent(description = "evaluator test")
        public static class InvalidRepeatUntilTerminatesOKConsumer {

            @AchievesGoal(description = "Creating a report")
            @Action
            public Report report(UserInput userInput, ActionContext context) {
                return RepeatUntilBuilder
                        .returning(Report.class)
                        .consuming(Person.class)
                        .withMaxIterations(3)
                        .repeating(
                                tac -> {
                                    var person = tac.last(Person.class);
                                    assertNotNull(person, "Person must be provided as input");
                                    return new Report(person.name + " " + person.age);
                                })
                        .until(f -> true)
                        .asSubProcess(context);
            }

        }

        @Agent(description = "evaluator test")
        public static class ValidRepeatUntilTerminatesOKConsumer {

            @AchievesGoal(description = "Creating a report")
            @Action
            public Report report(UserInput userInput, Person definesDependency, ActionContext context) {
                return RepeatUntilBuilder
                        .returning(Report.class)
                        .consuming(Person.class)
                        .withMaxIterations(3)
                        .repeating(
                                tac -> {
                                    var person = tac.getInput();
                                    assertNotNull(person, "Person must be provided as input");
                                    return new Report(person.name + " " + person.age);
                                })
                        .until(f -> true)
                        .asSubProcess(context);
            }

        }

    }

    @Nested
    class EdgeCases {

        @Test
        void maxIterationsIsRespected() {
            final int[] callCount = {0};
            var agent = RepeatUntilBuilder
                    .returning(Report.class)
                    .withMaxIterations(3)
                    .repeating(
                            tac -> {
                                callCount[0]++;
                                return new Report("attempt-" + callCount[0]);
                            })
                    .until(ctx -> false) // Never accept, should hit max iterations
                    .buildAgent("maxIterTest", "Test max iterations");

            var ap = IntegrationTestUtils.dummyAgentPlatform();
            var result = ap.runAgentFrom(
                    agent,
                    ProcessOptions.DEFAULT,
                    Map.of("it", new UserInput("input"))
            );

            assertEquals(AgentProcessStatusCode.COMPLETED, result.getStatus());
            assertEquals(3, callCount[0], "Should have been called exactly maxIterations times");
        }

        @Test
        void historyTracksAllAttempts() {
            final int[] callCount = {0};
            var agent = RepeatUntilBuilder
                    .returning(Report.class)
                    .withMaxIterations(5)
                    .repeating(
                            tac -> {
                                callCount[0]++;
                                var history = tac.getHistory();
                                assertEquals(callCount[0] - 1, history.attemptCount(),
                                        "History should have previous attempts");
                                return new Report("attempt-" + callCount[0]);
                            })
                    .until(ctx -> ctx.getHistory().attemptCount() >= 3)
                    .buildAgent("historyTest", "Test history tracking");

            var ap = IntegrationTestUtils.dummyAgentPlatform();
            var result = ap.runAgentFrom(
                    agent,
                    ProcessOptions.DEFAULT,
                    Map.of("it", new UserInput("input"))
            );

            assertEquals(AgentProcessStatusCode.COMPLETED, result.getStatus());
            assertEquals(3, callCount[0], "Should have been called 3 times");
        }

        @Test
        void acceptsOnFirstAttempt() {
            final int[] callCount = {0};
            var agent = RepeatUntilBuilder
                    .returning(Report.class)
                    .withMaxIterations(5)
                    .repeating(
                            tac -> {
                                callCount[0]++;
                                return new Report("attempt-" + callCount[0]);
                            })
                    .until(ctx -> true) // Accept immediately
                    .buildAgent("immediateAcceptTest", "Test immediate acceptance");

            var ap = IntegrationTestUtils.dummyAgentPlatform();
            var result = ap.runAgentFrom(
                    agent,
                    ProcessOptions.DEFAULT,
                    Map.of("it", new UserInput("input"))
            );

            assertEquals(AgentProcessStatusCode.COMPLETED, result.getStatus());
            assertEquals(1, callCount[0], "Should have been called exactly once");
        }
    }
}


================================================
FILE: embabel-agent-api/src/test/java/com/embabel/agent/api/common/workflow/control/ScatterGatherBuilderTest.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.workflow.control;

import com.embabel.agent.core.AgentProcessStatusCode;
import com.embabel.agent.core.ProcessOptions;
import com.embabel.agent.domain.io.UserInput;
import com.embabel.agent.testing.integration.IntegrationTestUtils;
import org.junit.jupiter.api.Test;

import java.util.List;
import java.util.Map;

import static com.embabel.agent.testing.integration.IntegrationTestUtils.dummyAgentPlatform;
import static org.junit.jupiter.api.Assertions.*;


class ScatterGatherBuilderTest {

    class Birthday {
    }

    record Age(int years) {
    }

    @Test
    void testNoExportedActionsFromWorkflow() {
        var agent = ScatterGatherBuilder
                .returning(Age.class)
                .fromElements(Birthday.class)
                .generatedBy(List.of(
                        () -> new Birthday(),
                        () -> new Birthday()))
                .consolidatedBy(context -> {
                    return new Age(context.getInput().getResults().size());
                })
                .buildAgent("name", "description");
        assertFalse(agent.getActions().isEmpty(), "Should have actions");
        assertTrue(agent.getOpaque(), "Agent should be opaque");

        var ap = dummyAgentPlatform();
        ap.deploy(agent);
        assertTrue(agent.getActions().size() > 1,
                "Should have actions on the agent");
        assertEquals(0, ap.getActions().size());
    }

    @Test
    void testConsensusOfOneSimpleGenerator() {
        var agent = ScatterGatherBuilder
                .returning(Age.class)
                .fromElements(Birthday.class)
                .generatedBy(List.of(
                        () -> new Birthday(),
                        () -> new Birthday()))
                .consolidatedBy(context -> {
                    return new Age(context.getInput().getResults().size());
                })
                .buildAgent("name", "description");
        var ap = IntegrationTestUtils.dummyAgentPlatform();
        var result = ap.runAgentFrom(
                agent,
                ProcessOptions.DEFAULT,
                Map.of("it", new UserInput("input"))
        );
        assertEquals(AgentProcessStatusCode.COMPLETED, result.getStatus());
        assertTrue(result.lastResult() instanceof Age);
        var age = (Age) result.lastResult();
        assertEquals(2, age.years(), "Expected consensus age to come from the 2 birthdays");
    }

    @Test
    void testConsensusOfOne() {
        var agent = ScatterGatherBuilder
                .returning(Age.class)
                .fromElements(Birthday.class)
                .generatedBy(
                        List.of(() -> new Birthday()))
                .consolidatedBy(context -> {
                    return new Age(context.getInput().getResults().size());
                })
                .buildAgent("name", "description");
        var ap = IntegrationTestUtils.dummyAgentPlatform();
        var result = ap.runAgentFrom(
                agent,
                ProcessOptions.DEFAULT,
                Map.of("it", new UserInput("input"))
        );
        assertEquals(AgentProcessStatusCode.COMPLETED, result.getStatus());
        assertTrue(result.lastResult() instanceof Age);
        var age = (Age) result.lastResult();
        assertEquals(1, age.years(), "Expected consensus age to come from single birthday");
    }


}


================================================
FILE: embabel-agent-api/src/test/java/com/embabel/agent/api/common/workflow/control/SimpleAgentBuilderTest.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.workflow.control;

import com.embabel.agent.api.common.autonomy.AgentInvocation;
import com.embabel.agent.core.AgentProcessStatusCode;
import com.embabel.agent.core.ProcessOptions;
import com.embabel.agent.domain.io.UserInput;
import com.embabel.agent.testing.integration.IntegrationTestUtils;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

class SimpleAgentBuilderTest {

    record Person(String name, int age) {
    }

    record Age(int years) {
    }

    record Combined(String name, int years) {
    }

    @Nested
    class Supplier {

        @Test
        void testConsensusOfOneSimpleGenerator() {
            var agent = SimpleAgentBuilder
                    .returning(Age.class)
                    .running(tac -> new Age(55))
                    .buildAgent("name", "description");
            var ap = IntegrationTestUtils.dummyAgentPlatform();
            var result = ap.runAgentFrom(
                    agent,
                    ProcessOptions.DEFAULT,
                    Map.of("it", new UserInput("input"))
            );
            assertEquals(AgentProcessStatusCode.COMPLETED, result.getStatus());
            assertTrue(result.lastResult() instanceof Age);
            var age = (Age) result.lastResult();
            assertEquals(55, age.years(), "Expected age");
        }

        @Test
        void invocation() {
            var agent = SimpleAgentBuilder
                    .returning(Age.class)
                    .running(tac -> new Age(55))
                    .buildAgent("name", "description");
            var agentPlatform = IntegrationTestUtils.dummyAgentPlatform();
            agentPlatform.deploy(agent);
            var result = AgentInvocation.builder(agentPlatform).build(Age.class).invoke(new UserInput("input"));
            assertEquals(55, result.years(), "Expected age");
        }

    }

    @Nested
    class ConsumerAndSupplier {

        @Test
        void testConsensusOfOneSimpleGenerator() {
            var agent = SimpleAgentBuilder
                    .returning(Person.class)
                    .consuming(Combined.class)
                    .running(tac -> {
                        assertEquals("James", tac.getInput().name(), "Expected name");
                        return new Person("Geoff", 55);
                    })
                    .buildAgent("name", "description");
            var ap = IntegrationTestUtils.dummyAgentPlatform();
            var result = ap.runAgentFrom(
                    agent,
                    ProcessOptions.DEFAULT,
                    Map.of("it", new Combined("James", 55))
            );
            assertEquals(AgentProcessStatusCode.COMPLETED, result.getStatus());
            assertTrue(result.lastResult() instanceof Person);
            var person = (Person) result.lastResult();
            assertEquals("Geoff", person.name(), "Expected name");
            assertEquals(55, person.age(), "Expected age");
        }

    }
}


================================================
FILE: embabel-agent-api/src/test/java/com/embabel/agent/api/common/workflow/multimodel/ConsensusBuilderTest.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.workflow.multimodel;

import com.embabel.agent.core.AgentProcessStatusCode;
import com.embabel.agent.core.ProcessOptions;
import com.embabel.agent.domain.io.UserInput;
import org.junit.jupiter.api.Test;

import java.util.List;
import java.util.Map;

import static com.embabel.agent.testing.integration.IntegrationTestUtils.dummyAgentPlatform;
import static org.junit.jupiter.api.Assertions.*;


class ConsensusBuilderTest {

    record Age(int years) {
    }

    @Test
    void testNoExportedActionsFromWorkflow() {
        var agent = ConsensusBuilder
                .returning(Age.class)
                .sourcedFrom(List.of(() -> new Age(42)))
                .withConsensusBy(context -> {
                    return new Age(context.getInput().getResults().stream().findFirst().get().years);
                })
                .buildAgent("name", "description");
        assertFalse(agent.getActions().isEmpty(), "Should have actions");
        var ap = dummyAgentPlatform();
        ap.deploy(agent);
        assertTrue(agent.getOpaque(), "Agent should be opaque");
        assertTrue(agent.getActions().size() > 1,
                "Should have actions on the agent");
        assertEquals(0, ap.getActions().size());
    }

    @Test
    void testConsensusOfOneSimpleGenerator() {
        var agent = ConsensusBuilder
                .returning(Age.class)
                .sourcedFrom(List.of(() -> new Age(42)))
                .withConsensusBy(context -> {
                    return new Age(context.getInput().getResults().stream().findFirst().get().years);
                })
                .buildAgent("name", "description");
        var ap = dummyAgentPlatform();
        var result = ap.runAgentFrom(
                agent,
                ProcessOptions.DEFAULT,
                Map.of("it", new UserInput("input"))
        );
        assertEquals(AgentProcessStatusCode.COMPLETED, result.getStatus());
        assertTrue(result.lastResult() instanceof Age);
        var age = (Age) result.lastResult();
        assertEquals(42, age.years(), "Expected consensus age to come from input 42");
    }

    @Test
    void testConsensusOfOne() {
        var agent = ConsensusBuilder
                .returning(Age.class)
                .withSources(List.of(tac -> new Age(42)))
                .withConsensusBy(context -> {
                    return new Age(context.getInput().getResults().stream().findFirst().get().years);
                })
                .buildAgent("name", "description");
        var ap = dummyAgentPlatform();
        var result = ap.runAgentFrom(
                agent,
                ProcessOptions.DEFAULT,
                Map.of("it", new UserInput("input"))
        );
        assertEquals(AgentProcessStatusCode.COMPLETED, result.getStatus());
        assertTrue(result.lastResult() instanceof Age);
        var age = (Age) result.lastResult();
        assertEquals(42, age.years(), "Expected consensus age to come from input 42");
    }

    @Test
    void testConsensusOfTwo() {
        var agent = ConsensusBuilder
                .returning(Age.class)
                .withSources(List.of(
                        tac -> new Age(42),
                        tac -> new Age(44)
                ))
                .withConsensusBy(context ->
                        new Age(
                                context.getInput().getResults().stream()
                                        .mapToInt(a -> ((Age) a).years)
                                        .sum() / context.getInput().getResults().size()
                        )
                )
                .buildAgent("name", "description");
        var ap = dummyAgentPlatform();
        var result = ap.runAgentFrom(
                agent,
                ProcessOptions.DEFAULT,
                Map.of("it", new UserInput("input"))
        );
        assertEquals(AgentProcessStatusCode.COMPLETED, result.getStatus());
        assertTrue(result.lastResult() instanceof Age);
        var age = (Age) result.lastResult();
        assertEquals(43, age.years(), "Expected consensus age to come from input 43");
    }

}


================================================
FILE: embabel-agent-api/src/test/java/com/embabel/agent/core/BudgetBuilderTest.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;

class BudgetBuilderTest {

    @Test
    void builder() {
        var budget = Budget.builder()
                .cost(1)
                .actions(2)
                .tokens(3)
                .build();

        assertEquals(1, budget.getCost());
        assertEquals(2, budget.getActions());
        assertEquals(3, budget.getTokens());
    }

}


================================================
FILE: embabel-agent-api/src/test/java/com/embabel/agent/core/ProcessOptionsBuilderTest.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core;

import com.embabel.agent.core.support.InMemoryBlackboard;
import com.embabel.agent.event.AgenticEventListener;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

class ProcessOptionsBuilderTest {

    @Test
    void builder() {
        var identities = new Identities();
        var blackboard = new InMemoryBlackboard();
        var listener = AgenticEventListener.DevNull;

        var po = ProcessOptions.builder()
                .contextId("42")
                .identities(identities)
                .blackboard(blackboard)
                .verbosity(vb -> vb
                        .showPrompts(true)
                        .showLlmResponses(true)
                        .debug(true)
                        .showPlanning(true)
                )
                .budget(bb -> bb
                        .cost(1)
                        .actions(2)
                        .tokens(3)
                )
                .control(cb -> cb
                        .toolDelay(Delay.MEDIUM)
                        .operationDelay(Delay.LONG)
                )
                .prune(true)
                .listener(listener)
                .listeners(listeners -> assertEquals(List.of(listener), listeners))
                .build();

        assertEquals(identities, po.getIdentities());
        assertEquals(blackboard, po.getBlackboard());

        assertTrue(po.getVerbosity().getShowPrompts());
        assertTrue(po.getVerbosity().getShowLlmResponses());
        assertTrue(po.getVerbosity().getDebug());
        assertTrue(po.getVerbosity().getShowPlanning());

        assertEquals(1, po.getBudget().getCost());
        assertEquals(2, po.getBudget().getActions());
        assertEquals(3, po.getBudget().getTokens());

        assertEquals(Delay.MEDIUM, po.getControl().getToolDelay());
        assertEquals(Delay.LONG, po.getControl().getOperationDelay());
        assertTrue(po.getPrune());
        assertEquals(List.of(listener), po.getListeners());
    }

    @Test
    void correctProcessControlDefault() {
        var identities = new Identities();
        var blackboard = new InMemoryBlackboard();
        var listener = AgenticEventListener.DevNull;

        var po = ProcessOptions.builder()
                .contextId("42")
                .identities(identities)
                .blackboard(blackboard)
                .verbosity(vb -> vb
                        .showPrompts(true)
                        .showLlmResponses(true)
                        .debug(true)
                        .showPlanning(true)
                )
                .budget(bb -> bb
                        .cost(1)
                        .actions(2)
                        .tokens(3)
                )
                .listener(listener)
                .listeners(listeners -> assertEquals(List.of(listener), listeners))
                .build();

        assertEquals(Delay.NONE, po.getControl().getToolDelay());
        assertEquals(Delay.NONE, po.getControl().getOperationDelay());
        assertEquals(po.getBudget().earlyTerminationPolicy(), po.getControl().getEarlyTerminationPolicy(),
                "Should have default budget-based early termination policy");
        assertEquals(List.of(listener), po.getListeners());
    }

}


================================================
FILE: embabel-agent-api/src/test/java/com/embabel/agent/core/ToolGroupDescriptionFromJavaTest.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core;

import org.junit.jupiter.api.Test;

class ToolGroupDescriptionFromJavaTest {

    @Test
    void testCanInstantiate() {
        var td = ToolGroupDescription.create("d", "r");
    }

}


================================================
FILE: embabel-agent-api/src/test/java/com/embabel/agent/core/VerbosityBuilderTest.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core;

import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

class VerbosityBuilderTest {

    @Test
    void builder() {
        var verbosity = Verbosity.builder()
                .showPrompts(true)
                .showLlmResponses(true)
                .debug(true)
                .showPlanning(true)
                .build();

        assertTrue(verbosity.getShowPrompts());
        assertTrue(verbosity.getShowLlmResponses());
        assertTrue(verbosity.getDebug());
        assertTrue(verbosity.getShowPlanning());
    }

}


================================================
FILE: embabel-agent-api/src/test/java/com/embabel/agent/rag/SimpleRagRagResponseFormatterTest.kt
================================================
package com.embabel.agent.rag

import com.embabel.agent.rag.support.DocumentSimilarityResult
import com.embabel.common.core.types.SimpleSimilaritySearchResult
import org.junit.jupiter.api.Assertions.assertFalse
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Test
import org.springframework.ai.document.Document
import kotlin.test.assertEquals

class SimpleRagRagResponseFormatterTest {

    @Test
    fun empty() {
        val rr = RagService.empty()
        val results = rr.search(RagRequest("any query at all"))
        val output = SimpleRagResponseFormatter.format(results)
        assertEquals(SimpleRagResponseFormatter.NO_RESULTS_FOUND, output)
    }

    @Test
    fun chunksOnly() {
        val results = RagResponse(
            request = RagRequest("any query at all"),
            service = "test",
            results = listOf(
                DocumentSimilarityResult(
                    Document("foo"),
                    1.0,
                )
            )
        )
        val output = SimpleRagResponseFormatter.format(results)
        assertTrue(output.contains("foo"))
    }

    @Test
    fun `chunks only with big content`() {
        val longContent = "foo ".repeat(10000).trim()
        val results = RagResponse(
            request = RagRequest("any query at all"),
            service = "test",
            results = listOf(
                DocumentSimilarityResult(
                    Document(longContent),
                    1.0,
                )
            )
        )
        val output = SimpleRagResponseFormatter.format(results)
        assertTrue(output.contains(longContent))
    }

    @Test
    fun `does not expose entity embedding for SimpleEntityData`() {
        val results = RagResponse(
            request = RagRequest("any query at all"),
            service = "test",
            results = listOf(
                SimpleSimilaritySearchResult(
                    match = SimpleEntityData(
                        "id",
                        labels = setOf("Label"),
                        properties = mapOf(
                            "embedding" to listOf(0.1, 0.2, 0.3),
                            "text" to "foo"
                        )
                    ),
                    score = 1.0,
                )
            )
        )
        val output = SimpleRagResponseFormatter.format(results)
        assertTrue(output.contains("foo"))
        assertFalse(output.contains("embedding"), "Should suppress embedding, have \n$output")
    }

    @Test
    fun `does not expose entity embedding for SimpleNamedEntityData`() {
        val results = RagResponse(
            request = RagRequest("any query at all"),
            service = "test",
            results = listOf(
                SimpleSimilaritySearchResult(
                    match = SimpleNamedEntityData(
                        "id",
                        name = "name1",
                        description = "descriptyThing",
                        labels = setOf("Label"),
                        properties = mapOf(
                            "embedding" to listOf(0.1, 0.2, 0.3),
                            "text" to "foo",
                            "name" to "name1",
                        )
                    ),
                    score = 1.0,
                )
            )
        )
        val output = SimpleRagResponseFormatter.format(results)
        assertTrue(output.contains("foo"), "Should contain properties: Have \n$output")
        assertFalse(output.contains("embedding"), "Should suppress embedding: Have \n$output")
        // Should contain name1 only once
        assertEquals(
            1, """\bname1\b""".toRegex().findAll(output).count(),
            "Should contain name once: Have \n$output"
        )
        // Should contain description only once
        assertEquals(
            1, """\bdescription\b""".toRegex().findAll(output).count(),
            "Should contain description once: Have \n$output"
        )

    }

}


================================================
FILE: embabel-agent-api/src/test/java/com/embabel/example/simple/horoscope/java/Horoscope.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.example.simple.horoscope.java;

public record Horoscope(String summary) {
}


================================================
FILE: embabel-agent-api/src/test/java/com/embabel/example/simple/horoscope/java/StarPerson.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.example.simple.horoscope.java;

import com.embabel.agent.domain.library.Person;
import com.fasterxml.jackson.annotation.JsonClassDescription;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyDescription;

@JsonClassDescription("Person with astrology details")
public record StarPerson(
        String name,
        @JsonPropertyDescription("Star sign") String sign
) implements Person {

    @JsonCreator
    public StarPerson(
            @JsonProperty("name") String name,
            @JsonProperty("sign") String sign
    ) {
        this.name = name;
        this.sign = sign;
    }

    @Override
    public String getName() {
        return name;
    }
}


================================================
FILE: embabel-agent-api/src/test/java/com/embabel/example/simple/horoscope/java/Starry.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.example.simple.horoscope.java;

import com.embabel.ux.form.Text;
import com.fasterxml.jackson.annotation.JsonClassDescription;

@JsonClassDescription("Astrological details for a person")
public record Starry(@Text(label = "Star sign") String sign) {
}


================================================
FILE: embabel-agent-api/src/test/java/com/embabel/example/simple/horoscope/java/TestStarNewsFinder.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.example.simple.horoscope.java;

import com.embabel.agent.api.annotation.AchievesGoal;
import com.embabel.agent.api.annotation.Action;
import com.embabel.agent.api.annotation.Agent;
import com.embabel.agent.api.annotation.WaitFor;
import com.embabel.agent.api.common.OperationContext;
import com.embabel.agent.api.models.OpenAiModels;
import com.embabel.agent.core.CoreToolGroups;
import com.embabel.agent.domain.io.UserInput;
import com.embabel.agent.domain.library.Person;
import com.embabel.agent.domain.library.PersonImpl;
import com.embabel.agent.domain.library.RelevantNewsStories;
import com.embabel.common.ai.model.LlmOptions;
import com.embabel.common.ai.model.ModelSelectionCriteria;
import com.embabel.example.simple.horoscope.TestHoroscopeService;
import org.springframework.beans.factory.annotation.Value;

import java.util.stream.Collectors;


/**
 * Find news based on a person's star sign
 */
@Agent(
        name = "JavaTestStarNewsFinder",
        description = "Find news based on a person's star sign",
        beanName = "javaTestStarNewsFinder",
        scan = false)
public class TestStarNewsFinder {

    private final TestHoroscopeService horoscopeService;
    private final int storyCount;

    public TestStarNewsFinder(
            TestHoroscopeService horoscopeService,
            @Value("${star-news-finder.story.count:5}") int storyCount) {
        this.horoscopeService = horoscopeService;
        this.storyCount = storyCount;
    }

    @Action
    public PersonImpl extractPerson(UserInput userInput, OperationContext operationContext) {
        return operationContext.ai().withLlm(LlmOptions.fromCriteria(ModelSelectionCriteria.getAuto())).createObjectIfPossible(
                """
                        Create a person from this user input, extracting their name:
                        %s""".formatted(userInput.getContent()),
                PersonImpl.class
        );
    }

    @Action(cost = 100.0) // Make it costly so it won't be used in a plan unless there's no other path
    public Starry makeStarry(Person person) {
        return WaitFor.formSubmission("Let's get some astrological details for " + person.getName(),
                Starry.class);
    }

    @Action
    public StarPerson assembleStarPerson(Person person, Starry starry) {
        return new StarPerson(
                person.getName(),
                starry.sign()
        );
    }

    @Action
    public StarPerson extractStarPerson(UserInput userInput,
                                        OperationContext operationContext) {
        return operationContext.ai().withLlm(OpenAiModels.GPT_41)
                .createObjectIfPossible(
                        """
                                Create a person from this user input, extracting their name and star sign:
                                %s""".formatted(userInput.getContent()),
                        StarPerson.class
                );
    }

    @Action
    public Horoscope retrieveHoroscope(StarPerson starPerson) {
        return new Horoscope(horoscopeService.dailyHoroscope(starPerson.sign()));
    }

    // toolGroups specifies tools that are required for this action to run
    @Action(toolGroups = {CoreToolGroups.WEB})
    public RelevantNewsStories findNewsStories(
            StarPerson person, Horoscope horoscope, OperationContext context) {
        var prompt = """
                %s is an astrology believer with the sign %s.
                Their horoscope for today is:
                    <horoscope>%s</horoscope>
                Given this, use web tools and generate search queries
                to find %d relevant news stories summarize them in a few sentences.
                Include the URL for each story.
                Do not look for another horoscope reading or return results directly about astrology;
                find stories relevant to the reading above.
                
                For example:
                - If the horoscope says that they may
                want to work on relationships, you could find news stories about
                novel gifts
                - If the horoscope says that they may want to work on their career,
                find news stories about training courses.""".formatted(
                person.name(), person.sign(), horoscope.summary(), storyCount);

        return context.ai().withDefaultLlm().createObject(prompt, RelevantNewsStories.class);
    }

    // The @AchievesGoal annotation indicates that completing this action
    // achieves the given goal, so the agent can be complete
    @AchievesGoal(
            description = "Write an amusing writeup for the target person based on their horoscope and current news stories"
    )
    @Action
    public Writeup writeup(
            StarPerson person,
            RelevantNewsStories relevantNewsStories,
            Horoscope horoscope,
            OperationContext context) {
        var llm = LlmOptions.fromCriteria(ModelSelectionCriteria.getAuto())
                .withTemperature(0.9);

        var newsItems = relevantNewsStories.getItems().stream()
                .map(item -> "- " + item.getUrl() + ": " + item.getSummary())
                .collect(Collectors.joining("\n"));

        var prompt = """
                Take the following news stories and write up something
                amusing for the target person.
                
                Begin by summarizing their horoscope in a concise, amusing way, then
                talk about the news. End with a surprising signoff.
                
                %s is an astrology believer with the sign %s.
                Their horoscope for today is:
                    <horoscope>%s</horoscope>
                Relevant news stories are:
                %s
                
                Format it as Markdown with links.""".formatted(
                person.name(), person.sign(), horoscope.summary(), newsItems);
        return context.ai().withLlm(llm).createObject(prompt, Writeup.class);
    }
}


================================================
FILE: embabel-agent-api/src/test/java/com/embabel/example/simple/horoscope/java/Writeup.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.example.simple.horoscope.java;

import com.embabel.agent.domain.library.HasContent;
import com.fasterxml.jackson.annotation.JsonClassDescription;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;

@JsonClassDescription("Writeup relating to a person's horoscope and relevant news")
public record Writeup(String text) implements HasContent {

    @JsonCreator
    public Writeup(@JsonProperty("text") String text) {
        this.text = text;
    }

    @Override
    public String getContent() {
        return text;
    }
}


================================================
FILE: embabel-agent-api/src/test/java/com/embabel/ux/form/JavaPersonImmutable.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.ux.form;

public class JavaPersonImmutable {

    final String name;

    final int age;


    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public JavaPersonImmutable(@FormField(controlId = "name-id") String name, @FormField(controlId = "age-id") int age) {
        this.name = name;
        this.age = age;
    }
}



================================================
FILE: embabel-agent-api/src/test/java/com/embabel/ux/form/JavaPersonRecord.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.ux.form;

public record JavaPersonRecord(
        String name,
        int age
) {
}




================================================
FILE: embabel-agent-api/src/test/java/com/embabel/ux/form/JavaPersonRecordWithControlId.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.ux.form;

public record JavaPersonRecordWithControlId(
        @FormField(controlId = "name-id")
        String name,
        @FormField(controlId = "age-id")
        int age
) {
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/AgentApiTestApplication.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent
import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.context.properties.ConfigurationPropertiesScan
import org.springframework.boot.runApplication
import org.springframework.context.annotation.ComponentScan

@SpringBootApplication
@ConfigurationPropertiesScan(
    basePackages = [
        "com.embabel.agent",
        "com.embabel.example",
    ]
)
@ComponentScan(
    basePackages = [
        "com.embabel.agent",
        "com.embabel.example",
    ]
)
class AgentApiTestApplication {}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/annotation/support/ActionMethodArgumentResolverTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation.support

import com.embabel.agent.api.common.Ai
import com.embabel.agent.api.common.OperationContext
import com.embabel.agent.core.IoBinding
import com.embabel.agent.core.ProcessContext
import com.embabel.agent.testing.unit.FakeOperationContext
import org.junit.jupiter.api.Test
import java.lang.reflect.Method
import kotlin.reflect.full.valueParameters
import kotlin.reflect.jvm.kotlinFunction
import kotlin.test.DefaultAsserter.assertSame
import kotlin.test.assertFalse
import kotlin.test.assertNotNull
import kotlin.test.assertTrue

class ActionMethodArgumentResolverTest {

    private val operationContext = FakeOperationContext()

    private val method: Method = javaClass.getDeclaredMethod(
        "arguments", ProcessContext::class.java,
        OperationContext::class.java, Ai::class.java, CustomType::class.java,
    )

    @Test
    fun processContext() {
        val argumentResolver = ProcessContextArgumentResolver()
        val javaParameter = method.parameters[0]
        val kotlinParameter = method.kotlinFunction!!.valueParameters[0]

        assertTrue { argumentResolver.supportsParameter(javaParameter, kotlinParameter, operationContext) }
        assertTrue { argumentResolver.supportsParameter(javaParameter, null, null) }
        assertFalse { argumentResolver.supportsParameter(method.parameters[1], null, null) }

        assertTrue { argumentResolver.resolveInputBinding(javaParameter, kotlinParameter).isEmpty() }

        val arg = argumentResolver.resolveArgument(javaParameter, kotlinParameter, operationContext)
        assertSame(
            message = "Invalid resolved argument",
            expected = operationContext.processContext,
            actual = arg
        )
    }

    @Test
    fun operationContext() {
        val argumentResolver = OperationContextArgumentResolver()
        val javaParameter = method.parameters[1]
        val kotlinParameter = method.kotlinFunction!!.valueParameters[1]

        assertTrue { argumentResolver.supportsParameter(javaParameter, kotlinParameter, operationContext) }
        assertTrue { argumentResolver.supportsParameter(javaParameter, null, null) }
        assertFalse { argumentResolver.supportsParameter(method.parameters[0], null, null) }

        assertTrue { argumentResolver.resolveInputBinding(javaParameter, kotlinParameter).isEmpty() }

        val arg = argumentResolver.resolveArgument(javaParameter, kotlinParameter, operationContext)
        assertSame(
            message = "Invalid resolved argument",
            expected = operationContext,
            actual = arg
        )
    }

    @Test
    fun ai() {
        val argumentResolver = AiArgumentResolver()
        val javaParameter = method.parameters[2]
        val kotlinParameter = method.kotlinFunction!!.valueParameters[2]

        assertTrue { argumentResolver.supportsParameter(javaParameter, kotlinParameter, operationContext) }
        assertTrue { argumentResolver.supportsParameter(javaParameter, null, null) }
        assertFalse { argumentResolver.supportsParameter(method.parameters[0], null, null) }

        assertTrue { argumentResolver.resolveInputBinding(javaParameter, kotlinParameter).isEmpty() }

        val arg = argumentResolver.resolveArgument(javaParameter, kotlinParameter, operationContext)

        assertNotNull(
            message = "Invalid resolved argument",
            actual = arg
        )
    }

    @Test
    fun blackboard() {
        val argumentResolver = BlackboardArgumentResolver()
        val expected = CustomType()
        operationContext.set(IoBinding.DEFAULT_BINDING, expected)

        val javaParameter = method.parameters[3]
        val kotlinParameter = method.kotlinFunction!!.valueParameters[3]
        assertTrue { argumentResolver.supportsParameter(javaParameter, kotlinParameter, operationContext) }
        assertTrue { argumentResolver.supportsParameter(javaParameter, null, null) }

        assertTrue { argumentResolver.resolveInputBinding(javaParameter, kotlinParameter).isNotEmpty() }

        val arg = argumentResolver.resolveArgument(javaParameter, kotlinParameter, operationContext)
        assertSame(
            message = "Invalid resolved argument",
            expected = expected,
            actual = arg
        )
    }


    private fun arguments(
        processContext: ProcessContext,
        operationContext: OperationContext,
        ai: Ai,
        customType: CustomType,
    ) {

    }

    class CustomType

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/annotation/support/AgentMetadataReaderActionTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation.support

import com.embabel.agent.api.common.PlatformServices
import com.embabel.agent.api.dsl.Frog
import com.embabel.agent.api.dsl.SnakeMeal
import com.embabel.agent.channel.DevNullOutputChannel
import com.embabel.agent.core.*
import com.embabel.agent.core.hitl.ConfirmationRequest
import com.embabel.agent.core.support.InMemoryBlackboard
import com.embabel.agent.core.support.SimpleAgentProcess
import com.embabel.agent.domain.io.UserInput
import com.embabel.agent.event.AgenticEventListener.Companion.DevNull
import com.embabel.agent.spi.LlmInteraction
import com.embabel.agent.spi.LlmOperations
import com.embabel.agent.spi.support.GoapPlannerFactory
import com.embabel.agent.support.Dog
import com.embabel.agent.testing.integration.IntegrationTestUtils
import com.embabel.agent.testing.integration.IntegrationTestUtils.dummyAgentProcessRunning
import com.embabel.agent.testing.integration.IntegrationTestUtils.dummyPlatformServices
import com.embabel.common.ai.model.DefaultModelSelectionCriteria
import com.embabel.common.ai.model.LlmOptions
import com.embabel.plan.goap.ConditionDetermination
import io.mockk.every
import io.mockk.mockk
import io.mockk.slot
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Disabled
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.springframework.ai.tool.ToolCallback
import com.embabel.agent.core.Agent as CoreAgent


class AgentMetadataReaderActionTest {

    @Test
    fun `no actions`() {
        val reader = AgentMetadataReader()
        val metadata = reader.createAgentMetadata(OneGoalOnly())
        assertNotNull(metadata)
        assertEquals(0, metadata!!.actions.size)
    }

    @Test
    fun `one action only`() {
        val reader = AgentMetadataReader()
        val metadata = reader.createAgentMetadata(OneTransformerActionOnly())
        assertNotNull(metadata)
        assertEquals(1, metadata!!.actions.size)
        val action = metadata.actions.single()
        assertEquals(1, action.inputs.size, "Should have 1 input")
        assertEquals(UserInput::class.java.name, action.inputs.single().type)
        assertEquals(1, action.outputs.size, "Should have 1 output")
        assertEquals(
            PersonWithReverseTool::class.java.name,
            action.outputs.single().type,
            "Output name must match",
        )
    }

    @Test
    fun `one action with nullable parameter metadata Kotlin`() {
        testNullableParameter(OneTransformerActionWithNullableParameter())
    }

    // Java nullable parameter tests moved to AgentMetadataReaderNullableParameterJavaTest.java
    // because Kotlin compiles first and Java test classes aren't available yet

    private fun testNullableParameter(instance: Any) {
        val reader = AgentMetadataReader()
        val metadata = reader.createAgentMetadata(instance)
        assertNotNull(metadata)
        assertEquals(1, metadata!!.actions.size)
        val action = metadata.actions.single()
        assertEquals(1, action.inputs.size, "Should have 1 input as nullable doesn't count in Java")
        assertEquals(UserInput::class.java.name, action.inputs.single().type)
        assertEquals(1, action.outputs.size, "Should have 1 output")
        assertEquals(
            PersonWithReverseTool::class.java.name,
            action.outputs.single().type,
            "Output name must match",
        )
    }

    @Test
    fun `one action referencing condition by name`() {
        val reader = AgentMetadataReader()
        val metadata = reader.createAgentMetadata(OneTransformerActionReferencingConditionByName())
        assertNotNull(metadata)
        assertEquals(1, metadata!!.actions.size)
        val action = metadata.actions.single()
        assertEquals(1, action.inputs.size, "Should have 1 input")
        assertEquals(UserInput::class.java.name, action.inputs.single().type)
        assertEquals(1, action.outputs.size, "Should have 1 output")
        assertEquals(
            PersonWithReverseTool::class.java.name,
            action.outputs.single().type,
            "Output name must match",
        )
        assertEquals(
            ConditionDetermination.TRUE,
            action.preconditions["it:${UserInput::class.qualifiedName}"],
            "Should have input precondition",
        )
        assertEquals(
            ConditionDetermination.TRUE,
            action.preconditions["condition1"],
            "Should have custom precondition",
        )
    }

    @Test
    fun `one action with custom tool group`() {
        val reader = AgentMetadataReader()
        val metadata = reader.createAgentMetadata(OneTransformerActionWithCustomToolGroupOnly())
        assertNotNull(metadata)
        assertEquals(1, metadata!!.actions.size)
        val action = metadata.actions.single()
        assertEquals(1, action.inputs.size, "Should have 1 input")
        assertEquals(UserInput::class.java.name, action.inputs.single().type)
        assertEquals(1, action.outputs.size, "Should have 1 output")
        assertEquals(
            PersonWithReverseTool::class.java.name,
            action.outputs.single().type,
            "Output name must match",
        )
        assertEquals(1, action.toolGroups.size)
        assertEquals(ToolGroupRequirement("magic"), action.toolGroups.single())
    }

    @Test
    fun `one action with custom tool group taking interface`() {
        val reader = AgentMetadataReader()
        val metadata = reader.createAgentMetadata(OneTransformerActionTakingInterfaceWithCustomToolGroupOnly())
        assertNotNull(metadata)
        assertEquals(1, metadata!!.actions.size)
        val action = metadata.actions.single()
        assertEquals(1, action.inputs.size, "Should have 1 input")
        assertEquals(PersonWithReverseTool::class.java.name, action.inputs.single().type)
        assertEquals(1, action.outputs.size, "Should have 1 output")
        assertEquals(
            Frog::class.java.name,
            action.outputs.single().type,
            "Output name must match",
        )
        assertEquals(1, action.toolGroups.size)
        assertEquals("magic", action.toolGroups.single().role)
        val ap = IntegrationTestUtils.dummyAgentPlatform()
        val agentProcess =
            ap.runAgentFrom(metadata as CoreAgent, ProcessOptions(), mapOf("it" to PersonWithReverseTool("John Doe")))
        assertEquals(AgentProcessStatusCode.COMPLETED, agentProcess.status)
        assertEquals(Frog("John Doe"), agentProcess.lastResult())
    }

    @Test
    fun `custom tool group is available through operation context`() {
        val reader = AgentMetadataReader()
        val metadata =
            reader.createAgentMetadata(OneTransformerActionTakingInterfaceWithExpectationCustomToolGroupOnly())
        assertNotNull(metadata)
        assertEquals(1, metadata!!.actions.size)
        val action = metadata.actions.single()
        assertEquals(1, action.inputs.size, "Should have 1 input")
        assertEquals(PersonWithReverseTool::class.java.name, action.inputs.single().type)
        assertEquals(1, action.outputs.size, "Should have 1 output")
        assertEquals(
            Frog::class.java.name,
            action.outputs.single().type,
            "Output name must match",
        )
        assertEquals(1, action.toolGroups.size)
        assertEquals("magic", action.toolGroups.single().role)
        val ap = IntegrationTestUtils.dummyAgentPlatform()
        val agentProcess =
            ap.runAgentFrom(metadata as CoreAgent, ProcessOptions(), mapOf("it" to PersonWithReverseTool("John Doe")))
        assertEquals(AgentProcessStatusCode.COMPLETED, agentProcess.status)
        assertEquals(Frog("John Doe"), agentProcess.lastResult())
    }

    @Test
    fun `custom tool group requirement is available through operation context`() {
        val reader = AgentMetadataReader()
        val metadata =
            reader.createAgentMetadata(OneTransformerActionTakingInterfaceWithExpectationCustomToolGroupRequirementOnly())
        assertNotNull(metadata)
        assertEquals(1, metadata!!.actions.size)
        val action = metadata.actions.single()
        assertEquals(1, action.inputs.size, "Should have 1 input")
        assertEquals(PersonWithReverseTool::class.java.name, action.inputs.single().type)
        assertEquals(1, action.outputs.size, "Should have 1 output")
        assertEquals(
            Frog::class.java.name,
            action.outputs.single().type,
            "Output name must match",
        )
        assertEquals(2, action.toolGroups.size, "Had ${action.toolGroups} tool groups, expected 1")
        assertEquals(setOf("magic", "frogs"), action.toolGroups.map { it.role }.toSet())
        val ap = IntegrationTestUtils.dummyAgentPlatform()
        val agentProcess =
            ap.runAgentFrom(metadata as CoreAgent, ProcessOptions(), mapOf("it" to PersonWithReverseTool("John Doe")))
        assertEquals(AgentProcessStatusCode.COMPLETED, agentProcess.status)
        assertEquals(Frog("John Doe"), agentProcess.lastResult())
    }

    @Test
    fun `one action with 2 args only`() {
        val reader = AgentMetadataReader()
        val metadata = reader.createAgentMetadata(AgentWithOneTransformerActionWith2ArgsOnly())
        assertNotNull(metadata)
        assertEquals(1, metadata!!.actions.size)
        val action = metadata.actions.single()
        assertEquals(2, action.inputs.size, "Should have 2 inputs")
        assertEquals(1, action.outputs.size, "Should have 1 output")
        assertTrue(action.inputs.any { it.type == UserInput::class.java.name })
        assertTrue(action.inputs.any { it.type == Task::class.java.name })
        assertEquals(
            PersonWithReverseTool::class.java.name,
            action.outputs.single().type,
            "Output name must match"
        )
        assertEquals(IoBinding.DEFAULT_BINDING, action.outputs.single().name)
    }

    @Nested
    inner class Invocation {

        @Test
        fun `action invocation with nullable parameter, passing no value`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(OneTransformerActionWithNullableParameter())
            assertNotNull(metadata)
            assertEquals(
                1, metadata!!.actions.size,
                "Should have exactly 1 action",
            )
            val action = metadata.actions.first()
            val agent = mockk<CoreAgent>()
            every { agent.jvmTypes } returns listOf(SnakeMeal::class.java, UserInput::class.java).map { JvmType(it) }
            val mockAgentProcess = mockk<AgentProcess>()
            every { mockAgentProcess.agent } returns agent
            val mockPlatformServices = mockk<PlatformServices>()
            every { mockPlatformServices.llmOperations } returns mockk()
            every { mockPlatformServices.eventListener } returns DevNull
            val blackboard = InMemoryBlackboard().bind(IoBinding.DEFAULT_BINDING, UserInput("John Doe"))
            every { mockAgentProcess.hasValue(any(), any(), any()) } answers {
                blackboard.hasValue(
                    firstArg(),
                    secondArg(),
                    thirdArg(),
                )
            }
            every { mockAgentProcess.getValue(any(), any(), any()) } answers {
                blackboard.getValue(
                    firstArg(),
                    secondArg(),
                    thirdArg(),
                )
            }
            every { mockAgentProcess[any()] = any() } answers {
                blackboard[firstArg()] = secondArg()
            }
            every { mockAgentProcess.lastResult() } returns PersonWithReverseTool("John Doe")

            val pc = ProcessContext(
                platformServices = mockPlatformServices,
                agentProcess = mockAgentProcess,
                outputChannel = DevNullOutputChannel,
            )
            val result = action.execute(pc)
            assertEquals(ActionStatusCode.SUCCEEDED, result.status)
            assertEquals(PersonWithReverseTool("John Doe"), pc.blackboard.lastResult())
        }

        @Test
        fun `action invocation with nullable parameter, passing value`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(OneTransformerActionWithNullableParameter())
            assertNotNull(metadata)
            assertEquals(
                1, metadata!!.actions.size,
                "Should have exactly 1 action",
            )
            val action = metadata.actions.first()
            val agent = CoreAgent(
                name = "name",
                provider = "provider",
                actions = listOf(action),
                domainTypes = emptyList(),
                goals = emptySet(),
                description = "whatever",
            )
            val platformServices = dummyPlatformServices()

            val pc = ProcessContext(
                agentProcess = SimpleAgentProcess(
                    id = "test",
                    agent = agent,
                    platformServices = platformServices,
                    processOptions = ProcessOptions(),
                    blackboard = InMemoryBlackboard(),
                    plannerFactory = GoapPlannerFactory,
                    parentId = null,
                ),
                platformServices = platformServices,
            )
            pc.blackboard += UserInput("John Doe")
            pc.blackboard += SnakeMeal(emptyList())
            val result = action.execute(pc)
            assertEquals(ActionStatusCode.SUCCEEDED, result.status)
            assertEquals(PersonWithReverseTool("John Doe and tasty!"), pc.blackboard.lastResult())
        }

        @Test
        fun `transformer action invocation`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(OneTransformerActionOnly())
            assertNotNull(metadata)
            assertEquals(1, metadata!!.actions.size)
            val action = metadata.actions.first()
            val agent = mockk<CoreAgent>()
            every { agent.domainTypes } returns listOf(
                PersonWithReverseTool::class.java,
                UserInput::class.java,
            ).map { JvmType(it) }

            val dummyPlatformServices = dummyPlatformServices()
            val pc = ProcessContext(
                platformServices = dummyPlatformServices,
                agentProcess = dummyAgentProcessRunning(
                    metadata as com.embabel.agent.core.Agent,
                    dummyPlatformServices
                ),
                outputChannel = DevNullOutputChannel,
            )
            pc.agentProcess.bind(IoBinding.DEFAULT_BINDING, UserInput("John Doe"))
            val result = action.execute(pc)
            assertEquals(ActionStatusCode.SUCCEEDED, result.status)
            assertEquals(PersonWithReverseTool("John Doe"), pc.blackboard.lastResult())
        }

        @Test
        fun `transformer action invocation with payload`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(OneTransformerActionTakingPayloadOnly())
            assertNotNull(metadata)
            assertEquals(1, metadata!!.actions.size)
            val action = metadata.actions.first()
            assertEquals(
                1,
                action.inputs.size,
                "Should not consider payload as input: ${action.inputs}",
            )
            assertEquals(
                UserInput::class.java.name,
                action.inputs.single().type,
                "Should not consider payload as input: ${action.inputs}",
            )
            val agent = mockk<CoreAgent>()
            every { agent.jvmTypes } returns listOf(PersonWithReverseTool::class.java, UserInput::class.java).map {
                JvmType(it)
            }
            val mockAgentProcess = mockk<AgentProcess>()
            every { mockAgentProcess.agent } returns agent
            val mockPlatformServices = mockk<PlatformServices>()
            every { mockPlatformServices.llmOperations } returns mockk()
            every { mockPlatformServices.eventListener } returns DevNull
            val blackboard = InMemoryBlackboard().bind(IoBinding.DEFAULT_BINDING, UserInput("John Doe"))
            every { mockAgentProcess.hasValue(any(), any(), any()) } answers {
                blackboard.hasValue(
                    firstArg(),
                    secondArg(),
                    thirdArg(),
                )
            }
            every { mockAgentProcess.getValue(any(), any(), any()) } answers {
                blackboard.getValue(
                    firstArg(),
                    secondArg(),
                    thirdArg(),
                )
            }
            every { mockAgentProcess.set(any(), any()) } answers {
                blackboard.set(
                    firstArg(),
                    secondArg(),
                )
            }
            every { mockAgentProcess.lastResult() } returns PersonWithReverseTool("John Doe")

            val pc = ProcessContext(
                platformServices = dummyPlatformServices(),
                agentProcess = mockAgentProcess,
            )
            val result = action.execute(pc)
            assertEquals(ActionStatusCode.SUCCEEDED, result.status)
            assertEquals(PersonWithReverseTool("John Doe"), pc.blackboard.lastResult())
        }

        @Test
        fun `action invocation with internal parameters`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(InternalDomainClasses())
            assertNotNull(metadata)
            assertEquals(
                1, metadata!!.actions.size,
                "Should have exactly 1 action",
            )
            val action = metadata.actions.first()
            val agent = CoreAgent(
                name = "name",
                provider = "provider",
                actions = listOf(action),
                domainTypes = emptyList(),
                goals = emptySet(),
                description = "whatever",
            )
            val platformServices = dummyPlatformServices()

            val pc = ProcessContext(
                agentProcess = SimpleAgentProcess(
                    id = "test",
                    agent = agent,
                    platformServices = platformServices,
                    processOptions = ProcessOptions(),
                    blackboard = InMemoryBlackboard(),
                    plannerFactory = GoapPlannerFactory,
                    parentId = null,
                ),
                platformServices = platformServices,
            )
            pc.blackboard += InternalInput("John Doe")
            val result = action.execute(pc)
            assertEquals(ActionStatusCode.SUCCEEDED, result.status)
            assertEquals(InternalOutput("John Doe"), pc.blackboard.lastResult())
        }

        @Test
        fun `action invocation with OperationPayload`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(OneTransformerActionTakingOperationPayload())
            assertNotNull(metadata)
            assertEquals(1, metadata!!.actions.size)
            val action = metadata.actions.first()
            assertEquals(
                1,
                action.inputs.size,
                "Should not consider payload as input: ${action.inputs}",
            )
            assertEquals(
                UserInput::class.java.name,
                action.inputs.single().type,
                "Should not consider payload as input",
            )
            val agent = mockk<CoreAgent>()
            every { agent.jvmTypes } returns listOf(
                PersonWithReverseTool::class.java,
                UserInput::class.java
            ).map { JvmType(it) }
            val mockAgentProcess = mockk<AgentProcess>()
            every { mockAgentProcess.agent } returns agent
            val mockPlatformServices = mockk<PlatformServices>()
            every { mockPlatformServices.llmOperations } returns mockk()
            every { mockPlatformServices.eventListener } returns DevNull
            val blackboard = InMemoryBlackboard().bind(IoBinding.DEFAULT_BINDING, UserInput("John Doe"))
            every { mockAgentProcess.hasValue(any(), any(), any()) } answers {
                blackboard.hasValue(
                    firstArg(),
                    secondArg(),
                    thirdArg(),
                )
            }
            every { mockAgentProcess.getValue(any(), any(), any()) } answers {
                blackboard.getValue(
                    firstArg(),
                    secondArg(),
                    thirdArg(),
                )
            }
            every { mockAgentProcess.set(any(), any()) } answers {
                blackboard.set(
                    firstArg(),
                    secondArg(),
                )
            }
            every { mockAgentProcess.lastResult() } returns PersonWithReverseTool("John Doe")

            val pc = ProcessContext(
                platformServices = dummyPlatformServices(),
                agentProcess = mockAgentProcess,
            )
            val result = action.execute(pc)
            assertEquals(ActionStatusCode.SUCCEEDED, result.status)
            assertEquals(PersonWithReverseTool("John Doe"), pc.blackboard.lastResult())
        }

        @Test
        fun `transformer action with 2 args invocation`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(AgentWithOneTransformerActionWith2ArgsOnly())
            assertNotNull(metadata)
            assertEquals(1, metadata!!.actions.size)
            val action = metadata.actions.first()
            val agent = mockk<CoreAgent>()
            every { agent.jvmTypes } returns listOf(
                PersonWithReverseTool::class.java,
                UserInput::class.java
            ).map { JvmType(it) }
            val mockAgentProcess = mockk<AgentProcess>()
            every { mockAgentProcess.agent } returns agent
            val mockPlatformServices = mockk<PlatformServices>()
            every { mockPlatformServices.llmOperations } returns mockk()
            every { mockPlatformServices.eventListener } returns DevNull

            val blackboard = InMemoryBlackboard()
            blackboard += UserInput("John Doe")
            blackboard += ("task" to Task("task"))
            every { mockAgentProcess.hasValue(any(), any(), any()) } answers {
                blackboard.hasValue(
                    firstArg(),
                    secondArg(),
                    thirdArg(),
                )
            }
            every { mockAgentProcess.getValue(any(), any(), any()) } answers {
                blackboard.getValue(
                    firstArg(),
                    secondArg(),
                    thirdArg(),
                )
            }
            every { mockAgentProcess.set(any(), any()) } answers {
                blackboard.set(
                    firstArg(),
                    secondArg(),
                )
            }
            every { mockAgentProcess.lastResult() } returns PersonWithReverseTool("John Doe")

            val pc = ProcessContext(
                platformServices = dummyPlatformServices(),
                agentProcess = mockAgentProcess,
            )
            val result = action.execute(pc)
            assertEquals(ActionStatusCode.SUCCEEDED, result.status)
            assertEquals(PersonWithReverseTool("John Doe"), pc.blackboard.lastResult())
        }

        @Test
        fun `transformer action with 2 args invocation and ai parameter`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(AgentWithOneTransformerActionWith2ArgsOnlyAndAiParameter())
            assertNotNull(metadata)
            assertEquals(1, metadata!!.actions.size)
            val action = metadata.actions.first()
            val agent = mockk<CoreAgent>()
            every { agent.jvmTypes } returns listOf(
                PersonWithReverseTool::class.java,
                UserInput::class.java
            ).map { JvmType(it) }
            val mockAgentProcess = mockk<AgentProcess>()
            every { mockAgentProcess.agent } returns agent
            val mockPlatformServices = mockk<PlatformServices>()
            every { mockPlatformServices.llmOperations } returns mockk()
            every { mockPlatformServices.eventListener } returns DevNull

            val blackboard = InMemoryBlackboard()
            blackboard += UserInput("John Doe")
            blackboard += ("task" to Task("task"))
            every { mockAgentProcess.hasValue(any(), any(), any()) } answers {
                blackboard.hasValue(
                    firstArg(),
                    secondArg(),
                    thirdArg(),
                )
            }
            every { mockAgentProcess.getValue(any(), any(), any()) } answers {
                blackboard.getValue(
                    firstArg(),
                    secondArg(),
                    thirdArg(),
                )
            }
            every { mockAgentProcess.set(any(), any()) } answers {
                blackboard.set(
                    firstArg(),
                    secondArg(),
                )
            }
            every { mockAgentProcess.lastResult() } returns PersonWithReverseTool("John Doe")

            val pc = ProcessContext(
                platformServices = dummyPlatformServices(),
                agentProcess = mockAgentProcess,
            )
            val result = action.execute(pc)
            assertEquals(ActionStatusCode.SUCCEEDED, result.status)
            assertEquals(PersonWithReverseTool("John Doe"), pc.blackboard.lastResult())
        }
    }


    @Nested
    inner class TestToolMethodsOnDomainObject {

        @Test
        @Disabled("not yet implemented")
        fun `handles conflicting tool definitions in multiple domain objects`() {
        }

    }

    @Nested
    inner class CustomBinding {

        @Test
        fun `custom input bindings`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(OneTransformerActionWith2ArgsAndCustomInputBindings())
            assertNotNull(metadata)
            assertEquals(1, metadata!!.actions.size)
            val action = metadata.actions.single()
            assertEquals(2, action.inputs.size, "Should have 2 inputs")
            assertEquals(1, action.outputs.size, "Should have 1 output")
            val uib = action.inputs.single { it.type == UserInput::class.java.name }
            val tb = action.inputs.single { it.type == Task::class.java.name }
            assertEquals("userInput", uib.name)
            assertEquals("task", tb.name)
            assertEquals(
                PersonWithReverseTool::class.java.name,
                action.outputs.single().type,
                "Output name must match",
            )
            assertEquals(
                IoBinding.DEFAULT_BINDING,
                action.outputs.single().name,
                "Output name must match",
            )
        }

        @Test
        fun `custom output binding`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(OneTransformerActionWith2ArgsAndCustomOutputBinding())
            assertNotNull(metadata)
            assertEquals(1, metadata!!.actions.size)
            val action = metadata.actions.single()
            assertEquals(2, action.inputs.size, "Should have 2 inputs")
            assertEquals(1, action.outputs.size, "Should have 1 output")
            assertTrue(action.inputs.any { it.type == UserInput::class.java.name })
            assertTrue(action.inputs.any { it.type == Task::class.java.name })
            assertEquals(
                PersonWithReverseTool::class.java.name,
                action.outputs.single().type,
                "Output name must match",
            )
            assertEquals("person", action.outputs.single().name)
        }
    }

    @Nested
    inner class Prompts {
        @Test
        fun `prompt action invocation`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(OnePromptActionOnly())
            assertNotNull(metadata)
            assertEquals(1, metadata!!.actions.size)
            val action = metadata.actions.first()
            val agent = mockk<CoreAgent>()
            every { agent.jvmTypes } returns listOf(
                PersonWithReverseTool::class.java,
                UserInput::class.java
            ).map { JvmType(it) }
            val mockAgentProcess = mockk<AgentProcess>()
            every { mockAgentProcess.agent } returns agent
            val llmo = slot<LlmInteraction>()
            val llmt = mockk<LlmOperations>()
            every {
                llmt.createObject<Any>(
                    any(),
                    capture(llmo),
                    any(),
                    any(),
                    any(),
                )
            } returns PersonWithReverseTool("John Doe")
            val mockPlatformServices = mockk<PlatformServices>()
            every { mockPlatformServices.llmOperations } returns llmt
            every { mockPlatformServices.eventListener } returns DevNull
            every { mockPlatformServices.outputChannel } returns DevNullOutputChannel

            val blackboard = InMemoryBlackboard().bind(IoBinding.DEFAULT_BINDING, UserInput("John Doe"))
            every { mockAgentProcess.hasValue(any(), any(), any()) } answers {
                blackboard.hasValue(
                    firstArg(),
                    secondArg(),
                    thirdArg(),
                )
            }
            every { mockAgentProcess.getValue(any(), any(), any()) } answers {
                blackboard.getValue(
                    firstArg(),
                    secondArg(),
                    thirdArg(),
                )
            }
            every { mockAgentProcess.set(any(), any()) } answers {
                blackboard.set(
                    firstArg(),
                    secondArg(),
                )
            }
            every { mockAgentProcess.lastResult() } returns PersonWithReverseTool("John Doe")

            val pc = ProcessContext(
                platformServices = mockPlatformServices,
                agentProcess = mockAgentProcess,
            )
            val result = action.execute(pc)
            assertEquals(ActionStatusCode.SUCCEEDED, result.status)
            assertEquals(PersonWithReverseTool("John Doe"), pc.blackboard.lastResult())
            assertEquals(LlmOptions.withModel("magical").withTemperature(.7), llmo.captured.llm)
        }

        @Test
        fun `prompt action invocation with tools`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(OnePromptActionWithToolOnly())
            assertNotNull(metadata)
            assertEquals(1, metadata!!.actions.size)
            val action = metadata.actions.first()
            val agent = mockk<CoreAgent>()
            every { agent.jvmTypes } returns listOf(
                PersonWithReverseTool::class.java,
                UserInput::class.java
            ).map { JvmType(it) }
            val mockAgentProcess = mockk<AgentProcess>()
            every { mockAgentProcess.agent } returns agent
            val llmi = slot<LlmInteraction>()
            val llmt = mockk<LlmOperations>()
            every {
                llmt.createObject<Any>(
                    any(),
                    capture(llmi),
                    any(),
                    any(),
                    any(),
                )
            } returns PersonWithReverseTool("John Doe")
            val mockPlatformServices = mockk<PlatformServices>()
            every { mockPlatformServices.llmOperations } returns llmt
            every { mockPlatformServices.eventListener } returns DevNull
            every { mockPlatformServices.outputChannel } returns DevNullOutputChannel
            val blackboard = InMemoryBlackboard().bind(IoBinding.DEFAULT_BINDING, UserInput("John Doe"))
            every { mockAgentProcess.hasValue(any(), any(), any()) } answers {
                blackboard.hasValue(
                    firstArg(),
                    secondArg(),
                    thirdArg(),
                )
            }
            every { mockAgentProcess.getValue(any(), any(), any()) } answers {
                blackboard.getValue(
                    firstArg(),
                    secondArg(),
                    thirdArg(),
                )
            }
            every { mockAgentProcess.set(any(), any()) } answers {
                blackboard.set(
                    firstArg(),
                    secondArg(),
                )
            }
            every { mockAgentProcess.lastResult() } returns PersonWithReverseTool("John Doe")

            val pc = ProcessContext(
                platformServices = mockPlatformServices,
                agentProcess = mockAgentProcess,
            )
            val result = action.execute(pc)
            assertEquals(ActionStatusCode.SUCCEEDED, result.status)
            assertEquals(PersonWithReverseTool("John Doe"), pc.blackboard.lastResult())
//                assertEquals(1, llmi.captured.toolCallbacks.size)
//                assertEquals("thing", llmi.captured.toolCallbacks.single().toolDefinition.name())
            assertEquals(DefaultModelSelectionCriteria, llmi.captured.llm.criteria)
        }

        @Test
        fun `prompt action invocation with tools on domain object parameter via using`() {
            testToolsAreExposed(FromPersonUsesDomainObjectTools())
        }

        @Test
        fun `prompt action invocation with tools on domain object parameter via ActionContext`() {
            testToolsAreExposed(FromPersonUsesDomainObjectToolsViaActionContext())
        }

        @Test
        fun `prompt action invocation with tools on domain object parameter via ExecutingOperationContext`() {
            testToolsAreExposed(FromPersonUsesDomainObjectToolsViaExecutingOperationContext())
        }

        @Test
        fun `prompt action invocation with tool object passed in via using`() {
            testToolsAreExposed(FromPersonUsesObjectToolsViaUsing(), expectedToolCount = 2)
        }

        @Test
        fun `prompt action invocation with tool object passed in via context`() {
            testToolsAreExposed(FromPersonUsesObjectToolsViaContext(), expectedToolCount = 2)
        }

        @Test
        fun `prompt action invocation with tool object passed in via ai`() {
            testToolsAreExposed(FromPersonUsesObjectToolsViaAi(), expectedToolCount = 2)
        }

        @Test
        fun `prompt action invocation with tool object passed in via using with renaming`() {
            val toolCallbacks =
                testToolsAreExposed(FromPersonUsesObjectToolsViaUsingWithRenaming(), expectedToolCount = 2)
            assertTrue(
                toolCallbacks.any { it.toolDefinition.name() == "_thing" },
                "Should have renamed thing tool, had ${toolCallbacks.map { it.toolDefinition.name() }}",
            )
        }

        @Test
        fun `prompt action invocation with tool object passed in via context with renaming`() {
            val toolCallbacks =
                testToolsAreExposed(FromPersonUsesObjectToolsViaContextWithRenaming(), expectedToolCount = 2)
            assertTrue(
                toolCallbacks.any { it.toolDefinition.name() == "_thing" },
                "Should have renamed thing tool, had ${toolCallbacks.map { it.toolDefinition.name() }}",
            )
        }

        @Test
        fun `prompt action invocation with tool object passed in via using with filter`() {
            val toolCallbacks =
                testToolsAreExposed(FromPersonUsesObjectToolsViaUsingWithFilter(), expectedToolCount = 1)
//            assertF(
//                toolCallbacks.any { it.toolDefinition.name() == "_thing" },
//                "Should have renamed thing tool, had ${toolCallbacks.map { it.toolDefinition.name() }}",
//            )
        }

        private fun testToolsAreExposed(
            instance: Any,
            expectedToolCount: Int = 1,
        ): List<ToolCallback> {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(instance)
            assertNotNull(metadata)
            assertEquals(1, metadata!!.actions.size)
            val action = metadata.actions.first()
            val agent = mockk<CoreAgent>()
            every { agent.jvmTypes } returns listOf(
                PersonWithReverseTool::class.java,
                UserInput::class.java
            ).map { JvmType(it) }
            val mockAgentProcess = mockk<AgentProcess>()
            every { mockAgentProcess.agent } returns agent
            val llmo = slot<LlmInteraction>()
            val llmt = mockk<LlmOperations>()
            every {
                llmt.createObject<Any>(
                    any(),
                    capture(llmo),
                    any(),
                    any(),
                    any(),
                )
            } returns UserInput("John Doe")
            val mockPlatformServices = mockk<PlatformServices>()
            every { mockPlatformServices.llmOperations } returns llmt
            every { mockPlatformServices.eventListener } returns DevNull
            every { mockPlatformServices.outputChannel } returns DevNullOutputChannel

            val blackboard = InMemoryBlackboard().bind(IoBinding.DEFAULT_BINDING, PersonWithReverseTool("John Doe"))
            every { mockAgentProcess.hasValue(any(), any(), any()) } answers {
                blackboard.hasValue(
                    firstArg(),
                    secondArg(),
                    thirdArg(),
                )
            }
            every { mockAgentProcess.getValue(any(), any(), any()) } answers {
                blackboard.getValue(
                    firstArg(),
                    secondArg(),
                    thirdArg(),
                )
            }
            every { mockAgentProcess.set(any(), any()) } answers {
                blackboard.set(
                    firstArg(),
                    secondArg(),
                )
            }
            every { mockAgentProcess.lastResult() } returns UserInput("John Doe")

            val pc = ProcessContext(
                platformServices = mockPlatformServices,
                agentProcess = mockAgentProcess,
            )
            val result = action.execute(pc)
            assertEquals(ActionStatusCode.SUCCEEDED, result.status)
            assertTrue(pc.blackboard.lastResult() is UserInput)
            assertEquals("John Doe", (pc.blackboard.lastResult() as UserInput).content)
            assertEquals(
                expectedToolCount,
                llmo.captured.toolCallbacks.size,
                "Should have $expectedToolCount tools, had ${llmo.captured.toolCallbacks.map { it.toolDefinition.name() }}",
            )
            assertTrue(llmo.captured.toolCallbacks.any { it.toolDefinition.name() == "reverse" })
            assertEquals(DefaultModelSelectionCriteria, llmo.captured.llm.criteria)
            return llmo.captured.toolCallbacks
        }
    }

    @Nested
    inner class PathFinding {

        @Test
        fun `can find path when value comes from blackboard rather than parameter`() {
            val reader = AgentMetadataReader()
            val metadata =
                reader.createAgentMetadata(
                    GetsFromBlackboard()
                )
            assertNotNull(metadata)
            assertEquals(2, metadata!!.actions.size)

            val ap = IntegrationTestUtils.dummyAgentPlatform()
            val agent = metadata as CoreAgent
            val agentProcess =
                ap.runAgentFrom(
                    agent,
                    ProcessOptions(),
                    emptyMap(),
                )
            assertEquals(AgentProcessStatusCode.COMPLETED, agentProcess.status)
            assertEquals(PersonWithReverseTool("Kermit"), agentProcess.lastResult())
        }

        @Test
        fun `always chooses action with most preconditions`() {
            val reader = AgentMetadataReader()
            val mostSpecificPathAgent = MostSpecificPath()
            val metadata = reader.createAgentMetadata(mostSpecificPathAgent)

            val ap = IntegrationTestUtils.dummyAgentPlatform()
            val agent = metadata as CoreAgent
            var agentProcess =
                ap.runAgentFrom(
                    agent,
                    ProcessOptions(),
                    emptyMap(),
                )
            assertEquals(AgentProcessStatusCode.COMPLETED, agentProcess.status)
            assertEquals(Prince("Kermit"), agentProcess.lastResult())
            assertEquals(1, mostSpecificPathAgent.frogsCreatedFromScratch)

            mostSpecificPathAgent.frogsCreatedFromScratch = 0
            agentProcess =
                ap.runAgentFrom(
                    agent,
                    ProcessOptions(),
                    mapOf("it" to UserInput("Billy")),
                )
            assertEquals(AgentProcessStatusCode.COMPLETED, agentProcess.status)
            assertEquals(0, mostSpecificPathAgent.frogsCreatedFromScratch, "Should use most specific path")

            assertEquals(Prince("Billy"), agentProcess.lastResult())
        }
    }

    @Nested
    inner class AnnotationInheritance {

        @Test
        fun `recognises Action annotations inherited from interface`() {
            test(GetsFromBlackboardInheritedInterfaceAction())
        }

        @Nested
        @Disabled("We need to decide whether we permit overriding or not")
        inner class Overrides {
            @Test
            fun `recognises Action annotations inherited and overridden from interface`() {
                test(GetsFromBlackboardInheritedInterfaceActionOverride())
            }

            @Test
            fun `recognises Action annotations inherited from class override`() {
                test(GetsFromBlackboardInheritedClassActionOverride())
            }
        }

        @Test
        fun `recognises Action annotations inherited from class`() {
            test(GetsFromBlackboardInheritedClassAction())
        }

        @Test
        fun `recognises Goal annotation inherited from interface`() {
            test(GetsGoalFromBlackboardInheritedInterfaceAction())
        }

        @Test
        fun `recognises Goal annotation inherited from class`() {
            test(GetsGoalFromBlackboardInheritedClassAction())
        }

        @Test
        fun `recognises Condition annotation inherited from interface`() {
            test(GetsConditionFromBlackboardInheritedInterfaceAction())
        }

        @Test
        fun `recognises Condition annotation inherited from class`() {
            test(GetsConditionFromBlackboardInheritedClassAction())
        }

        private fun test(instance: Any) {
            val reader = AgentMetadataReader()
            val metadata =
                reader.createAgentMetadata(
                    instance
                )
            assertNotNull(metadata)
            assertEquals(2, metadata!!.actions.size)

            val ap = IntegrationTestUtils.dummyAgentPlatform()
            val agent = metadata as CoreAgent
            val agentProcess =
                ap.runAgentFrom(
                    agent,
                    ProcessOptions(),
                    emptyMap(),
                )
            assertEquals(AgentProcessStatusCode.COMPLETED, agentProcess.status)
            assertEquals(PersonWithReverseTool("Kermit"), agentProcess.lastResult())
        }

    }

    @Nested
    inner class AwaitableTest {

        @Test
        fun `awaitable action invocation`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(AwaitableOne())
            assertNotNull(metadata)
            assertEquals(1, metadata!!.actions.size)
            val action = metadata.actions.first()
            val agent = mockk<CoreAgent>()
            every { agent.jvmTypes } returns listOf(
                PersonWithReverseTool::class.java,
                UserInput::class.java
            ).map { JvmType(it) }
            val mockAgentProcess = mockk<AgentProcess>()
            every { mockAgentProcess.agent } returns agent
            every { mockAgentProcess.id } returns "mythical_beast"

            val mockPlatformServices = mockk<PlatformServices>()
            val llmt = mockk<LlmOperations>()
            every { mockPlatformServices.llmOperations } returns llmt
            every { mockPlatformServices.eventListener } returns DevNull
            every { mockPlatformServices.outputChannel } returns DevNullOutputChannel
            val blackboard = InMemoryBlackboard().bind(IoBinding.DEFAULT_BINDING, UserInput("John Doe"))
            every { mockAgentProcess.hasValue(any(), any(), any()) } answers {
                blackboard.hasValue(
                    firstArg(),
                    secondArg(),
                    thirdArg(),
                )
            }
            every { mockAgentProcess.getValue(any(), any(), any()) } answers {
                blackboard.getValue(
                    firstArg(),
                    secondArg(),
                    thirdArg(),
                )
            }
            every { mockAgentProcess.addObject(any()) } answers {
                blackboard.addObject(
                    firstArg(),
                )
            }
            every {
                mockAgentProcess.lastResult()
            } answers {
                blackboard.lastResult()
            }

            val pc = ProcessContext(
                platformServices = mockPlatformServices,
                agentProcess = mockAgentProcess,
            )
            val result = action.execute(pc)
            assertEquals(ActionStatusCode.WAITING, result.status)
            val fr = pc.blackboard.lastResult()
            assertTrue(
                fr is ConfirmationRequest<*>,
                "Last result should be an ConfirmationRequest: had ${blackboard.infoString(true)}",
            )
            val awaitable = fr as ConfirmationRequest<*>
            assertEquals(PersonWithReverseTool("John Doe"), awaitable.payload)
        }
    }

    @Nested
    inner class SomeOfComposite {

        @Test
        fun `composition metadata is found`() {
            val reader = AgentMetadataReader()
            val metadata =
                reader.createAgentMetadata(
                    UsesFrogOrDogSomeOf()
                )
            assertNotNull(metadata)
            assertEquals(2, metadata!!.actions.size)
            val frogOrDogAction = metadata.actions.find { it.name.contains("frogOrDog") }!!
            assertEquals(2, frogOrDogAction.outputs.size, "Should have 2 outputs, not ${frogOrDogAction.outputs}")
            assertEquals(
                setOf(IoBinding("it", Frog::class), IoBinding("it", Dog::class)),
                frogOrDogAction.outputs,
            )
            val toPerson = metadata.actions.find { it.name.contains("toPerson") }!!
            assertEquals(Frog::class.java.name, toPerson.inputs.single().type)
            assertEquals(1, toPerson.outputs.size, "Should have 1 output")
            assertEquals(
                PersonWithReverseTool::class.java.name,
                toPerson.outputs.single().type,
                "Output name must match",
            )
//            assertEquals(2, action.toolGroups.size, "Had ${action.toolGroups} tool groups, expected 1")
//            assertEquals(setOf("magic", "frogs"), action.toolGroups.map { it.role }.toSet())
//            val ap = IntegrationTestUtils.dummyAgentPlatform()
//            val agentProcess =
//                ap.runAgentFrom(
//                    metadata as CoreAgent,
//                    ProcessOptions(),
//                    mapOf("it" to PersonWithReverseTool("John Doe"))
//                )
//            assertEquals(AgentProcessStatusCode.COMPLETED, agentProcess.status)
//            assertEquals(Frog("John Doe"), agentProcess.lastResult())
        }

        @Test
        fun `invoke method compose result`() {
            val reader = AgentMetadataReader()
            val metadata =
                reader.createAgentMetadata(
                    UsesFrogOrDogSomeOf()
                )
            assertNotNull(metadata)
            assertEquals(2, metadata!!.actions.size)
            val frogOrDogAction = metadata.actions.find { it.name.contains("frogOrDog") }!!

            val toPerson = metadata.actions.find { it.name.contains("toPerson") }!!

            val ap = IntegrationTestUtils.dummyAgentPlatform()
            val agent = metadata as CoreAgent
            val agentProcess =
                ap.runAgentFrom(
                    agent,
                    ProcessOptions(),
                    emptyMap(),
                )
            assertEquals(AgentProcessStatusCode.COMPLETED, agentProcess.status)
            assertEquals(PersonWithReverseTool("Kermit"), agentProcess.lastResult())
        }

        @Test
        @Disabled("Not yet implemented")
        fun `invoke method compose result with RequiresMatch`() {

        }
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/annotation/support/AgentMetadataReaderConditionsTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation.support

import com.embabel.agent.api.common.OperationContext
import com.embabel.agent.api.dsl.Frog
import com.embabel.agent.testing.unit.FakeOperationContext
import com.embabel.plan.goap.ConditionDetermination
import io.mockk.every
import io.mockk.mockk
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertNotNull
import org.junit.jupiter.api.Test

class AgentMetadataReaderConditionsTest {

    @Test
    fun `no conditions`() {
        val reader = AgentMetadataReader()
        val metadata = reader.createAgentMetadata(NoConditions())
        assertNotNull(metadata)
        assertEquals(0, metadata!!.conditions.size)
    }

    @Test
    fun `one condition taking OperationContext`() {
        val reader = AgentMetadataReader()
        val metadata = reader.createAgentMetadata(OneOperationContextConditionOnly())
        assertNotNull(metadata)
        assertEquals(1, metadata!!.conditions.size)
        assertEquals(
            "${OneOperationContextConditionOnly::class.java.name}.condition1",
            metadata.conditions.first().name
        )
    }

    @Test
    fun `one condition taking Ai`() {
        val reader = AgentMetadataReader()
        val metadata = reader.createAgentMetadata(OneOperationContextAiOnly())
        assertNotNull(metadata)
        assertEquals(1, metadata!!.conditions.size)
        assertEquals(
            "${OneOperationContextAiOnly::class.java.name}.condition1",
            metadata.conditions.first().name
        )
    }

    @Test
    fun `processContext condition invocation`() {
        val reader = AgentMetadataReader()
        val metadata = reader.createAgentMetadata(OneOperationContextConditionOnly())
        assertNotNull(metadata)
        assertEquals(1, metadata!!.conditions.size)
        val condition = metadata.conditions.first()
        val mockProcessContext = mockk<OperationContext>()
        every { mockProcessContext.processContext.agentProcess } returns mockk()
        assertEquals(ConditionDetermination.TRUE, condition.evaluate(mockProcessContext))
    }

    @Test
    fun `blackboard condition invocation not found`() {
        val reader = AgentMetadataReader()
        val metadata = reader.createAgentMetadata(ConditionFromBlackboard())
        assertNotNull(metadata)
        assertEquals(1, metadata!!.conditions.size)
        val condition = metadata.conditions.first()
        val fakeOperationContext = FakeOperationContext()
        assertEquals(ConditionDetermination.FALSE, condition.evaluate(fakeOperationContext))
    }

    @Test
    fun `blackboard condition invocation found and true`() {
        val reader = AgentMetadataReader()
        val metadata = reader.createAgentMetadata(ConditionFromBlackboard())
        assertNotNull(metadata)
        assertEquals(1, metadata!!.conditions.size)
        val condition = metadata.conditions.first()
        val fakeOperationContext = FakeOperationContext()
        fakeOperationContext += PersonWithReverseTool("Rod")
        assertEquals(ConditionDetermination.TRUE, condition.evaluate(fakeOperationContext))
    }

    @Test
    fun `custom named blackboard condition invocation found and true`() {
        val reader = AgentMetadataReader()
        val metadata = reader.createAgentMetadata(CustomNameConditionFromBlackboard())
        assertNotNull(metadata)
        assertEquals(1, metadata!!.conditions.size)
        val condition = metadata.conditions.first()
        assertEquals("condition1", condition.name)
        val fakeOperationContext = FakeOperationContext()
        fakeOperationContext += PersonWithReverseTool("Rod")
        assertEquals(ConditionDetermination.TRUE, condition.evaluate(fakeOperationContext))
    }

    @Test
    fun `blackboard condition invocation found and false`() {
        val reader = AgentMetadataReader()
        val metadata = reader.createAgentMetadata(ConditionFromBlackboard())
        assertNotNull(metadata)
        assertEquals(1, metadata!!.conditions.size)
        val condition = metadata.conditions.first()
        val fakeOperationContext = FakeOperationContext()
        fakeOperationContext += PersonWithReverseTool("ted")
        assertEquals(ConditionDetermination.FALSE, condition.evaluate(fakeOperationContext))
    }

    @Test
    fun `blackboard conditions invocation not all found and false`() {
        val reader = AgentMetadataReader()
        val metadata = reader.createAgentMetadata(ConditionsFromBlackboard())
        assertNotNull(metadata)
        assertEquals(1, metadata!!.conditions.size)
        val condition = metadata.conditions.first()
        val fakeOperationContext = FakeOperationContext()
        fakeOperationContext += PersonWithReverseTool("Rod")
        assertEquals(ConditionDetermination.FALSE, condition.evaluate(fakeOperationContext))
    }

    @Test
    fun `blackboard conditions invocation all found and true`() {
        val reader = AgentMetadataReader()
        val metadata = reader.createAgentMetadata(ConditionsFromBlackboard())
        assertNotNull(metadata)
        assertEquals(1, metadata!!.conditions.size)
        val condition = metadata.conditions.first()
        val fakeOperationContext = FakeOperationContext()
        fakeOperationContext += PersonWithReverseTool("Rod")
        fakeOperationContext += Frog("Kermit")
        assertEquals(ConditionDetermination.TRUE, condition.evaluate(fakeOperationContext))
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/annotation/support/AgentMetadataReaderImportTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation.support

import com.embabel.agent.api.dsl.SnakeMeal
import com.embabel.agent.core.Agent
import com.embabel.agent.core.AgentProcessStatusCode
import com.embabel.agent.core.ProcessOptions
import com.embabel.agent.domain.io.UserInput
import com.embabel.agent.testing.integration.IntegrationTestUtils
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test
import kotlin.test.assertTrue

class AgentMetadataReaderImportTest {

    @Test
    fun `define flow`() {
        val reader = AgentMetadataReader()
        val agent = reader.createAgentMetadata(DefineFlowTest()) as Agent
        val ap = IntegrationTestUtils.dummyAgentPlatform()
        val result = ap.runAgentFrom(
            agent = agent,
            processOptions = ProcessOptions(),
            bindings = mapOf(
                "it" to UserInput("input"),
            ),
        )
        assertEquals(AgentProcessStatusCode.COMPLETED, result.status)
        assertTrue(result.lastResult() is PersonWithReverseTool)
    }

    @Test
    fun `local agent`() {
        val reader = AgentMetadataReader()
        val agent = reader.createAgentMetadata(LocalAgentTest()) as Agent
        val ap = IntegrationTestUtils.dummyAgentPlatform()
        val result = ap.runAgentFrom(
            agent, processOptions = ProcessOptions(),
            bindings = mapOf(
                "it" to UserInput("input"),
            ),
        )
        assertEquals(AgentProcessStatusCode.COMPLETED, result.status)
        assertTrue(result.lastResult() is SnakeMeal)
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/annotation/support/AgentMetadataReaderMetadataTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation.support

import com.embabel.agent.api.common.Ai
import com.embabel.agent.api.common.OperationContext
import com.embabel.agent.api.dsl.Frog
import com.embabel.agent.core.JvmType
import com.embabel.agent.core.support.Rerun
import com.embabel.agent.support.containsAll
import com.embabel.agent.testing.integration.IntegrationTestUtils.dummyAgentPlatform
import com.embabel.plan.goap.ConditionDetermination
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Disabled
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import kotlin.test.assertNull
import com.embabel.agent.core.Agent as CoreAgent


/**
 * Test for metadata extraction from annotations,
 * not invocation
 */
class AgentMetadataReaderMetadataTest {

    @Nested
    inner class Errors {

        @Test
        fun `no annotation`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(PersonWithReverseTool("John Doe"))
            assertNull(metadata)
        }

        @Test
        fun `no methods`() {
            val reader = AgentMetadataReader()
            assertNull(reader.createAgentMetadata(NoMethods()))
        }

        @Test
        @Disabled
        fun invalidConditionSignature() {
        }

        @Test
        fun `invalid action signature returning interface without serialization annotation`() {
            val reader = AgentMetadataReader()
            assertNull(reader.createAgentMetadata(InvalidActionNoDeserializationInInterfaceGoal()))
        }

        @Test
        fun `valid action signature returning interface with serialization annotation`() {
            val reader = AgentMetadataReader()
            assertNotNull(reader.createAgentMetadata(ValidActionWithDeserializationInInterfaceGoal()))
        }

    }

    @Nested
    inner class Goals {

        @Test
        fun `one goal only`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(OneGoalOnly())
            assertNotNull(metadata)
            assertEquals(1, metadata!!.goals.size)
        }

        @Test
        fun `metadata is preserved`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(OneGoalOnlyWithRichMetadata())
            assertNotNull(metadata)
            assertEquals(1, metadata!!.goals.size)
            val g = metadata.goals.single()
            assertEquals("This is a goal with rich metadata", g.description)
            assertEquals(setOf("foo", "bar"), g.tags)
            assertEquals(setOf("make me happy"), g.examples)
        }

        @Test
        fun `two goals only`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(TwoGoalsOnly())
            assertNotNull(metadata)
            assertEquals(2, metadata!!.goals.size)
            val expectedThing1GoalName = "${TwoGoalsOnly::class.java.name}.thing1"
            val expectedThing2GoalName = "${TwoGoalsOnly::class.java.name}.thing2"
            val t1 = metadata.goals.find { it.name == expectedThing1GoalName }
            val t2 = metadata.goals.find { it.name == expectedThing2GoalName }
            assertNotNull(t1, "Should have $expectedThing1GoalName goal: " + metadata.goals.map { it.name })
            assertNotNull(t2, "Should have $expectedThing2GoalName goal: " + metadata.goals.map { it.name })

            assertEquals("Thanks to Dr Seuss", t1!!.description)
            assertEquals("Thanks again to Dr Seuss", t2!!.description)
        }

        @Test
        fun `action goal requires output of action method`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(ActionGoal())
            assertNotNull(metadata)
            assertEquals(1, metadata!!.goals.size)
            val g = metadata.goals.single()
            assertEquals("Creating a person", g.description)
            assertTrue(
                g.preconditions.containsAll(mapOf("it:${PersonWithReverseTool::class.qualifiedName}" to ConditionDetermination.TRUE)),
                "Should have precondition for Person",
            )
        }

        @Test
        fun `action goal requires action method to have run`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(ActionGoal())
            assertNotNull(metadata)
            assertEquals(1, metadata!!.goals.size)
            val action = metadata.actions.single()
            val g = metadata.goals.single()
            assertEquals(PersonWithReverseTool::class.java, (g.outputType as JvmType).clazz)
            assertEquals("Creating a person", g.description)
            val expected = mapOf(
                "it:${PersonWithReverseTool::class.qualifiedName}" to ConditionDetermination.TRUE,
                Rerun.hasRunCondition(action) to ConditionDetermination.TRUE
            )
            assertTrue(
                g.preconditions.containsAll(
                    expected,
                ),
                "Should have precondition for input to the action method: have\n${g.preconditions}, expected\n$expected",
            )
        }

        @Test
        fun `two distinct action goals`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(TwoActionGoals())
            assertNotNull(metadata)
            assertEquals(2, metadata!!.goals.size)
            val personGoal = metadata.goals.find { it.name == TwoActionGoals::class.java.name + ".toPerson" }
                ?: fail("Should have toPerson goal: " + metadata.goals.map { it.name })
            val frogGoal = metadata.goals.find { it.name == TwoActionGoals::class.java.name + ".toFrog" }
                ?: fail("Should have toFrog goal: " + metadata.goals.map { it.name })

            assertEquals("Creating a person", personGoal.description)
            assertTrue(
                personGoal.preconditions.containsAll(
                    mapOf(
                        "it:${PersonWithReverseTool::class.qualifiedName}" to ConditionDetermination.TRUE,
//                        "it:${UserInput::class.qualifiedName}" to ConditionDetermination.TRUE
                    )
                ),
                "Should have precondition for Person",
            )
            assertEquals("Creating a frog", frogGoal.description)
            assertTrue(
                frogGoal.preconditions.containsAll(
                    mapOf("it:${Frog::class.qualifiedName}" to ConditionDetermination.TRUE),
                ),
                "Should have precondition for Frog",
            )
        }

        @Test
        fun `two actually non conflicting action goals with different inputs but same output`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(TwoActuallyNonConflictingActionGoalsWithSameOutput())
            assertNotNull(metadata)
            assertEquals(2, metadata!!.goals.size)
            val expectedPersonGoalName =
                TwoActuallyNonConflictingActionGoalsWithSameOutput::class.java.name + ".toPerson"
            val personGoal =
                metadata.goals.find { it.name == expectedPersonGoalName }
                    ?: fail("Should have $expectedPersonGoalName goal: " + metadata.goals.map { it.name })

            val alsoGoal =
                metadata.goals.find { it.name == TwoActuallyNonConflictingActionGoalsWithSameOutput::class.java.name + ".alsoToPerson" }
                    ?: fail("Should have alsoToPerson goal: " + metadata.goals.map { it.name })

            assertEquals("Creating a person", personGoal.description)
            assertTrue(
                personGoal.preconditions.containsAll(
                    mapOf(
                        "it:${PersonWithReverseTool::class.qualifiedName}" to ConditionDetermination.TRUE,
//                        "it:${UserInput::class.qualifiedName}" to ConditionDetermination.TRUE,
                    )
                ),
                "Should have precondition for Person",
            )
            assertEquals("Also to person", alsoGoal.description)
            assertTrue(
                alsoGoal.preconditions.containsAll(
                    mapOf("it:${PersonWithReverseTool::class.qualifiedName}" to ConditionDetermination.TRUE)
                ),
                "Should have precondition for alsoPerson",
            )
        }

        @Test
        @Disabled("must decide what behavior should be")
        fun `two conflicting action goals`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(TwoConflictingActionGoals())
            TODO("decide what to do here: this invalid")
        }
    }


    @Nested
    inner class Agents {

        @Test
        fun `not an agent`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(ConditionFromBlackboard())
            assertNotNull(metadata)
            assertFalse(metadata!! is CoreAgent)
        }

        @Test
        fun `recognize an agent`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(AgentWithOneTransformerActionWith2ArgsOnly())
            assertNotNull(metadata)
            assertTrue(metadata is CoreAgent, "@Agent should create an agent")
            metadata as CoreAgent
            assertEquals(1, metadata.actions.size)
            assertEquals(
                AgentWithOneTransformerActionWith2ArgsOnly::class.java.simpleName,
                metadata.name,
            )
        }

        @Test
        fun `support agent with custom name, provider and version`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(AgentWithCustomName())
            assertNotNull(metadata)
            assertTrue(metadata is CoreAgent, "@Agent should create an agent")
            metadata as CoreAgent
            assertEquals(1, metadata.actions.size)
            assertEquals("magic", metadata.provider)
            assertEquals("1.1.1", metadata.version.value)
            assertEquals(
                "myAgentWithCustomName",
                metadata.name,
            )
        }

        @Test
        fun `not expose actions on opaque agent `() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(OpaqueAgent())
            assertNotNull(metadata)
            assertTrue(metadata is CoreAgent, "@Agent should create an agent")
            metadata as CoreAgent
            assertEquals(1, metadata.actions.size)
            val ap = dummyAgentPlatform()
            ap.deploy(metadata)
            assertEquals(1, ap.agents().size)
            assertEquals(0, ap.actions.size)
        }

        @Test
        fun `expose actions by default on non-opaque agent`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(AgentWithCustomName())
            assertNotNull(metadata)
            assertTrue(metadata is CoreAgent, "@Agent should create an agent")
            metadata as CoreAgent
            assertEquals(1, metadata.actions.size)
            val ap = dummyAgentPlatform()
            ap.deploy(metadata)
            assertEquals(1, ap.agents().size)
            assertEquals(1, ap.actions.size)
        }

        @Test
        fun `not treat OperationContext parameter as a precondition`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(
                AgentWithOneTransformerActionWith2ArgsOnlyAndOperationContextParameter()
            )
            assertNotNull(metadata)
            assertTrue(metadata is CoreAgent, "@Agent should create an agent")
            metadata as CoreAgent
            assertEquals(1, metadata.actions.size)
            val action = metadata.actions.single()
            assertFalse(
                action.preconditions.any { it.key == "it:${OperationContext::class.java.name}" },
                "OperationContext parameter should not be treated as an input precondition: ${action.preconditions}"
            )
        }

        @Test
        fun `not treat Ai parameter as a precondition`() {
            val reader = AgentMetadataReader()
            val metadata = reader.createAgentMetadata(AgentWithOneTransformerActionWith2ArgsOnlyAndAiParameter())
            assertNotNull(metadata)
            assertTrue(metadata is CoreAgent, "@Agent should create an agent")
            metadata as CoreAgent
            assertEquals(1, metadata.actions.size)
            val action = metadata.actions.single()
            assertFalse(
                action.preconditions.any { it.key == "it:${Ai::class.java.name}" },
                "Ai parameter should not be treated as an input precondition: ${action.preconditions}"
            )
        }
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/annotation/support/FromClassAndMethodMethodDefinedOperationNameGeneratorTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation.support

import com.embabel.agent.support.Dog
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test

class FromClassAndMethodMethodDefinedOperationNameGeneratorTest {

    @Test
    fun `should generate method name from class and method without $ prefix`() {
        val generator = FromClassAndMethodMethodDefinedOperationNameGenerator
        val name = generator.generateName(
            Dog("Disco"),
            "bark"
        )
        assertEquals("${Dog::class.java.name}.bark", name)
    }

    @Test
    fun `should generate method name from class and method with Kotlin internal $ prefix`() {
        val name = FromClassAndMethodMethodDefinedOperationNameGenerator.generateName(
            Dog("Duke"),
            "bark\$special_package"
        )
        assertEquals("${Dog::class.java.name}.bark", name)
    }

    @Test
    fun `should respect inner class name`() {
        val generator = FromClassAndMethodMethodDefinedOperationNameGenerator
        val name = generator.generateName(
            Thing.InnerClass(),
            "getHomePage"
        )
        assertEquals("${Thing.InnerClass::class.java.name}.getHomePage", name)
    }
}

class Thing {

    class InnerClass {
        fun getHomePage() {}
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/annotation/support/IntentReceptionAgent.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation.support

import com.embabel.agent.api.annotation.AchievesGoal
import com.embabel.agent.api.annotation.Action
import com.embabel.agent.api.annotation.Agent
import com.embabel.agent.domain.io.UserInput
import com.embabel.common.util.loggerFor

sealed class Intent
class BillingIntent : Intent()
class SalesIntent : Intent()
class ServiceIntent : Intent()

data class IntentClassificationSuccess(val text: String)

@Agent(
    description = "Figure out the department a customer wants to transfer to",
)
class IntentReceptionAgent() {

    @Action
    fun classifyIntent(userInput: UserInput): Intent? =
        when (userInput.content) {
            "billing" -> BillingIntent()
            "sales" -> SalesIntent()
            "service" -> ServiceIntent()
            else -> {
                loggerFor<IntentReceptionAgent>().warn("Unknown intent: $userInput")
                null
            }
        }

    @Action
    fun billingAction(intent: BillingIntent): IntentClassificationSuccess {
        return IntentClassificationSuccess("billing")
    }

    @Action
    fun salesAction(intent: SalesIntent): IntentClassificationSuccess {
        return IntentClassificationSuccess("sales")
    }

    @Action
    fun serviceAction(intent: ServiceIntent): IntentClassificationSuccess {
        return IntentClassificationSuccess("service")
    }

    @AchievesGoal(description = "The department has been determined")
    @Action
    fun success(success: IntentClassificationSuccess): IntentClassificationSuccess {
        return success
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/annotation/support/RequireNonAmbiguousParametersTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation.support

import com.embabel.agent.api.annotation.Condition
import com.embabel.agent.api.annotation.RequireNameMatch
import com.embabel.agent.core.IoBinding
import org.junit.jupiter.api.Assertions.assertDoesNotThrow
import org.junit.jupiter.api.Assertions.assertThrows
import org.junit.jupiter.api.Test
import java.lang.reflect.Method
import kotlin.test.assertEquals
import kotlin.test.assertNull

class RequireNonAmbiguousParametersTest {

    private class Demo {
        fun distinctTypes(
            a: String,
            b: Int,
        ) {
        }

        @Condition
        fun twoSameTypeBothAnnotated(
            @RequireNameMatch a: String,
            @RequireNameMatch b: String,
        ) {
        }

        @Condition
        fun twoSameTypeOneAnnotated(
            @RequireNameMatch a: String,
            b: String,
        ) {
        }

        @Condition
        fun threeSameTypeOneAnnotated(
            @RequireNameMatch a: String,
            b: String,
            c: String,
        ) {
        }

        @Condition
        fun threeSameTypeAllAnnotated(
            @RequireNameMatch a: String,
            @RequireNameMatch b: String,
            @RequireNameMatch c: String,
        ) {
        }

        @Condition
        fun annotatedWithValue(
            @RequireNameMatch("bindingX") a: String,
        ) {
        }

        @Condition
        fun annotatedWithoutValue(
            @RequireNameMatch a: String,
        ) {
        }
    }

    private fun method(name: String): Method = Demo::class.java.declaredMethods.first { it.name == name }

    @Test
    fun `distinct class types`() {
        val m = method("distinctTypes")
        assertDoesNotThrow { requireNonAmbiguousParameters(m) }
    }

    @Test
    fun `two parameters same type both annotated`() {
        val m = method("twoSameTypeBothAnnotated")
        assertDoesNotThrow { requireNonAmbiguousParameters(m) }
    }

    @Test
    fun `two parameters same type one annotated`() {
        val m = method("twoSameTypeOneAnnotated")
        assertThrows(DuplicateParameterTypeException::class.java) {
            requireNonAmbiguousParameters(m)
        }
    }

    @Test
    fun `three parameters same type one annotated`() {
        val m = method("threeSameTypeOneAnnotated")
        assertThrows(DuplicateParameterTypeException::class.java) {
            requireNonAmbiguousParameters(m)
        }
    }

    @Test
    fun `three parameters same type all annotated`() {
        val m = method("threeSameTypeAllAnnotated")
        assertDoesNotThrow { requireNonAmbiguousParameters(m) }
    }

    // Tests for getParameterName
    @Test
    fun `getParameterName returns annotation value when provided`() {
        val m = method("annotatedWithValue")
        val p = m.parameters[0]
        val ann = p.getAnnotation(RequireNameMatch::class.java)
        val result = getBindingParameterName(p.name, ann)
        assertEquals("bindingX", result)
    }

    @Test
    fun `getParameterName returns parameter name when annotation value is blank`() {
        val m = method("annotatedWithoutValue")
        val p = m.parameters[0]
        val ann = p.getAnnotation(RequireNameMatch::class.java)
        val expected = p.name
        val result = getBindingParameterName(p.name, ann)
        assertEquals(expected, result)
    }

    @Test
    fun `getParameterName returns null parameter name when parameter name is null`() {
        val m = method("annotatedWithoutValue")
        val p = m.parameters[0]
        val ann = p.getAnnotation(RequireNameMatch::class.java)
        val result = getBindingParameterName(null, ann)
        assertNull(result)
    }

    @Test
    fun `getParameterName returns DEFAULT_BINDING when annotation is null`() {
        val m = method("distinctTypes")
        val p = m.parameters[0]
        val result = getBindingParameterName(p.name, null)
        assertEquals(IoBinding.DEFAULT_BINDING, result)
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/annotation/support/RoutingViaSubclassTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation.support

import com.embabel.agent.core.Agent
import com.embabel.agent.core.AgentProcessStatusCode
import com.embabel.agent.core.ProcessOptions
import com.embabel.agent.domain.io.UserInput
import com.embabel.agent.testing.integration.IntegrationTestUtils
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test

/**
 * Test for routing via subclassing.
 */
class RoutingViaSubclassTest {

    @Test
    fun `billing routing`() {
        checkRouting("billing")
    }

    @Test
    fun `sales routing`() {
        checkRouting("sales")
    }

    @Test
    fun `service routing`() {
        checkRouting("service")
    }

    @Test
    fun noSuchRouting() {
        val reader = AgentMetadataReader()
        val agent = reader.createAgentMetadata(IntentReceptionAgent()) as Agent

        val ap = IntegrationTestUtils.dummyAgentPlatform()
        val agentProcess =
            ap.runAgentFrom(agent, ProcessOptions(), mapOf("it" to UserInput("meaningless-routing")))
        assertEquals(AgentProcessStatusCode.STUCK, agentProcess.status)
    }

    private fun checkRouting(routing: String) {
        val reader = AgentMetadataReader()
        val agent = reader.createAgentMetadata(IntentReceptionAgent()) as Agent

        val ap = IntegrationTestUtils.dummyAgentPlatform()
        val agentProcess =
            ap.runAgentFrom(agent, ProcessOptions(), mapOf("it" to UserInput(routing)))
        assertEquals(AgentProcessStatusCode.COMPLETED, agentProcess.status)
        assertEquals(
            IntentClassificationSuccess(routing), agentProcess.lastResult(),
            "Should have detected $routing intent"
        )
    }


}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/annotation/support/testTypes.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation.support

import com.embabel.agent.api.annotation.*
import com.embabel.agent.api.common.*
import com.embabel.agent.api.dsl.*
import com.embabel.agent.core.Goal
import com.embabel.agent.core.ProcessContext
import com.embabel.agent.core.ToolGroupRequirement
import com.embabel.agent.core.hitl.ConfirmationRequest
import com.embabel.agent.core.last
import com.embabel.agent.domain.io.UserInput
import com.embabel.agent.support.Dog
import com.embabel.common.ai.model.LlmOptions
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import org.junit.jupiter.api.Assertions.assertEquals
import org.springframework.ai.tool.annotation.Tool

data class PersonWithReverseTool(val name: String) {

    @Tool
    fun reverse() = name.reversed()

}

@AgentCapabilities
class NoMethods

@AgentCapabilities
class OneGoalOnly {

    val thing1 = Goal.createInstance(
        name = "thing1",
        description = "Thanks to Dr Seuss",
        type = PersonWithReverseTool::class.java,
    ).withValue(30.0)
}

@AgentCapabilities
class OneGoalOnlyWithRichMetadata {

    val thing1 = Goal.createInstance(
        name = "thing1",
        description = "This is a goal with rich metadata",
        type = PersonWithReverseTool::class.java,
        tags = setOf("foo", "bar"),
        examples = setOf("make me happy"),
    ).withValue(30.0)
}

@AgentCapabilities
class TwoGoalsOnly {

    val thing1 = Goal.createInstance(
        description = "Thanks to Dr Seuss",
        type = PersonWithReverseTool::class.java,
    )
    val thing2 = Goal.createInstance(
        description = "Thanks again to Dr Seuss",
        type = PersonWithReverseTool::class.java,
    )
}

@AgentCapabilities
class ActionGoal {

    @Action
    @AchievesGoal(description = "Creating a person")
    fun toPerson(userInput: UserInput): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

}

interface InterfaceWithNoDeser {
    val content: String
}

@AgentCapabilities
class InvalidActionNoDeserializationInInterfaceGoal {

    @Action
    @AchievesGoal(description = "Creating a weird thing")
    fun createWeirdThing(userInput: UserInput): InterfaceWithNoDeser {
        TODO()
    }

}

@JsonDeserialize(`as` = MyInterfaceWithDeser::class)
interface InterfaceWithDeser {
    val content: String
}

data class MyInterfaceWithDeser(
    override val content: String,
) : InterfaceWithDeser

@AgentCapabilities
class ValidActionWithDeserializationInInterfaceGoal {

    @Action
    @AchievesGoal(description = "Creating a weird thing")
    fun createWeirdThing(userInput: UserInput): InterfaceWithDeser {
        TODO()
    }

}

@AgentCapabilities
class TwoActionGoals {

    @Action
    @AchievesGoal(description = "Creating a person")
    fun toPerson(userInput: UserInput): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

    @Action
    @AchievesGoal(description = "Creating a frog")
    fun toFrog(person: PersonWithReverseTool): Frog {
        return Frog(person.name)
    }

}

@AgentCapabilities
class TwoActuallyNonConflictingActionGoalsWithSameOutput {

    @Action
    @AchievesGoal(description = "Creating a person")
    fun toPerson(userInput: UserInput): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

    @Action
    @AchievesGoal(description = "Also to person")
    fun alsoToPerson(person: PersonWithReverseTool): PersonWithReverseTool {
        return person
    }

}

@AgentCapabilities
class TwoConflictingActionGoals {

    @Action
    @AchievesGoal(description = "Creating a person")
    fun toPerson(userInput: UserInput): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

    @Action
    @AchievesGoal(description = "Also to person")
    fun alsoToPerson(userInput: UserInput): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

}

@AgentCapabilities
class NoConditions {

    // A goal makes it legal
    val g = Goal.createInstance(
        name = "thing1",
        description = "Thanks to Dr Seuss",
        type = PersonWithReverseTool::class.java,
    ).withValue(30.0)

}

@AgentCapabilities
class OneOperationContextConditionOnly {

    @Condition(cost = .5)
    fun condition1(operationContext: OperationContext): Boolean {
        return true
    }

}

@AgentCapabilities
class OneOperationContextAiOnly {

    @Condition(cost = .5)
    fun condition1(ai: Ai): Boolean {
        return true
    }

}

@AgentCapabilities
class ConditionFromBlackboard {

    @Condition
    fun condition1(person: PersonWithReverseTool): Boolean {
        return person.name == "Rod"
    }

}

@AgentCapabilities
class CustomNameConditionFromBlackboard {

    @Condition(name = "condition1")
    fun `this is a weird name no one will see`(person: PersonWithReverseTool): Boolean {
        return person.name == "Rod"
    }

}

@AgentCapabilities
class ConditionsFromBlackboard {

    @Condition
    fun condition1(
        person: PersonWithReverseTool,
        frog: Frog,
    ): Boolean {
        return person.name == "Rod"
    }

}

@Agent(description = "one transformer action only")
class OneTransformerActionOnly {

    @Action(cost = 500.0)
    fun toPerson(userInput: UserInput): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

}

@AgentCapabilities
class OneTransformerActionWithNullableParameter {

    @Action(cost = 500.0)
    fun toPerson(
        userInput: UserInput,
        person: SnakeMeal?,
    ): PersonWithReverseTool {
        var content = userInput.content
        if (person != null) {
            content += " and tasty!"
        }
        return PersonWithReverseTool(content)
    }

}

internal data class InternalInput(val content: String)
internal data class InternalOutput(val content: String)

@Agent(description = "Package visible domain classes")
class InternalDomainClasses {

    @Action(cost = 500.0)
    internal fun oo(internalInput: InternalInput): InternalOutput {
        return InternalOutput(internalInput.content)
    }

}

@AgentCapabilities
class OneTransformerActionTakingPayloadOnly {

    @Action(cost = 500.0)
    fun toPerson(
        userInput: UserInput,
        payload: TransformationActionContext<UserInput, PersonWithReverseTool>,
    ): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

}

@AgentCapabilities
class OneTransformerActionTakingOperationPayload {

    @Action(cost = 500.0)
    fun toPerson(
        userInput: UserInput,
        payload: ActionContext,
    ): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

}

@AgentCapabilities
class OneTransformerActionReferencingConditionByName {

    @Action(pre = ["condition1"])
    fun toPerson(userInput: UserInput): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

}

@AgentCapabilities
class OneTransformerActionWithCustomToolGroupOnly {

    @Action(cost = 500.0, toolGroups = ["magic"])
    fun toPerson(userInput: UserInput): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

}

@Agent(description = "thing")
class OneTransformerActionTakingInterfaceWithCustomToolGroupOnly {

    @AchievesGoal(description = "Creating a frog")
    @Action(cost = 500.0, toolGroups = ["magic"])
    fun toPerson(person: PersonWithReverseTool): Frog {
        return Frog(person.name)
    }

}

@Agent(description = "thing")
class OneTransformerActionTakingInterfaceWithExpectationCustomToolGroupOnly {

    @AchievesGoal(description = "Creating a frog")
    @Action(cost = 500.0, toolGroups = ["magic"])
    fun toPerson(
        person: PersonWithReverseTool,
        context: OperationContext,
    ): Frog {
        val pr = context.promptRunner()
        assertEquals(setOf(ToolGroupRequirement("magic")), pr.toolGroups.toSet())
//        assertFalse(pr.toolCallbacks.isEmpty(), "ToolCallbacks should be expanded")
        return Frog(person.name)
    }

}

@Agent(description = "thing")
class OneTransformerActionTakingInterfaceWithExpectationCustomToolGroupRequirementOnly {

    @AchievesGoal(description = "Creating a frog")
    @Action(cost = 500.0, toolGroups = ["frogs"], toolGroupRequirements = [ToolGroup("magic")])
    fun toPerson(
        person: PersonWithReverseTool,
        context: OperationContext,
    ): Frog {
        val pr = context.promptRunner()
        assertEquals(setOf(ToolGroupRequirement("magic"), ToolGroupRequirement("frogs")), pr.toolGroups.toSet())
//        assertFalse(pr.toolCallbacks.isEmpty(), "ToolCallbacks should be expanded")
        return Frog(person.name)
    }

}

data class Task(
    val what: String,
)

@Agent(
    name = "myAgentWithCustomName",
    provider = "magic",
    version = "1.1.1",
    description = "one transformer action only",
)
class AgentWithCustomName {

    @Action(cost = 500.0)
    fun toPerson(
        userInput: UserInput,
        task: Task,
    ): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

}

@Agent(
    description = "one transformer action only",
    opaque = true,
)
class OpaqueAgent {

    @Action(cost = 500.0)
    fun toPerson(
        userInput: UserInput,
        task: Task,
    ): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

}


@Agent(
    description = "one transformer action only",
)
class AgentWithOneTransformerActionWith2ArgsOnly {

    @Action(cost = 500.0)
    fun toPerson(
        userInput: UserInput,
        task: Task,
    ): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

}

@Agent(
    description = "one transformer action only with ai",
)
class AgentWithOneTransformerActionWith2ArgsOnlyAndAiParameter {

    @Action(cost = 500.0)
    fun toPerson(
        userInput: UserInput,
        task: Task,
        ai: Ai,
    ): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

}

@Agent(
    description = "one transformer action only with OperationContext",
)
class AgentWithOneTransformerActionWith2ArgsOnlyAndOperationContextParameter {

    @Action(cost = 500.0)
    fun toPerson(
        userInput: UserInput,
        task: Task,
        context: OperationContext,
    ): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

}

@AgentCapabilities
class OneTransformerActionWith2ArgsAndCustomInputBindings {

    @Action
    fun toPerson(
        @RequireNameMatch userInput: UserInput,
        @RequireNameMatch task: Task,
    ): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

}

@AgentCapabilities
class OneTransformerActionWith2ArgsAndCustomOutputBinding {

    @Action(outputBinding = "person")
    fun toPerson(
        userInput: UserInput,
        task: Task,
    ): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

}

@AgentCapabilities
class OnePromptActionOnly(
) {

    val llm = LlmOptions.withModel("magical").withTemperature(.7)

    @Action(cost = 500.0)
    fun toPersonWithPrompt(
        userInput: UserInput,
        context: OperationContext,
    ): PersonWithReverseTool {
        return context.ai().withLlm(llm).createObject("Generated prompt for ${userInput.content}")
    }

}

@AgentCapabilities
class AwaitableOne(
) {

    @Action(cost = 500.0)
    fun waitForPersonConfirmation(userInput: UserInput): PersonWithReverseTool {
        return waitFor(
            ConfirmationRequest(
                payload = PersonWithReverseTool(userInput.content),
                message = "Is this dude the right person?",
            )
        )
    }

}

@AgentCapabilities
class Combined {

    val planner = Goal.createInstance(
        description = "Create a person",
        type = PersonWithReverseTool::class.java,
    ).withValue(30.0)

    // Can reuse this or inject
    val magicalLlm = LlmOptions.withModel("magical").withTemperature(1.7)

    @Condition(cost = .5)
    fun condition1(processContext: ProcessContext): Boolean {
        return true
    }

    @Action
    fun toPerson(userInput: UserInput): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

    @Action(cost = 500.0)
    fun toPersonWithPrompt(
        userInput: UserInput,
        context: OperationContext,
    ): PersonWithReverseTool {
        return context.ai().withLlm(magicalLlm).createObject("Generated prompt for ${userInput.content}")
    }

    @Tool
    fun weatherService(location: String) =
        "The weather in $location is ${listOf("sunny", "raining", "foggy").random()}"


}

@AgentCapabilities
class OnePromptActionWithToolOnly(
) {

    @Action(cost = 500.0)
    fun toPersonWithPrompt(
        userInput: UserInput,
        operationContext: OperationContext,
    ): PersonWithReverseTool {

        return operationContext.ai().withDefaultLlm() createObject
                "Generated prompt for ${userInput.content}"
    }

    @Tool
    fun thing(): String {
        return "foobar"
    }

}

@AgentCapabilities
class FromPersonUsesDomainObjectTools {

    @Action
    fun fromPerson(
        person: PersonWithReverseTool,
        context: OperationContext,
    ): UserInput {
        return context.ai().withDefaultLlm().createObject("Create a UserInput")
    }
}

@AgentCapabilities
class FromPersonUsesDomainObjectToolsViaActionContext {

    @Action
    fun fromPerson(
        person: PersonWithReverseTool,
        context: ActionContext,
    ): UserInput {
        return context.promptRunner().createObject("Create a UserInput")
    }
}

@AgentCapabilities
class FromPersonUsesDomainObjectToolsViaExecutingOperationContext {

    @Action
    fun fromPerson(
        person: PersonWithReverseTool,
        context: ExecutingOperationContext,
    ): UserInput {
        return context.promptRunner().createObject("Create a UserInput")
    }
}

@AgentCapabilities
class FromPersonUsesObjectToolsViaUsing {

    @Action
    fun fromPerson(
        person: PersonWithReverseTool,
        context: ActionContext,
    ): UserInput {
        return context.promptRunner(toolObjects = listOf(ToolObject(FunnyTool()))).createObject("Create a UserInput")
    }
}

@AgentCapabilities
class FromPersonUsesObjectToolsViaUsingWithRenaming {

    @Action
    fun fromPerson(
        person: PersonWithReverseTool,
        context: OperationContext,
    ): UserInput {
        return context.promptRunner()
            .withToolObject(
                ToolObject(
                    FunnyTool(),
                    namingStrategy = { "_$it" },
                )
            ).createObject("Create a UserInput")
    }
}

@AgentCapabilities
class FromPersonUsesObjectToolsViaUsingWithFilter {

    @Action
    fun fromPerson(
        person: PersonWithReverseTool,
        context: OperationContext,
    ): UserInput {
        return context.ai().withDefaultLlm()
            .withToolObject(
                ToolObject(FunnyTool()).withNamingStrategy { "_$it" }.withFilter { false },
            ).createObject("Create a UserInput")
    }
}

@AgentCapabilities
class FromPersonUsesObjectToolsViaContext {

    @Action
    fun fromPerson(
        person: PersonWithReverseTool,
        context: ActionContext,
    ): UserInput {
        return context.promptRunner(toolObjects = listOf(ToolObject(FunnyTool()))).createObject("Create a UserInput")
    }
}

@AgentCapabilities
class FromPersonUsesObjectToolsViaAi {

    @Action
    fun fromPerson(
        person: PersonWithReverseTool,
        ai: Ai,
    ): UserInput {
        return ai.withDefaultLlm()
            .withToolObjects(ToolObject(FunnyTool()))
            .createObject("Create a UserInput")
    }
}

@AgentCapabilities
class FromPersonUsesObjectToolsViaContextWithRenaming {

    @Action
    fun fromPerson(
        person: PersonWithReverseTool,
        context: ActionContext,
    ): UserInput {
        return context.promptRunner().withToolObject(
            ToolObject(
                FunnyTool(),
                namingStrategy = { "_$it" }),
        ).createObject("Create a UserInput")
    }
}

class FunnyTool {
    @Tool
    fun thing(): String {
        return "foobar"
    }
}

@AgentCapabilities
class OneTransformerActionWith2Tools {

    @Action
    fun toPerson(
        @RequireNameMatch userInput: UserInput,
        @RequireNameMatch task: Task,
    ): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

    @Tool
    fun toolWithoutArg(): String = "foo"

    @Tool
    fun toolWithArg(location: String) = "bar"

}

@AgentCapabilities
class ToolMethodsOnDomainObject {

    @Action
    fun toPerson(
        wumpty: Wumpus,
    ): PersonWithReverseTool {
        return PersonWithReverseTool(wumpty.name)
    }

    @Action
    fun toFrog(
        noTools: NoTools,
    ): Frog {
        return Frog("Kermit")
    }

}

class Wumpus(val name: String) {

    @Tool
    fun toolWithoutArg(): String = "The wumpus's name is $name"

    @Tool
    fun toolWithArg(location: String) = location
}

@AgentCapabilities
class ToolMethodsOnDomainObjects {

    @Action
    fun toFrog(
        wumpty: Wumpus,
        person: PersonWithReverseTool,
    ): Frog {
        return Frog(wumpty.name)
    }

}

data class NoTools(val x: Int)


@Agent(description = "define flow")
class DefineFlowTest {

    @Action
    fun toFrog(
        userInput: UserInput,
        context: TransformationActionContext<UserInput, PersonWithReverseTool>,
    ): Frog {
        return chain<UserInput, PersonWithReverseTool, Frog>(
            { PersonWithReverseTool(it.input.content) },
            { Frog(it.input.name) },
        ).asSubProcess(context)
    }

    @AchievesGoal(description = "Creating a person")
    @Action
    fun done(frog: Frog): PersonWithReverseTool {
        return PersonWithReverseTool(frog.name)
    }
}

@Agent(description = "local agent")
class LocalAgentTest {

    @Action
    fun toDeadPerson(
        userInput: UserInput,
        context: TransformationActionContext<UserInput, SnakeMeal>,
    ): SnakeMeal {
        return runAgent<UserInput, SnakeMeal>(evenMoreEvilWizard(), context)
    }

    @AchievesGoal(description = "Eating a person")
    @Action
    fun done(person: SnakeMeal): SnakeMeal {
        return person
    }
}

data class FrogOrDog(
    val frog: Frog? = null,
    val dog: Dog? = null,
) : SomeOf

@Agent(description = "thing")
class UsesFrogOrDogSomeOf {

    @Action
    fun frogOrDog(): FrogOrDog {
        return FrogOrDog(frog = Frog("Kermit"))
    }

    @AchievesGoal(description = "Creating a prince from a frog")
    @Action
    fun toPerson(frog: Frog): PersonWithReverseTool {
        return PersonWithReverseTool(frog.name)
    }

}

@Agent(description = "thing")
class GetsFromBlackboard {

    @Action(post = ["done"])
    fun frog(): Frog {
        return Frog("Kermit")
    }

    @Condition
    fun done(context: OperationContext): Boolean {
        return context.last(Frog::class.java) != null
    }

    @AchievesGoal(description = "Creating a prince from a frog")
    @Action(pre = ["done"])
    fun toPerson(
        context: OperationContext,
    ): PersonWithReverseTool {
        // Would be better to declare a Frog parameter but that's not what we are testing
        val frog = context.last<Frog>()!!
        return PersonWithReverseTool(frog.name)
    }

}

data class Prince(val name: String)

@Agent(description = "thing")
class MostSpecificPath {

    var frogsCreatedFromScratch = 0

    @Action
    fun makeFrogFromScratch(): Frog {
        frogsCreatedFromScratch += 1
        return Frog("Kermit")
    }

    @Action
    fun makeFrogFromPerson(userInput: UserInput): Frog {
        return Frog(userInput.content)
    }

    @AchievesGoal(description = "Creating a prince from a frog")
    @Action
    fun createPrince(
        frog: Frog,
    ) = Prince(frog.name)

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/annotation/support/typesWithInheritance.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.annotation.support

import com.embabel.agent.api.annotation.AchievesGoal
import com.embabel.agent.api.annotation.Action
import com.embabel.agent.api.annotation.Agent
import com.embabel.agent.api.annotation.Condition
import com.embabel.agent.api.common.OperationContext
import com.embabel.agent.api.dsl.Frog
import com.embabel.agent.core.last

interface GetFromBlackboardInterfaceSuperAction {

    @Action(post = ["done"])
    fun frog(): Frog {
        return Frog("Kermit")
    }
}

@Agent(description = "thing")
class GetsFromBlackboardInheritedInterfaceAction : GetFromBlackboardInterfaceSuperAction {

    @Condition
    fun done(context: OperationContext): Boolean {
        return context.last(Frog::class.java) != null
    }

    @AchievesGoal(description = "Creating a prince from a frog")
    @Action(pre = ["done"])
    fun toPerson(
        context: OperationContext,
    ): PersonWithReverseTool {
        // Would be better to declare a Frog parameter but that's not what we are testing
        val frog = context.last<Frog>()!!
        return PersonWithReverseTool(frog.name)
    }

}

interface GetFromBlackboardInterfaceSuperActionOverride {

    @Action(post = ["done"])
    fun frog(): Frog
}

@Agent(description = "thing")
class GetsFromBlackboardInheritedInterfaceActionOverride : GetFromBlackboardInterfaceSuperActionOverride {

    override fun frog(): Frog {
        return Frog("Kermit")
    }

    @Condition
    fun done(context: OperationContext): Boolean {
        return context.last(Frog::class.java) != null
    }

    @AchievesGoal(description = "Creating a prince from a frog")
    @Action(pre = ["done"])
    fun toPerson(
        context: OperationContext,
    ): PersonWithReverseTool {
        // Would be better to declare a Frog parameter but that's not what we are testing
        val frog = context.last<Frog>()!!
        return PersonWithReverseTool(frog.name)
    }

}

abstract class GetFromBlackboardClassSuperAction {

    @Action(post = ["done"])
    fun frog(): Frog {
        return Frog("Kermit")
    }
}

@Agent(description = "thing")
class GetsFromBlackboardInheritedClassAction : GetFromBlackboardClassSuperAction() {

    @Condition
    fun done(context: OperationContext): Boolean {
        return context.last(Frog::class.java) != null
    }

    @AchievesGoal(description = "Creating a prince from a frog")
    @Action(pre = ["done"])
    fun toPerson(
        context: OperationContext,
    ): PersonWithReverseTool {
        // Would be better to declare a Frog parameter but that's not what we are testing
        val frog = context.last<Frog>()!!
        return PersonWithReverseTool(frog.name)
    }

}

abstract class GetFromBlackboardClassSuperActionOverride {

    @Action(post = ["done"])
    abstract fun frog(): Frog
}

@Agent(description = "thing")
class GetsFromBlackboardInheritedClassActionOverride : GetFromBlackboardClassSuperActionOverride() {

    override fun frog(): Frog {
        return Frog("Kermit")
    }

    @Condition
    fun done(context: OperationContext): Boolean {
        return context.last(Frog::class.java) != null
    }

    @AchievesGoal(description = "Creating a prince from a frog")
    @Action(pre = ["done"])
    fun toPerson(
        context: OperationContext,
    ): PersonWithReverseTool {
        // Would be better to declare a Frog parameter but that's not what we are testing
        val frog = context.last<Frog>()!!
        return PersonWithReverseTool(frog.name)
    }

}

interface GetGoalFromBlackboardInterfaceSuperAction {

    @Action(post = ["done"])
    fun frog(): Frog {
        return Frog("Kermit")
    }

    @AchievesGoal(description = "Creating a prince from a frog")
    @Action(pre = ["done"])
    fun toPerson(
        context: OperationContext,
    ): PersonWithReverseTool {
        // Would be better to declare a Frog parameter but that's not what we are testing
        val frog = context.last<Frog>()!!
        return PersonWithReverseTool(frog.name)
    }
}

@Agent(description = "thing")
class GetsGoalFromBlackboardInheritedInterfaceAction : GetGoalFromBlackboardInterfaceSuperAction {

    @Condition
    fun done(context: OperationContext): Boolean {
        return context.last(Frog::class.java) != null
    }

}

abstract class GetGoalFromBlackboardClassSuperAction {

    @Action(post = ["done"])
    fun frog(): Frog {
        return Frog("Kermit")
    }

    @AchievesGoal(description = "Creating a prince from a frog")
    @Action(pre = ["done"])
    fun toPerson(
        context: OperationContext,
    ): PersonWithReverseTool {
        // Would be better to declare a Frog parameter but that's not what we are testing
        val frog = context.last<Frog>()!!
        return PersonWithReverseTool(frog.name)
    }
}

@Agent(description = "thing")
class GetsGoalFromBlackboardInheritedClassAction : GetGoalFromBlackboardClassSuperAction() {

    @Condition
    fun done(context: OperationContext): Boolean {
        return context.last(Frog::class.java) != null
    }

}


interface GetConditionFromBlackboardInterfaceSuperAction {

    @Condition
    fun done(context: OperationContext): Boolean {
        return context.last(Frog::class.java) != null
    }

}

@Agent(description = "thing")
class GetsConditionFromBlackboardInheritedInterfaceAction : GetConditionFromBlackboardInterfaceSuperAction {

    @Action(post = ["done"])
    fun frog(): Frog {
        return Frog("Kermit")
    }

    @AchievesGoal(description = "Creating a prince from a frog")
    @Action(pre = ["done"])
    fun toPerson(
        context: OperationContext,
    ): PersonWithReverseTool {
        // Would be better to declare a Frog parameter but that's not what we are testing
        val frog = context.last<Frog>()!!
        return PersonWithReverseTool(frog.name)
    }

}

abstract class GetConditionFromBlackboardClassSuperAction {

    @Condition
    fun done(context: OperationContext): Boolean {
        return context.last(Frog::class.java) != null
    }

}

@Agent(description = "thing")
class GetsConditionFromBlackboardInheritedClassAction : GetConditionFromBlackboardClassSuperAction() {

    @Action(post = ["done"])
    fun frog(): Frog {
        return Frog("Kermit")
    }

    @AchievesGoal(description = "Creating a prince from a frog")
    @Action(pre = ["done"])
    fun toPerson(
        context: OperationContext,
    ): PersonWithReverseTool {
        // Would be better to declare a Frog parameter but that's not what we are testing
        val frog = context.last<Frog>()!!
        return PersonWithReverseTool(frog.name)
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/common/MulticastStuckHandlerTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common

import com.embabel.agent.core.AgentProcess
import io.mockk.*
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import java.time.Instant

class MulticastStuckHandlerTest {

    private lateinit var mockAgentProcess: AgentProcess
    private lateinit var mockStuckHandler1: StuckHandler
    private lateinit var mockStuckHandler2: StuckHandler
    private lateinit var mockStuckHandler3: StuckHandler

    @BeforeEach
    fun setUp() {
        mockAgentProcess = mockk(relaxed = true)
        mockStuckHandler1 = mockk(relaxed = true)
        mockStuckHandler2 = mockk(relaxed = true)
        mockStuckHandler3 = mockk(relaxed = true)

        // Set up basic agent process properties that might be needed
        every { mockAgentProcess.id } returns "test-process-123"
        every { mockAgentProcess.toString() } returns "AgentProcess(id=test-process-123)"
    }

    @Nested
    inner class StuckHandlerResultTests {

        @Test
        fun `should create StuckHandlerResult with all properties`() {
            val message = "Test resolution message"
            val handler = mockStuckHandler1
            val code = StuckHandlingResultCode.REPLAN

            val result = StuckHandlerResult(message, handler, code, mockAgentProcess)

            assertEquals(message, result.message)
            assertEquals(handler, result.handler)
            assertEquals(code, result.code)
            assertEquals(mockAgentProcess, result.agentProcess)
            assertNotNull(result.timestamp)
        }

        @Test
        fun `should create StuckHandlerResult with null handler`() {
            val message = "No resolution found"
            val code = StuckHandlingResultCode.NO_RESOLUTION

            val result = StuckHandlerResult(message, null, code, mockAgentProcess)

            assertEquals(message, result.message)
            assertNull(result.handler)
            assertEquals(code, result.code)
            assertEquals(mockAgentProcess, result.agentProcess)
        }

        @Test
        fun `should extend AbstractAgentProcessEvent correctly`() {
            val result = StuckHandlerResult("Test", null, StuckHandlingResultCode.REPLAN, mockAgentProcess)

            assertEquals("test-process-123", result.processId)
            assertTrue(result.timestamp.isBefore(Instant.now().plusSeconds(1)))
            assertTrue(result.timestamp.isAfter(Instant.now().minusSeconds(1)))
        }
    }

    @Nested
    inner class StuckHandlingResultCodeTests {

        @Test
        fun `should have correct enum values`() {
            val values = StuckHandlingResultCode.values()

            assertEquals(2, values.size)
            assertTrue(values.contains(StuckHandlingResultCode.REPLAN))
            assertTrue(values.contains(StuckHandlingResultCode.NO_RESOLUTION))
        }

        @Test
        fun `should support enum operations`() {
            assertEquals("REPLAN", StuckHandlingResultCode.REPLAN.name)
            assertEquals("NO_RESOLUTION", StuckHandlingResultCode.NO_RESOLUTION.name)
            assertEquals(StuckHandlingResultCode.REPLAN, StuckHandlingResultCode.valueOf("REPLAN"))
            assertEquals(StuckHandlingResultCode.NO_RESOLUTION, StuckHandlingResultCode.valueOf("NO_RESOLUTION"))
        }
    }

    @Nested
    inner class StuckHandlerCompanionTests {

        @Test
        fun `should create MulticastStuckHandler with single handler`() {
            val handler = StuckHandler.invoke(mockStuckHandler1)

            assertTrue(handler is MulticastStuckHandler)
        }

        @Test
        fun `should create MulticastStuckHandler with multiple handlers`() {
            val handler = StuckHandler.invoke(mockStuckHandler1, mockStuckHandler2, mockStuckHandler3)

            assertTrue(handler is MulticastStuckHandler)
        }

        @Test
        fun `should create MulticastStuckHandler with empty handlers`() {
            val handler = StuckHandler.invoke()

            assertTrue(handler is MulticastStuckHandler)
        }
    }

    @Nested
    inner class MulticastStuckHandlerConstructorTests {

        @Test
        fun `should create handler with list of handlers`() {
            val handlers = listOf(mockStuckHandler1, mockStuckHandler2)
            val multicastHandler = MulticastStuckHandler(handlers)

            assertNotNull(multicastHandler)
        }

        @Test
        fun `should create handler with empty list`() {
            val multicastHandler = MulticastStuckHandler(emptyList())

            assertNotNull(multicastHandler)
        }

        @Test
        fun `should create handler with single handler in list`() {
            val multicastHandler = MulticastStuckHandler(listOf(mockStuckHandler1))

            assertNotNull(multicastHandler)
        }
    }

    @Nested
    inner class MulticastHandlerExecutionTests {

        @Test
        fun `should return first successful resolution`() {
            val successResult = StuckHandlerResult("Success!", mockStuckHandler1, StuckHandlingResultCode.REPLAN, mockAgentProcess)
            every { mockStuckHandler1.handleStuck(mockAgentProcess) } returns successResult

            val multicastHandler = MulticastStuckHandler(listOf(mockStuckHandler1, mockStuckHandler2))
            val result = multicastHandler.handleStuck(mockAgentProcess)

            assertEquals(successResult, result)
            assertEquals("Success!", result.message)
            assertEquals(StuckHandlingResultCode.REPLAN, result.code)
            assertEquals(mockStuckHandler1, result.handler)

            verify(exactly = 1) { mockStuckHandler1.handleStuck(mockAgentProcess) }
            verify(exactly = 0) { mockStuckHandler2.handleStuck(mockAgentProcess) }
        }

        @Test
        fun `should try second handler if first fails`() {
            val noResolutionResult1 = StuckHandlerResult("No resolution 1", mockStuckHandler1, StuckHandlingResultCode.NO_RESOLUTION, mockAgentProcess)
            val successResult2 = StuckHandlerResult("Success from handler 2", mockStuckHandler2, StuckHandlingResultCode.REPLAN, mockAgentProcess)

            every { mockStuckHandler1.handleStuck(mockAgentProcess) } returns noResolutionResult1
            every { mockStuckHandler2.handleStuck(mockAgentProcess) } returns successResult2

            val multicastHandler = MulticastStuckHandler(listOf(mockStuckHandler1, mockStuckHandler2))
            val result = multicastHandler.handleStuck(mockAgentProcess)

            assertEquals(successResult2, result)
            assertEquals("Success from handler 2", result.message)
            assertEquals(StuckHandlingResultCode.REPLAN, result.code)
            assertEquals(mockStuckHandler2, result.handler)

            verify(exactly = 1) { mockStuckHandler1.handleStuck(mockAgentProcess) }
            verify(exactly = 1) { mockStuckHandler2.handleStuck(mockAgentProcess) }
        }

        @Test
        fun `should try all handlers in order until success`() {
            val noResolutionResult1 = StuckHandlerResult("No resolution 1", mockStuckHandler1, StuckHandlingResultCode.NO_RESOLUTION, mockAgentProcess)
            val noResolutionResult2 = StuckHandlerResult("No resolution 2", mockStuckHandler2, StuckHandlingResultCode.NO_RESOLUTION, mockAgentProcess)
            val successResult3 = StuckHandlerResult("Success from handler 3", mockStuckHandler3, StuckHandlingResultCode.REPLAN, mockAgentProcess)

            every { mockStuckHandler1.handleStuck(mockAgentProcess) } returns noResolutionResult1
            every { mockStuckHandler2.handleStuck(mockAgentProcess) } returns noResolutionResult2
            every { mockStuckHandler3.handleStuck(mockAgentProcess) } returns successResult3

            val multicastHandler = MulticastStuckHandler(listOf(mockStuckHandler1, mockStuckHandler2, mockStuckHandler3))
            val result = multicastHandler.handleStuck(mockAgentProcess)

            assertEquals(successResult3, result)
            assertEquals("Success from handler 3", result.message)
            assertEquals(StuckHandlingResultCode.REPLAN, result.code)
            assertEquals(mockStuckHandler3, result.handler)

            verify(exactly = 1) { mockStuckHandler1.handleStuck(mockAgentProcess) }
            verify(exactly = 1) { mockStuckHandler2.handleStuck(mockAgentProcess) }
            verify(exactly = 1) { mockStuckHandler3.handleStuck(mockAgentProcess) }
        }

        @Test
        fun `should return NO_RESOLUTION when all handlers fail`() {
            val noResolutionResult1 = StuckHandlerResult("No resolution 1", mockStuckHandler1, StuckHandlingResultCode.NO_RESOLUTION, mockAgentProcess)
            val noResolutionResult2 = StuckHandlerResult("No resolution 2", mockStuckHandler2, StuckHandlingResultCode.NO_RESOLUTION, mockAgentProcess)

            every { mockStuckHandler1.handleStuck(mockAgentProcess) } returns noResolutionResult1
            every { mockStuckHandler2.handleStuck(mockAgentProcess) } returns noResolutionResult2

            val multicastHandler = MulticastStuckHandler(listOf(mockStuckHandler1, mockStuckHandler2))
            val result = multicastHandler.handleStuck(mockAgentProcess)

            assertEquals(StuckHandlingResultCode.NO_RESOLUTION, result.code)
            assertNull(result.handler)
            assertTrue(result.message.contains("No stuck handler could resolve the issue"))
            assertTrue(result.message.contains(mockStuckHandler1::class.java.name))
            assertTrue(result.message.contains(mockStuckHandler2::class.java.name))
            assertEquals(mockAgentProcess, result.agentProcess)

            verify(exactly = 1) { mockStuckHandler1.handleStuck(mockAgentProcess) }
            verify(exactly = 1) { mockStuckHandler2.handleStuck(mockAgentProcess) }
        }

        @Test
        fun `should handle empty handlers list`() {
            val multicastHandler = MulticastStuckHandler(emptyList())
            val result = multicastHandler.handleStuck(mockAgentProcess)

            assertEquals(StuckHandlingResultCode.NO_RESOLUTION, result.code)
            assertNull(result.handler)
            assertTrue(result.message.contains("No stuck handler could resolve the issue"))
            assertEquals(mockAgentProcess, result.agentProcess)
        }
    }

    @Nested
    inner class ErrorHandlingTests {

        @Test
        fun `should handle exception from handler gracefully`() {
            every { mockStuckHandler1.handleStuck(mockAgentProcess) } throws RuntimeException("Handler failed")

            val multicastHandler = MulticastStuckHandler(listOf(mockStuckHandler1))

            val exception = assertThrows(RuntimeException::class.java) {
                multicastHandler.handleStuck(mockAgentProcess)
            }

            assertEquals("Handler failed", exception.message)
            verify(exactly = 1) { mockStuckHandler1.handleStuck(mockAgentProcess) }
        }

        @Test
        fun `should continue to next handler if one throws exception`() {
            val successResult2 = StuckHandlerResult("Success from handler 2", mockStuckHandler2, StuckHandlingResultCode.REPLAN, mockAgentProcess)

            every { mockStuckHandler1.handleStuck(mockAgentProcess) } throws RuntimeException("Handler 1 failed")
            every { mockStuckHandler2.handleStuck(mockAgentProcess) } returns successResult2

            val multicastHandler = MulticastStuckHandler(listOf(mockStuckHandler1, mockStuckHandler2))

            // The current implementation doesn't handle exceptions, so this will throw
            assertThrows(RuntimeException::class.java) {
                multicastHandler.handleStuck(mockAgentProcess)
            }

            verify(exactly = 1) { mockStuckHandler1.handleStuck(mockAgentProcess) }
            // Handler 2 won't be called because handler 1 threw an exception
        }
    }

    @Nested
    inner class IntegrationTests {

        @Test
        fun `should work with real handler implementations`() {
            val realHandler1 = object : StuckHandler {
                override fun handleStuck(agentProcess: AgentProcess): StuckHandlerResult {
                    return StuckHandlerResult("Real handler resolution", this, StuckHandlingResultCode.REPLAN, agentProcess)
                }
            }

            val realHandler2 = object : StuckHandler {
                override fun handleStuck(agentProcess: AgentProcess): StuckHandlerResult {
                    return StuckHandlerResult("Backup handler resolution", this, StuckHandlingResultCode.NO_RESOLUTION, agentProcess)
                }
            }

            val multicastHandler = MulticastStuckHandler(listOf(realHandler1, realHandler2))
            val result = multicastHandler.handleStuck(mockAgentProcess)

            assertEquals("Real handler resolution", result.message)
            assertEquals(StuckHandlingResultCode.REPLAN, result.code)
            assertEquals(realHandler1, result.handler)
        }

        @Test
        fun `should work with companion object factory method`() {
            val successResult = StuckHandlerResult("Success!", mockStuckHandler1, StuckHandlingResultCode.REPLAN, mockAgentProcess)
            every { mockStuckHandler1.handleStuck(mockAgentProcess) } returns successResult

            val compositeHandler = StuckHandler(mockStuckHandler1, mockStuckHandler2)
            val result = compositeHandler.handleStuck(mockAgentProcess)

            assertEquals(successResult, result)
            verify(exactly = 1) { mockStuckHandler1.handleStuck(mockAgentProcess) }
            verify(exactly = 0) { mockStuckHandler2.handleStuck(mockAgentProcess) }
        }
    }

    @Nested
    inner class EdgeCaseTests {

        @Test
        fun `should handle single handler that succeeds`() {
            val successResult = StuckHandlerResult("Single handler success", mockStuckHandler1, StuckHandlingResultCode.REPLAN, mockAgentProcess)
            every { mockStuckHandler1.handleStuck(mockAgentProcess) } returns successResult

            val multicastHandler = MulticastStuckHandler(listOf(mockStuckHandler1))
            val result = multicastHandler.handleStuck(mockAgentProcess)

            assertEquals(successResult, result)
            verify(exactly = 1) { mockStuckHandler1.handleStuck(mockAgentProcess) }
        }

        @Test
        fun `should handle single handler that fails`() {
            val noResolutionResult = StuckHandlerResult("Single handler failed", mockStuckHandler1, StuckHandlingResultCode.NO_RESOLUTION, mockAgentProcess)
            every { mockStuckHandler1.handleStuck(mockAgentProcess) } returns noResolutionResult

            val multicastHandler = MulticastStuckHandler(listOf(mockStuckHandler1))
            val result = multicastHandler.handleStuck(mockAgentProcess)

            assertEquals(StuckHandlingResultCode.NO_RESOLUTION, result.code)
            assertNull(result.handler)
            assertTrue(result.message.contains("No stuck handler could resolve the issue"))
            assertTrue(result.message.contains(mockStuckHandler1::class.java.name))

            verify(exactly = 1) { mockStuckHandler1.handleStuck(mockAgentProcess) }
        }

        @Test
        fun `should handle duplicate handlers in list`() {
            val successResult = StuckHandlerResult("Success!", mockStuckHandler1, StuckHandlingResultCode.REPLAN, mockAgentProcess)
            every { mockStuckHandler1.handleStuck(mockAgentProcess) } returns successResult

            val multicastHandler = MulticastStuckHandler(listOf(mockStuckHandler1, mockStuckHandler1))
            val result = multicastHandler.handleStuck(mockAgentProcess)

            assertEquals(successResult, result)
            verify(exactly = 1) { mockStuckHandler1.handleStuck(mockAgentProcess) }
        }
    }

    @Nested
    inner class MessageFormattingTests {

        @Test
        fun `should format failure message correctly with multiple handlers`() {
            val noResolutionResult1 = StuckHandlerResult("No resolution 1", mockStuckHandler1, StuckHandlingResultCode.NO_RESOLUTION, mockAgentProcess)
            val noResolutionResult2 = StuckHandlerResult("No resolution 2", mockStuckHandler2, StuckHandlingResultCode.NO_RESOLUTION, mockAgentProcess)

            every { mockStuckHandler1.handleStuck(mockAgentProcess) } returns noResolutionResult1
            every { mockStuckHandler2.handleStuck(mockAgentProcess) } returns noResolutionResult2

            val multicastHandler = MulticastStuckHandler(listOf(mockStuckHandler1, mockStuckHandler2))
            val result = multicastHandler.handleStuck(mockAgentProcess)

            assertTrue(result.message.startsWith("No stuck handler could resolve the issue: Tried "))
            assertTrue(result.message.contains(mockStuckHandler1::class.java.name))
            assertTrue(result.message.contains(mockStuckHandler2::class.java.name))
        }

        @Test
        fun `should format failure message correctly with empty handlers`() {
            val multicastHandler = MulticastStuckHandler(emptyList())
            val result = multicastHandler.handleStuck(mockAgentProcess)

            assertEquals("No stuck handler could resolve the issue: Tried ", result.message)
        }

        @Test
        fun `should format failure message correctly with single handler`() {
            val noResolutionResult = StuckHandlerResult("No resolution", mockStuckHandler1, StuckHandlingResultCode.NO_RESOLUTION, mockAgentProcess)
            every { mockStuckHandler1.handleStuck(mockAgentProcess) } returns noResolutionResult

            val multicastHandler = MulticastStuckHandler(listOf(mockStuckHandler1))
            val result = multicastHandler.handleStuck(mockAgentProcess)

            assertTrue(result.message.contains("No stuck handler could resolve the issue: Tried "))
            assertTrue(result.message.contains(mockStuckHandler1::class.java.name))
        }
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/common/OperationContextAiTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common

import com.embabel.agent.core.AgentPlatform
import com.embabel.agent.core.Operation
import com.embabel.agent.core.ProcessContext
import com.embabel.common.ai.model.*
import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.springframework.ai.embedding.EmbeddingModel

class OperationContextAiTest {

    private fun createMockOperationContext(): OperationContext {
        val mockContext = mockk<OperationContext>()
        val mockProcessContext = mockk<ProcessContext>()
        val mockPlatformServices = mockk<PlatformServices>()
        val mockAgentPlatform = mockk<AgentPlatform>()
        val mockOperation = mockk<Operation>()

        every { mockContext.processContext } returns mockProcessContext
        every { mockContext.operation } returns mockOperation
        every { mockProcessContext.platformServices } returns mockPlatformServices
        every { mockPlatformServices.agentPlatform } returns mockAgentPlatform

        return mockContext
    }

    private fun createOperationContextAi(context: OperationContext = createMockOperationContext()): Ai {
        return OperationContextAi(context)
    }

    @Nested
    inner class EmbeddingModelTests {

        @Test
        fun `test withEmbeddingModel with criteria`() {
            val mockContext = createMockOperationContext()
            val mockModelProvider = mockk<ModelProvider>()
            val mockEmbeddingService = mockk<EmbeddingService>()
            val mockEmbeddingModel = mockk<EmbeddingModel>()
            val criteria = ModelSelectionCriteria.byName("test-embedding-model")

            every { mockContext.processContext.platformServices.modelProvider() } returns mockModelProvider
            every { mockModelProvider.getEmbeddingService(criteria) } returns mockEmbeddingService
            every { mockEmbeddingService.model } returns mockEmbeddingModel

            val ai = createOperationContextAi(mockContext)
            val result = ai.withEmbeddingModel(criteria)

            assertEquals(mockEmbeddingModel, result, "Embedding model not returned correctly")
            verify { mockModelProvider.getEmbeddingService(criteria) }
        }

        @Test
        fun `test withEmbeddingModel with string model name`() {
            val mockContext = createMockOperationContext()
            val mockModelProvider = mockk<ModelProvider>()
            val mockEmbeddingService = mockk<EmbeddingService>()
            val mockEmbeddingModel = mockk<EmbeddingModel>()
            val modelName = "test-embedding-model"

            every { mockContext.processContext.platformServices.modelProvider() } returns mockModelProvider
            every { mockModelProvider.getEmbeddingService(any()) } returns mockEmbeddingService
            every { mockEmbeddingService.model } returns mockEmbeddingModel

            val ai = createOperationContextAi(mockContext)
            val result = ai.withEmbeddingModel(modelName)

            assertEquals(mockEmbeddingModel, result, "Embedding model not returned correctly")
            verify {
                mockModelProvider.getEmbeddingService(any())
            }
        }

        @Test
        fun `test withDefaultEmbeddingModel`() {
            val mockContext = createMockOperationContext()
            val mockModelProvider = mockk<ModelProvider>()
            val mockEmbeddingService = mockk<EmbeddingService>()
            val mockEmbeddingModel = mockk<EmbeddingModel>()

            every { mockContext.processContext.platformServices.modelProvider() } returns mockModelProvider
            every { mockModelProvider.getEmbeddingService(DefaultModelSelectionCriteria) } returns mockEmbeddingService
            every { mockEmbeddingService.model } returns mockEmbeddingModel

            val ai = createOperationContextAi(mockContext)
            val result = ai.withDefaultEmbeddingModel()

            assertEquals(mockEmbeddingModel, result, "Default embedding model not returned correctly")
            verify { mockModelProvider.getEmbeddingService(DefaultModelSelectionCriteria) }
        }
    }

    @Nested
    inner class LlmTests {

        @Test
        fun `test withLlm with LlmOptions`() {
            val mockContext = createMockOperationContext()
            val mockPromptRunner = mockk<PromptRunner>()
            val mockModifiedPromptRunner = mockk<PromptRunner>()
            val llmOptions = LlmOptions.withModel("test-model").withTemperature(0.8)

            every { mockContext.promptRunner() } returns mockPromptRunner
            every { mockPromptRunner.withLlm(llmOptions) } returns mockModifiedPromptRunner

            val ai = createOperationContextAi(mockContext)
            val result = ai.withLlm(llmOptions)

            assertEquals(mockModifiedPromptRunner, result, "Prompt runner with LLM options not returned correctly")
            verify { mockContext.promptRunner() }
            verify { mockPromptRunner.withLlm(llmOptions) }
        }

        @Test
        fun `test withLlm with string model name`() {
            val mockContext = createMockOperationContext()
            val mockPromptRunner = mockk<PromptRunner>()
            val mockModifiedPromptRunner = mockk<PromptRunner>()
            val modelName = "gpt-4"

            every { mockContext.promptRunner() } returns mockPromptRunner
            every { mockPromptRunner.withLlm(any<LlmOptions>()) } returns mockModifiedPromptRunner

            val ai = createOperationContextAi(mockContext)
            val result = ai.withLlm(modelName)

            assertEquals(mockModifiedPromptRunner, result, "Prompt runner with model name not returned correctly")
            verify { mockContext.promptRunner() }
            verify {
                mockPromptRunner.withLlm(match<LlmOptions> {
                    it.model == modelName
                })
            }
        }

        @Test
        fun `test withLlmByRole`() {
            val mockContext = createMockOperationContext()
            val mockPromptRunner = mockk<PromptRunner>()
            val mockModifiedPromptRunner = mockk<PromptRunner>()
            val role = "summarization"

            every { mockContext.promptRunner() } returns mockPromptRunner
            every { mockPromptRunner.withLlm(any<LlmOptions>()) } returns mockModifiedPromptRunner

            val ai = createOperationContextAi(mockContext)
            val result = ai.withLlmByRole(role)

            assertEquals(mockModifiedPromptRunner, result, "Prompt runner with LLM role not returned correctly")
            verify { mockContext.promptRunner() }
            verify {
                mockPromptRunner.withLlm(any<LlmOptions>())
            }
        }

        @Test
        fun `test withAutoLlm`() {
            val mockContext = createMockOperationContext()
            val mockPromptRunner = mockk<PromptRunner>()
            val mockModifiedPromptRunner = mockk<PromptRunner>()

            every { mockContext.promptRunner() } returns mockPromptRunner
            every { mockPromptRunner.withLlm(any<LlmOptions>()) } returns mockModifiedPromptRunner

            val ai = createOperationContextAi(mockContext)
            val result = ai.withAutoLlm()

            assertEquals(mockModifiedPromptRunner, result, "Prompt runner with auto LLM not returned correctly")
            verify { mockContext.promptRunner() }
            verify {
                mockPromptRunner.withLlm(match<LlmOptions> {
                    it.criteria == AutoModelSelectionCriteria
                })
            }
        }

        @Test
        fun `test withDefaultLlm`() {
            val mockContext = createMockOperationContext()
            val mockPromptRunner = mockk<PromptRunner>()
            val mockModifiedPromptRunner = mockk<PromptRunner>()

            every { mockContext.promptRunner() } returns mockPromptRunner
            every { mockPromptRunner.withLlm(any<LlmOptions>()) } returns mockModifiedPromptRunner

            val ai = createOperationContextAi(mockContext)
            val result = ai.withDefaultLlm()

            assertEquals(mockModifiedPromptRunner, result, "Prompt runner with default LLM not returned correctly")
            verify { mockContext.promptRunner() }
            verify {
                mockPromptRunner.withLlm(match<LlmOptions> {
                    it.criteria == DefaultModelSelectionCriteria
                })
            }
        }

        @Test
        fun `test withFirstAvailableLlmOf with single model`() {
            val mockContext = createMockOperationContext()
            val mockPromptRunner = mockk<PromptRunner>()
            val mockModifiedPromptRunner = mockk<PromptRunner>()
            val modelName = "gpt-4"

            every { mockContext.promptRunner() } returns mockPromptRunner
            every { mockPromptRunner.withLlm(any<LlmOptions>()) } returns mockModifiedPromptRunner

            val ai = createOperationContextAi(mockContext)
            val result = ai.withFirstAvailableLlmOf(modelName)

            assertEquals(
                mockModifiedPromptRunner,
                result,
                "Prompt runner with first available LLM not returned correctly"
            )
            verify { mockContext.promptRunner() }
            verify {
                mockPromptRunner.withLlm(any<LlmOptions>())
            }
        }

        @Test
        fun `test withFirstAvailableLlmOf with multiple models`() {
            val mockContext = createMockOperationContext()
            val mockPromptRunner = mockk<PromptRunner>()
            val mockModifiedPromptRunner = mockk<PromptRunner>()
            val models = arrayOf("gpt-4", "gpt-3.5-turbo", "claude-3")

            every { mockContext.promptRunner() } returns mockPromptRunner
            every { mockPromptRunner.withLlm(any<LlmOptions>()) } returns mockModifiedPromptRunner

            val ai = createOperationContextAi(mockContext)
            val result = ai.withFirstAvailableLlmOf(*models)

            assertEquals(
                mockModifiedPromptRunner,
                result,
                "Prompt runner with first available LLM not returned correctly"
            )
            verify { mockContext.promptRunner() }
            verify {
                mockPromptRunner.withLlm(any<LlmOptions>())
            }
        }

        @Test
        fun `test withFirstAvailableLlmOf with empty varargs`() {
            val mockContext = createMockOperationContext()
            val mockPromptRunner = mockk<PromptRunner>()
            val mockModifiedPromptRunner = mockk<PromptRunner>()

            every { mockContext.promptRunner() } returns mockPromptRunner
            every { mockPromptRunner.withLlm(any<LlmOptions>()) } returns mockModifiedPromptRunner

            val ai = createOperationContextAi(mockContext)
            val result = ai.withFirstAvailableLlmOf()

            assertEquals(
                mockModifiedPromptRunner,
                result,
                "Prompt runner with empty fallback list not returned correctly"
            )
            verify { mockContext.promptRunner() }
            verify {
                mockPromptRunner.withLlm(any<LlmOptions>())
            }
        }
    }

    @Nested
    inner class IntegrationTests {

        @Test
        fun `test OperationContextAi is created correctly by OperationContext`() {
            val mockContext = createMockOperationContext()
            every { mockContext.ai() } returns OperationContextAi(mockContext)

            val ai = mockContext.ai()

            assertNotNull(ai, "AI should not be null")
            assertTrue(ai is OperationContextAi, "AI should be instance of OperationContextAi")
        }

    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/common/OperationContextPromptRunnerTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common

import com.embabel.agent.api.annotation.support.Wumpus
import com.embabel.agent.api.common.support.OperationContextPromptRunner
import com.embabel.agent.core.Operation
import com.embabel.agent.experimental.primitive.Determination
import com.embabel.agent.support.Dog
import com.embabel.agent.testing.unit.FakeOperationContext
import com.embabel.chat.Message
import com.embabel.chat.UserMessage
import com.embabel.common.ai.model.LlmOptions
import com.embabel.common.util.StringTransformer
import io.mockk.every
import io.mockk.mockk
import io.mockk.slot
import io.mockk.spyk
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Disabled
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test

class OperationContextPromptRunnerTest {

    private fun createOperationContextPromptRunnerWithDefaults(context: OperationContext): OperationContextPromptRunner {
        return OperationContextPromptRunner(
            context = context,
            llm = LlmOptions(),
            toolGroups = emptySet(),
            toolObjects = emptyList(),
            promptContributors = emptyList(),
            contextualPromptContributors = emptyList(),
            generateExamples = false,
        )
    }

    @Nested
    inner class LlmOptionsTest {

        @Test
        fun `test change LlmOptions`() {
            val llm = LlmOptions.withModel("my-model").withTemperature(1.0)
            val ocpr = createOperationContextPromptRunnerWithDefaults(mockk<OperationContext>())
                .withLlm(llm)
            assertEquals(llm, ocpr.llm, "LlmOptions not set correctly")
        }
    }

    @Nested
    inner class ToolObject {

        @Test
        fun `test toolObject instance`() {
            val llm = LlmOptions.withModel("my-model").withTemperature(1.0)
            val wumpus = Wumpus("wumpuses-have-tools")
            val ocpr = createOperationContextPromptRunnerWithDefaults(mockk<OperationContext>())
                .withLlm(llm)
                .withToolObject(wumpus)
            assertEquals(1, ocpr.toolObjects.size, "Must have one tool object")
            assertEquals(wumpus, ocpr.toolObjects[0].obj, "Tool object instance not set correctly")
            assertEquals(
                StringTransformer.IDENTITY,
                ocpr.toolObjects[0].namingStrategy,
                "Tool object naming strategy not set correctly"
            )
        }

        @Test
        fun `test ToolObject instance with custom naming strategy`() {
            val llm = LlmOptions.withModel("my-model").withTemperature(1.0)
            val wumpus = Wumpus("wumpuses-have-tools")
            val namingStrategy = StringTransformer { it.replace("_", " ") }
            val ocpr = createOperationContextPromptRunnerWithDefaults(mockk<OperationContext>())
                .withLlm(llm)
                .withToolObject(ToolObject(wumpus).withNamingStrategy(namingStrategy))
            assertEquals(1, ocpr.toolObjects.size, "Must have one tool object")
            assertEquals(wumpus, ocpr.toolObjects[0].obj, "Tool object instance not set correctly")
            assertEquals(
                namingStrategy,
                ocpr.toolObjects[0].namingStrategy,
                "Tool object naming strategy not set correctly"
            )
        }

    }

    @Nested
    inner class PromptElements {

        @Test
        @Disabled("test not implemented yet")
        fun `test contextual prompt contributors`() {
        }

        @Test
        @Disabled("test not implemented yet")
        fun `test withPromptElements`() {
        }
    }

    @Nested
    inner class SystemPrompt {

        @Test
        fun `test withSystemPrompt`() {
            val systemPrompt = "You are a helpful assistant specialized in testing."
            val ocpr = createOperationContextPromptRunnerWithDefaults(mockk<OperationContext>())
                .withSystemPrompt(systemPrompt)

            assertEquals(1, ocpr.promptContributors.size, "Must have one prompt contributor for system prompt")
            assertEquals(systemPrompt, ocpr.promptContributors[0].contribution(), "System prompt not set correctly")
        }

        @Test
        fun `test withSystemPrompt with empty string`() {
            val systemPrompt = ""
            val ocpr = createOperationContextPromptRunnerWithDefaults(mockk<OperationContext>())
                .withSystemPrompt(systemPrompt)

            assertEquals(1, ocpr.promptContributors.size, "Must have one prompt contributor for system prompt")
            assertEquals(
                systemPrompt,
                ocpr.promptContributors[0].contribution(),
                "Empty system prompt not handled correctly"
            )
        }

        @Test
        fun `test withSystemPrompt with multiline content`() {
            val systemPrompt = """
                You are a helpful assistant.
                You should always:
                1. Be polite
                2. Be accurate
                3. Be concise
            """.trimIndent()

            val ocpr = createOperationContextPromptRunnerWithDefaults(mockk<OperationContext>())
                .withSystemPrompt(systemPrompt)

            assertEquals(1, ocpr.promptContributors.size, "Must have one prompt contributor for system prompt")
            assertEquals(
                systemPrompt,
                ocpr.promptContributors[0].contribution(),
                "Multiline system prompt not set correctly"
            )
        }

        @Test
        fun `test chaining multiple withSystemPrompt calls`() {
            val systemPrompt1 = "First system prompt"
            val systemPrompt2 = "Second system prompt"

            val ocpr = createOperationContextPromptRunnerWithDefaults(mockk<OperationContext>())
                .withSystemPrompt(systemPrompt1)
                .withSystemPrompt(systemPrompt2)

            assertEquals(2, ocpr.promptContributors.size, "Must have two prompt contributors")
            assertTrue(
                ocpr.promptContributors.any { it.contribution() == systemPrompt1 },
                "First system prompt not found"
            )
            assertTrue(
                ocpr.promptContributors.any { it.contribution() == systemPrompt2 },
                "Second system prompt not found"
            )
        }

    }

    @Nested
    inner class ToolGroups {

        @Test
        fun `test withToolGroups with set of strings`() {
            val toolGroups = setOf("math", "file", "web")
            val ocpr = createOperationContextPromptRunnerWithDefaults(mockk<OperationContext>())
                .withToolGroups(toolGroups)

            assertEquals(3, ocpr.toolGroups.size, "Must have three tool groups")
            assertTrue(ocpr.toolGroups.any { it.role == "math" }, "Math tool group not found")
            assertTrue(ocpr.toolGroups.any { it.role == "file" }, "File tool group not found")
            assertTrue(ocpr.toolGroups.any { it.role == "web" }, "Web tool group not found")
        }

        @Test
        fun `test withToolGroups with empty set`() {
            val toolGroups = emptySet<String>()
            val ocpr = createOperationContextPromptRunnerWithDefaults(mockk<OperationContext>())
                .withToolGroups(toolGroups)

            assertEquals(0, ocpr.toolGroups.size, "Must have no tool groups")
        }

        @Test
        fun `test withTools with varargs`() {
            val ocpr = createOperationContextPromptRunnerWithDefaults(mockk<OperationContext>())
                .withTools("math", "file", "web")

            assertEquals(3, ocpr.toolGroups.size, "Must have three tool groups")
            assertTrue(ocpr.toolGroups.any { it.role == "math" }, "Math tool group not found")
            assertTrue(ocpr.toolGroups.any { it.role == "file" }, "File tool group not found")
            assertTrue(ocpr.toolGroups.any { it.role == "web" }, "Web tool group not found")
        }

        @Test
        fun `test withTools with no arguments`() {
            val ocpr = createOperationContextPromptRunnerWithDefaults(mockk<OperationContext>())
                .withTools()

            assertEquals(0, ocpr.toolGroups.size, "Must have no tool groups when no args provided")
        }

        @Test
        fun `test withToolGroup single string`() {
            val ocpr = createOperationContextPromptRunnerWithDefaults(mockk<OperationContext>())
                .withToolGroup("math")

            assertEquals(1, ocpr.toolGroups.size, "Must have one tool group")
            assertEquals("math", ocpr.toolGroups.first().role, "Tool group name not set correctly")
        }
    }


    @Nested

    inner class Conditions {
        @Test
        fun `test evaluateCondition`() {
            val mockOperationContext = mockk<OperationContext>()
            every { mockOperationContext.processContext } returns mockk()
            every { mockOperationContext.processContext.agentProcess } returns mockk()
            every {
                mockOperationContext.processContext.createObject(
                    any(),
                    any(),
                    Determination::class.java,
                    any(),
                    null
                )
            } answers {
                val messages = firstArg<List<Message>>()
                val prompt = (messages[0] as UserMessage).content
                assertTrue(prompt.contains("Evaluate this condition"), "Prompt didn't contain evaluate: $prompt")
                Determination(
                    result = true,
                    confidence = 0.8,
                    explanation = "Mocked explanation"
                )
            }
            every { mockOperationContext.operation } returns mockk<Operation>(relaxed = true)

            val runner = OperationContextPromptRunner(
                context = mockOperationContext,
                llm = LlmOptions(),
                toolGroups = emptySet(),
                toolObjects = emptyList(),
                promptContributors = emptyList(),
                contextualPromptContributors = emptyList(),
                generateExamples = false,
            )

            val result = runner.evaluateCondition("condition", "context", 0.5)
            assertTrue(result)
        }
    }

    @Nested
    inner class ObjectCreator {

        @Test
        fun `test no examples`() {
            val duke = Dog("Duke")
            val context = FakeOperationContext()
            val pr = spyk(createOperationContextPromptRunnerWithDefaults(context))
            val um = slot<List<Message>>()
            every { pr.createObject(capture(um), Dog::class.java) } returns duke
            val result = pr
                .creating(Dog::class.java)
                .fromPrompt("foo bar")
            assertEquals(duke, result, "Dog instance not returned correctly")
            assertEquals(1, um.captured.size, "Must be one message")
            assertEquals(um.captured[0].content, "foo bar", "Example not included in prompt")
        }

        @Test
        fun `test no examples preserves interaction id`() {
            val duke = Dog("Duke")
            val context = FakeOperationContext()
            val pr = spyk(createOperationContextPromptRunnerWithDefaults(context).withId("iid"))
            val um = slot<List<Message>>()
            every { pr.createObject(capture(um), Dog::class.java) } returns duke
            val result = pr
                .creating(Dog::class.java)
                .fromPrompt("foo bar")
            assertEquals(duke, result, "Dog instance not returned correctly")
            assertEquals(1, um.captured.size, "Must be one message")
            assertEquals(um.captured[0].content, "foo bar", "Example not included in prompt")
        }

        @Test
        fun `test example`() {
            val context = FakeOperationContext()
            val pr = spyk(createOperationContextPromptRunnerWithDefaults(context))
            val pr1 = (pr
                .creating(Dog::class.java)
                .withExample("Good dog", Dog("Duke")) as PromptRunnerObjectCreator).promptRunner
            assertEquals(1, pr1.promptContributors.size, "Must be one contributor")
            val eg = pr1.promptContributors[0].contribution()
            assertTrue(eg.contains("Duke"), "Should include example dog name")
            assertTrue(eg.contains("Good dog"), "Should include example description")
            assertTrue(eg.contains("{"), "Should include JSON")
        }
    }


    @Nested
    inner class WithReferences {

        @Test
        fun `test withReference`() {
            val mockReference = mockk<LlmReference>()
            every { mockReference.name } returns "TestAPI"
            every { mockReference.description } returns "Test API"
            every { mockReference.toolPrefix() } returns "testapi"
            every { mockReference.notes() } returns "Test API documentation"
            every { mockReference.contribution() } returns "Reference: TestAPI\nDescription: Test API\nTool prefix: testapi\nNotes: Test API documentation"
            every { mockReference.toolObject() } returns ToolObject(mockReference)

            val ocpr = createOperationContextPromptRunnerWithDefaults(mockk<OperationContext>())
                .withReference(mockReference)

            assertEquals(1, ocpr.toolObjects.size, "Must have one tool object for reference")
            assertEquals(mockReference, ocpr.toolObjects[0].obj, "Reference not set correctly as tool object")
            assertEquals(1, ocpr.promptContributors.size, "Must have one prompt contributor for reference")
            assertEquals(
                mockReference,
                ocpr.promptContributors[0],
                "Reference not set correctly as prompt contributor"
            )

            // Test that a naming strategy is set (actual behavior may vary)
            assertNotNull(ocpr.toolObjects[0].namingStrategy, "Naming strategy should not be null")
        }

        @Test
        fun `test withReference with special characters in name`() {
            val mockReference = mockk<LlmReference>()
            every { mockReference.name } returns "Test-API@v2!"
            every { mockReference.description } returns "Test API v2"
            every { mockReference.toolPrefix() } returns "test-api_v2_"
            every { mockReference.notes() } returns "Test API v2 documentation"
            every { mockReference.contribution() } returns "Reference: Test-API@v2!\nDescription: Test API v2\nTool prefix: test-api_v2_\nNotes: Test API v2 documentation"
            every { mockReference.toolObject() } returns ToolObject(mockReference)

            val ocpr = createOperationContextPromptRunnerWithDefaults(mockk<OperationContext>())
                .withReference(mockReference)

            assertEquals(1, ocpr.toolObjects.size, "Must have one tool object for reference")

            // Test that a naming strategy is set for special characters
            assertNotNull(
                ocpr.toolObjects[0].namingStrategy,
                "Naming strategy should not be null even with special characters"
            )
        }


        @Test
        fun `test withReferences with multiple references`() {
            val mockReference1 = mockk<LlmReference>()
            every { mockReference1.name } returns "API1"
            every { mockReference1.description } returns "API 1"
            every { mockReference1.toolPrefix() } returns "api1"
            every { mockReference1.notes() } returns "API 1 documentation"
            every { mockReference1.contribution() } returns "Reference: API1\nDescription: API 1\nTool prefix: api1\nNotes: API 1 documentation"
            every { mockReference1.toolObject() } returns ToolObject(mockReference1)

            val mockReference2 = mockk<LlmReference>()
            every { mockReference2.name } returns "API2"
            every { mockReference2.description } returns "API 2"
            every { mockReference2.toolPrefix() } returns "api2"
            every { mockReference2.notes() } returns "API 2 documentation"
            every { mockReference2.contribution() } returns "Reference: API2\nDescription: API 2\nTool prefix: api2\nNotes: API 2 documentation"
            every { mockReference2.toolObject() } returns ToolObject(mockReference2)

            val ocpr = createOperationContextPromptRunnerWithDefaults(mockk<OperationContext>())
                .withReferences(listOf(mockReference1, mockReference2))

            assertEquals(2, ocpr.toolObjects.size, "Must have two tool objects for references")
            assertEquals(2, ocpr.promptContributors.size, "Must have two prompt contributors for references")

            assertTrue(ocpr.toolObjects.any { it.obj == mockReference1 }, "Reference 1 not found in tool objects")
            assertTrue(ocpr.toolObjects.any { it.obj == mockReference2 }, "Reference 2 not found in tool objects")
            assertTrue(
                ocpr.promptContributors.contains(mockReference1),
                "Reference 1 not found in prompt contributors"
            )
            assertTrue(
                ocpr.promptContributors.contains(mockReference2),
                "Reference 2 not found in prompt contributors"
            )
        }

        @Test
        fun `test withReferences with varargs`() {
            val mockReference1 = mockk<LlmReference>()
            every { mockReference1.name } returns "API1"
            every { mockReference1.description } returns "API 1"
            every { mockReference1.toolPrefix() } returns "api1"
            every { mockReference1.notes() } returns "API 1 documentation"
            every { mockReference1.contribution() } returns "Reference: API1\nDescription: API 1\nTool prefix: api1\nNotes: API 1 documentation"
            every { mockReference1.toolObject() } returns ToolObject(mockReference1)

            val mockReference2 = mockk<LlmReference>()
            every { mockReference2.name } returns "API2"
            every { mockReference2.description } returns "API 2"
            every { mockReference2.toolPrefix() } returns "api2"
            every { mockReference2.notes() } returns "API 2 documentation"
            every { mockReference2.contribution() } returns "Reference: API2\nDescription: API 2\nTool prefix: api2\nNotes: API 2 documentation"
            every { mockReference2.toolObject() } returns ToolObject(mockReference2)

            val ocpr = createOperationContextPromptRunnerWithDefaults(mockk<OperationContext>())
                .withReferences(mockReference1, mockReference2)

            assertEquals(2, ocpr.toolObjects.size, "Must have two tool objects for references")
            assertEquals(2, ocpr.promptContributors.size, "Must have two prompt contributors for references")
        }

        @Test
        fun `test combining withReference and withSystemPrompt`() {
            val mockReference = mockk<LlmReference>()
            every { mockReference.name } returns "TestAPI"
            every { mockReference.description } returns "Test API"
            every { mockReference.toolPrefix() } returns "testapi"
            every { mockReference.notes() } returns "Test API documentation"
            every { mockReference.contribution() } returns "Reference: TestAPI\nDescription: Test API\nTool prefix: testapi\nNotes: Test API documentation"
            every { mockReference.toolObject() } returns ToolObject(mockReference)

            val systemPrompt = "You are a helpful assistant."

            val ocpr = createOperationContextPromptRunnerWithDefaults(mockk<OperationContext>())
                .withReference(mockReference)
                .withSystemPrompt(systemPrompt)

            assertEquals(1, ocpr.toolObjects.size, "Must have one tool object for reference")
            assertEquals(
                2,
                ocpr.promptContributors.size,
                "Must have two prompt contributors (reference + system prompt)"
            )
            assertTrue(
                ocpr.promptContributors.contains(mockReference),
                "Reference not found in prompt contributors"
            )
            assertTrue(
                ocpr.promptContributors.any { it.contribution() == systemPrompt },
                "System prompt not found in prompt contributors"
            )
        }
    }


    @Nested
    inner class WithPropertyFilter {

        @Test
        fun `test property filter`() {
            val pr = createOperationContextPromptRunnerWithDefaults(FakeOperationContext())
                .withPropertyFilter { it == "name" || it == "age" }

            assertTrue(pr.propertyFilter.test("name"))
            assertTrue(pr.propertyFilter.test("age"))
            assertFalse(pr.propertyFilter.test("email"))
        }

        @Test
        fun `test chain multiple property filters`() {
            val pr = createOperationContextPromptRunnerWithDefaults(FakeOperationContext())
                .withPropertyFilter { it == "name" || it == "age" || it == "email" }
                .withPropertyFilter { it != "email" }

            assertTrue(pr.propertyFilter.test("name"))
            assertTrue(pr.propertyFilter.test("age"))
            assertFalse(pr.propertyFilter.test("email"))
            assertFalse(pr.propertyFilter.test("address"))
        }

        @Test
        fun `test default filter`() {
            val pr = createOperationContextPromptRunnerWithDefaults(FakeOperationContext())

            assertTrue(pr.propertyFilter.test("name"))
            assertTrue(pr.propertyFilter.test("age"))
            assertTrue(pr.propertyFilter.test("email"))
            assertTrue(pr.propertyFilter.test("anyProperty"))
        }
    }


    @Nested
    inner class WithProperties {

        @Test
        fun `test varargs syntax`() {
            val pr = createOperationContextPromptRunnerWithDefaults(FakeOperationContext())
                .withProperties("name", "age")

            assertTrue(pr.propertyFilter.test("name"))
            assertTrue(pr.propertyFilter.test("age"))
            assertFalse(pr.propertyFilter.test("email"))
            assertFalse(pr.propertyFilter.test("address"))
        }

        @Test
        fun `test KProperty syntax`() {
            val pr = createOperationContextPromptRunnerWithDefaults(FakeOperationContext())
                .withProperties(Dog::name)

            assertTrue(pr.propertyFilter.test("name"))
            assertFalse(pr.propertyFilter.test("age"))
        }

        @Test
        fun `test chain with withoutProperties`() {
            val pr = createOperationContextPromptRunnerWithDefaults(FakeOperationContext())
                .withProperties("name", "age", "email")
                .withoutProperties("email")

            assertTrue(pr.propertyFilter.test("name"))
            assertTrue(pr.propertyFilter.test("age"))
            assertFalse(pr.propertyFilter.test("email"))
            assertFalse(pr.propertyFilter.test("address"))
        }

    }


    @Nested
    inner class WithoutProperties {

        @Test
        fun `test varargs syntax`() {
            val pr = createOperationContextPromptRunnerWithDefaults(FakeOperationContext())
                .withoutProperties("email", "address")

            assertTrue(pr.propertyFilter.test("name"))
            assertTrue(pr.propertyFilter.test("age"))
            assertFalse(pr.propertyFilter.test("email"))
            assertFalse(pr.propertyFilter.test("address"))
        }

        @Test
        fun `test KProperty syntax`() {
            val pr = createOperationContextPromptRunnerWithDefaults(FakeOperationContext())
                .withoutProperties(Dog::name)

            assertFalse(pr.propertyFilter.test("name"))
            assertTrue(pr.propertyFilter.test("age"))
        }

        @Test
        fun `test chain multiple`() {
            val pr = createOperationContextPromptRunnerWithDefaults(FakeOperationContext())
                .withoutProperties("email")
                .withoutProperties("address")

            assertTrue(pr.propertyFilter.test("name"))
            assertTrue(pr.propertyFilter.test("age"))
            assertFalse(pr.propertyFilter.test("email"))
            assertFalse(pr.propertyFilter.test("address"))
        }
    }


}


// Create a simple mock implementation for testing
private class TestLlmReference(
    override val name: String,
    private val promptContribution: String,
) : LlmReference {
    override val description: String = "Test reference: $name"
    override fun notes(): String = promptContribution
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/common/SubagentTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common

import org.junit.jupiter.api.Disabled
import org.junit.jupiter.api.Test

class SubagentTest {

    @Test
    @Disabled("Implement subagent tests")
    fun `test subagent functionality`() {

    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/common/ToolGroupExposerKtTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/common/autonomy/AgentDeployerTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.autonomy

import com.embabel.agent.api.dsl.EvilWizardAgent
import com.embabel.agent.core.AgentPlatform
import com.embabel.agent.core.deployment.AgentDeployer
import com.embabel.agent.core.deployment.AgentScanningProperties
import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import org.junit.jupiter.api.Test
import kotlin.test.assertEquals
import kotlin.test.assertTrue

class AgentDeployerTest {

    @Test
    fun `no agents`() {
        val agentDeployer = AgentDeployer(
            agents = emptyList(),
            agentPlatform = mockk(),
            properties = AgentScanningProperties(
                annotation = false,
                bean = true,
            ),
        )
        val allAgents = agentDeployer.agents
        assertTrue(allAgents.isEmpty(), "No agents")
    }

    @Test
    fun `no publication because disabled`() {
        val agentDeployer = AgentDeployer(
            agents = listOf(EvilWizardAgent),
            agentPlatform = mockk(),
            properties = AgentScanningProperties(
                annotation = false,
                bean = false,
            ),
        )
        val allAgents = agentDeployer.agents
        assertEquals(1, allAgents.size)
        // Should not have deployed
    }

    @Test
    fun publication() {
        val mockAgentPlatform = mockk<AgentPlatform>()
        every { mockAgentPlatform.deploy(any()) } returns mockAgentPlatform
        val agentDeployer = AgentDeployer(
            agents = listOf(EvilWizardAgent),
            agentPlatform = mockAgentPlatform,
            properties = AgentScanningProperties(
                annotation = false,
                bean = true,
            ),
        )
        val allAgents = agentDeployer.agents
        assertEquals(1, allAgents.size)
        // Should have deployed
        verify(exactly = 1) { mockAgentPlatform.deploy(EvilWizardAgent) }
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/common/autonomy/AgentInvocationKotlinTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.autonomy

import com.embabel.agent.api.common.autonomy.AgentInvocation.Companion.builder
import com.embabel.agent.api.common.autonomy.AgentInvocation.Companion.create
import com.embabel.agent.core.*
import com.embabel.agent.core.Goal.Companion.createInstance
import io.mockk.every
import io.mockk.mockk
import org.junit.jupiter.api.Test
import java.util.concurrent.CompletableFuture
import kotlin.test.assertEquals

class AgentInvocationKotlinTest {

    private val agentPlatform = mockk<AgentPlatform>()

    private val agent = mockk<Agent>()

    private val agentProcess = mockk<AgentProcess>()

    private val goal: Goal = createInstance("Test goal", Bar::class.java)

    @Test
    fun `default varargs invocation`() {
        val foo = Foo()
        val expected = Bar()
        val invocation: AgentInvocation<Bar> = create(agentPlatform)

        every {agentPlatform.agents()} returns listOf(agent)
        every {agent.goals} returns setOf(goal)
        every {agentPlatform.createAgentProcessFrom(
            agent = agent,
            processOptions = any(),
            *arrayOf(foo)
        )} returns agentProcess
        every {agentPlatform.start(agentProcess)} returns CompletableFuture.completedFuture(agentProcess)
        every {agentProcess.last(Bar::class.java)} returns expected

        val bar: Bar = invocation.invoke(foo)
        assertEquals(
            expected = expected,
            actual = bar
        )
    }

    @Test
    fun `default map invocation`() {
        val foo = Foo()
        val map = mapOf("id" to foo)
        val expected = Bar()
        val invocation: AgentInvocation<Bar> = create(agentPlatform)

        every {agentPlatform.agents()} returns listOf(agent)
        every {agent.goals} returns setOf(goal)
        every {agentPlatform.createAgentProcess(
            agent = agent,
            processOptions = any(),
            bindings = map
        )} returns agentProcess
        every {agentPlatform.start(agentProcess)} returns CompletableFuture.completedFuture(agentProcess)
        every {agentProcess.last(Bar::class.java)} returns expected

        val bar: Bar = invocation.invoke(map)
        assertEquals(
            expected = expected,
            actual = bar
        )
    }

    @Test
    fun `custom processing options`() {
        val processOptions = ProcessOptions(verbosity = Verbosity(debug = true))
        val invocation: AgentInvocation<Bar> = builder(agentPlatform)
            .options(processOptions)
            .build()

        every {agentPlatform.agents()} returns listOf(agent)
        every {agent.goals} returns setOf(goal)
        every {agentPlatform.createAgentProcessFrom(any(),
            processOptions = processOptions,
            any()
        )} returns agentProcess
        every {agentPlatform.start(agentProcess)} returns CompletableFuture.completedFuture(agentProcess)
        every {agentProcess.last(Bar::class.java)} returns Bar()


        invocation.invoke(Foo())
    }

}

class Foo
class Bar



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/common/autonomy/AutonomyActionLeakageTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.autonomy

import com.embabel.agent.core.*
import com.embabel.agent.domain.io.UserInput
import com.embabel.agent.testing.integration.IntegrationTestUtils
import com.embabel.agent.testing.integration.RandomRanker
import com.embabel.agent.testing.integration.forAutonomyTesting
import com.embabel.common.core.types.ZeroToOne
import com.embabel.common.util.indent
import com.embabel.plan.goap.ConditionDetermination
import io.mockk.clearAllMocks
import io.mockk.unmockkAll
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Test
import java.lang.reflect.Method
import java.time.Duration
import kotlin.reflect.full.declaredMemberExtensionFunctions
import kotlin.reflect.jvm.isAccessible
import kotlin.reflect.jvm.javaMethod
import kotlin.test.assertFalse
import kotlin.test.assertTrue

/**
 * Tests to verify there's no "action leakage" between agents during agent creation
 * and goal accomplishment.
 *
 * This test suite focuses on:
 *
 * Testing the private prune method:
 *    - Ensures actions from one goal don't leak into agents created for other goals
 *    - Verifies correct action filtering based on the goal's requirements
 *
 * These tests are critical for maintaining isolation between different agents and
 * ensuring that only required actions are included during agent creation.
 *
 * Test suite can be as used as template for actions scalability testing.
 */
class AutonomyActionLeakageTest {

    data class DummyType(val x: Int) {}

    @BeforeEach
    fun setUp() {
        clearAllMocks()
    }

    @AfterEach
    fun tearDown() {
        unmockkAll()
    }

    /**
     * Test the prune method directly to ensure it correctly filters actions
     * and doesn't allow actions from one goal to leak into agents for another goal.
     *
     * This test:
     * 1. Creates two distinctly different actions, each for a different goal
     * 2. Creates an agent containing both actions
     * 3. Uses reflection to call the private prune method
     * 4. Verifies that the pruned agent only contains the action needed for the target goal
     *
     * Relationships between Conditions, Goals and Actions:
     *
     * Cond1 -------------input ---->Goal1
     * InputCondition --- input ---->Action1
     * Action1 ---------- output --->Cond1
     * Cond1 ------------ input ---->Action2
     * Cond2 -------------input----->Goal2
     * Action2 ---------- output --->Cond2
     *
     * GOAP constructs 2 plans: {action1 to goal1} and {action1-->action2 to goal2}
     *
     */
    @Test
    @DisplayName("test prune method correctly filters actions without leakage")
    fun testSingleAgentPruneMethodPreventsActionLeakage() {
        // Create test conditions
        val condition1 = ComputedBooleanCondition(
            name = "Test Condition 1",
            cost = 0.25,
            evaluator = { _, _ -> true }
        )

        val condition2 = ComputedBooleanCondition(
            name = "Test Condition 2",
            cost = 0.25,
            evaluator = { _, _ -> true }
        )
        val inputCondition = ComputedBooleanCondition(
            name = "UserInput Condition",
            cost = 0.5,
            evaluator = { _, _ -> true }
        )

        // Create test goals with different conditions
        val goal1 = Goal(
            name = "goal1",
            description = "Test goal 1",
            value = 0.8,
            pre = setOf(condition1.name),
            outputType = null,
        )

        val goal2 = Goal(
            name = "goal2",
            description = "Test goal 2",
            value = 0.8,
            pre = setOf(condition2.name),
            outputType = null,
        )

        // Create action1 that satisfies goal1
        val action1 = object : Action {
            override val outputs: Set<IoBinding> = setOf(IoBinding("goal1", type = UserInput::class.java))
            override val cost: ZeroToOne
                get() = 0.9
            override val canRerun: Boolean
                get() = true
            override val qos: ActionQos
                get() = ActionQos()
            override val name = "action1"
            override val value: ZeroToOne = 0.3
            override fun infoString(
                verbose: Boolean?,
                indent: Int,
            ): String {
                return "ACTION 1".indent(indent)
            }

            override val description = "Action for goal 1"
            override val inputs: Set<IoBinding> = setOf(IoBinding("goal1", type = UserInput::class.java))
            val output = String::class.java
            override val preconditions = mapOf(   // pushes towards achievable goal
                inputCondition.name to ConditionDetermination.FALSE
            )
            override val effects = mapOf(
                condition1.name to ConditionDetermination.TRUE
            )

            override fun execute(
                processContext: ProcessContext,
            ): ActionStatus {
                return ActionStatus(runningTime = Duration.ofSeconds(2), status = ActionStatusCode.SUCCEEDED)
            }

            override fun referencedInputProperties(variable: String): Set<String> {
                return emptySet()
            }

            override val domainTypes: Collection<DomainType>
                get() = listOf(JvmType(DummyType::class.java))
            override val toolGroups: Set<ToolGroupRequirement>
                get() = emptySet()

        }

        // Create action2 that satisfies goal2
        val action2 = object : Action {
            override val outputs: Set<IoBinding> = setOf(IoBinding("goal1", type = UserInput::class.java))
            override val cost: ZeroToOne
                get() = 0.9
            override val canRerun: Boolean
                get() = true
            override val qos: ActionQos
                get() = ActionQos()
            override val name = "action2"
            override val value: ZeroToOne = 0.3
            override fun infoString(
                verbose: Boolean?,
                indent: Int,
            ): String {
                return "ACTION 2".indent(indent)
            }

            override val description = "Action for goal 2"
            override val inputs: Set<IoBinding> = setOf(IoBinding("goal2", type = UserInput::class.java))
            val output = String::class.java
            override val preconditions = mapOf(
                condition1.name to ConditionDetermination.TRUE
            )
            override val effects = mapOf(
                condition2.name to ConditionDetermination.TRUE
            )

            override fun execute(
                processContext: ProcessContext,
            ): ActionStatus {
                return ActionStatus(runningTime = Duration.ofSeconds(2), status = ActionStatusCode.SUCCEEDED)
            }

            override fun referencedInputProperties(variable: String): Set<String> {
                return emptySet()
            }

            override val domainTypes
                get() = listOf(JvmType(DummyType::class.java))
            override val toolGroups: Set<ToolGroupRequirement>
                get() = emptySet()
        }

        // Create an agent with both actions
        val agent = Agent(
            name = "testAgent",
            description = "Test agent",
            actions = listOf(action1, action2),
            goals = setOf(goal1, goal2),
            conditions = setOf(condition1, condition2, inputCondition),
            provider = "Test Provider"
        )

        // Create dependencies
        val agentPlatform = IntegrationTestUtils.dummyAgentPlatform()
        val platformServices = IntegrationTestUtils.dummyPlatformServices()
        agentPlatform.deploy(agent)

        val ranker = RandomRanker()

        // Create Autonomy instance
        val autonomy = Autonomy(
            agentPlatform = agentPlatform,
            ranker = ranker,
            properties = forAutonomyTesting()
        )

        // Create test user input
        val userInput = UserInput("test input for goal 1")

        // Use reflection to access the private prune method
        val pruneMethod = getPruneMethod(autonomy)

        // Call prune method with our agent and userInput
        val prunedAgent = pruneMethod.invoke(autonomy, agent, userInput) as Agent

        // Verify correct actions gets included into plan after pruning
        assertEquals(2, prunedAgent.actions.size, "Pruned agent should  have 2 action")
        assertEquals("action1", prunedAgent.actions[0].name, "Pruned agent should contain  action1")
        assertTrue(prunedAgent.actions.any { it.name == "action2" }, "Pruned agent should contain  action2")
    }

    /**
     *  Purpose of test to detect scenario when actions planned for achieving goal for Agent 1 and 2 are mutually exclusive.
     *  As example, actions 3 and 4 for Agent 2 should never leak into any plan for Agent 1.
     *  Test employs "shared condition" between Agents in order to test for action leakages.
     */
    @Test
    @DisplayName("test that actions from one agent don't leak into another agent")
    fun testCrossAgentActionLeakage() {
        // Create shared condition used by both agents
        val sharedCondition = ComputedBooleanCondition(
            name = "SharedCondition",
            cost = 0.25,
            evaluator = { _, _ -> true }
        )

        // Agent1 conditions and goals
        val condition1 = ComputedBooleanCondition(
            name = "Agent1Condition1",
            cost = 0.25,
            evaluator = { _, _ -> true }
        )

        val condition2 = ComputedBooleanCondition(
            name = "Agent1Condition2",
            cost = 0.25,
            evaluator = { _, _ -> true }
        )

        val goal1 = Goal(
            name = "goal1",
            description = "Agent1 goal 1",
            value = 0.8,
            pre = setOf(condition1.name),
            outputType = null,
        )

        val goal2 = Goal(
            name = "goal2",
            description = "Agent1 goal 2",
            value = 0.8,
            pre = setOf(condition2.name),
            outputType = null,
        )

        // Agent2 conditions and goals
        val condition3 = ComputedBooleanCondition(
            name = "Agent2Condition1",
            cost = 0.25,
            evaluator = { _, _ -> true }
        )

        val condition4 = ComputedBooleanCondition(
            name = "Agent2Condition2",
            cost = 0.25,
            evaluator = { _, _ -> true }
        )

        val goal3 = Goal(
            name = "goal3",
            description = "Agent2 goal 1",
            value = 0.8,
            pre = setOf(condition3.name),
            outputType = null,
        )

        val goal4 = Goal(
            name = "goal4",
            description = "Agent2 goal 2",
            value = 0.8,
            pre = setOf(condition4.name),
            outputType = null,
        )

        // Create Agent1 actions
        val action1 = createTestAction(
            name = "action1",
            description = "Action for Agent1 goal1",
            preconditions = mapOf(sharedCondition.name to ConditionDetermination.FALSE),
            effects = mapOf(condition1.name to ConditionDetermination.TRUE)
        )

        val action2 = createTestAction(
            name = "action2",
            description = "Action for Agent1 goal2",
            preconditions = mapOf(sharedCondition.name to ConditionDetermination.TRUE),
            effects = mapOf(condition2.name to ConditionDetermination.TRUE)
        )

        // Create Agent2 actions that also use the shared condition
        val action3 = createTestAction(
            name = "action3",
            description = "Action for Agent2 goal3",
            preconditions = mapOf(sharedCondition.name to ConditionDetermination.FALSE),
            effects = mapOf(condition3.name to ConditionDetermination.TRUE)
        )

        val action4 = createTestAction(
            name = "action4",
            description = "Action for Agent2 goal4",
            preconditions = mapOf(sharedCondition.name to ConditionDetermination.TRUE),
            effects = mapOf(condition4.name to ConditionDetermination.TRUE)
        )

        // Create Agent1
        val agent1 = Agent(
            name = "agent1",
            description = "Test agent 1",
            actions = listOf(action1, action2),
            goals = setOf(goal1, goal2),
            conditions = setOf(condition1, condition2, sharedCondition),
            provider = "Test Provider"
        )

        // Create Agent2
        val agent2 = Agent(
            name = "agent2",
            description = "Test agent 2",
            actions = listOf(action3, action4),
            goals = setOf(goal3, goal4),
            conditions = setOf(condition3, condition4, sharedCondition),
            provider = "Test Provider"
        )

        // Create and set up platform
        val agentPlatform = IntegrationTestUtils.dummyAgentPlatform()
        agentPlatform.deploy(agent1)
        agentPlatform.deploy(agent2)

        // Create Autonomy
        val autonomy = Autonomy(
            agentPlatform = agentPlatform,
            ranker = RandomRanker(),
            properties = forAutonomyTesting()
        )

        // Create user input
        val userInput = UserInput("test input for goal1")

        // Get the prune method
        val pruneMethod = getPruneMethod(autonomy)

        // Test pruning Agent1 with goal1
        val prunedAgent1 = pruneMethod.invoke(autonomy, agent1, userInput) as Agent

        // Verify no action leakage from Agent2 to Agent1
        assertEquals(1, prunedAgent1.actions.size, "Pruned agent should only have 1 action")
        assertEquals("action1", prunedAgent1.actions[0].name, "Pruned agent should contain only action1")
        assertFalse(
            prunedAgent1.actions.any { it.name == "action3" || it.name == "action4" },
            "Agent1 should not contain any actions from Agent2"
        )

        // Test pruning Agent2 with goal3
        val prunedAgent2 = pruneMethod.invoke(autonomy, agent2, userInput) as Agent

        // Verify no action leakage from Agent1 to Agent2
        assertEquals(1, prunedAgent2.actions.size, "Pruned agent should only have 1 action")
        assertEquals("action3", prunedAgent2.actions[0].name, "Pruned agent should contain only action3")
        assertFalse(
            prunedAgent2.actions.any { it.name == "action1" || it.name == "action2" },
            "Agent2 should not contain any actions from Agent1"
        )
    }

    // Helper method to create test actions
    private fun createTestAction(
        name: String,
        description: String,
        preconditions: Map<String, ConditionDetermination>,
        effects: Map<String, ConditionDetermination>,
    ): Action {
        return object : Action {
            override val outputs: Set<IoBinding> = setOf(IoBinding(name, type = UserInput::class.java))
            override val cost: ZeroToOne = 0.9
            override val canRerun: Boolean = true
            override val qos: ActionQos = ActionQos()
            override val name = name
            override val value: ZeroToOne = 0.3
            override fun infoString(
                verbose: Boolean?,
                indent: Int,
            ): String = name.indent(indent)

            override val description = description
            override val inputs: Set<IoBinding> = setOf(IoBinding(name, type = UserInput::class.java))
            override val preconditions = preconditions
            override val effects = effects

            override fun execute(
                processContext: ProcessContext,
            ): ActionStatus {
                return ActionStatus(runningTime = Duration.ofSeconds(2), status = ActionStatusCode.SUCCEEDED)
            }

            override fun referencedInputProperties(variable: String): Set<String> = emptySet()
            override val domainTypes = listOf(JvmType(DummyType::class.java))
            override val toolGroups: Set<ToolGroupRequirement> = emptySet()
        }
    }

    /**
     * Helper method to get the prune extension method via reflection
     */
    private fun getPruneMethod(autonomy: Autonomy): Method {
        // Get the prune extension method via reflection
        val autonomyClass = Autonomy::class

        // Use Kotlin reflection first to find the extension function
        val pruneFunction = autonomyClass.declaredMemberExtensionFunctions.first { it.name == "prune" }
        // Make it accessible
        pruneFunction.isAccessible = true

        // Get the Java method to invoke it
        val pruneMethod = pruneFunction.javaMethod!!
        pruneMethod.isAccessible = true

        return pruneMethod
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/common/autonomy/AutonomyAgentSelectionTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.autonomy

import com.embabel.agent.core.*
import com.embabel.agent.domain.io.UserInput
import com.embabel.agent.domain.library.HasContent
import com.embabel.agent.event.AgenticEventListener
import com.embabel.agent.spi.Ranking
import com.embabel.agent.spi.Rankings
import com.embabel.agent.testing.integration.FakeRanker
import com.embabel.agent.testing.integration.forAutonomyTesting
import com.embabel.common.core.types.Described
import com.embabel.common.core.types.Named
import io.mockk.*
import org.junit.jupiter.api.*
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Assertions.assertNotNull //Explicit import to disambiguate from kotlin.test.assertNotNull

/**
 * Tests for the agent selection functionality in Autonomy.
 *
 * This test suite focuses on the following aspects of agent selection:
 *
 * 1. Proper agent ranking and threshold-based filtering
 *    - Tests that agents are ranked using the provided Ranker
 *    - Verifies that only agents above the confidence threshold are selected
 *
 * 2. Agent execution after selection
 *    - Tests that the selected agent is executed through the platform
 *    - Verifies result handling based on process status
 *
 * Technical notes:
 * - We use a spy approach for Agent objects to prevent infoString errors
 * - The test creates real objects where possible, with minimal mocking
 * - A custom ranker returns varied scores to test threshold comparisons
 * - The tests validate that scores above threshold pass, while scores below fail
 * - ProcessOptions(test=false) is used to prevent RandomRanker substitution
 *
 * This approach ensures we test the actual agent selection behavior of the Autonomy
 * class while avoiding issues with infoString calls during Agent operations.
 */
class AutonomyAgentSelectionTest {

    @BeforeEach
    fun setUp() {
        clearAllMocks()
    }

    @AfterEach
    fun tearDown() {
        unmockkAll()
    }

    /**
     * Test agent selection with valid input (confidence above threshold).
     *
     * This test verifies that when an agent with confidence above threshold is found,
     * it is executed properly.
     *
     * Test approach:
     * 1. Setup test with an agent having score 0.8 (above threshold 0.5)
     * 2. Create a real Agent as a spy to handle infoString calls
     * 3. Mock only the necessary external dependencies
     * 4. Use a ranker that returns high scores above threshold
     * 5. Execute the real chooseAndRunAgent method (not mocked)
     * 6. Verify all key method interactions and event publications
     *
     * Critical aspects tested:
     * - Agent selection based on confidence score comparison to threshold
     * - Process execution with the selected agent
     * - Result handling based on process status
     * - Event publication for agent selection
     */
    @Test
    @DisplayName("test agent selection with valid input (score above threshold)")
    fun testChooseAndRunAgentWithValidInput() {
        val userInput = "Find a horoscope for Lynda who is a Scorpio"

        // Create a real goal for our agent
        val testGoal = Goal(
            name = "testGoal",
            description = "Test goal",
            value = 0.8
        )

        // Create a real agent as a spy
        val realAgent = spyk(
            Agent(
                name = "realTestAgent",
                provider = "test",
                description = "Real Test Agent",
                actions = emptyList(),
                goals = setOf(testGoal),
                conditions = emptySet(),
            )
        ) {
            // Only override the problematic infoString method
            every { infoString(any()) } returns "TestAgent() - spied"
        }

        val testProcess = mockk<AgentProcess>()
        val testOutput = object : HasContent {
            override val content = "Test output content"
        }

        every { testProcess.status } returns AgentProcessStatusCode.COMPLETED
        every { testProcess.lastResult() } returns testOutput

        // Mock platform to return available agents and execute our test agent
        val agentPlatform = mockk<AgentPlatform>()
        every { agentPlatform.agents() } returns listOf(realAgent)
        every {
            agentPlatform.createAgentProcess(
                processOptions = any(),
                agent = realAgent,
                bindings = any<Map<String, Any>>()
            )
        } returns testProcess
        every { testProcess.run() } returns testProcess

        // Create a ranker that returns high confidence for our test agent
        val highScoreRanker = object : FakeRanker {
            override fun <T> rank(
                description: String,
                userInput: String,
                rankables: Collection<T>,
            ): Rankings<T> where T : Named, T : Described {
                return Rankings(rankables.map { Ranking(it, 0.8) })
            }
        }

        val eventListener = mockk<AgenticEventListener>(relaxUnitFun = true)

        every {
            agentPlatform.platformServices.eventListener
        } returns eventListener

        // Create the Autonomy instance to test
        val autonomy = Autonomy(
            agentPlatform = agentPlatform,
            ranker = highScoreRanker,
            properties = forAutonomyTesting(agentConfidenceCutOff = 0.5),
        )

        // Execute the real method - no mocking of chooseAndRunAgent
        val result = autonomy.chooseAndRunAgent(
            intent = userInput,
            processOptions = ProcessOptions()
        )

        assertNotNull(result, "Result should not be null")
        assertEquals(testOutput, result.output, "Output should match expected")
        assertEquals(testProcess, result.agentProcess, "Process should match expected")

        verify {
            agentPlatform.agents()

            // Verify the agent was executed
            agentPlatform.createAgentProcess(
                processOptions = any(),
                agent = realAgent,
                bindings = any()
            )

            testProcess.status
            testProcess.lastResult()
        }

        verify {
            // Event listener should be called with events related to agent selection
            eventListener.onPlatformEvent(
                withArg { event ->
                    // This verifies that events about ranking/selection were published
                    assertTrue(
                        event.toString().contains("Ranking") ||
                                event.toString().contains("Agent"),
                        "Event should be related to agent ranking or selection"
                    )
                }
            )
        }
    }

    /**
     * Test agent selection with invalid input (confidence below threshold).
     *
     * This test verifies that when no agent has confidence above threshold,
     * a NoAgentFound exception is thrown with the appropriate details.
     *
     * Test approach:
     * 1. Setup test with an agent having score 0.3 (below threshold 0.5)
     * 2. Create a real Agent as a spy to handle infoString calls
     * 3. Use a ranker that returns low scores below threshold
     * 4. Execute the real chooseAndRunAgent method (not mocked)
     * 5. Verify the expected exception is thrown with correct details
     *
     * Critical aspects tested:
     * - Agent ranking and filtering based on confidence threshold
     * - Proper exception thrown when no agent meets the threshold
     * - Exception contains correct ranking information
     */
    @Test
    @DisplayName("test NoAgentFound is thrown when agent confidence score is below threshold")
    fun testChooseAndRunAgentWithInvalidInput() {
        // Setup test data
        val userInput = "Some input that won't match any agent"

        // Create a real agent but with low confidence
        val lowConfidenceAgent = spyk(
            Agent(
                name = "lowConfidenceAgent",
                description = "Agent with low confidence score",
                provider = "test",
                actions = emptyList(),
                goals = emptySet(),
                conditions = emptySet(),
            )
        ) {
            // Only override the problematic infoString method
            every { infoString(any()) } returns "LowConfidenceAgent() - spied"
        }

        // Mock platform to return our agent
        val agentPlatform = mockk<AgentPlatform>()
        every { agentPlatform.agents() } returns listOf(lowConfidenceAgent)


        // Create a ranker that returns low confidence scores (below threshold)
        val lowScoreRanker = object : FakeRanker {
            override fun <T> rank(
                description: String,
                userInput: String,
                rankables: Collection<T>,
            ): Rankings<T> where T : Named, T : Described {
                return Rankings(rankables.map { Ranking(it, 0.3) })
            }
        }

        // Create event listener
        val eventListener = mockk<AgenticEventListener>(relaxUnitFun = true)
        every {
            agentPlatform.platformServices.eventListener
        } returns eventListener

        // Create the Autonomy instance to test
        val autonomy = Autonomy(
            agentPlatform = agentPlatform,
            ranker = lowScoreRanker,
            properties = forAutonomyTesting(agentConfidenceCutOff = 0.5),
        )

        // Execute and verify exception is thrown
        val exception = assertThrows<NoAgentFound> {
            autonomy.chooseAndRunAgent(
                intent = userInput,
                processOptions = ProcessOptions()
            )
        }

        // Verify exception contains expected details
        assertTrue(exception.basis is UserInput, "Exception basis should be UserInput")
        assertEquals(
            userInput, (exception.basis as UserInput).content,
            "UserInput content should match"
        )

        // Verify rankings in exception
        val rankings = exception.agentRankings.rankings()
        assertEquals(1, rankings.size, "Should have exactly one ranking")

        val ranking = rankings.first()
        assertEquals(
            "lowConfidenceAgent", ranking.match.name,
            "Ranking should contain our low confidence agent"
        )
        assertEquals(
            0.3, ranking.score,
            "Ranking score should be 0.3, below threshold of 0.5"
        )

        // Verify platform interaction
        verify {
            agentPlatform.agents()
        }

        // Verify events
        verify {
            eventListener.onPlatformEvent(any())
        }
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/common/autonomy/AutonomyGoalSelectionTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.autonomy

import com.embabel.agent.core.*
import com.embabel.agent.domain.io.UserInput
import com.embabel.agent.domain.library.HasContent
import com.embabel.agent.event.AgenticEventListener
import com.embabel.agent.spi.Ranking
import com.embabel.agent.spi.Rankings
import com.embabel.agent.testing.integration.FakeRanker
import com.embabel.agent.testing.integration.forAutonomyTesting
import com.embabel.common.core.types.Described
import com.embabel.common.core.types.Named
import io.mockk.*
import org.junit.jupiter.api.*
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Assertions.assertNotNull //Explicit import to disambiguate from kotlin.test.assertNotNull

/**
 * Tests for the goal selection functionality in Autonomy.
 *
 * This test suite focuses on testing the chooseAndAccomplishGoal method with:
 *
 * 1. Valid Input: High confidence goal (above threshold)
 *    - Tests that goals with confidence above threshold are selected
 *    - Verifies agent creation and execution works properly
 *
 * 2. Invalid Input: Low confidence goal (below threshold)
 *    - Tests that goals with confidence below threshold trigger NoGoalFound
 *    - Verifies exception contains expected goal rankings
 *
 * Technical notes:
 * - We use a spy approach for Agent objects to prevent infoString errors
 * - The tests ensure score comparison logic is properly exercised
 * - ProcessOptions(test=false) is used to prevent RandomRanker substitution
 * - Both tests validate core functionality without mocking the main method
 */
class AutonomyGoalSelectionTest {

    @BeforeEach
    fun setUp() {
        clearAllMocks()
    }

    @AfterEach
    fun tearDown() {
        unmockkAll()
    }

    /**
     * Test the valid input case for goal selection.
     *
     * This verifies that when a goal with confidence above threshold is found,
     * it is selected and executed properly.
     *
     * Test approach:
     * 1. Setup test with a goal having score 0.8 (above threshold 0.5)
     * 2. Create a real Agent as a spy to handle infoString calls
     * 3. Mock only the necessary external dependencies
     * 4. Use a ranker that returns varied scores (0.8 for test goal, 0.3 for others)
     * 5. Execute the real chooseAndAccomplishGoal method (not mocked)
     * 6. Verify all key method interactions and event publications
     *
     * Critical aspects tested:
     * - Goal selection based on confidence score comparison to threshold
     * - Agent creation with the selected goal
     * - Process execution and result handling
     * - Event publication for goal/agent selection
     *
     * The key testing technique here is using a spy on a real Agent object
     * and overriding only the infoString method that causes issues.
     * This allows us to test the real pruning logic while avoiding
     * the MockKException for infoString.
     */
    @Test
    @DisplayName("test goal selection with valid input (score above threshold)")
    fun testChooseAndAccomplishGoalWithValidInput() {
        // Setup test data
        val userInput = "Find a horoscope for Lynda who is a Scorpio"

        // Create a real goal object
        val testGoal = Goal(
            name = "testGoal",
            description = "Test goal with high confidence",
            value = 0.8
        )

        // Create a real agent as a spy - this is the KEY to fixing the infoString issue
        val realAgent = spyk(
            Agent(
                name = "realAgent",
                description = "Real Agent",
                provider = "test",
                actions = emptyList(),
                goals = setOf(testGoal),
            )
        ) {
            // Only override the problematic infoString method
            every { infoString(any()) } returns "TestAgent() - spied"
        }

        // Mock the scope
        val agentScope = mockk<AgentScope>()
        every { agentScope.goals } returns setOf(testGoal)
        every { agentScope.createAgent(any(), any(), any()) } returns realAgent

        // Mock process with expected return value
        val testProcess = mockk<AgentProcess>()
        val testOutput = object : HasContent {
            override val content = "Test output content"
        }

        // Configure process to return COMPLETED status
        // This tests that DynamicExecutionResult.fromProcessStatus correctly handles the status
        every { testProcess.status } returns AgentProcessStatusCode.COMPLETED

        // Configure the result to be returned
        every { testProcess.lastResult() } returns testOutput

        // Mock platform to return our test process
        val agentPlatform = mockk<AgentPlatform>()
        every {
            agentPlatform.createAgentProcess(
                processOptions = any(),
                agent = any(),
                bindings = any<Map<String, Any>>()
            )
        } returns testProcess
        every { testProcess.run() } returns testProcess

        // Create a more realistic ranker that returns varied confidence scores
        // This better tests the score comparison logic
        val testRanker = object : FakeRanker {
            override fun <T> rank(
                description: String,
                userInput: String,
                rankables: Collection<T>,
            ): Rankings<T> where T : Named, T : Described {
                // Create a map of rankings with different scores
                val rankings = rankables.mapIndexed { index, item ->
                    val score = when (item.name) {
                        "testGoal" -> 0.8  // High score for our test goal (above threshold)
                        else -> 0.3        // Low score for any other goals (below threshold)
                    }
                    Ranking(item, score)
                }
                return Rankings(rankings)
            }
        }

        // Create event listener mock to verify event publication
        val eventListener = mockk<AgenticEventListener>(relaxUnitFun = true)

        every {
            agentPlatform.platformServices.eventListener
        } returns eventListener

        // Create the Autonomy instance to test with different thresholds
        // to verify the comparison logic is working
        val autonomy = Autonomy(
            agentPlatform = agentPlatform,
            ranker = testRanker,
            properties = forAutonomyTesting(
                goalConfidenceCutOff = 0.5,  // Our test goal (0.8) should be above this
                agentConfidenceCutOff = 0.5
            ),
        )

        // Execute the real method - no mocking of chooseAndAccomplishGoal
        val result = autonomy.chooseAndAccomplishGoal(
            processOptions = ProcessOptions(),
            goalChoiceApprover = GoalChoiceApprover.APPROVE_ALL,
            agentScope = agentScope,
            bindings = mapOf(IoBinding.DEFAULT_BINDING to UserInput(userInput))
        )

        // Verify the result
        assertNotNull(result, "Result should not be null")
        assertEquals(testOutput, result.output, "Output should match expected")
        assertEquals(testProcess, result.agentProcess, "Process should match expected")

        // Verify the key method interactions
        verify {
            // Verify the scope was accessed to get goals
            agentScope.goals

            // Verify agent creation
            agentScope.createAgent(any(), any(), any())

            // Verify goal selection
            realAgent.withSingleGoal(testGoal)

            // Verify that the chosen agent was executed
            agentPlatform.createAgentProcess(
                processOptions = any(),
                agent = any(),
                bindings = any()
            )
            testProcess.run()

            // Verify process status was checked
            testProcess.status

            // Verify result was retrieved
            testProcess.lastResult()
        }

        // Verify events for goal selection - this confirms the ranking logic was used
        verify {
            // Event listener should be called with events related to goal selection
            eventListener.onPlatformEvent(
                withArg { event ->
                    // This verifies that events about ranking/selection were published
                    assertTrue(
                        event.toString().contains("Ranking") ||
                                event.toString().contains("Goal") ||
                                event.toString().contains("Agent"),
                        "Event should be related to goal/agent ranking or selection"
                    )
                }
            )
        }
    }

    /**
     * Test for NoGoalFound exception being thrown when goal confidence is too low.
     *
     * This test verifies that when no goal has confidence above threshold,
     * a NoGoalFound exception is thrown with the appropriate details.
     *
     * Test approach:
     * 1. Setup test with a goal having score 0.3 (below threshold 0.5)
     * 2. Use a FakeRanker that returns low confidence scores
     * 3. Execute the real chooseAndAccomplishGoal method (not mocked)
     * 4. Verify the expected exception is thrown with correct details
     *
     * Critical aspects tested:
     * - Goal ranking and filtering based on confidence threshold
     * - Proper exception thrown when no goal meets the threshold
     * - Exception contains correct ranking information
     *
     * The test explicitly uses ProcessOptions(test=false) to prevent
     * the random ranker substitution that occurs in test mode.
     */
    @Test
    @DisplayName("test NoGoalFound is thrown when goal confidence score is below threshold")
    fun testChooseAndAccomplishGoalWithInvalidInput() {
        // Create test objects
        val testGoal = Goal(
            name = "testGoal",
            description = "Test Goal",
            value = 0.2
        )

        // Create a real agent as a spy - this is the KEY to fixing the infoString issue
        val agent = spyk(
            Agent(
                name = "testAgent",
                provider = "test",
                description = "Test agent",
                actions = emptyList(),
                goals = setOf(testGoal),
                conditions = emptySet(),
            )
        ) {
            // Only override the problematic infoString method
            every { infoString(any()) } returns "TestAgent() - spied"
        }

        // Create a ranker that returns low confidence scores
        val lowScoreRanker = object : FakeRanker {
            override fun <T> rank(
                description: String,
                userInput: String,
                rankables: Collection<T>,
            ): Rankings<T> where T : Named, T : Described {
                // Return 0.3 which is below the 0.5 threshold
                return Rankings(rankables.map { Ranking(it, 0.3) })
            }
        }

        // Create more specific mocks with proper enum handling
        val agentScope = mockk<AgentScope>(relaxUnitFun = true)
        val agentPlatform = mockk<AgentPlatform>(relaxUnitFun = true)
        val eventListener = mockk<AgenticEventListener>(relaxUnitFun = true)

        // Only mock the methods that are definitely needed
        every { agentScope.goals } returns setOf(testGoal)
        justRun { eventListener.onPlatformEvent(any()) }

        // Mock agent creation
        every {
            agentScope.createAgent(name = any(), provider = any(), description = any())
        } returns agent

        // Mock process with all necessary methods
        val mockProcess = mockk<AgentProcess>()
        every { mockProcess.status } returns AgentProcessStatusCode.COMPLETED
        every { mockProcess.id } returns "test-process-id"

        // Create a test output to return from lastResult
        val testOutput = object : HasContent {
            override val content = "Test output"
        }
        every { mockProcess.lastResult() } returns testOutput

        // Mock runAgentFrom
        every {
            agentPlatform.runAgentFrom(any(), any(), any())
        } returns mockProcess
        every {
            agentPlatform.platformServices.eventListener
        } returns eventListener

        // Create autonomy instance
        val autonomy = Autonomy(
            agentPlatform = agentPlatform,
            ranker = lowScoreRanker,
            properties = forAutonomyTesting(goalConfidenceCutOff = 0.5),
        )

        // Execute and verify the exception is thrown
        val exception = assertThrows<NoGoalFound> {
            // IMPORTANT: Use test=false to prevent RandomRanker creation
            autonomy.chooseAndAccomplishGoal(
                processOptions = ProcessOptions(),
                goalChoiceApprover = GoalChoiceApprover.APPROVE_ALL,
                agentScope = agentScope,
                bindings = mapOf(IoBinding.DEFAULT_BINDING to UserInput("test input"))
            )
        }

        // Verify the exception has the expected properties
        assertNotNull(exception.goalRankings, "Exception should have goalRankings")

        assertTrue(exception.basis is UserInput, "Exception basis should be UserInput")
        assertEquals(
            "test input", (exception.basis as UserInput).content,
            "UserInput should contain our test string"
        )

        // Verify rankings
        assertEquals(
            1, exception.goalRankings.rankings().size,
            "There should be exactly one ranking"
        )

        val ranking = exception.goalRankings.rankings().firstOrNull()
        assertNotNull(ranking, "There should be a ranking in the exception")

        assertEquals(
            "testGoal", ranking?.match?.name,
            "Ranking should contain our goal"
        )
        assertEquals(
            0.3, ranking?.score,
            "Ranking score should be 0.3, below threshold"
        )
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/common/autonomy/PlanListerTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.autonomy

import com.embabel.agent.api.common.workflow.control.SimpleAgentBuilder
import com.embabel.agent.api.dsl.*
import com.embabel.agent.core.Export
import com.embabel.agent.core.ProcessOptions
import com.embabel.agent.domain.io.UserInput
import com.embabel.agent.testing.integration.IntegrationTestUtils.dummyAgentPlatform
import org.junit.jupiter.api.Test
import kotlin.test.assertEquals

class PlanListerTest {

    fun needsVictimAgent() = agent("NeedsVictimAgent", description = "Turn a person into a frog") {

        transformation<MagicVictim, SnakeMeal>(name = "thing") {
            SnakeMeal(frogs = listOf(Frog(name = "Hamish")))
        }

        goal(
            name = "done",
            description = "done",
            satisfiedBy = SnakeMeal::class,
            export = Export(
                startingInputTypes = setOf(MagicVictim::class.java),
            ),
        )
    }

    @Test
    fun `no plans with no agents`() {
        val planLister = DefaultPlanLister(dummyAgentPlatform())
        val plans = planLister.achievablePlans(
            processOptions = ProcessOptions(),
            bindings = emptyMap()
        )
        assert(plans.isEmpty()) { "Expected no plans, but found ${plans.size}" }
    }

    @Test
    fun `plan with one agent that can run from nothing`() {
        val agentPlatform = dummyAgentPlatform()
        agentPlatform.deploy(
            SimpleAgentBuilder
                .returning(Frog::class.java)
                .running { TODO() }
                .buildAgent("name", description = "description")
        )
        val planLister = DefaultPlanLister(agentPlatform)
        val plans = planLister.achievablePlans(
            processOptions = ProcessOptions(),
            bindings = emptyMap()
        )
        assertEquals(1, plans.size, "Expected 1 plans, but found ${plans.size}")
    }

    @Test
    fun `plan with one agent that cannot start from nothing`() {
        val agentPlatform = dummyAgentPlatform()
        agentPlatform.deploy(
            needsVictimAgent()
        )
        val planLister = DefaultPlanLister(agentPlatform)
        val plans = planLister.achievablePlans(
            processOptions = ProcessOptions(),
            bindings = emptyMap()
        )
        assert(plans.isEmpty()) { "Expected no plans, but found ${plans.size}" }
    }

    @Test
    fun `plan with one agent that cannot start from nothing but is satisfied`() {
        val agentPlatform = dummyAgentPlatform()
        agentPlatform.deploy(
            needsVictimAgent()
        )
        val planLister = DefaultPlanLister(agentPlatform)
        val plans = planLister.achievablePlans(
            processOptions = ProcessOptions(),
            bindings = mapOf(
                "it" to MagicVictim(name = "Hamish")
            )
        )
        assertEquals(1, plans.size, "Expected 1 plans, but found ${plans.size}")
    }

    @Test
    fun `plan with one agent that needs UserInput and is satisfied`() {
        val agentPlatform = dummyAgentPlatform()
        agentPlatform.deploy(
            evenMoreEvilWizard()
        )
        val planLister = DefaultPlanLister(agentPlatform)
        val plans = planLister.achievablePlans(
            processOptions = ProcessOptions(),
            bindings = mapOf(
                "it" to UserInput(content = "Hamish is our unfortunate victim")
            )
        )
        assertEquals(1, plans.size, "Expected 1 plans, but found ${plans.size}")
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/common/support/BindFieldsToBlackboardTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.support

import com.embabel.agent.api.annotation.support.PersonWithReverseTool
import com.embabel.agent.api.common.SomeOf
import com.embabel.agent.core.support.InMemoryBlackboard
import com.embabel.agent.support.Dog
import com.embabel.common.util.loggerFor
import org.junit.jupiter.api.Test
import kotlin.test.assertEquals

data class DogOrPerson(
    val dog: Dog?,
    val person: PersonWithReverseTool?,
) : SomeOf

class BindFieldsToBlackboardTest {

    @Test
    fun `test bind fields to blackboard`() {
        val dog = Dog("Duke")
        val person = PersonWithReverseTool("Alice")
        val dogOrPerson = DogOrPerson(dog, person)
        val bb = InMemoryBlackboard()
        assertEquals(0, bb.objects.size)
        destructureAndBindIfNecessary(dogOrPerson, "name", bb, loggerFor<SomeOf>())
        assertEquals(2, bb.objects.size)
        assertEquals(dog, bb.last(Dog::class.java), "Duke")
        assertEquals(person, bb.last(PersonWithReverseTool::class.java), "Alice")
    }

    @Test
    fun `test null fields not bound`() {
        val dogOrPerson = DogOrPerson(null, null)
        val bb = InMemoryBlackboard()
        assertEquals(0, bb.objects.size)
        destructureAndBindIfNecessary(dogOrPerson, "name", bb, loggerFor<SomeOf>())
        assertEquals(0, bb.objects.size, "Nothing to bind")
    }


}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/common/support/MultiTransformationActionTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.common.support

import com.embabel.agent.core.DomainType
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Test

class MultiTransformationActionTest {

    @Test
    fun `domainTypes should handle normal case correctly`() {
        val action = MultiTransformationAction(
            name = "testAction",
            inputs = emptySet(),
            inputClasses = listOf(String::class.java, Int::class.java),
            outputClass = String::class.java,
            toolGroups = emptySet()
        ) { _ -> "result" }

        val domainTypes = action.domainTypes
        assertNotNull(domainTypes, "domainTypes should not be null")
        assertEquals(2, domainTypes.size, "Should have 2 domain types")

        val typeNames = domainTypes.map { it.name }.toSet()
        assertTrue(typeNames.contains("java.lang.String"), "Should contain String type")
        assertTrue(typeNames.contains("int"), "Should contain int type")
    }

    @Test
    fun `domainTypes should handle empty input classes`() {
        val action = MultiTransformationAction<String>(
            name = "testAction",
            inputs = emptySet(),
            inputClasses = emptyList(),
            outputClass = String::class.java,
            toolGroups = emptySet()
        ) { _ -> "result" }

        val domainTypes = action.domainTypes
        assertNotNull(domainTypes, "domainTypes should not be null")
        assertEquals(1, domainTypes.size, "Should have 1 domain type")
        assertEquals("java.lang.String", domainTypes.first().name, "Should contain String type")
    }

    @Test
    fun `domainTypes should handle void output class gracefully`() {
        // Create action with Void output type
        val action = MultiTransformationAction<Void>(
            name = "testAction",
            inputs = emptySet(),
            inputClasses = listOf(String::class.java),
            outputClass = Void.TYPE,
            toolGroups = emptySet()
        ) { _ -> null }

        val domainTypes = action.domainTypes
        assertNotNull(domainTypes, "domainTypes should not be null")
        // Should have String input type and potentially void type
        assertTrue(domainTypes.isNotEmpty(), "Should have at least one domain type")
    }

    @Test
    fun `domainTypes should handle primitive types`() {
        val action = MultiTransformationAction<Int>(
            name = "testAction",
            inputs = emptySet(),
            inputClasses = listOf(
                Int::class.javaPrimitiveType ?: Int::class.java,
                Double::class.javaPrimitiveType ?: Double::class.java
            ),
            outputClass = Int::class.javaPrimitiveType ?: Int::class.java,
            toolGroups = emptySet()
        ) { _ -> 42 }

        val domainTypes = action.domainTypes
        assertNotNull(domainTypes, "domainTypes should not be null")
        assertFalse(domainTypes.isEmpty(), "Should have domain types for primitive types")
    }

    @Test
    fun `domainTypes should never return null even with problematic inputs`() {
        // Test with classes that might cause issues
        val action = MultiTransformationAction<Object>(
            name = "testAction",
            inputs = emptySet(),
            inputClasses = listOf(Object::class.java, Array<String>::class.java),
            outputClass = Object::class.java,
            toolGroups = emptySet()
        ) { _ -> Object() }

        val domainTypes = action.domainTypes
        assertNotNull(domainTypes, "domainTypes should never be null")
        // Even if there are issues, it should return an empty collection, not null
        assertTrue(domainTypes is Collection<DomainType>, "Should return a collection")
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/dsl/AgentBuilderTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.dsl

import com.embabel.agent.api.annotation.support.PersonWithReverseTool
import com.embabel.agent.core.ActionStatusCode
import com.embabel.agent.core.IoBinding
import com.embabel.agent.core.ProcessContext
import com.embabel.agent.core.ProcessOptions
import com.embabel.agent.core.support.InMemoryBlackboard
import com.embabel.agent.core.support.SimpleAgentProcess
import com.embabel.agent.spi.support.GoapPlannerFactory
import com.embabel.agent.support.Dog
import com.embabel.agent.testing.integration.IntegrationTestUtils.dummyPlatformServices
import com.embabel.common.core.types.Semver
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import kotlin.test.assertTrue

val emptyAgent = agent(name = "foo", description = "bar") {}

val oneAction = agent(
    name = "oneAction",
    description = "one action agent",
) {
    transformation<PersonWithReverseTool, PersonWithReverseTool>(name = "reverser") { payload ->
        payload.input.copy(name = "foo")
    }
}

val oneActionAndOneGoal = agent(
    name = "oneActionAndOneGoal",
    description = "one action agent",
) {
    transformation<PersonWithReverseTool, Dog>(name = "reverser") { payload ->
        Dog(name = payload.input.name)
    }

    goal(
        name = "turnedIntoDog",
        description = "the person has been turned into a dog",
        satisfiedBy = Dog::class
    )
}

class AgentBuilderTest {

    @Nested
    inner class Errors {

        @Test
        fun `empty agent`() {
            val agent = emptyAgent
            assertEquals("foo", agent.name)
            assertEquals("bar", agent.description)
            assertEquals(Semver.DEFAULT_VERSION, agent.version.value)
            assertTrue(agent.actions.isEmpty(), "Should be no actions")
            assertTrue(agent.goals.isEmpty(), "Should be no goals")
        }
    }

    @Nested
    inner class HappyPath {

        @Test
        fun `one action`() {
            val agent = oneAction
            assertEquals("oneAction", agent.name)
            assertEquals("one action agent", agent.description)
            assertEquals(Semver.DEFAULT_VERSION, agent.version.value)
            assertEquals(1, agent.actions.size)
            assertTrue(agent.goals.isEmpty())
        }

        @Test
        fun `one action and one goal`() {
            val agent = oneActionAndOneGoal
            assertEquals("oneActionAndOneGoal", agent.name)
            assertEquals(1, agent.actions.size)
            assertEquals(1, agent.goals.size)
            assertEquals("turnedIntoDog", agent.goals.first().name)
        }

        @Test
        fun `finds and invokes transform`() {
            val agent = EvilWizardAgent
            val action = agent.actions.find { it.name == "thing" }
                ?: error("Action not found: ${agent.actions.map { it.name }}")
            val blackboard = InMemoryBlackboard()
            blackboard += PersonWithReverseTool("foo")
            val platformServices = dummyPlatformServices()
            val processContext = ProcessContext(
                agentProcess = SimpleAgentProcess(
                    agent = EvilWizardAgent,
                    blackboard = blackboard,
                    processOptions = ProcessOptions(blackboard = blackboard),
                    platformServices = platformServices,
                    id = "test",
                    plannerFactory = GoapPlannerFactory,
                    parentId = null,
                ),
                processOptions = ProcessOptions(blackboard = blackboard),
                platformServices = platformServices,
            )
            val r = action.execute(processContext)
            assertEquals(ActionStatusCode.SUCCEEDED, r.status)
            assertEquals(
                MagicVictim("Hamish"),
                processContext.blackboard[IoBinding.DEFAULT_BINDING],
                "Result should have been bound to blackboard"
            )
        }

        @Test
        fun `finds and invokes prompted transform`() {
            val agent = EvilWizardAgent
            val action = agent.actions.find { it.name == "turn-into-frog" }
                ?: error("Action not found: ${agent.actions.map { it.name }}")
            val blackboard = InMemoryBlackboard()
            blackboard += MagicVictim("Hash")
            val platformServices = dummyPlatformServices()
            val processContext = ProcessContext(
                agentProcess = SimpleAgentProcess(
                    agent = EvilWizardAgent,
                    blackboard = blackboard,
                    processOptions = ProcessOptions(blackboard = blackboard),
                    platformServices = platformServices,
                    id = "test",
                    plannerFactory = GoapPlannerFactory,
                    parentId = null,
                ),
                processOptions = ProcessOptions(blackboard = blackboard),
                platformServices = platformServices,
            )
            val r = action.execute(processContext)
            assertEquals(ActionStatusCode.SUCCEEDED, r.status)
            val output = processContext.blackboard.lastResult()
            assertTrue(
                output is Frog,
                "Result should be of correct type, although dummy LLM operations may have populated it strangely"
            )
        }
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/dsl/AgentScopeBuilderTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.dsl

import com.embabel.agent.api.annotation.support.Wumpus
import com.embabel.agent.api.common.support.Branch
import com.embabel.agent.core.Agent
import com.embabel.agent.core.AgentProcessStatusCode
import com.embabel.agent.core.ProcessOptions
import com.embabel.agent.core.objectsOfType
import com.embabel.agent.domain.io.UserInput
import com.embabel.agent.spi.support.SpiPerson
import com.embabel.agent.testing.integration.IntegrationTestUtils.dummyAgentPlatform
import com.embabel.common.core.MobyNameGenerator
import com.embabel.common.core.types.Semver
import com.embabel.common.core.types.Semver.Companion.DEFAULT_VERSION
import com.embabel.example.dogfood.factchecker.FactCheck
import com.embabel.example.dogfood.factchecker.FactCheckerProperties
import com.embabel.example.dogfood.factchecker.factCheckerAgent
import io.mockk.mockk
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import kotlin.test.assertEquals

class AgentScopeBuilderTest {

    @Nested
    inner class Split {
        @Test
        fun `metadata is correct`() {
            val agent: Agent = splitGarden()
            assertEquals("splitter", agent.name)
            assertEquals("splitter0", agent.description)
            assertEquals(Semver.DEFAULT_VERSION, agent.version.value)
            assertEquals(0, agent.conditions.size, "Should have no conditions")
            assertEquals(3, agent.actions.size, "Should have 3 actions")
            assertEquals(1, agent.goals.size)
        }

        @Test
        fun `agent runs`() {
            val agent: Agent = splitGarden()
            val ap = dummyAgentPlatform()
            val processOptions = ProcessOptions()
            val result = ap.runAgentFrom(
                agent = agent,
                processOptions = processOptions,
                bindings = mapOf("it" to UserInput("do something")),
            )
            assertEquals(AgentProcessStatusCode.COMPLETED, result.status)
            assertEquals(
                3,
                result.processContext.agentProcess.history.size,
                "Expected history:\nActual:\n${result.processContext.agentProcess.history.joinToString("\n")}"
            )
            assertTrue(result.lastResult() is SnakeMeal)
        }
    }

    @Nested
    inner class Branch {
        @Test
        fun `metadata is correct`() {
            val agent: Agent = userInputToFrogOrPersonBranch()
            assertEquals("brancher", agent.name)
            assertEquals("brancher0", agent.description)
            assertEquals(Semver.DEFAULT_VERSION, agent.version.value)
            assertEquals(0, agent.conditions.size, "Should have no conditions")
            assertEquals(1, agent.actions.size, "Should have 2 actions")
            assertEquals(1, agent.goals.size)
        }

        @Test
        fun `agent runs`() {
            val agent: Agent = userInputToFrogOrPersonBranch()
            val ap = dummyAgentPlatform()
            val processOptions = ProcessOptions()
            val result = ap.runAgentFrom(
                agent = agent,
                processOptions = processOptions,
                bindings = mapOf(
                    "it" to UserInput("do something")
                ),
            )
            assertEquals(AgentProcessStatusCode.COMPLETED, result.status)
            assertEquals(
                1,
                result.processContext.agentProcess.history.size,
                "Expected history:\nActual:\n${result.processContext.agentProcess.history.joinToString("\n")}"
            )
            assertTrue(result.lastResult() is SpiPerson)
        }
    }

    @Nested
    inner class Chain {
        @Test
        fun `metadata is correct`() {
            val agent: Agent = userInputToFrogChain()
            assertEquals("uitf", agent.name)
            assertEquals("Evil frogly wizard", agent.description)
            assertEquals(Semver.DEFAULT_VERSION, agent.version.value)
            assertEquals(0, agent.conditions.size, "Should have no conditions")
            assertEquals(2, agent.actions.size, "Should have 2 actions")
            assertEquals(1, agent.goals.size, "Should have 2 goals")
        }

        @Test
        fun `agent runs`() {
            val agent: Agent = userInputToFrogChain()
            val ap = dummyAgentPlatform()
            val processOptions = ProcessOptions()
            val result = ap.runAgentFrom(
                agent = agent,
                processOptions = processOptions,
                bindings = mapOf(
                    "it" to UserInput("do something")
                ),
            )
            assertEquals(AgentProcessStatusCode.COMPLETED, result.status)
            assertEquals(
                2,
                result.processContext.agentProcess.history.size,
                "Expected history:\nActual:\n${result.processContext.agentProcess.history.joinToString("\n")}"
            )
            assertTrue(result.lastResult() is Frog)
        }
    }

    @Nested
    inner class AndThen {
        @Test
        fun `metadata is correct`() {
            val agent: Agent = userInputToFrogAndThenDo()
            assertEquals("uitf", agent.name)
            assertEquals("Evil frogly wizard", agent.description)
            assertEquals(Semver.DEFAULT_VERSION, agent.version.value)
            assertEquals(0, agent.conditions.size, "Should have no conditions")
            assertEquals(2, agent.actions.size, "Should have 2 actions")
            assertEquals(1, agent.goals.size)
        }

        @Test
        fun `agent runs andThen`() {
            val agent: Agent = userInputToFrogAndThen()
            val ap = dummyAgentPlatform()
            val processOptions = ProcessOptions()
            val result = ap.runAgentFrom(
                agent = agent,
                processOptions = processOptions,
                bindings = mapOf(
                    "it" to UserInput("do something")
                ),
            )
            assertEquals(AgentProcessStatusCode.COMPLETED, result.status)
            assertEquals(
                2,
                result.processContext.agentProcess.history.size,
                "Expected history:\nActual:\n${result.processContext.agentProcess.history.joinToString("\n")}"
            )
            assertTrue(result.lastResult() is Frog)
        }

        @Test
        fun `agent runs andThenDo`() {
            val agent: Agent = userInputToFrogAndThenDo()
            val ap = dummyAgentPlatform()
            val processOptions = ProcessOptions()
            val result = ap.runAgentFrom(
                agent = agent,
                processOptions = processOptions,
                bindings = mapOf(
                    "it" to UserInput("do something")
                ),
            )
            assertEquals(AgentProcessStatusCode.COMPLETED, result.status)
            assertEquals(
                2,
                result.processContext.agentProcess.history.size,
                "Expected history:\nActual:\n${result.processContext.agentProcess.history.joinToString("\n")}"
            )
            assertTrue(result.lastResult() is Frog)
        }

        @Test
        fun `agent runs andThen chain`() {
            val agent: Agent = userInputToFrogAndThenAgain()
            val ap = dummyAgentPlatform()
            val processOptions = ProcessOptions()
            val result = ap.runAgentFrom(
                agent = agent,
                processOptions = processOptions,
                bindings = mapOf(
                    "it" to UserInput("do something")
                ),
            )
            assertEquals(AgentProcessStatusCode.COMPLETED, result.status)
            assertEquals(
                3,
                result.processContext.agentProcess.history.size,
                "Expected history:\nActual:\n${result.processContext.agentProcess.history.joinToString("\n")}"
            )
            assertTrue(result.lastResult() is Wumpus)
        }
    }

    @Nested
    inner class Aggregate {
        @Test
        fun `metadata is correct`() {
            val agent: Agent = simpleNamer()
            assertEquals("Thing namer", agent.name)
            assertEquals("Name a thing, using internet research", agent.description)
            assertEquals(DEFAULT_VERSION, agent.version.value)
            assertEquals(1, agent.conditions.size, "Should have join condition")
            assertEquals(3, agent.actions.size, "Should have actions")
            assertEquals(1, agent.goals.size)
        }

        @Test
        fun `agent runs`() {
            var count = 0
            val agent: Agent = simpleNamer { ++count }
            val ap = dummyAgentPlatform()
            val processOptions = ProcessOptions()
            val result = ap.runAgentFrom(
                agent = agent,
                processOptions = processOptions,
                bindings = mapOf(
                    "it" to UserInput("do something")
                ),
            )
            assertEquals(AgentProcessStatusCode.COMPLETED, result.status)
            assertEquals(2, count, "All transforms should have been invoked")
            assertEquals(
                3, result.processContext.agentProcess.history.size,
                "Expected history:\nActual:\n${result.processContext.agentProcess.history.joinToString("\n")}"
            )
            assertTrue(result.lastResult() is AllNames)
        }

        @Test
        fun `agent runs with listMaker`() {
            val agent: Agent = factCheckerAgent(listOf(mockk()), FactCheckerProperties())
            val ap = dummyAgentPlatform()
            val processOptions = ProcessOptions()
            val result = ap.runAgentFrom(
                agent = agent,
                processOptions = processOptions,
                bindings = mapOf(
                    "it" to UserInput("do something")
                ),
            )
            assertEquals(
                AgentProcessStatusCode.COMPLETED,
                result.status,
                "Result wasn't completed: ${result.failureInfo}",
            )
//            assertEquals(
//                3,
//                result.processContext.agentProcess.history.size,
//                "Expected history:\nActual:\n${result.processContext.agentProcess.history.joinToString("\n")}"
//            )
            assertTrue(
                result.lastResult() is FactCheck,
                "Result wasn't fact check: ${result.lastResult()}",
            )
            println(result.lastResult())
        }
    }

    @Nested
    inner class BiAggregate {
        @Test
        fun `metadata is correct`() {
            val agent: Agent = biAggregate()
            assertEquals("biAggregate", agent.name)
            assertEquals(DEFAULT_VERSION, agent.version.value)
            assertEquals(1, agent.conditions.size, "Should have join condition")
            assertEquals(4, agent.actions.size, "Should have actions")
            assertEquals(1, agent.goals.size)
        }

        @Test
        fun `agent runs`() {
            val agent: Agent = biAggregate()
            val ap = dummyAgentPlatform()
            val processOptions = ProcessOptions()
            val result = ap.runAgentFrom(
                agent = agent,
                processOptions = processOptions,
                bindings = mapOf(
                    "it" to UserInput("do something")
                ),
            )
            assertEquals(AgentProcessStatusCode.COMPLETED, result.status)
            assertEquals(
                4,
                result.processContext.agentProcess.history.size,
                "Expected history:\nActual:\n${result.processContext.agentProcess.history.joinToString("\n")}",
            )
            assertTrue(result.lastResult() is AllNames)
        }
    }

    @Nested
    inner class Nesting {
        @Test
        fun `metadata is correct`() {
            val agent = nestingByName()

            assertEquals(1, agent.conditions.size, "Should have join condition")
            assertEquals(4, agent.actions.size, "Should have actions")
            assertEquals(1, agent.goals.size)
        }

        @Test
        fun `fails without agent`() {
            val agent = nestingByName()
            val ap = dummyAgentPlatform()
            val processOptions = ProcessOptions()
            assertThrows<IllegalArgumentException> {
                ap.runAgentFrom(
                    agent = agent,
                    processOptions = processOptions,
                    bindings = mapOf(
                        "it" to UserInput("do something")
                    ),
                )
            }
        }

        @Test
        fun `by reference - agent runs`() {
            val agent = nestingByReference()
            val ap = dummyAgentPlatform()
            val processOptions = ProcessOptions()
            val result = ap.runAgentFrom(
                agent = agent,
                processOptions = processOptions,
                bindings = mapOf(
                    "it" to UserInput("do something")
                ),
            )
            assertEquals(AgentProcessStatusCode.COMPLETED, result.status)
            assertEquals(
                4,
                result.processContext.agentProcess.history.size,
                "Expected history:\nActual:\n${result.processContext.agentProcess.history.joinToString("\n")}"
            )
            assertTrue(result.lastResult() is AllNames)
            assertTrue(result.objectsOfType<Thing>().isNotEmpty(), "Should have got interim result from agent")
        }


        @Test
        fun `by name - agent runs`() {
            val agent = nestingByName()
            val ap = dummyAgentPlatform()
            ap.deploy(agent(name = "foobar", description = "doesn't matter here") {
                transformation<UserInput, Thing>("foobar") {
                    Thing(it.input.content)
                }
                goal("name", "description", satisfiedBy = Thing::class)
            }
            )
            val processOptions = ProcessOptions()
            val result = ap.runAgentFrom(
                agent = agent,
                processOptions = processOptions,
                bindings = mapOf(
                    "it" to UserInput("do something")
                ),
            )
            assertEquals(AgentProcessStatusCode.COMPLETED, result.status)
            assertEquals(
                4,
                result.processContext.agentProcess.history.size,
                "Expected history:\nActual:\n${result.processContext.agentProcess.history.joinToString("\n")}"
            )
            assertTrue(result.lastResult() is AllNames)
            assertTrue(result.objectsOfType<Thing>().isNotEmpty(), "Should have got interim result from agent")
        }
    }

    @Nested
    inner class Redo {
        @Test
        fun `metadata is correct`() {
            val agent: Agent = redoNamer()
            assertEquals("Thing namer", agent.name)
            assertEquals("Name a thing, using internet research, repeating until we are happy", agent.description)
            assertEquals(Semver.DEFAULT_VERSION, agent.version.value)
            assertEquals(1, agent.conditions.size, "Should have join condition")
            assertEquals(5, agent.actions.size, "Should have actions")
            assertEquals(1, agent.goals.size)
        }

        @Test
        fun `agent runs`() {
            val agent: Agent = redoNamer()
            val ap = dummyAgentPlatform()
            val processOptions = ProcessOptions()
            val result = ap.runAgentFrom(
                agent = agent,
                processOptions = processOptions,
                bindings = mapOf(
                    "it" to UserInput("do something")
                ),
            )
            assertEquals(AgentProcessStatusCode.COMPLETED, result.status)
            assertEquals(
                1,
                result.processContext.agentProcess.history.size,
                "Will have short history in top level process"
            )
            assertTrue(result.lastResult() is AllNames)
        }
    }
}

data class GeneratedName(
    val name: String,
    val reason: String,
)

data class GeneratedNames(val names: List<GeneratedName>)
data class AllNames(
    val accepted: List<GeneratedName>,
    val rejected: List<GeneratedName>,
)

data class Garden(val name: String)

fun splitGarden() = agent("splitter", description = "splitter0") {

    transformation<UserInput, Garden> { Garden(it.input.content) }

    flow {
        split<Garden, Frog> {
            listOf(Frog("Kermit"), Frog("Freddo"))
        } andThenDo {
            SnakeMeal(it.objects.filterIsInstance<Frog>())
        }
    }

    goal(
        name = "snakeFed",
        description = "We are satisfied with generated names",
        satisfiedBy = SnakeMeal::class,
    )
}

fun userInputToFrogOrPersonBranch() = agent("brancher", description = "brancher0") {

    flow {
        branch<UserInput, SpiPerson, Frog> { Branch(SpiPerson(it.input.content)) }
    }

    goal(name = "namingDone", description = "We are satisfied with generated names", satisfiedBy = SpiPerson::class)
}

fun userInputToFrogChain() = agent("uitf", description = "Evil frogly wizard") {

    flow {
        chain<UserInput, SpiPerson, Frog>(
            { SpiPerson(it.input.content) },
            { Frog(it.input.name) },
        )
    }

    goal(name = "namingDone", description = "We are satisfied with generated names", satisfiedBy = Frog::class)
}

fun userInputToFrogAndThenDo() = agent("uitf", description = "Evil frogly wizard") {

    fun toSpiPerson(userInput: UserInput) = SpiPerson(userInput.content)

    flow {
        ::toSpiPerson andThenDo { Frog(it.input.name) }
    }

    goal(name = "namingDone", description = "We are satisfied with generated names", satisfiedBy = Frog::class)
}

fun userInputToFrogAndThen() = agent("uitf", description = "Evil frogly wizard") {

    fun toSpiPerson(userInput: UserInput) = SpiPerson(userInput.content)

    flow {
        ::toSpiPerson andThen { Frog(it.name) }
    }

    goal(name = "namingDone", description = "We are satisfied with generated names", satisfiedBy = Frog::class)
}

fun userInputToFrogAndThenAgain() = agent("uitf", description = "Evil frogly wizard") {

    fun toSpiPerson(userInput: UserInput) = SpiPerson(userInput.content)

    flow {
        ::toSpiPerson andThen { Frog(it.name) } andThen { Wumpus(it.name) }
    }

    goal(
        name = "namingDone", description = "We are satisfied with generated names",
        satisfiedBy = Wumpus::class
    )
}

fun simpleNamer(transformListener: () -> Unit = {}) =
    agent("Thing namer", description = "Name a thing, using internet research") {

        flow {
            aggregate<UserInput, GeneratedNames, AllNames>(
                transforms = listOf(
                    {
                        transformListener()
                        GeneratedNames(names = emptyList())
                    },
                    {
                        transformListener()
                        GeneratedNames(
                            names = listOf(
                                GeneratedName(
                                    "money.com",
                                    "Helps make money"
                                )
                            )
                        )
                    }),
                merge = { list, _ ->
                    AllNames(
                        accepted = list.flatMap { it.names }.distinctBy { it.name },
                        rejected = emptyList()
                    )
                },
            )
        }

        goal(name = "namingDone", description = "We are satisfied with generated names", satisfiedBy = AllNames::class)
    }


fun redoNamer() =
    agent(
        name = "Thing namer",
        description = "Name a thing, using internet research, repeating until we are happy"
    ) {

        flow {
            repeat<AllNames>(
                what = {
                    repeatableAggregate<UserInput, GeneratedNames, AllNames>(
                        startWith = AllNames(accepted = emptyList(), rejected = emptyList()),
                        transforms = listOf(
                            {
                                GeneratedNames(
                                    names = listOf(
                                        GeneratedName(
                                            MobyNameGenerator.generateName(),
                                            "Helps make money"
                                        )
                                    )
                                )
                            },
                            { GeneratedNames(names = listOf(GeneratedName("money.com", "Helps make money"))) }),
                        merge = { generatedNamesList ->
                            AllNames(
                                accepted = generatedNamesList.flatMap { it.names }.distinctBy { it.name },
                                rejected = emptyList()
                            )
                        },
                    )
                },
                until = { it, _ ->
                    it.accepted.size > 5
                })
        }

        goal(name = "namingDone", description = "We are satisfied with generated names", satisfiedBy = AllNames::class)
    }

data class Thing(val t: String)

fun nestingByName() = agent("nesting test", description = "Nesting test") {

    referencedAgentAction<UserInput, Thing>(agentName = "foobar")

    flow {
        aggregate<Thing, GeneratedNames, AllNames>(
            transforms = listOf(
                { GeneratedNames(names = emptyList()) },
                { GeneratedNames(names = listOf(GeneratedName("money.com", "Helps make money"))) }),
            merge = { generatedNamesList, _ ->
                AllNames(
                    accepted = generatedNamesList.flatMap { it.names }.distinctBy { it.name },
                    rejected = emptyList()
                )
            },
        )
    }

    goal(name = "namingDone", description = "We are satisfied with generated names", satisfiedBy = AllNames::class)
}

fun nestingByReference() = agent("nesting test", description = "Nesting test") {

    localAgentAction<UserInput, Thing>(
        agent(name = "foobar", description = "doesn't matter here") {
            transformation<UserInput, Thing>("foobar") {
                Thing(it.input.content)
            }
            goal("name", "description", satisfiedBy = Thing::class)
        })
    flow {
        aggregate<Thing, GeneratedNames, AllNames>(
            transforms = listOf(
                { GeneratedNames(names = emptyList()) },
                { GeneratedNames(names = listOf(GeneratedName("money.com", "Helps make money"))) }),
            merge = { generatedNamesList, _ ->
                AllNames(
                    accepted = generatedNamesList.flatMap { it.names }.distinctBy { it.name },
                    rejected = emptyList()
                )
            },
        )
    }

    goal(name = "namingDone", description = "We are satisfied with generated names", satisfiedBy = AllNames::class)
}

fun biAggregate() = agent("biAggregate", description = "Nesting test") {

    transformation<UserInput, Thing>("foo") {
        Thing(it.input.content)
    }

    flow {
        biAggregate<UserInput, Thing, GeneratedNames, AllNames>(
            transforms = listOf(
                { GeneratedNames(names = emptyList()) },
                { GeneratedNames(names = listOf(GeneratedName("money.com", "Helps make money"))) }),
            merge = { generatedNamesList ->
                AllNames(
                    accepted = generatedNamesList.flatMap { it.names }.distinctBy { it.name },
                    rejected = emptyList()
                )
            },
        )
    }

    goal(name = "namingDone", description = "We are satisfied with generated names", satisfiedBy = AllNames::class)
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/dsl/dslAgents.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.dsl

import com.embabel.agent.core.Export
import com.embabel.agent.domain.io.UserInput

data class MagicVictim(
    val name: String,
)

data class Frog(
    val name: String,
)

val EvilWizardAgent = agent("EvilWizard", description = "Turn a person into a frog") {

    transformation<UserInput, MagicVictim>(name = "thing") {
        MagicVictim(name = "Hamish")
    }

    promptedTransformer<MagicVictim, Frog>(name = "turn-into-frog") {
        "Turn the person named ${it.input.name} into a frog"

    }

    goal(name = "done", description = "done", satisfiedBy = Frog::class)
}

data class SnakeMeal(val frogs: List<Frog>)

fun evenMoreEvilWizard() = agent("EvenMoreEvilWizard", description = "Turn a person into a frog") {

    transformation<UserInput, MagicVictim>(name = "thing") {
        MagicVictim(name = "Hamish")
    }

    flow {
        aggregate<MagicVictim, Frog, SnakeMeal>(
            transforms = listOf({ Frog(it.input.name) }, { Frog("2") }, { Frog("3") }),
            merge = { frogs, _ -> SnakeMeal(frogs) },
        )
    }

    goal(
        name = "done",
        description = "done",
        satisfiedBy = SnakeMeal::class,
        export = Export(
            startingInputTypes = setOf(MagicVictim::class.java),
        ),
    )
}

fun exportedEvenMoreEvilWizard() = agent("EvenMoreEvilWizard", description = "Turn a person into a frog") {

    transformation<UserInput, MagicVictim>(name = "thing") {
        MagicVictim(name = "Hamish")
    }

    flow {
        aggregate<MagicVictim, Frog, SnakeMeal>(
            transforms = listOf({ Frog(it.input.name) }, { Frog("2") }, { Frog("3") }),
            merge = { frogs, _ -> SnakeMeal(frogs) },
        )
    }

    goal(
        name = "done",
        description = "done",
        satisfiedBy = SnakeMeal::class,
        export = Export(remote = true, startingInputTypes = setOf(MagicVictim::class.java)),
    )
}

fun evenMoreEvilWizardWithStructuredInput() =
    agent("EvenMoreEvilWizardWithStructuredInput", description = "Turn a person into a frog") {

        transformation<UserInput, MagicVictim>(name = "thing") {
            MagicVictim(name = "Hamish")
        }

        flow {
            aggregate<MagicVictim, Frog, SnakeMeal>(
                transforms = listOf({ Frog(it.input.name) }, { Frog("2") }, { Frog("3") }),
                merge = { frogs, _ -> SnakeMeal(frogs) },
            )
        }

        goal(
            name = "done",
            description = "done",
            satisfiedBy = SnakeMeal::class,
            export = Export(
                remote = true,
                startingInputTypes = setOf(MagicVictim::class.java),
            ),
        )
    }



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/dsl/MapperParallelTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.dsl

import com.embabel.agent.api.common.OperationContext
import io.mockk.mockk
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertTimeoutPreemptively
import java.time.Duration
import java.util.concurrent.atomic.AtomicInteger

class MapperParallelTest {
    private val context = mockk<OperationContext>()

    @Nested
    inner class ParallelMap {
        @Test
        fun `test parallelMap produces correct results`() {
            val list = (1..10).toList()
            val result = list.parallelMap(context) { it * 2 }
            assertEquals(list.map { it * 2 }, result)
        }

        @Test
        fun `test parallelMap is parallel`() {
            val n = 8
            val list = (1..n).toList()
            val started = AtomicInteger(0)
            val maxConcurrent = AtomicInteger(0)
            val concurrencyLevel = 4

            val results = assertTimeoutPreemptively(Duration.ofMillis(300)) {
                list.parallelMap(context, concurrencyLevel) { elt ->
                    val current = started.incrementAndGet()
                    maxConcurrent.updateAndGet { it.coerceAtLeast(current) }
                    Thread.sleep(100)
                    started.decrementAndGet()
                    elt * 2
                }
            }
            assertEquals(
                list.map { it * 2 },
                results.sorted(),
                "Results should match expected values"
            )
            // Should have reached at least the concurrency level
            assert(maxConcurrent.get() >= concurrencyLevel) { "Did not parallelize as expected" }
        }
    }

    @Nested
    inner class MapAsync {
        @Test
        fun `test mapAsync produces correct results`() = kotlinx.coroutines.runBlocking {
            val list = (1..10).toList()
            val result = list.mapAsync(context) { it + 1 }
            assertEquals(list.map { it + 1 }, result)
        }

//        @Test
//        fun `test mapAsync is parallel`() = kotlinx.coroutines.runBlocking {
//            val n = 8
//            val list = (1..n).toList()
//            val started = AtomicInteger(0)
//            val maxConcurrent = AtomicInteger(0)
//            val concurrencyLevel = 4
//            val results = CopyOnWriteArrayList<Int>()
//
//            assertTimeoutPreemptively(Duration.ofMillis(300)) {
//                list.mapAsync(context, concurrencyLevel, Dispatchers.Default) {
//                    val current = started.incrementAndGet()
//                    maxConcurrent.updateAndGet { Math.max(it, current) }
//                    kotlinx.coroutines.delay(100)
//                    results.add(it)
//                    started.decrementAndGet()
//                    it + 1
//                }
//            }
//            assertEquals(list.map { it + 1 }, results.sorted())
//            assert(maxConcurrent.get() >= concurrencyLevel) { "Did not parallelize as expected" }
//        }
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/dsl/MapperTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.dsl

import com.embabel.agent.api.common.OperationContext
import io.mockk.mockk
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.runBlocking
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Disabled
import org.junit.jupiter.api.Test
import java.util.*
import java.util.concurrent.atomic.AtomicInteger
import kotlin.system.measureTimeMillis

class MapperTest {

    private val context = mockk<OperationContext>()

    @Test
    @Disabled("Flaky test, needs investigation")
    fun `parallelMap should process items concurrently`() {
        val items = (1..100).toList()
        val counter = AtomicInteger(0)
        val processingTracker = mutableListOf<Int>()

        val results = items.parallelMap(context) { item ->
            val currentCount = counter.incrementAndGet()
            processingTracker.add(currentCount)
            Thread.sleep(10) // Simulate some work
            item * 2
        }

        // Verify all items were processed
        assertEquals(items.size, results.size)
        assertEquals(items.map { it * 2 }, results)

        // Verify concurrent processing by checking that some items were processed
        // while others were still in progress (counter should have jumps)
        val hasNonSequentialProcessing = processingTracker.zipWithNext().any { (a, b) -> b - a > 1 }
        assertTrue(hasNonSequentialProcessing, "Processing should be concurrent, not sequential")
    }

    @Test
    fun `mapAsync should process items concurrently`() = runBlocking {
        val items = (1..100).toList()
        val counter = AtomicInteger(0)
        val processingTracker = Collections.synchronizedList(mutableListOf<Int>())
        val random = Random(System.currentTimeMillis())
        val results = items.mapAsync(context) { item ->
            val currentCount = counter.incrementAndGet()
            val bias = 1 + ((items.size - item) / 50)   // 1..3
            val delayMs = random.nextInt(
                5 * bias,
                5 + 5 * bias
            ) //early ones run for longer times 5ms to 10ms, 10ms to 15ms and 15ms to 20ms
            delay(delayMs.toLong())
            processingTracker.add(currentCount)
            item * 2
        }

        assertEquals(items.size, results.size)
        assertEquals(items.map { it * 2 }, results)

        // Verify concurrent processing by checking that some items were processed
        // while others were still in progress (counter should have jumps)
        val hasNonSequentialProcessing = processingTracker.zipWithNext().any { (a, b) -> b - a > 1 }
        assertTrue(hasNonSequentialProcessing, "Processing should be concurrent, not sequential")

    }

    @Test
    fun `parallelMap should respect concurrencyLevel`() {
        val items = (1..100).toList()
        val concurrencyLevel = 5
        val activeThreads = AtomicInteger(0)
        val maxActiveThreads = AtomicInteger(0)

        items.parallelMap(context, concurrencyLevel = concurrencyLevel) { item ->
            val current = activeThreads.incrementAndGet()
            maxActiveThreads.set(maxOf(current, maxActiveThreads.get()))
            Thread.sleep(50) // Ensure overlap
            activeThreads.decrementAndGet()
            item * 2
        }

        // The max active threads should be approximately equal to the concurrency level
        // We allow some flexibility since thread scheduling isn't perfectly predictable
        assertTrue(maxActiveThreads.get() <= concurrencyLevel + 2)
        assertTrue(maxActiveThreads.get() >= concurrencyLevel - 2)
    }

    @Test
    fun `mapAsync should respect concurrencyLevel`() = runBlocking {
        val items = (1..100).toList()
        val concurrencyLevel = 5
        val activeThreads = AtomicInteger(0)
        val maxActiveThreads = AtomicInteger(0)

        items.mapAsync(context, concurrencyLevel = concurrencyLevel) { item ->
            val current = activeThreads.incrementAndGet()
            maxActiveThreads.set(maxOf(current, maxActiveThreads.get()))
            delay(50) // Ensure overlap
            activeThreads.decrementAndGet()
            item * 2
        }

        // The max active threads should be approximately equal to the concurrency level
        // We allow some flexibility since thread scheduling isn't perfectly predictable
        assertTrue(maxActiveThreads.get() <= concurrencyLevel + 2)
        assertTrue(maxActiveThreads.get() >= concurrencyLevel - 2)
    }

    @Test
    fun `parallelMap should be faster than sequential processing`() {
        val items = (1..20).toList()

        // Sequential processing time
        val sequentialTime = measureTimeMillis {
            items.map {
                Thread.sleep(100) // Simulate work
                it * 2
            }
        }

        // Parallel processing time
        val parallelTime = measureTimeMillis {
            items.parallelMap(context, concurrencyLevel = 10) {
                Thread.sleep(100) // Same work
                it * 2
            }
        }

        // Parallel should be significantly faster
        assertTrue(
            parallelTime < sequentialTime / 2,
            "Parallel processing ($parallelTime ms) should be much faster than sequential processing ($sequentialTime ms)"
        )
    }

    @Test
    fun `mapAsync should be faster than sequential processing`() = runBlocking {
        val items = (1..20).toList()

        // Sequential processing time
        val sequentialTime = measureTimeMillis {
            items.map {
                Thread.sleep(100) // Simulate work
                it * 2
            }
        }

        // Parallel processing time
        val parallelTime = measureTimeMillis {
            items.mapAsync(context, concurrencyLevel = 10) {
                delay(100) // Same work, coroutine-friendly
                it * 2
            }
        }

        // Parallel should be significantly faster
        assertTrue(
            parallelTime < sequentialTime / 2,
            "Parallel processing ($parallelTime ms) should be much faster than sequential processing ($sequentialTime ms)"
        )
    }

    @Test
    fun `parallelMap should handle empty collections`() {
        val emptyList = emptyList<Int>()
        val result = emptyList.parallelMap(context) { it * 2 }
        assertTrue(result.isEmpty())
    }

    @Test
    fun `mapAsync should handle empty collections`() = runBlocking {
        val emptyList = emptyList<Int>()
        val result = emptyList.mapAsync(context) { it * 2 }
        assertTrue(result.isEmpty())
    }

    @Test
    fun `parallelMap should use specified dispatcher`() {
        val items = (1..10).toList()
        val customDispatcher = Dispatchers.IO

        // Just verify it doesn't crash with custom dispatcher
        val results = items.parallelMap(context, dispatcher = customDispatcher) { it * 2 }
        assertEquals(items.map { it * 2 }, results)
    }

    @Test
    fun `mapAsync should use specified dispatcher`() = runBlocking {
        val items = (1..10).toList()
        val customDispatcher = Dispatchers.IO

        // Just verify it doesn't crash with custom dispatcher
        val results = items.mapAsync(context, dispatcher = customDispatcher) { it * 2 }
        assertEquals(items.map { it * 2 }, results)
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/dsl/ParallelizationTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.dsl

import com.embabel.agent.api.common.OperationContext
import io.mockk.mockk
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.runBlocking
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Test
import java.util.*
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicInteger

class ParallelizationTest {

    private val context = mockk<OperationContext>()

    @Test
    fun `parallelMap should handle high concurrency workloads`() {
        val itemCount = 100
        val items = (1..itemCount).toList()
        val concurrencyLevel = 500

        // Track maximum concurrent executions
        val concurrentExecutions = AtomicInteger(0)
        val maxConcurrentExecutions = AtomicInteger(0)

        val results = items.parallelMap(
            context = context,
            concurrencyLevel = concurrencyLevel,
        ) { item ->
            val current = concurrentExecutions.incrementAndGet()
            val max = maxConcurrentExecutions.getAndUpdate { prev -> maxOf(prev, current) }

            // Small delay to ensure overlap
            Thread.sleep(5)

            concurrentExecutions.decrementAndGet()
            item * 2
        }

        // Verify results
        assertEquals(items.size, results.size)
        assertEquals(items.map { it * 2 }, results)

        assertTrue(
            maxConcurrentExecutions.get() <= concurrencyLevel + 5,
            "Expected no more than ${concurrencyLevel + 5} concurrent executions, but got ${maxConcurrentExecutions.get()}"
        )
    }

    @Test
    fun `mapAsync should handle high concurrency workloads`() = runBlocking {
        val itemCount = 1000
        val items = (1..itemCount).toList()
        val concurrencyLevel = 50

        // Track maximum concurrent executions
        val concurrentExecutions = AtomicInteger(0)
        val maxConcurrentExecutions = AtomicInteger(0)

        val results = items.mapAsync(context, concurrencyLevel = concurrencyLevel) { item ->
            val current = concurrentExecutions.incrementAndGet()
            val max = maxConcurrentExecutions.getAndUpdate { prev -> maxOf(prev, current) }

            // Small delay to ensure overlap
            delay(5)

            concurrentExecutions.decrementAndGet()
            item * 2
        }

        // Verify results
        assertEquals(items.size, results.size)
        assertEquals(items.map { it * 2 }, results)

        // Verify concurrency was utilized (should be close to our concurrencyLevel)
        assertTrue(
            maxConcurrentExecutions.get() >= concurrencyLevel / 2,
            "Expected at least ${concurrencyLevel / 2} concurrent executions, but got ${maxConcurrentExecutions.get()}"
        )
        assertTrue(
            maxConcurrentExecutions.get() <= concurrencyLevel + 5,
            "Expected no more than ${concurrencyLevel + 5} concurrent executions, but got ${maxConcurrentExecutions.get()}"
        )
    }

    @Test
    fun `parallelMap should enforce concurrency limits under high load`() {
        val itemCount = 500
        val items = (1..itemCount).toList()
        val concurrencyLevel = 10

        // Use a latch to synchronize all tasks to start at the same time
        val startLatch = CountDownLatch(1)
        val concurrentExecutions = AtomicInteger(0)
        val maxConcurrentExecutions = AtomicInteger(0)
        val random = Random()
        val results = items.parallelMap(
            context, concurrencyLevel = concurrencyLevel,
            dispatcher = Dispatchers.Default
        ) { item ->
            // Wait for the signal to start
            startLatch.await(
                random.nextInt(1, 100).toLong(), TimeUnit.MILLISECONDS
            )

            val current = concurrentExecutions.incrementAndGet()
            maxConcurrentExecutions.updateAndGet { prev -> maxOf(prev, current) }

            // Hold the permit for a bit
            Thread.sleep(random.nextInt(1, 20).toLong())
            concurrentExecutions.decrementAndGet()
            item * 2
        }

        // Release the latch to start all tasks
        startLatch.countDown()

        // Verify results
        assertEquals(items.size, results.size)

        // Verify concurrency was strictly limited
        assertTrue(
            maxConcurrentExecutions.get() <= concurrencyLevel,
            "Expected no more than $concurrencyLevel concurrent executions, but got ${maxConcurrentExecutions.get()}"
        )
    }

    @Test
    fun `mapAsync should maintain result order regardless of completion order`() = runBlocking {
        val items = (1..100).toList()

        val results = items.mapAsync(context, concurrencyLevel = 20) { item ->
            // Make items with even indices take longer to complete
            if (item % 2 == 0) {
                delay(50)
            } else {
                delay(10)
            }
            item * 2
        }

        // Verify results are in the correct order despite different completion times
        assertEquals(items.map { it * 2 }, results)
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/api/dsl/support/PromptTransformerKtTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.api.dsl.support

import com.embabel.agent.api.dsl.Frog
import com.embabel.agent.api.dsl.MagicVictim
import com.embabel.agent.core.*
import com.embabel.agent.core.support.InMemoryBlackboard
import com.embabel.chat.Message
import com.embabel.common.ai.model.LlmOptions
import io.mockk.every
import io.mockk.mockk
import io.mockk.slot
import io.mockk.verify
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.springframework.ai.tool.ToolCallback


data class PromptPerson(
    val name: String,
    val age: Int,
)

data class Summary(val text: String)

class PromptTransformerKtTest {

    @Nested
    inner class PromptTransformer {

        @Test
        fun `test prompt`() {
            val transformer = promptTransformer<MagicVictim, Frog>(
                name = "frogger",
                inputClass = MagicVictim::class.java,
                outputClass = Frog::class.java,
            ) {
                "Turn the person named ${it.input.name} into a frog"
            }
            val magicVictim = MagicVictim(name = "Marmaduke")
            val blackboard = InMemoryBlackboard()
            val frog = Frog(name = "Marmaduke")
            val mockAgentProcess = mockk<AgentProcess>()
            val processContext = mockk<ProcessContext>()
            every { mockAgentProcess.processContext } returns processContext
            every { processContext.blackboard } returns blackboard
            every { processContext.agentProcess } returns mockAgentProcess
            every {
                processContext.getValue(
                    IoBinding.DEFAULT_BINDING,
                    MagicVictim::class.java.name
                )
            } returns magicVictim
            val promptSlot = slot<List<Message>>()
            every {
                processContext.createObject(
                    capture(promptSlot),
                    any(),
                    Frog::class.java,
                    mockAgentProcess,
                    transformer
                )
            } returns frog
            transformer.execute(processContext)
        }

        @Test
        fun `transformer should use custom input and output variable names`() {
            val transformer = promptTransformer<PromptPerson, Summary>(
                name = "summarizer",
                inputVarName = "person",
                outputVarName = "summary",
                inputClass = PromptPerson::class.java,
                outputClass = Summary::class.java,
            ) {
                "Summarize information about ${it.input.name} who is ${it.input.age} years old"
            }

//            assertEquals("person", transformer.inputVarName)
//            assertEquals("summary", transformer.outputVarName)

            val person = PromptPerson(name = "John", age = 30)
            val summary = Summary(text = "John is 30 years old")
            val mockAgentProcess = mockk<AgentProcess>()
            val processContext = mockk<ProcessContext>()

            every { mockAgentProcess.processContext } returns processContext
            every { processContext.blackboard } returns InMemoryBlackboard()
            every { processContext.agentProcess } returns mockAgentProcess
            every { processContext.getValue("person", PromptPerson::class.java.name) } returns person
            every {
                processContext.createObject(
                    any(),
                    any(),
                    Summary::class.java,
                    mockAgentProcess,
                    transformer
                )
            } returns summary

            transformer.execute(processContext = processContext)

            verify { processContext.getValue("person", PromptPerson::class.java.name) }
        }

        @Test
        fun `transformer should handle pre and post conditions`() {
            val preCondition = mockk<Condition>()
            val postCondition = mockk<Condition>()

            every { preCondition.name } returns "preCheck"
            every { postCondition.name } returns "postCheck"

            val transformer = promptTransformer<MagicVictim, Frog>(
                name = "conditionalTransformer",
                pre = listOf(preCondition),
                post = listOf(postCondition),
                inputClass = MagicVictim::class.java,
                outputClass = Frog::class.java,
            ) {
                "Transform ${it.input.name}"
            }

            assertEquals(listOf("preCheck"), transformer.pre)
            assertEquals(listOf("postCheck"), transformer.post)
        }

        @Test
        fun `transformer should handle custom LLM options`() {
            val customLlmOptions = LlmOptions().withTemperature(temperature = 0.7)

            val transformer = promptTransformer(
                name = "customLlmTransformer",
                llm = customLlmOptions,
                inputClass = MagicVictim::class.java,
                outputClass = Frog::class.java,
            ) {
                "Transform ${it.input.name}"
            }

            val magicVictim = MagicVictim(name = "Alice")
            val mockAgentProcess = mockk<AgentProcess>()
            val processContext = mockk<ProcessContext>()

            every { mockAgentProcess.processContext } returns processContext
            every { processContext.blackboard } returns InMemoryBlackboard()
            every { processContext.agentProcess } returns mockAgentProcess
            every {
                processContext.getValue(
                    IoBinding.DEFAULT_BINDING,
                    MagicVictim::class.java.name
                )
            } returns magicVictim
            every {
                processContext.createObject(
                    any(),
                    any(),
                    Frog::class.java,
                    mockAgentProcess,
                    transformer
                )
            } returns Frog(name = "Alice")

            transformer.execute(processContext = processContext)
        }

        @Test
        fun `transformer should handle tool groups and callbacks`() {
            val toolCallback = mockk<ToolCallback>()
            every { toolCallback.toolDefinition.name() } returns "test"
            val toolGroups = setOf(ToolGroupRequirement("math"), ToolGroupRequirement("web"))

            val transformer = promptTransformer<MagicVictim, Frog>(
                name = "toolTransformer",
                toolGroups = toolGroups.map { ToolGroupRequirement(it.role) }.toSet(),
                toolCallbacks = listOf(toolCallback),
                inputClass = MagicVictim::class.java,
                outputClass = Frog::class.java,
            ) {
                "Transform ${it.input.name}"
            }

            assertEquals(toolGroups, transformer.toolGroups)

            val magicVictim = MagicVictim(name = "Bob")
            val mockAgentProcess = mockk<AgentProcess>()
            val processContext = mockk<ProcessContext>()

            every { mockAgentProcess.processContext } returns processContext
            every { processContext.blackboard } returns InMemoryBlackboard()
            every { processContext.agentProcess } returns mockAgentProcess
            every {
                processContext.getValue(
                    IoBinding.DEFAULT_BINDING,
                    MagicVictim::class.java.name
                )
            } returns magicVictim
            every {
                processContext.createObject(
                    any(),
                    any(),
                    Frog::class.java,
                    mockAgentProcess,
                    transformer
                )
            } returns Frog(name = "Bob")

            transformer.execute(processContext = processContext)
        }

        @Test
        fun `transformer should handle rerunnable actions`() {
            val rerunnable = promptTransformer<MagicVictim, Frog>(
                name = "rerunnableTransformer",
                canRerun = true,
                inputClass = MagicVictim::class.java,
                outputClass = Frog::class.java,
            ) {
                "Transform ${it.input.name}"
            }

            val nonRerunnable = promptTransformer<MagicVictim, Frog>(
                name = "nonRerunnableTransformer",
                canRerun = false,
                inputClass = MagicVictim::class.java,
                outputClass = Frog::class.java,
            ) {
                "Transform ${it.input.name}"
            }

            assertTrue(rerunnable.canRerun)
            assertFalse(nonRerunnable.canRerun)
        }
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/channel/OutputChannelTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.channel

import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*

class OutputChannelTest {

    @Test
    fun `plus operator with DevNull and regular channel returns the regular channel`() {
        val regularChannel = TestOutputChannel("test")

        val result1 = DevNullOutputChannel + regularChannel
        val result2 = regularChannel + DevNullOutputChannel

        assertEquals(regularChannel, result1)
        assertEquals(regularChannel, result2)
    }

    @Test
    fun `plus operator with two DevNull channels returns DevNull`() {
        val result = DevNullOutputChannel + DevNullOutputChannel

        assertEquals(DevNullOutputChannel, result)
    }

    @Test
    fun `plus operator with two different regular channels returns MulticastOutputChannel`() {
        val channel1 = TestOutputChannel("channel1")
        val channel2 = TestOutputChannel("channel2")

        val result = channel1 + channel2

        assertTrue(result is MulticastOutputChannel)
    }

    @Test
    fun `plus operator creates MulticastOutputChannel that sends to all channels`() {
        val channel1 = TestOutputChannel("channel1")
        val channel2 = TestOutputChannel("channel2")
        val event = TestOutputChannelEvent("test-process")

        val multicastChannel = channel1 + channel2
        multicastChannel.send(event)

        assertEquals(1, channel1.receivedEvents.size)
        assertEquals(1, channel2.receivedEvents.size)
        assertEquals(event, channel1.receivedEvents[0])
        assertEquals(event, channel2.receivedEvents[0])
    }

    @Test
    fun `plus operator is associative - different groupings produce equivalent behavior`() {
        val channel1 = TestOutputChannel("channel1")
        val channel2 = TestOutputChannel("channel2")
        val channel3 = TestOutputChannel("channel3")
        val event = TestOutputChannelEvent("test-process")

        val result1 = (channel1 + channel2) + channel3
        val result2 = channel1 + (channel2 + channel3)

        result1.send(event)
        assertEquals(1, channel1.receivedEvents.size)
        assertEquals(1, channel2.receivedEvents.size)
        assertEquals(1, channel3.receivedEvents.size)

        channel1.receivedEvents.clear()
        channel2.receivedEvents.clear()
        channel3.receivedEvents.clear()

        result2.send(event)
        assertEquals(1, channel1.receivedEvents.size)
        assertEquals(1, channel2.receivedEvents.size)
        assertEquals(1, channel3.receivedEvents.size)
    }

    @Test
    fun `DevNullOutputChannel sends warning to logger`() {
        val event = TestOutputChannelEvent("test-process")

        assertDoesNotThrow {
            DevNullOutputChannel.send(event)
        }
    }

    @Test
    fun `MulticastOutputChannel handles exceptions from individual channels gracefully`() {
        val workingChannel = TestOutputChannel("working")
        val failingChannel = FailingOutputChannel()
        val event = TestOutputChannelEvent("test-process")

        val multicastChannel = workingChannel + failingChannel

        assertDoesNotThrow {
            multicastChannel.send(event)
        }

        assertEquals(1, workingChannel.receivedEvents.size)
        assertEquals(event, workingChannel.receivedEvents[0])
    }

    @Test
    fun `plus operator with multiple DevNull combinations`() {
        val regularChannel = TestOutputChannel("test")

        val result1 = DevNullOutputChannel + DevNullOutputChannel + regularChannel
        val result2 = regularChannel + DevNullOutputChannel + DevNullOutputChannel
        val result3 = DevNullOutputChannel + regularChannel + DevNullOutputChannel

        assertEquals(regularChannel, result1)
        assertEquals(regularChannel, result2)
        assertEquals(regularChannel, result3)
    }
}

class TestOutputChannel(private val name: String) : OutputChannel {
    val receivedEvents = mutableListOf<OutputChannelEvent>()

    override fun send(event: OutputChannelEvent) {
        receivedEvents.add(event)
    }

    override fun equals(other: Any?): Boolean {
        return other is TestOutputChannel && other.name == this.name
    }

    override fun hashCode(): Int {
        return name.hashCode()
    }

    override fun toString(): String {
        return "TestOutputChannel($name)"
    }
}

class FailingOutputChannel : OutputChannel {
    override fun send(event: OutputChannelEvent) {
        throw RuntimeException("This channel always fails")
    }
}

data class TestOutputChannelEvent(override val processId: String) : OutputChannelEvent



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/config/AgentPlatformPropertiesIntegrationTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config

import com.embabel.agent.api.common.autonomy.AutonomyProperties
import com.embabel.agent.spi.config.spring.AgentPlatformProperties
import com.embabel.agent.spi.config.spring.migration.DeprecatedPropertyScanningConfig
import com.embabel.agent.spi.support.DefaultProcessIdGeneratorProperties
import com.embabel.agent.web.sse.SseProperties
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Disabled
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.context.properties.EnableConfigurationProperties
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.context.annotation.Bean
import org.springframework.core.env.Environment
import org.springframework.test.context.ActiveProfiles
import org.springframework.test.context.TestPropertySource

/**
 * Integration tests for AgentPlatformProperties migration from legacy to unified configuration.
 *
 * ## Test Scope: Both Legacy and Platform Properties
 *
 * This test validates the **complete migration architecture** by testing:
 * 1. **AgentPlatformProperties** (unified configuration) - loads correctly from `embabel.agent.platform.*` properties
 * 2. **Legacy adapter classes** (AutonomyProperties, DefaultProcessIdGeneratorProperties, SseProperties) - get values from AgentPlatformProperties
 * 3. **Property binding precedence** - ensures test properties override defaults
 * 4. **E2E migration workflow** - validates that legacy code still works but now uses unified properties
 *
 * ## Expected Test Behavior
 *
 * ✅ **13 tests pass** - Unified properties and most legacy adapter functionality works correctly
 * ❌ **1 test fails intentionally** - `legacy properties should be bound from TestPropertySource`
 *
 * ### Expected Failure Explanation:
 * The failing test validates that **migration is working correctly**:
 * - **Test expectation**: Legacy properties (e.g., `embabel.autonomy.agent-confidence-cut-off=0.95`) should bind to legacy classes
 * - **Actual behavior**: Legacy classes now get values from unified properties (e.g., `embabel.agent.platform.autonomy.agent-confidence-cut-off=0.8`)
 * - **Why this is correct**: Post-migration, legacy adapter classes are sourced from AgentPlatformProperties, not original property names
 * - **Migration success indicator**: The "failure" proves the unified configuration is the single source of truth
 *
 * ## Spring Boot + Kotlin Complex Type Binding Analysis
 *
 * This test also investigates and documents Spring Boot property binding behavior with Kotlin classes,
 * specifically focusing on complex types (Lists, Maps, nested objects) and the val vs var implications.
 *
 * ### Key Findings & Official Documentation References:
 *
 * #### 1. Constructor Binding (val properties) - Kotlin Data Classes:
 * - **✅ Works**: Simple properties (String, Int, Boolean, Double) from any property source
 * - **✅ Works**: Complex properties (List, Map, nested objects) from YAML/@TestPropertySource
 * - **❌ Limited**: Complex properties from environment variables (unreliable/unsupported)
 * - **Auto-detection**: Kotlin data classes with all `val` parameters automatically use constructor binding
 * - **Reference**: https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.typesafe-configuration-properties.constructor-binding
 * - **Kotlin Integration**: https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.kotlin
 *
 * #### 2. Setter Binding (var properties) - Mutable Properties:
 * - **✅ Works**: All property types from all property sources (most reliable)
 * - **✅ Required**: For Map properties (Spring Boot official requirement)
 * - **✅ Recommended**: For List properties when environment variable support needed
 * - **✅ Recommended**: For nested object properties with complex configuration
 * - **Reference**: https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.typesafe-configuration-properties.java-bean-properties
 *
 * #### 3. Environment Variable Limitations with Complex Types:
 * - **Official Quote**: "Environment variables cannot be used to bind to Lists"
 * - **Maps**: "Constructor binding does not support relaxed binding for Map properties. For Map properties, you need to use setter-based binding."
 * - **Lists**: Environment variables require specific naming patterns (PROP_0, PROP_1) and work better with setter binding
 * - **Nested Objects**: Complex to bind via environment variables with constructor binding
 * - **Reference**: https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.typesafe-configuration-properties.relaxed-binding.environment-variables
 * - **GitHub Issue**: Constructor binding with collections limitations: https://github.com/spring-projects/spring-boot/issues/21454
 *
 * #### 4. Kotlin Collection Types & Spring Boot:
 * - **Immutable Collections**: Kotlin's `List<T>` is immutable by default, works well with constructor binding from YAML
 * - **Mutable Collections**: `MutableList<T>` required for setter binding, but `var` with `List<T>` also works (property replacement)
 * - **Collection Initialization**: Default values in Kotlin data classes work seamlessly with Spring Boot
 * - **Type Safety**: Kotlin's type system provides compile-time safety for Spring Boot property binding
 * - **Reference**: https://kotlinlang.org/docs/collections-overview.html#collection-types
 *
 * #### 5. Property Source Precedence (Official Spring Boot Order):
 * ```
 * 1. @TestPropertySource (HIGHEST) → Overrides everything in tests
 * 2. Command line arguments
 * 3. Java System properties (System.getProperties())
 * 4. OS environment variables
 * 5. Profile-specific application properties (application-{profile}.yml)
 * 6. Application properties (application.yml.unused)
 * 7. @PropertySource annotations
 * 8. Kotlin class defaults (LOWEST)
 * ```
 * **Reference**: https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config
 *
 * ### Practical Recommendations:
 *
 * #### For Simple Properties (String, Int, Boolean):
 * ```kotlin
 * @ConfigurationProperties("app.config")
 * data class SimpleConfig(
 *     val name: String = "default",           // ✅ val works with all property sources
 *     val enabled: Boolean = false,           // ✅ val works with all property sources
 *     val maxRetries: Int = 3                 // ✅ val works with all property sources
 * )
 * ```
 *
 * #### For Complex Properties (List, Map, nested objects):
 * ```kotlin
 * @ConfigurationProperties("app.config")
 * data class ComplexConfig(
 *     val name: String = "default",                              // ✅ val for simple types
 *     var servers: List<String> = emptyList(),                   // ✅ var for Lists (env var support)
 *     var features: Map<String, Boolean> = emptyMap(),           // ✅ var for Maps (required by Spring)
 *     var database: DatabaseConfig = DatabaseConfig()            // ✅ var for nested objects
 * )
 *
 * data class DatabaseConfig(
 *     val host: String = "localhost",         // ✅ val works for nested simple properties
 *     val port: Int = 5432                    // ✅ val works for nested simple properties
 * )
 * ```
 *
 * #### Environment Variable Examples:
 * ```bash
 * # Simple properties (work with val)
 * export APP_CONFIG_NAME=production
 * export APP_CONFIG_ENABLED=true
 * export APP_CONFIG_MAX_RETRIES=5
 *
 * # Complex properties (work better with var)
 * export APP_CONFIG_SERVERS_0=server1.example.com
 * export APP_CONFIG_SERVERS_1=server2.example.com
 * export APP_CONFIG_FEATURES_CACHING=true
 * export APP_CONFIG_FEATURES_METRICS=false
 * export APP_CONFIG_DATABASE_HOST=prod.db.example.com
 * export APP_CONFIG_DATABASE_PORT=5433
 * ```
 *
 * ### Test Strategy:
 * This test uses @TestPropertySource instead of environment variables to ensure:
 * - ✅ Reliable execution in automated builds (no external environment setup)
 * - ✅ Demonstrates both val and var binding working correctly
 * - ✅ Shows property source precedence in action
 * - ✅ Documents Spring Boot + Kotlin integration patterns
 */
@SpringBootTest(classes = [AgentPlatformPropertiesIntegrationTest.TestConfiguration::class])
@ActiveProfiles("test") // using FakeAIConfig
@TestPropertySource(
    properties = [
        // New AgentPlatformProperties (var properties) - these should always work
        "embabel.agent.platform.name=test-platform",
        "embabel.agent.platform.description=Test Platform Description",
        "embabel.agent.platform.scanning.annotation=false",
        "embabel.agent.platform.scanning.bean=true",
        "embabel.agent.platform.ranking.max-attempts=15",
        "embabel.agent.platform.ranking.backoff-millis=200",
        "embabel.agent.platform.autonomy.agent-confidence-cut-off=0.8",
        "embabel.agent.platform.autonomy.goal-confidence-cut-off=0.7",
        "embabel.agent.platform.process-id-generation.include-version=true",
        "embabel.agent.platform.process-id-generation.include-agent-name=true",
        "embabel.agent.platform.llm-operations.prompts.maybe-prompt-template=custom_template",
        "embabel.agent.platform.llm-operations.prompts.generate-examples-by-default=false",
        "embabel.agent.platform.llm-operations.data-binding.max-attempts=20",
        "embabel.agent.platform.llm-operations.data-binding.fixed-backoff-millis=50",
        "embabel.agent.platform.models.anthropic.max-attempts=8",
        "embabel.agent.platform.models.anthropic.backoff-millis=3000",
        "embabel.agent.platform.models.openai.max-attempts=12",
        "embabel.agent.platform.models.openai.backoff-millis=2500",
        "embabel.agent.platform.sse.max-buffer-size=200",
        "embabel.agent.platform.sse.max-process-buffers=2000",
        "embabel.agent.platform.test.mock-mode=false",

        // Migration scanning config (var properties) - known to work with environment variables
        "embabel.agent.platform.migration.scanning.enabled=true",
        "embabel.agent.platform.migration.scanning.include-packages[0]=com.embabel.agent",
        "embabel.agent.platform.migration.scanning.include-packages[1]=com.test.package",
        "embabel.agent.platform.migration.warnings.enabled=true",

        // Legacy properties for val/var investigation (using @TestPropertySource instead of env vars)
        "embabel.autonomy.agent-confidence-cut-off=0.95",
        "embabel.autonomy.goal-confidence-cut-off=0.85",
        "embabel.process-id-generation.include-version=true",
        "embabel.process-id-generation.include-agent-name=true",
        "embabel.sse.max-buffer-size=250",
        "embabel.sse.max-process-buffers=2500"
    ]
)
class AgentPlatformPropertiesIntegrationTest {

    @Autowired
    private lateinit var properties: AgentPlatformProperties

    @Autowired
    private lateinit var legacyAutonomyProperties: AutonomyProperties

    @Autowired
    private lateinit var legacyProcessIdProperties: DefaultProcessIdGeneratorProperties

    @Autowired
    private lateinit var legacySseProperties: SseProperties

    @Autowired
    private lateinit var scanningConfig: DeprecatedPropertyScanningConfig

    @Autowired
    private lateinit var environment: Environment

    @Test
    fun `should bind core platform properties correctly`() {
        assertThat(properties.name).isEqualTo("test-platform")
        assertThat(properties.description).isEqualTo("Test Platform Description")
    }

    @Test
    fun `should bind scanning properties correctly`() {
        assertThat(properties.scanning.annotation).isFalse()
        assertThat(properties.scanning.bean).isTrue()
    }

    @Test
    fun `should bind ranking properties correctly`() {
        assertThat(properties.ranking.maxAttempts).isEqualTo(15)
        assertThat(properties.ranking.backoffMillis).isEqualTo(200L)
    }

    @Test
    fun `should bind autonomy properties correctly`() {
        assertThat(properties.autonomy.agentConfidenceCutOff).isEqualTo(0.8)
        assertThat(properties.autonomy.goalConfidenceCutOff).isEqualTo(0.7)
    }

    @Test
    fun `should bind process ID generation properties correctly`() {
        assertThat(properties.processIdGeneration.includeVersion).isTrue()
        assertThat(properties.processIdGeneration.includeAgentName).isTrue()
    }

    @Test
    fun `should bind LLM operations properties correctly`() {
        assertThat(properties.llmOperations.prompts.maybePromptTemplate).isEqualTo("custom_template")
        assertThat(properties.llmOperations.prompts.generateExamplesByDefault).isFalse()
        assertThat(properties.llmOperations.dataBinding.maxAttempts).isEqualTo(20)
        assertThat(properties.llmOperations.dataBinding.fixedBackoffMillis).isEqualTo(50L)
    }

    @Test
    fun `should bind model provider properties correctly`() {
        assertThat(properties.models.anthropic.maxAttempts).isEqualTo(8)
        assertThat(properties.models.anthropic.backoffMillis).isEqualTo(3000L)
        assertThat(properties.models.openai.maxAttempts).isEqualTo(12)
        assertThat(properties.models.openai.backoffMillis).isEqualTo(2500L)
    }

    @Test
    fun `should bind SSE properties correctly`() {
        assertThat(properties.sse.maxBufferSize).isEqualTo(200)
        assertThat(properties.sse.maxProcessBuffers).isEqualTo(2000)
    }

    @Test
    fun `should bind test properties correctly`() {
        assertThat(properties.test.mockMode).isFalse()
    }

    @Test
    fun `should use default values when properties not specified`() {
        val defaultProperties = AgentPlatformProperties()

        // Test a few key defaults
        assertThat(defaultProperties.scanning.annotation).isTrue()
        assertThat(defaultProperties.ranking.maxAttempts).isEqualTo(5)
        assertThat(defaultProperties.autonomy.agentConfidenceCutOff).isEqualTo(0.6)
        assertThat(defaultProperties.models.anthropic.maxAttempts).isEqualTo(10)
        assertThat(defaultProperties.models.openai.maxAttempts).isEqualTo(10)
        assertThat(defaultProperties.test.mockMode).isTrue()
    }

    // ===================================================================================
    // VAL vs VAR BINDING INVESTIGATION TESTS
    // ===================================================================================

    @Test
    fun `INVESTIGATION - EMBABEL_AUTONOMY_AGENT_CONFIDENCE_CUT_OFF works with val properties`() {
        // This is the mystery scenario - environment variable binding works with 'val' in AutonomyProperties
        // Environment variable: EMBABEL_AUTONOMY_AGENT_CONFIDENCE_CUT_OFF=0.95
        // Property class: AutonomyProperties uses 'val' properties

        println("=== EMBABEL_AUTONOMY_AGENT_CONFIDENCE_CUT_OFF Investigation ===\n")

        // Check environment variable is actually set
        val envValue = environment.getProperty("EMBABEL_AUTONOMY_AGENT_CONFIDENCE_CUT_OFF")
        println("Environment variable EMBABEL_AUTONOMY_AGENT_CONFIDENCE_CUT_OFF: $envValue")

        // Check property resolution
        val resolvedValue = environment.getProperty("embabel.autonomy.agent-confidence-cut-off")
        println("Resolved property embabel.autonomy.agent-confidence-cut-off: $resolvedValue")

        // Check actual binding result
        println("AutonomyProperties.agentConfidenceCutOff (val): ${legacyAutonomyProperties.agentConfidenceCutOff}")
        println("AutonomyProperties.goalConfidenceCutOff (val): ${legacyAutonomyProperties.goalConfidenceCutOff}")

        // This should work if environment variable is set to 0.95
        // If it doesn't work, we'll see the default value 0.6
        println("Expected: 0.95, Actual: ${legacyAutonomyProperties.agentConfidenceCutOff}")
    }

    @Test
    fun `INVESTIGATION - EMBABEL_AGENT_PLATFORM_MIGRATION_SCANNING_INCLUDE_PACKAGES with var properties`() {
        // This is the scenario that required changing val to var in DeprecatedPropertyScanningConfig
        // Environment variable: EMBABEL_AGENT_PLATFORM_MIGRATION_SCANNING_INCLUDE_PACKAGES_0=com.test
        // Property class: DeprecatedPropertyScanningConfig now uses 'var includePackages'

        println("\n=== EMBABEL_AGENT_PLATFORM_MIGRATION_SCANNING_INCLUDE_PACKAGES Investigation ===\n")

        // Check environment variable is set
        val envValue0 = environment.getProperty("EMBABEL_AGENT_PLATFORM_MIGRATION_SCANNING_INCLUDE_PACKAGES_0")
        val envValue1 = environment.getProperty("EMBABEL_AGENT_PLATFORM_MIGRATION_SCANNING_INCLUDE_PACKAGES_1")
        println("Environment variable EMBABEL_AGENT_PLATFORM_MIGRATION_SCANNING_INCLUDE_PACKAGES_0: $envValue0")
        println("Environment variable EMBABEL_AGENT_PLATFORM_MIGRATION_SCANNING_INCLUDE_PACKAGES_1: $envValue1")

        // Check property resolution
        val resolvedValue = environment.getProperty("embabel.agent.platform.migration.scanning.include-packages[0]")
        println("Resolved property embabel.agent.platform.migration.scanning.include-packages[0]: $resolvedValue")

        // Check actual binding result
        println("DeprecatedPropertyScanningConfig.includePackages (var): ${scanningConfig.includePackages}")

        // This should work because we changed from 'val' to 'var'
        println("Include packages count: ${scanningConfig.includePackages.size}")
        scanningConfig.includePackages.forEachIndexed { index, pkg ->
            println("  [$index]: $pkg")
        }
    }

    @Test
    fun `COMPARISON - val vs var property binding behavior analysis`() {
        println("\n=== VAL vs VAR BINDING ANALYSIS ===\n")

        // Compare the two scenarios side by side
        println("1. AutonomyProperties (val properties):")
        println("   - Class: data class AutonomyProperties(val agentConfidenceCutOff: ZeroToOne = 0.6)")
        println("   - Env var: EMBABEL_AUTONOMY_AGENT_CONFIDENCE_CUT_OFF=0.95")
        println("   - Result: ${legacyAutonomyProperties.agentConfidenceCutOff}")
        println("   - Binding works: ${legacyAutonomyProperties.agentConfidenceCutOff != 0.6}")

        println("\n2. DeprecatedPropertyScanningConfig (var properties):")
        println("   - Class: data class DeprecatedPropertyScanningConfig(var includePackages: List<String> = ...)")
        println("   - Env var: EMBABEL_AGENT_PLATFORM_MIGRATION_SCANNING_INCLUDE_PACKAGES_0=com.test")
        println("   - Result: ${scanningConfig.includePackages}")
        println("   - Binding works: ${scanningConfig.includePackages.isNotEmpty()}")

        // Print Spring Boot version and other context that might matter
        println("\n3. Context Information:")
        println("   - Spring Boot version: Check build.gradle/pom.xml")
        println("   - Property source precedence: Environment variables > TestPropertySource > application.properties")

        // Log all environment variables starting with EMBABEL for debugging
        println("\n4. All EMBABEL Environment Variables:")
        System.getenv().entries
            .filter { it.key.startsWith("EMBABEL") }
            .sortedBy { it.key }
            .forEach { (key, value) ->
                println("   $key=$value")
            }
    }

    /**
     * ❌ **EXPECTED TO FAIL** - This test validates that migration is working correctly.
     *
     * **Test Purpose**: Verify that legacy adapter classes now get values from unified AgentPlatformProperties
     * instead of original legacy property names.
     *
     * **Expected Failure**:
     * - Test sets: `embabel.autonomy.agent-confidence-cut-off=0.95` (legacy property)
     * - Test sets: `embabel.agent.platform.autonomy.agent-confidence-cut-off=0.8` (unified property)
     * - Legacy AutonomyProperties gets: 0.8 (from unified property - CORRECT POST-MIGRATION BEHAVIOR)
     * - Test expects: 0.95 (from legacy property - PRE-MIGRATION BEHAVIOR)
     *
     * **Migration Success Indicator**: This failure proves unified properties are the single source of truth.
     */
    @Test
    @Disabled("Expected failure - validates migration correctness. Legacy classes now source from unified properties.")
    fun `legacy properties should be bound from TestPropertySource`() {
        // Test all three legacy configuration classes that were detected by scanner
        // Now using @TestPropertySource for reliable test execution instead of environment variables

        // 1. AutonomyProperties (val properties) - POST-MIGRATION: Gets value from AgentPlatformProperties (0.8)
        //    PRE-MIGRATION: Would get value from embabel.autonomy.agent-confidence-cut-off (0.95)
        assertThat(legacyAutonomyProperties.agentConfidenceCutOff)
            .describedAs("AutonomyProperties.agentConfidenceCutOff should bind from @TestPropertySource")
            .isEqualTo(0.95) // ❌ EXPECTED TO FAIL: Gets 0.8 from unified properties, not 0.95 from legacy

        // 2. DefaultProcessIdGeneratorProperties (val properties)
        println("DefaultProcessIdGeneratorProperties:")
        println("  includeVersion (val): ${legacyProcessIdProperties.includeVersion}")
        println("  includeAgentName (val): ${legacyProcessIdProperties.includeAgentName}")

        // 3. SseProperties (var properties)
        println("SseProperties:")
        println("  maxBufferSize (var): ${legacySseProperties.maxBufferSize}")
        println("  maxProcessBuffers (var): ${legacySseProperties.maxProcessBuffers}")
    }

    @EnableConfigurationProperties(
        AgentPlatformProperties::class,
        DeprecatedPropertyScanningConfig::class
    )
    class TestConfiguration {

        @Bean
        fun autonomyProperties(platformProperties: AgentPlatformProperties): AutonomyProperties {
            return AutonomyProperties(platformProperties)
        }

        @Bean
        fun defaultProcessIdGeneratorProperties(platformProperties: AgentPlatformProperties): DefaultProcessIdGeneratorProperties {
            return DefaultProcessIdGeneratorProperties(platformProperties)
        }

        @Bean
        fun sseProperties(platformProperties: AgentPlatformProperties): SseProperties {
            return SseProperties(platformProperties)
        }
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/config/migration/DeprecatedPropertyScannerTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.migration

import com.embabel.agent.spi.config.spring.migration.DeprecatedPropertyScanner
import com.embabel.agent.spi.config.spring.migration.DeprecatedPropertyScanningConfig
import com.embabel.agent.spi.config.spring.migration.SimpleDeprecatedConfigWarner
import io.mockk.*
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.ObjectProvider
import org.springframework.mock.env.MockEnvironment
import java.util.regex.Pattern

/**
 * Tests for DeprecatedPropertyScanner explicit mapping and runtime rule functionality.
 */
class DeprecatedPropertyScannerTest {

    private lateinit var scanningConfig: DeprecatedPropertyScanningConfig
    private lateinit var propertyWarner: SimpleDeprecatedConfigWarner
    private lateinit var scanner: DeprecatedPropertyScanner
    private lateinit var scanningConfigProvider: ObjectProvider<DeprecatedPropertyScanningConfig>
    private lateinit var propertyWarnerProvider: ObjectProvider<SimpleDeprecatedConfigWarner>
    private lateinit var environment: MockEnvironment

    @BeforeEach
    fun setUp() {
        scanningConfig = mockk<DeprecatedPropertyScanningConfig>()
        propertyWarner = mockk<SimpleDeprecatedConfigWarner>()
        scanningConfigProvider = mockk<ObjectProvider<DeprecatedPropertyScanningConfig>>()
        propertyWarnerProvider = mockk<ObjectProvider<SimpleDeprecatedConfigWarner>>()
        environment = MockEnvironment()

        // Create scanner with constructor injection
        scanner = DeprecatedPropertyScanner(scanningConfigProvider, propertyWarnerProvider, environment)
    }

    @Test
    fun `scanner should skip processing when scanning config unavailable`() {
        // Given
        every { scanningConfigProvider.getIfAvailable() } returns null
        every { propertyWarnerProvider.getIfAvailable() } returns propertyWarner

        // When
        scanner.afterSingletonsInstantiated()

        // Then
        verify { scanningConfigProvider.getIfAvailable() }
        verify { propertyWarnerProvider.getIfAvailable() }
        verify(exactly = 0) { propertyWarner.warnDeprecatedConditional(any(), any(), any()) }
    }

    @Test
    fun `scanner should process when both components available and enabled`() {
        // Given
        every { scanningConfigProvider.getIfAvailable() } returns scanningConfig
        every { propertyWarnerProvider.getIfAvailable() } returns propertyWarner
        every { scanningConfig.enabled } returns true
        every { scanningConfig.includePackages } returns listOf("com.example.test")
        every { scanningConfig.shouldIncludePackage(any()) } returns true
        every { propertyWarner.logAggregatedSummary() } just Runs

        // When
        scanner.afterSingletonsInstantiated()

        // Then
        verify { scanningConfigProvider.getIfAvailable() }
        verify { propertyWarnerProvider.getIfAvailable() }
        verify { scanningConfig.enabled }
        verify(atLeast = 1) { scanningConfig.includePackages }
        verify { propertyWarner.logAggregatedSummary() }
        // Note: Full scanning behavior would require more complex mocking of Spring's resource resolution
    }

    @Test
    fun `getMigrationRules should return empty list initially`() {
        // When - No pattern rules are configured by default (using explicit mappings)
        val rules = scanner.getMigrationRules()

        // Then
        assertThat(rules).isEmpty()
    }

    @Test
    fun `addMigrationRule should allow runtime rule addition`() {
        // Given
        val initialRuleCount = scanner.getMigrationRules().size
        val newRule = DeprecatedPropertyScanner.PropertyMigrationRule(
            pattern = Pattern.compile("test\\.([^.]+)\\.property"),
            replacement = "migrated.test.\$1.property",
            description = "Test rule addition"
        )

        // When
        scanner.addMigrationRule(newRule)

        // Then
        val updatedRules = scanner.getMigrationRules()
        assertThat(updatedRules).hasSize(initialRuleCount + 1)
        assertThat(updatedRules.last().description).isEqualTo("Test rule addition")
    }

    @Test
    fun `PropertyMigrationRule should transform properties correctly when used`() {
        // Given - Test pattern-based rules for runtime extensibility
        val rule = DeprecatedPropertyScanner.PropertyMigrationRule(
            pattern = Pattern.compile("custom\\.company\\.([^.]+)\\.config"),
            replacement = "embabel.agent.custom.\$1.config",
            description = "Custom company namespace migration"
        )

        // When/Then - Pattern transformation
        assertThat(rule.tryApply("custom.company.auth.config"))
            .isEqualTo("embabel.agent.custom.auth.config")

        assertThat(rule.tryApply("custom.company.database.config"))
            .isEqualTo("embabel.agent.custom.database.config")

        // When/Then - Non-matching property
        assertThat(rule.tryApply("other.namespace.auth.config"))
            .isNull()
    }

    @Test
    fun `PropertyMigrationRule should respect conditions`() {
        // Given
        val conditionalRule = DeprecatedPropertyScanner.PropertyMigrationRule(
            pattern = Pattern.compile("legacy\\.([^.]+)\\.setting"),
            replacement = "embabel.agent.legacy.\$1.setting",
            description = "Test rule with condition",
            condition = { property -> property.contains("important") }
        )

        // When/Then - Condition met
        assertThat(conditionalRule.tryApply("legacy.important.setting"))
            .isEqualTo("embabel.agent.legacy.important.setting")

        // When/Then - Condition not met
        assertThat(conditionalRule.tryApply("legacy.optional.setting"))
            .isNull()
    }

    @Test
    fun `runtime rules should be invoked after explicit mappings`() {
        // Given - Add a runtime rule
        val runtimeRule = DeprecatedPropertyScanner.PropertyMigrationRule(
            pattern = Pattern.compile("runtime\\.([^.]+)\\.test"),
            replacement = "embabel.agent.runtime.\$1.test",
            description = "Runtime extensibility test"
        )
        scanner.addMigrationRule(runtimeRule)

        // When/Then - Runtime rule should work for unmapped properties
        // Note: This would be tested through integration tests since the method is private
        assertThat(runtimeRule.tryApply("runtime.custom.test"))
            .isEqualTo("embabel.agent.runtime.custom.test")
    }

    @Test
    fun `PropertyMigrationRule should handle edge cases`() {
        // Given
        val rule = DeprecatedPropertyScanner.PropertyMigrationRule(
            pattern = Pattern.compile("test\\.(.+)"),
            replacement = "migrated.\$1",
            description = "Test rule"
        )

        // When/Then - Empty capture group (note: .+ requires at least one character)
        assertThat(rule.tryApply("test."))
            .isNull()

        // When/Then - Multiple dots in capture
        assertThat(rule.tryApply("test.very.deep.property"))
            .isEqualTo("migrated.very.deep.property")

        // When/Then - No match
        assertThat(rule.tryApply("other.property"))
            .isNull()
    }

    @Test
    fun `rule patterns should be correctly escaped for regex`() {
        // Given
        val dotSensitiveRule = DeprecatedPropertyScanner.PropertyMigrationRule(
            pattern = Pattern.compile("exact\\.match\\.test"),
            replacement = "migrated.exact.match.test",
            description = "Dot escaping test"
        )

        // When/Then - Verify dot escaping works correctly
        assertThat(dotSensitiveRule.tryApply("exact.match.test"))
            .isEqualTo("migrated.exact.match.test")

        // Should not match similar but different patterns (dots are literal)
        assertThat(dotSensitiveRule.tryApply("exactXmatchXtest"))
            .isNull()
    }

    @Test
    fun `multiple runtime rules should be processed in order`() {
        // Given
        val rule1 = DeprecatedPropertyScanner.PropertyMigrationRule(
            pattern = Pattern.compile("first\\.(.+)"),
            replacement = "migrated.first.\$1",
            description = "First rule"
        )

        val rule2 = DeprecatedPropertyScanner.PropertyMigrationRule(
            pattern = Pattern.compile("second\\.(.+)"),
            replacement = "migrated.second.\$1",
            description = "Second rule"
        )

        // When
        scanner.addMigrationRule(rule1)
        scanner.addMigrationRule(rule2)

        // Then
        val rules = scanner.getMigrationRules()
        assertThat(rules).hasSize(2)
        assertThat(rules[0].description).isEqualTo("First rule")
        assertThat(rules[1].description).isEqualTo("Second rule")
    }

    @Test
    fun `scanner should skip processing when scanning explicitly disabled`() {
        // Given
        every { scanningConfigProvider.getIfAvailable() } returns scanningConfig
        every { propertyWarnerProvider.getIfAvailable() } returns propertyWarner
        every { scanningConfig.enabled } returns false

        // When
        scanner.afterSingletonsInstantiated()

        // Then
        verify { scanningConfigProvider.getIfAvailable() }
        verify { propertyWarnerProvider.getIfAvailable() }
        verify { scanningConfig.enabled }
        verify(exactly = 0) { propertyWarner.warnDeprecatedConditional(any(), any(), any()) }
    }

    @Test
    fun `scanner should skip processing when both components unavailable`() {
        // Given
        every { scanningConfigProvider.getIfAvailable() } returns null
        every { propertyWarnerProvider.getIfAvailable() } returns null

        // When
        scanner.afterSingletonsInstantiated()

        // Then
        verify { scanningConfigProvider.getIfAvailable() }
        verify { propertyWarnerProvider.getIfAvailable() }
        verify(exactly = 0) { scanningConfig.enabled }
        verify(exactly = 0) { propertyWarner.warnDeprecatedConditional(any(), any(), any()) }
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/config/migration/DeprecatedPropertyScanningConfigIntegrationTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.migration

import com.embabel.agent.spi.config.spring.migration.DeprecatedPropertyScanningConfig
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.context.properties.EnableConfigurationProperties
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.TestPropertySource

/**
 * Tests for DeprecatedPropertyScanningConfig configuration binding and logic.
 *
 * ## Test Strategy for Default Values
 *
 * This test suite uses @TestPropertySource to override scanning defaults for stable,
 * predictable test behavior regardless of production default changes.
 *
 * **Production Default (as of Iteration 1)**: enabled = true
 * **Test Override**: We explicitly control values via @TestPropertySource
 *
 * This approach ensures:
 * - Tests remain stable when production defaults change
 * - Clear separation between test expectations and production behavior
 * - No need to update tests when toggling production scanning on/off
 */
@SpringBootTest(classes = [DeprecatedPropertyScanningConfigIntegrationTest.TestConfiguration::class])
@TestPropertySource(
    properties = [
        "embabel.agent.platform.migration.scanning.enabled=true",
        "embabel.agent.platform.migration.scanning.auto-exclude-jar-packages=false",
        "embabel.agent.platform.migration.scanning.max-scan-depth=5",
        "embabel.agent.platform.migration.scanning.include-packages[0]=com.example.test",
        "embabel.agent.platform.migration.scanning.include-packages[1]=com.example.custom",
        "embabel.agent.platform.migration.scanning.additional-excludes[0]=com.example.excluded",
        "embabel.agent.platform.migration.scanning.additional-excludes[1]=org.example.test"
    ]
)
class DeprecatedPropertyScanningConfigIntegrationTest {

    @Autowired
    private lateinit var config: DeprecatedPropertyScanningConfig

    @Test
    fun `should bind scanning configuration properties correctly`() {
        assertThat(config.enabled).isTrue()
        assertThat(config.autoExcludeJarPackages).isFalse()
        assertThat(config.maxScanDepth).isEqualTo(5)

        assertThat(config.includePackages).containsExactly(
            "com.example.test",
            "com.example.custom"
        )

        assertThat(config.additionalExcludes).containsExactly(
            "com.example.excluded",
            "org.example.test"
        )
    }


    @Test
    fun `should have comprehensive default exclude packages`() {
        val defaultExcludes = DeprecatedPropertyScanningConfig.defaultExcludePackages()

        // Verify key framework packages are excluded
        assertThat(defaultExcludes).contains(
            "java.",
            "javax.",
            "kotlin.",
            "kotlinx.",
            "org.springframework.",
            "org.springframework.boot.",
            "com.fasterxml.jackson.",
            "org.slf4j.",
            "ch.qos.logback.",
            "io.micrometer.",
            "org.apache.",
            "com.google.guava."
        )

        // Should be comprehensive - at least 50+ entries
        assertThat(defaultExcludes.size).isGreaterThan(50)
    }


    @Test
    fun `should combine default and additional excludes correctly`() {
        val allExcludes = config.getAllExcludePackages()

        // Should include defaults
        assertThat(allExcludes).contains("java.", "org.springframework.")

        // Should include additional excludes from test properties
        assertThat(allExcludes).contains("com.example.excluded", "org.example.test")
    }

    @Test
    fun `shouldExcludePackage should work correctly`() {
        // Framework packages should be excluded
        assertThat(config.shouldExcludePackage("java.lang.String")).isTrue()
        assertThat(config.shouldExcludePackage("org.springframework.boot.Application")).isTrue()
        assertThat(config.shouldExcludePackage("kotlin.collections.List")).isTrue()

        // Additional excludes should work
        assertThat(config.shouldExcludePackage("com.example.excluded.SomeClass")).isTrue()
        assertThat(config.shouldExcludePackage("org.example.test.TestClass")).isTrue()

        // User packages should not be excluded
        assertThat(config.shouldExcludePackage("com.example.test.UserClass")).isFalse()
        assertThat(config.shouldExcludePackage("com.embabel.agent.MyService")).isFalse()
    }

    @Test
    fun `shouldIncludePackage should work correctly`() {
        // Included packages should be included
        assertThat(config.shouldIncludePackage("com.example.test.SomeClass")).isTrue()
        assertThat(config.shouldIncludePackage("com.example.custom.MyClass")).isTrue()

        // Excluded packages should not be included even if they match include pattern
        assertThat(config.shouldIncludePackage("com.example.excluded.ExcludedClass")).isFalse()

        // Non-matching packages should not be included
        assertThat(config.shouldIncludePackage("com.other.package.SomeClass")).isFalse()

        // Framework packages should not be included
        assertThat(config.shouldIncludePackage("org.springframework.boot.Application")).isFalse()
    }

    @Test
    fun `should handle edge cases in package matching`() {
        // Exact prefix matches
        assertThat(config.shouldExcludePackage("java")).isFalse() // Should require dot
        assertThat(config.shouldExcludePackage("java.")).isTrue()
        assertThat(config.shouldExcludePackage("java.lang")).isTrue()

        // Empty package names
        assertThat(config.shouldExcludePackage("")).isFalse()
        assertThat(config.shouldIncludePackage("")).isFalse()
    }

    @EnableConfigurationProperties(DeprecatedPropertyScanningConfig::class)
    class TestConfiguration
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/config/migration/PlatformPropertiesMigrationIntegrationTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.migration

import ch.qos.logback.classic.Level
import ch.qos.logback.classic.Logger
import ch.qos.logback.classic.spi.ILoggingEvent
import ch.qos.logback.core.read.ListAppender
import com.embabel.agent.spi.config.spring.migration.DeprecatedPropertyScanner
import com.embabel.agent.spi.config.spring.migration.DeprecatedPropertyScanningConfig
import com.embabel.agent.spi.config.spring.migration.DeprecatedPropertyWarningConfig
import com.embabel.agent.spi.config.spring.migration.SimpleDeprecatedConfigWarner
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.ObjectProvider
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.context.properties.EnableConfigurationProperties
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.core.env.Environment
import org.springframework.test.context.TestPropertySource

/**
 * Integration tests for the complete platform properties migration system.
 *
 * Tests the interaction between DeprecatedPropertyScanningConfig, SimpleDeprecatedConfigWarner,
 * and DeprecatedPropertyScanner components working together for platform property migrations.
 */
@SpringBootTest(
    classes = [
        PlatformPropertiesMigrationIntegrationTest.TestConfiguration::class
    ]
)
@TestPropertySource(
    properties = [
        // Enable migration scanning
        "embabel.agent.platform.migration.scanning.enabled=true",
        "embabel.agent.platform.migration.scanning.include-packages[0]=com.embabel.agent",

        // Set up deprecated properties for testing
        "embabel.anthropic.max-attempts=15",
        "embabel.agent-platform.ranking.backoff-millis=500",
        "embabel.agent.sse.max-buffer-size=200",

        // Configure scanning to include test packages
        "embabel.agent.platform.migration.scanning.auto-exclude-jar-packages=false"
    ]
)
class PlatformPropertiesMigrationIntegrationTest {

    @Autowired
    private lateinit var scanningConfig: DeprecatedPropertyScanningConfig

    @Autowired
    private lateinit var propertyWarner: SimpleDeprecatedConfigWarner

    @Autowired
    private lateinit var propertyScanner: DeprecatedPropertyScanner

    private lateinit var listAppender: ListAppender<ILoggingEvent>
    private lateinit var logger: Logger

    @BeforeEach
    fun setUp() {
        // Set up log capture for warner
        logger = LoggerFactory.getLogger(SimpleDeprecatedConfigWarner::class.java) as Logger
        listAppender = ListAppender()
        listAppender.start()
        logger.addAppender(listAppender)
        logger.level = Level.WARN

        // Clear any previous warnings
        propertyWarner.clearWarnings()
    }

    @AfterEach
    fun tearDown() {
        logger.detachAppender(listAppender)
        listAppender.stop()
    }

    @Test
    fun `should configure scanning correctly from properties`() {
        assertThat(scanningConfig.enabled).isTrue()
        assertThat(scanningConfig.includePackages).contains("com.embabel.agent")
        assertThat(scanningConfig.autoExcludeJarPackages).isFalse()
    }

    @Test
    fun `should issue warnings for deprecated properties`() {
        // When - manually trigger property warnings (simulating what scanner would do)
        propertyWarner.warnDeprecatedProperty(
            "embabel.anthropic.max-attempts",
            "embabel.agent.platform.models.anthropic.max-attempts",
            "Model provider configuration consolidation"
        )

        propertyWarner.warnDeprecatedProperty(
            "embabel.agent-platform.ranking.backoff-millis",
            "embabel.agent.platform.ranking.backoff-millis",
            "Platform namespace consolidation"
        )

        // Then
        assertThat(listAppender.list).hasSize(2)
        assertThat(propertyWarner.getWarningCount()).isEqualTo(2)

        val messages = listAppender.list.map { it.message }
        assertThat(messages).anySatisfy { message ->
            assertThat(message).contains(
                "embabel.anthropic.max-attempts",
                "embabel.agent.platform.models.anthropic.max-attempts",
                "15"
            )
        }
        assertThat(messages).anySatisfy { message ->
            assertThat(message).contains(
                "embabel.agent-platform.ranking.backoff-millis",
                "embabel.agent.platform.ranking.backoff-millis",
                "500"
            )
        }
    }

    @Test
    fun `should transform properties using migration rules correctly`() {
        // Given - Test the complete rule transformation pipeline
        val testCases = mapOf(
            "embabel.anthropic.max-attempts" to "embabel.agent.platform.models.anthropic.max-attempts",
            "embabel.anthropic.backoff-millis" to "embabel.agent.platform.models.anthropic.backoff-millis",
            "embabel.openai.max-attempts" to "embabel.agent.platform.models.openai.max-attempts",
            "embabel.agent-platform.ranking.max-attempts" to "embabel.agent.platform.ranking.max-attempts",
            "embabel.agent-platform.llm-operations.prompts.template" to "embabel.agent.platform.llm-operations.prompts.template"
        )

        testCases.forEach { (deprecated, expected) ->
            // When - apply rules through scanner
            val result = getRecommendedPropertyUsingScanner(deprecated)

            // Then
            assertThat(result).isEqualTo(expected)
        }
    }

    @Test
    fun `should handle exact property mappings`() {
        // Given - test exact mappings vs pattern rules (for @ConditionalOnProperty migrations only)
        val exactMappings = mapOf(
            "embabel.agent.enable-scanning" to "embabel.agent.platform.scanning.annotation",
            "embabel.agent.mock-mode" to "embabel.agent.platform.test.mock-mode",
            "embabel.anthropic" to "embabel.agent.platform.models.anthropic"
        )

        exactMappings.forEach { (deprecated, expected) ->
            // When
            val result = getRecommendedPropertyUsingScanner(deprecated)

            // Then
            assertThat(result).isEqualTo(expected)
        }
    }

    @Test
    fun `should not transform already migrated properties`() {
        // Given - properties that are already in correct namespace
        val alreadyMigrated = listOf(
            "embabel.agent.platform.models.anthropic.max-attempts",
            "embabel.agent.platform.ranking.max-attempts",
            "embabel.agent.platform.sse.max-buffer-size"
        )

        alreadyMigrated.forEach { property ->
            // When
            val result = getRecommendedPropertyUsingScanner(property)

            // Then - should fall back to generic message
            assertThat(result).contains("please check migration guide")
        }
    }

    @Test
    fun `should handle package inclusion and exclusion correctly`() {
        // Test that scanning config correctly identifies packages to include/exclude
        assertThat(scanningConfig.shouldIncludePackage("com.embabel.agent.config.migration.TestClass")).isTrue()
        assertThat(scanningConfig.shouldIncludePackage("com.embabel.agent.service.MyService")).isTrue()

        // Framework packages should be excluded
        assertThat(scanningConfig.shouldIncludePackage("org.springframework.boot.Application")).isFalse()
        assertThat(scanningConfig.shouldIncludePackage("java.lang.String")).isFalse()
    }

    @Test
    fun `should support runtime rule addition`() {
        // Given
        val initialRuleCount = propertyScanner.getMigrationRules().size
        val customRule = DeprecatedPropertyScanner.PropertyMigrationRule(
            pattern = java.util.regex.Pattern.compile("custom\\.([^.]+)\\.config"),
            replacement = "migrated.custom.\$1.config",
            description = "Custom runtime rule"
        )

        // When
        propertyScanner.addMigrationRule(customRule)

        // Then
        assertThat(propertyScanner.getMigrationRules()).hasSize(initialRuleCount + 1)

        // And the new rule should work (test the rule directly since scanner method is private)
        val result = customRule.tryApply("custom.test.config")
        assertThat(result).isEqualTo("migrated.custom.test.config")
    }

    @Test
    fun `should demonstrate complete migration workflow`() {
        // Given - simulate a complete migration scenario
        val deprecatedProperties = mapOf(
            "embabel.anthropic.max-attempts" to "15",
            "embabel.agent-platform.ranking.backoff-millis" to "500",
            "embabel.agent.sse.max-buffer-size" to "200"
        )

        // When - process each deprecated property through the complete system
        deprecatedProperties.forEach { (property, value) ->
            val recommendedProperty = getRecommendedPropertyUsingScanner(property)

            // Simulate the scanner finding and warning about this property
            propertyWarner.warnDeprecatedProperty(
                deprecatedProperty = property,
                recommendedProperty = recommendedProperty,
                deprecationReason = "Property migration consolidation"
            )
        }

        // Then - verify complete system behavior
        assertThat(propertyWarner.getWarningCount()).isEqualTo(3)
        assertThat(listAppender.list).hasSize(3)

        // Verify all warnings contain expected information
        val logMessages = listAppender.list.map { it.message }
        assertThat(logMessages).allSatisfy { message ->
            assertThat(message).contains("DEPRECATED PROPERTY USAGE")
            assertThat(message).contains("Property migration consolidation")
        }

        // Verify specific transformations
        assertThat(logMessages).anySatisfy { message ->
            assertThat(message).contains("embabel.agent.platform.models.anthropic.max-attempts")
        }
        assertThat(logMessages).anySatisfy { message ->
            assertThat(message).contains("embabel.agent.platform.ranking.backoff-millis")
        }
        assertThat(logMessages).anySatisfy { message ->
            assertThat(message).contains("embabel.agent.platform.sse.max-buffer-size")
        }
    }

    /**
     * Helper method to simulate the scanner's explicit mapping logic for testing.
     * Uses the same explicit mappings as the actual scanner.
     */
    private fun getRecommendedPropertyUsingScanner(deprecatedProperty: String): String {
        // Explicit mappings from the scanner (replicated for testing)
        val exactMappings = mapOf(
            // Platform namespace consolidation
            "embabel.agent-platform.ranking.max-attempts" to "embabel.agent.platform.ranking.max-attempts",
            "embabel.agent-platform.ranking.backoff-millis" to "embabel.agent.platform.ranking.backoff-millis",
            "embabel.agent-platform.llm-operations.prompts.template" to "embabel.agent.platform.llm-operations.prompts.template",

            // Model provider configurations
            "embabel.anthropic.max-attempts" to "embabel.agent.platform.models.anthropic.max-attempts",
            "embabel.anthropic.backoff-millis" to "embabel.agent.platform.models.anthropic.backoff-millis",
            "embabel.openai.max-attempts" to "embabel.agent.platform.models.openai.max-attempts",
            "embabel.openai.backoff-millis" to "embabel.agent.platform.models.openai.backoff-millis",

            // Specific platform features
            "embabel.agent.enable-scanning" to "embabel.agent.platform.scanning.annotation",
            "embabel.agent.mock-mode" to "embabel.agent.platform.test.mock-mode",
            "embabel.agent.sse.max-buffer-size" to "embabel.agent.platform.sse.max-buffer-size",
            "embabel.agent.sse.max-process-buffers" to "embabel.agent.platform.sse.max-process-buffers",

            // @ConfigurationProperties prefix migrations
            "embabel.anthropic" to "embabel.agent.platform.models.anthropic",
            "embabel.openai" to "embabel.agent.platform.models.openai"
        )

        // Simple lookup (mirroring simplified scanner logic)
        return exactMappings[deprecatedProperty]
            ?: "$deprecatedProperty (please check migration guide for specific replacement)"
    }

    @Configuration
    @EnableConfigurationProperties(DeprecatedPropertyScanningConfig::class)
    class TestConfiguration {

        @Bean
        fun simpleDeprecatedConfigWarner(environment: Environment): SimpleDeprecatedConfigWarner =
            SimpleDeprecatedConfigWarner(environment, DeprecatedPropertyWarningConfig(individualLogging = true))

        @Bean
        fun conditionalPropertyScanner(
            scanningConfigProvider: ObjectProvider<DeprecatedPropertyScanningConfig>,
            propertyWarnerProvider: ObjectProvider<SimpleDeprecatedConfigWarner>,
            environment: Environment,
        ): DeprecatedPropertyScanner =
            DeprecatedPropertyScanner(scanningConfigProvider, propertyWarnerProvider, environment)
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/config/migration/SimpleDeprecatedConfigWarnerTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.migration

import ch.qos.logback.classic.Level
import ch.qos.logback.classic.Logger
import ch.qos.logback.classic.spi.ILoggingEvent
import ch.qos.logback.core.read.ListAppender
import com.embabel.agent.spi.config.spring.migration.DeprecatedPropertyWarningConfig
import com.embabel.agent.spi.config.spring.migration.SimpleDeprecatedConfigWarner
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.slf4j.LoggerFactory
import org.springframework.mock.env.MockEnvironment

/**
 * Tests for SimpleDeprecatedConfigWarner warning functionality.
 */
class SimpleDeprecatedConfigWarnerTest {

    private lateinit var environment: MockEnvironment
    private lateinit var warner: SimpleDeprecatedConfigWarner
    private lateinit var warnerWithLogging: SimpleDeprecatedConfigWarner
    private lateinit var listAppender: ListAppender<ILoggingEvent>
    private lateinit var logger: Logger

    @BeforeEach
    fun setUp() {
        environment = MockEnvironment()
        warner = SimpleDeprecatedConfigWarner(environment, DeprecatedPropertyWarningConfig(individualLogging = false))
        warnerWithLogging =
            SimpleDeprecatedConfigWarner(environment, DeprecatedPropertyWarningConfig(individualLogging = true))

        // Set up log capture
        logger = LoggerFactory.getLogger(SimpleDeprecatedConfigWarner::class.java) as Logger
        listAppender = ListAppender()
        listAppender.start()
        logger.addAppender(listAppender)
        logger.level = Level.WARN
    }

    @AfterEach
    fun tearDown() {
        logger.detachAppender(listAppender)
        listAppender.stop()
    }

    @Test
    fun `warnDeprecatedProperty should issue warning when property exists`() {
        // Given
        environment.setProperty("old.property", "test-value")

        // When
        warnerWithLogging.warnDeprecatedProperty(
            deprecatedProperty = "old.property",
            recommendedProperty = "new.property",
            deprecationReason = "Property consolidation"
        )

        // Then
        assertThat(listAppender.list).hasSize(1)
        val logEvent = listAppender.list[0]
        assertThat(logEvent.level).isEqualTo(Level.WARN)
        assertThat(logEvent.message).contains(
            "DEPRECATED PROPERTY USAGE",
            "old.property",
            "new.property",
            "Property consolidation",
            "test-value"
        )

        assertThat(warnerWithLogging.getWarningCount()).isEqualTo(1)
        assertThat(warnerWithLogging.getWarnedItems()).contains("old.property")
    }

    @Test
    fun `warnDeprecatedProperty should not warn when property does not exist`() {
        // When
        warnerWithLogging.warnDeprecatedProperty(
            deprecatedProperty = "nonexistent.property",
            recommendedProperty = "new.property"
        )

        // Then
        assertThat(listAppender.list).isEmpty()
        assertThat(warnerWithLogging.getWarningCount()).isEqualTo(0)
    }

    @Test
    fun `warnDeprecatedProperty should warn only once per property`() {
        // Given
        environment.setProperty("duplicate.property", "value")

        // When - warn multiple times
        warnerWithLogging.warnDeprecatedProperty("duplicate.property", "new.property")
        warnerWithLogging.warnDeprecatedProperty("duplicate.property", "new.property")
        warnerWithLogging.warnDeprecatedProperty("duplicate.property", "different.property")

        // Then - only one warning logged
        assertThat(listAppender.list).hasSize(1)
        assertThat(warnerWithLogging.getWarningCount()).isEqualTo(1)
    }

    @Test
    fun `warnDeprecatedProfile should issue warning when profile is active`() {
        // Given
        environment.setActiveProfiles("deprecated-profile")

        // When
        warnerWithLogging.warnDeprecatedProfile(
            deprecatedProfile = "deprecated-profile",
            recommendedProperty = "embabel.agent.feature.enabled",
            deprecationReason = "Profile-to-property migration"
        )

        // Then
        assertThat(listAppender.list).hasSize(1)
        val logEvent = listAppender.list[0]
        assertThat(logEvent.level).isEqualTo(Level.WARN)
        assertThat(logEvent.message).contains(
            "DEPRECATED PROFILE USAGE",
            "deprecated-profile",
            "embabel.agent.feature.enabled=true",
            "Profile-to-property migration"
        )

        assertThat(warnerWithLogging.getWarningCount()).isEqualTo(1)
        assertThat(warnerWithLogging.getWarnedItems()).contains("PROFILE:deprecated-profile")
    }

    @Test
    fun `warnDeprecatedProfile should not warn when profile is not active`() {
        // Given - no active profiles set or different profile active
        environment.setActiveProfiles("other-profile")

        // When
        warnerWithLogging.warnDeprecatedProfile(
            deprecatedProfile = "deprecated-profile",
            recommendedProperty = "embabel.agent.feature.enabled"
        )

        // Then
        assertThat(listAppender.list).isEmpty()
        assertThat(warnerWithLogging.getWarningCount()).isEqualTo(0)
    }

    @Test
    fun `warnDeprecatedConditional should issue warning with class and annotation details`() {
        // When
        warnerWithLogging.warnDeprecatedConditional(
            className = "com.example.MyService",
            annotationDetails = "@ConditionalOnProperty(\"old.property\")",
            recommendedApproach = "@ConditionalOnProperty(\"new.property\")"
        )

        // Then
        assertThat(listAppender.list).hasSize(1)
        val logEvent = listAppender.list[0]
        assertThat(logEvent.level).isEqualTo(Level.WARN)
        assertThat(logEvent.message).contains(
            "DEPRECATED CONDITIONAL USAGE",
            "com.example.MyService",
            "@ConditionalOnProperty(\"old.property\")",
            "@ConditionalOnProperty(\"new.property\")"
        )

        assertThat(warnerWithLogging.getWarningCount()).isEqualTo(1)
        assertThat(warnerWithLogging.getWarnedItems()).contains("CONDITIONAL:com.example.MyService")
    }

    @Test
    fun `warnDeprecatedConditional should warn only once per class`() {
        // When - warn multiple times for same class
        warnerWithLogging.warnDeprecatedConditional(
            "com.example.Service",
            "@ConditionalOnProperty(\"prop1\")",
            "@ConditionalOnProperty(\"new.prop1\")"
        )
        warnerWithLogging.warnDeprecatedConditional(
            "com.example.Service",
            "@ConditionalOnProperty(\"prop2\")",
            "@ConditionalOnProperty(\"new.prop2\")"
        )

        // Then - only one warning per class
        assertThat(listAppender.list).hasSize(1)
        assertThat(warnerWithLogging.getWarningCount()).isEqualTo(1)
    }

    @Test
    fun `should handle multiple different warning types`() {
        // Given
        environment.setProperty("old.prop", "value")
        environment.setActiveProfiles("old-profile")

        // When - different types of warnings
        warnerWithLogging.warnDeprecatedProperty("old.prop", "new.prop")
        warnerWithLogging.warnDeprecatedProfile("old-profile", "new.property")
        warnerWithLogging.warnDeprecatedConditional("MyClass", "@ConditionalOnProperty(\"test\")", "new approach")

        // Then - all warnings issued
        assertThat(listAppender.list).hasSize(3)
        assertThat(warnerWithLogging.getWarningCount()).isEqualTo(3)
        assertThat(warnerWithLogging.getWarnedItems()).containsExactlyInAnyOrder(
            "old.prop",
            "PROFILE:old-profile",
            "CONDITIONAL:MyClass"
        )
    }

    @Test
    fun `logAggregatedSummary should provide overview of all deprecated configuration usage`() {
        // Given - various deprecated configurations
        environment.setProperty("old.prop1", "value1")
        environment.setProperty("old.prop2", "value2")
        environment.setActiveProfiles("old-profile1", "old-profile2")

        warner.warnDeprecatedProperty("old.prop1", "new.prop1")
        warner.warnDeprecatedProperty("old.prop2", "new.prop2")
        warner.warnDeprecatedProfile("old-profile1", "new.feature1.enabled")
        warner.warnDeprecatedProfile("old-profile2", "new.feature2.enabled")
        warner.warnDeprecatedConditional("MyService", "@ConditionalOnProperty(\"test\")", "new approach")

        // Clear existing individual warnings for cleaner test
        listAppender.list.clear()

        // When
        warner.logAggregatedSummary()

        // Then - single aggregated log message
        assertThat(listAppender.list).hasSize(1)
        val summaryMessage = listAppender.list[0].message

        assertThat(summaryMessage).contains(
            "DEPRECATED CONFIGURATION SUMMARY",
            "2 deprecated properties",
            "2 deprecated profiles",
            "1 deprecated conditionals"
        )

        // Should contain migration details
        assertThat(summaryMessage).contains(
            "old.prop1 → new.prop1",
            "old.prop2 → new.prop2",
            "old-profile1 → new.feature1.enabled=true",
            "old-profile2 → new.feature2.enabled=true",
            "MyService: @ConditionalOnProperty"
        )
    }

    @Test
    fun `logAggregatedSummary should handle empty state gracefully`() {
        // When - no deprecated configurations warned about
        warner.logAggregatedSummary()

        // Then - no log message (or informational message about clean state)
        assertThat(listAppender.list).isEmpty()
    }

    @Test
    fun `clearWarnings should reset warning tracking`() {
        // Given - some warnings issued
        environment.setProperty("test.prop", "value")
        warnerWithLogging.warnDeprecatedProperty("test.prop", "new.prop")
        assertThat(warnerWithLogging.getWarningCount()).isEqualTo(1)

        // When
        warnerWithLogging.clearWarnings()

        // Then
        assertThat(warnerWithLogging.getWarningCount()).isEqualTo(0)
        assertThat(warnerWithLogging.getWarnedItems()).isEmpty()

        // And should allow warning again for same property
        warnerWithLogging.warnDeprecatedProperty("test.prop", "new.prop")
        assertThat(listAppender.list).hasSize(2) // Original + new warning
    }

    @Test
    fun `should handle warnings without optional deprecation reason`() {
        // Given
        environment.setProperty("simple.prop", "value")

        // When - no deprecation reason provided
        warnerWithLogging.warnDeprecatedProperty("simple.prop", "new.prop")

        // Then
        assertThat(listAppender.list).hasSize(1)
        val logEvent = listAppender.list[0]
        assertThat(logEvent.message).contains("simple.prop", "new.prop")
        assertThat(logEvent.message).doesNotContain("Reason:")
    }

    @Test
    fun `should handle edge cases with empty or null values`() {
        // Test empty property values
        environment.setProperty("empty.prop", "")
        warnerWithLogging.warnDeprecatedProperty("empty.prop", "new.prop")
        assertThat(listAppender.list).hasSize(1)
        assertThat(listAppender.list[0].message).contains("Current value: ''")

        // Test with empty profiles array
        environment.setActiveProfiles() // No active profiles
        warnerWithLogging.warnDeprecatedProfile("test-profile", "new.prop")
        assertThat(listAppender.list).hasSize(1) // Only the property warning from above
    }

    @Test
    fun `getDeprecationCategories should return organized deprecation info`() {
        // Given
        environment.setProperty("old.prop", "value")
        environment.setActiveProfiles("old-profile")

        warner.warnDeprecatedProperty("old.prop", "new.prop")
        warner.warnDeprecatedProfile("old-profile", "new.feature.enabled")
        warner.warnDeprecatedConditional("MyClass", "@ConditionalOnProperty(\"test\")", "new approach")

        // When
        val categories = warner.getDeprecationCategories()

        // Then
        assertThat(categories.properties).hasSize(1)
        assertThat(categories.profiles).hasSize(1)
        assertThat(categories.conditionals).hasSize(1)

        assertThat(categories.properties[0].deprecatedItem).isEqualTo("old.prop")
        assertThat(categories.properties[0].recommendedReplacement).isEqualTo("new.prop")

        assertThat(categories.profiles[0].deprecatedItem).isEqualTo("old-profile")
        assertThat(categories.profiles[0].recommendedReplacement).isEqualTo("new.feature.enabled=true")

        assertThat(categories.conditionals[0].deprecatedItem).isEqualTo("MyClass")
        assertThat(categories.conditionals[0].recommendedReplacement).contains("new approach")
    }

    @Test
    fun `should support disabling individual logging while keeping aggregated logging`() {
        // Given
        environment.setProperty("test.prop", "value")

        // When - individual warning called (warner has enableIndividualLogging = false)
        warner.warnDeprecatedProperty("test.prop", "new.prop")

        // Then - no individual log message
        assertThat(listAppender.list).isEmpty()
        assertThat(warner.getWarningCount()).isEqualTo(1) // Still tracked for aggregation

        // When - aggregated summary called
        warner.logAggregatedSummary()

        // Then - aggregated log message appears
        assertThat(listAppender.list).hasSize(1)
        assertThat(listAppender.list[0].message).contains("DEPRECATED CONFIGURATION SUMMARY")
    }

    @Test
    fun `should not log individually when enableIndividualLogging is false (default behavior)`() {
        // Given
        environment.setProperty("test.prop", "value")

        // When
        warner.warnDeprecatedProperty("test.prop", "new.prop")

        // Then - no individual warning logged
        assertThat(listAppender.list).isEmpty()
        assertThat(warner.getWarningCount()).isEqualTo(1) // Still tracked for aggregation
    }

    @Test
    fun `should handle mixed individual and aggregated logging configurations`() {
        // Given
        environment.setProperty("prop1", "value1")
        environment.setProperty("prop2", "value2")

        // When - log first property with individual logging enabled
        warnerWithLogging.warnDeprecatedProperty("prop1", "new.prop1")
        assertThat(listAppender.list).hasSize(1)

        // When - log second property with individual logging disabled
        warner.warnDeprecatedProperty("prop2", "new.prop2")
        assertThat(listAppender.list).hasSize(1) // No new individual log

        // When - log aggregated summary (using warner with both properties)
        warner.logAggregatedSummary()

        // Then - aggregated summary includes the second property
        assertThat(listAppender.list).hasSize(2)
        val summaryMessage = listAppender.list[1].message
        assertThat(summaryMessage).contains("1 deprecated properties")
        assertThat(summaryMessage).contains("prop2 → new.prop2")
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/config/models/FallbackChatModelTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.models

import com.embabel.agent.api.models.FallbackChatModel
import com.embabel.agent.api.models.withFallback
import com.embabel.common.ai.model.Llm
import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import org.springframework.ai.chat.model.ChatModel
import org.springframework.ai.chat.model.ChatResponse
import org.springframework.ai.chat.prompt.Prompt
import kotlin.test.assertEquals
import kotlin.test.assertSame

class FallbackChatModelTest {

    private val prompt = Prompt("foo")
    private val primaryResponse = mockk<ChatResponse>()
    private val fallbackResponse = mockk<ChatResponse>()

    @Nested
    inner class CallMethod {

        @Test
        fun `should use primary model when it succeeds`() {
            val primaryModel = mockk<ChatModel>()
            val fallbackModel = mockk<ChatModel>()
            every { primaryModel.call(prompt) } returns primaryResponse
            val resilientModel = FallbackChatModel(primaryModel, fallbackModel) { true }

            val result = resilientModel.call(prompt)

            assertSame(primaryResponse, result)
            verify(exactly = 1) { primaryModel.call(prompt) }
        }

        @Test
        fun `should use fallback model when primary fails and predicate returns true`() {
            val primaryModel = mockk<ChatModel>()
            val fallbackModel = mockk<ChatModel>()
            val exception = RuntimeException("Primary model failed")
            every { primaryModel.call(prompt) } throws exception
            every { fallbackModel.call(prompt) } returns fallbackResponse
            val resilientModel = primaryModel.withFallback(fallbackModel) { true }

            val result = resilientModel.call(prompt)

            // Assert
            assertSame(fallbackResponse, result)
            verify(exactly = 1) { primaryModel.call(prompt) }
            verify(exactly = 1) { fallbackModel.call(prompt) }
        }

        @Test
        fun `should rethrow exception when primary fails and predicate returns false`() {
            // Arrange
            val primaryModel = mockk<ChatModel>()
            val fallbackModel = mockk<ChatModel>()
            every { fallbackModel.call(prompt) } returns fallbackResponse
            val exception = RuntimeException("Primary model failed")
            every { primaryModel.call(prompt) } throws exception
            val resilientModel = primaryModel.withFallback(fallbackModel) { false }

            // Act & Assert
            val thrownException = assertThrows<RuntimeException> {
                resilientModel.call(prompt)
            }
            assertEquals("Primary model failed", thrownException.message)
            verify(exactly = 1) { primaryModel.call(prompt) }
        }
    }

    @Nested
    inner class ExtensionFunctions {

        @Test
        fun `withFallback should create FallbackChatModel from ChatModel`() {
            // Arrange
            val predicate: (Throwable) -> Boolean = { true }

            val primaryModel = mockk<ChatModel>()
            val fallbackModel = mockk<ChatModel>()

            // Act
            val result = primaryModel.withFallback(fallbackModel, predicate)

            // Assert
            assertTrue(result is FallbackChatModel)
        }

        @Test
        fun `withFallback should create Llm with fallback model`() {
            // Arrange
            val primaryModel = mockk<ChatModel>()
            val fallbackModel = mockk<ChatModel>()
            val primaryLlm = Llm(
                name = "primary",
                model = primaryModel,
                optionsConverter = mockk(),
                provider = "test",
            )

            val fallbackLlm = Llm(
                name = "fallback",
                model = fallbackModel,
                optionsConverter = mockk(),
                provider = "test",
            )

            val predicate: (Throwable) -> Boolean = { true }

            // Act
            val result = primaryLlm.withFallback(fallbackLlm, predicate)

            // Assert
            assertEquals("primary", result.name)
            assertTrue(result.model is FallbackChatModel, "Result should be fallback model")
        }

        @Test
        fun `withFallback should return original Llm when fallback is null`() {
            // Arrange
            val primaryModel = mockk<ChatModel>()
            val fallbackModel = mockk<ChatModel>()
            val primaryLlm = Llm(
                name = "primary",
                model = primaryModel,
                optionsConverter = mockk(),
                provider = "test",
            )

            val predicate: (Throwable) -> Boolean = { true }

            // Act
            val result = primaryLlm.withFallback(null, predicate)

            // Assert
            assertSame(primaryLlm, result)
        }
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/config/models/OpenAiCompatibleModelFactoryTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.models

import com.embabel.agent.api.models.OpenAiCompatibleModelFactory
import com.embabel.common.ai.model.PricingModel
import io.mockk.mockk
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Test
import org.springframework.ai.openai.OpenAiChatModel

class OpenAiCompatibleModelFactoryTest {

    @Test
    fun `default base url`() {
        val mf = OpenAiCompatibleModelFactory(
            baseUrl = null,
            apiKey = null,
            completionsPath = null,
            embeddingsPath = null,
            observationRegistry = mockk(),
        )
        val llm = mf.openAiCompatibleLlm(
            model = "foo", pricingModel = PricingModel.ALL_YOU_CAN_EAT,
            provider = "Test", knowledgeCutoffDate = null,
        )
        assertEquals("foo", llm.name)
        assertEquals("Test", llm.provider)
        assertTrue(llm.model is OpenAiChatModel)
    }

    @Test
    fun `custom base url`() {
        val mf = OpenAiCompatibleModelFactory(
            baseUrl = "foobar",
            apiKey = null,
            completionsPath = null,
            embeddingsPath = null,
            observationRegistry = mockk(),
        )
        val llm = mf.openAiCompatibleLlm(
            model = "foo", pricingModel = PricingModel.ALL_YOU_CAN_EAT,
            provider = "Test", knowledgeCutoffDate = null,
        )
        assertEquals("foo", llm.name)
        assertEquals("Test", llm.provider)
        assertTrue(llm.model is OpenAiChatModel)
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/core/ConditionTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import com.embabel.agent.api.common.OperationContext
import com.embabel.common.core.types.ZeroToOne
import com.embabel.plan.goap.ConditionDetermination
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test
import org.mockito.Mockito.mock

class ConditionTest {

    private val mockOperationContext = mock<OperationContext>()

    // Helper function to create test conditions
    private fun createTestCondition(
        name: String,
        cost: ZeroToOne,
        result: ConditionDetermination
    ): Condition {
        return object : Condition {
            override val name = name
            override val cost = cost
            override fun evaluate(context: OperationContext) = result
        }
    }

    @Test
    fun `test not operator`() {
        val trueCondition = createTestCondition("True", 0.1, ConditionDetermination.TRUE)
        val falseCondition = createTestCondition("False", 0.2, ConditionDetermination.FALSE)
        val unknownCondition = createTestCondition("Unknown", 0.3, ConditionDetermination.UNKNOWN)

        // Test negation
        assertEquals(ConditionDetermination.FALSE, (!trueCondition).evaluate(mockOperationContext))
        assertEquals(ConditionDetermination.TRUE, (!falseCondition).evaluate(mockOperationContext))
        assertEquals(ConditionDetermination.UNKNOWN, (!unknownCondition).evaluate(mockOperationContext))

        // Verify name and cost
        assertEquals("!True", (!trueCondition).name)
        assertEquals(0.1, (!trueCondition).cost)
    }


    @Test
    fun `test or operator`() {
        val trueCondition = createTestCondition("True", 0.1, ConditionDetermination.TRUE)
        val falseCondition = createTestCondition("False", 0.2, ConditionDetermination.FALSE)
        val unknownCondition = createTestCondition("Unknown", 0.3, ConditionDetermination.UNKNOWN)

        // Test OR logic - TRUE cases
        assertEquals(ConditionDetermination.TRUE, (trueCondition or trueCondition).evaluate(mockOperationContext))
        assertEquals(ConditionDetermination.TRUE, (trueCondition or falseCondition).evaluate(mockOperationContext))
        assertEquals(ConditionDetermination.TRUE, (trueCondition or unknownCondition).evaluate(mockOperationContext))
        assertEquals(ConditionDetermination.TRUE, (falseCondition or trueCondition).evaluate(mockOperationContext))
        assertEquals(ConditionDetermination.TRUE, (unknownCondition or trueCondition).evaluate(mockOperationContext))

        // Test OR logic - UNKNOWN cases
        assertEquals(
            ConditionDetermination.UNKNOWN,
            (falseCondition or unknownCondition).evaluate(mockOperationContext)
        )
        assertEquals(
            ConditionDetermination.UNKNOWN,
            (unknownCondition or falseCondition).evaluate(mockOperationContext)
        )
        assertEquals(
            ConditionDetermination.UNKNOWN,
            (unknownCondition or unknownCondition).evaluate(mockOperationContext)
        )

        // Test OR logic - FALSE case
        assertEquals(ConditionDetermination.FALSE, (falseCondition or falseCondition).evaluate(mockOperationContext))

        // Verify cost is minimum of the two conditions
        assertEquals(0.1, (trueCondition or falseCondition).cost)
        assertEquals(0.2, (falseCondition or unknownCondition).cost)

        // Verify name format
        assertEquals("(True OR False)", (trueCondition or falseCondition).name)
    }

    @Test
    fun `test and operator`() {
        val trueCondition = createTestCondition("True", 0.1, ConditionDetermination.TRUE)
        val falseCondition = createTestCondition("False", 0.2, ConditionDetermination.FALSE)
        val unknownCondition = createTestCondition("Unknown", 0.3, ConditionDetermination.UNKNOWN)

        // Test AND logic - FALSE cases
        assertEquals(ConditionDetermination.FALSE, (falseCondition and falseCondition).evaluate(mockOperationContext))
        assertEquals(ConditionDetermination.FALSE, (falseCondition and trueCondition).evaluate(mockOperationContext))
        assertEquals(ConditionDetermination.FALSE, (falseCondition and unknownCondition).evaluate(mockOperationContext))
        assertEquals(ConditionDetermination.FALSE, (trueCondition and falseCondition).evaluate(mockOperationContext))
        assertEquals(ConditionDetermination.FALSE, (unknownCondition and falseCondition).evaluate(mockOperationContext))

        // Test AND logic - UNKNOWN cases
        assertEquals(
            ConditionDetermination.UNKNOWN,
            (trueCondition and unknownCondition).evaluate(mockOperationContext)
        )
        assertEquals(
            ConditionDetermination.UNKNOWN,
            (unknownCondition and trueCondition).evaluate(mockOperationContext)
        )
        assertEquals(
            ConditionDetermination.UNKNOWN,
            (unknownCondition and unknownCondition).evaluate(mockOperationContext)
        )

        // Test AND logic - TRUE case
        assertEquals(ConditionDetermination.TRUE, (trueCondition and trueCondition).evaluate(mockOperationContext))

        // Verify cost is minimum of the two conditions
        assertEquals(0.1, (trueCondition and falseCondition).cost)
        assertEquals(0.2, (falseCondition and unknownCondition).cost)

        // Verify name format
        assertEquals("(True AND False)", (trueCondition and falseCondition).name)
    }

    @Test
    fun `test complex condition combinations`() {
        val trueCondition = createTestCondition("True", 0.1, ConditionDetermination.TRUE)
        val falseCondition = createTestCondition("False", 0.2, ConditionDetermination.FALSE)
        val unknownCondition = createTestCondition("Unknown", 0.3, ConditionDetermination.UNKNOWN)

        // Test complex combinations
        // (True OR False) AND Unknown = Unknown
        val complex1 = (trueCondition or falseCondition) and unknownCondition
        assertEquals(ConditionDetermination.UNKNOWN, complex1.evaluate(mockOperationContext))

        // (False AND Unknown) OR True = True
        val complex2 = (falseCondition and unknownCondition) or trueCondition
        assertEquals(ConditionDetermination.TRUE, complex2.evaluate(mockOperationContext))

        // !(True OR Unknown) = False
        val complex3 = !(trueCondition or unknownCondition)
        assertEquals(ConditionDetermination.FALSE, complex3.evaluate(mockOperationContext))

        // Complex nested example
        // !((True AND Unknown) OR (False AND True))
        val complex5 = !((trueCondition and unknownCondition) or (falseCondition and trueCondition))
        assertEquals(ConditionDetermination.UNKNOWN, complex5.evaluate(mockOperationContext))
    }

    @Test
    fun `test ComputedBooleanCondition`() {
        // Test condition that evaluates to true
        val trueComputedCondition = ComputedBooleanCondition(
            name = "IsPositive",
            cost = 0.5,
            evaluator = { it, condition -> true }
        )
        assertEquals(ConditionDetermination.TRUE, trueComputedCondition.evaluate(mockOperationContext))

        // Test condition that evaluates to false
        val falseComputedCondition = ComputedBooleanCondition(
            name = "IsNegative",
            cost = 0.3,
            evaluator = { it, condition -> false }
        )
        assertEquals(ConditionDetermination.FALSE, falseComputedCondition.evaluate(mockOperationContext))

        // Test combining computed conditions
        val combinedCondition = trueComputedCondition and falseComputedCondition
        assertEquals(ConditionDetermination.FALSE, combinedCondition.evaluate(mockOperationContext))

        // Test toString()
        assertEquals("ComputedBooleanCondition(name='IsPositive', cost=0.5)", trueComputedCondition.toString())
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/core/DataDictionaryTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Test

class DataDictionaryTest {

    class Person(
        val name: String,
        val age: Int,
    )

    class Address(
        val street: String,
        val city: String,
    )

    class Customer(
        val name: String,
        val address: Address,
    )

    @Test
    fun `should return empty relationships when no domain types have relationships`() {
        val dictionary = DataDictionaryImpl(Person::class.java)
        val relationships = dictionary.allowedRelationships()
        assertEquals(0, relationships.size)
    }

    @Test
    fun `should find relationships in JvmType with nested entity`() {
        val dictionary = DataDictionaryImpl(Customer::class.java, Address::class.java)
        val relationships = dictionary.allowedRelationships()

        assertEquals(1, relationships.size)
        val rel = relationships[0]
        assertEquals("Customer", (rel.from as JvmType).clazz.simpleName)
        assertEquals("Address", (rel.to as JvmType).clazz.simpleName)
        assertEquals("address", rel.name)
        assertEquals(Cardinality.ONE, rel.cardinality)
    }

    class Company(
        val name: String,
        val headquarters: Address,
        val billingAddress: Address,
    )

    @Test
    fun `should find multiple relationships from same type`() {
        val dictionary = DataDictionaryImpl(Company::class.java, Address::class.java)
        val relationships = dictionary.allowedRelationships()

        assertEquals(2, relationships.size)
        val relationshipNames = relationships.map { it.name }
        assertTrue(relationshipNames.contains("headquarters"))
        assertTrue(relationshipNames.contains("billingAddress"))
    }

    class Order(
        val customer: Customer,
        val shippingAddress: Address,
    )

    @Test
    fun `should find all relationships across multiple types`() {
        val dictionary = DataDictionaryImpl(Order::class.java, Customer::class.java, Address::class.java)
        val relationships = dictionary.allowedRelationships()

        assertEquals(3, relationships.size)

        val fromOrder = relationships.filter { (it.from as JvmType).clazz.simpleName == "Order" }
        assertEquals(2, fromOrder.size)

        val fromCustomer = relationships.filter { (it.from as JvmType).clazz.simpleName == "Customer" }
        assertEquals(1, fromCustomer.size)
    }

    @Test
    fun `should find relationships in DynamicType`() {
        val addressType = DynamicType(
            name = "Address",
            ownProperties = listOf(
                SimplePropertyDefinition(name = "street", type = "string"),
            ),
        )

        val personType = DynamicType(
            name = "Person",
            ownProperties = listOf(
                SimplePropertyDefinition(name = "name", type = "string"),
                DomainTypePropertyDefinition(name = "address", type = addressType),
            ),
        )

        val dictionary = DataDictionaryImpl(listOf(personType, addressType))
        val relationships = dictionary.allowedRelationships()

        assertEquals(1, relationships.size)
        assertEquals("Person", relationships[0].from.name)
        assertEquals("Address", relationships[0].to.name)
        assertEquals("address", relationships[0].name)
        assertEquals(Cardinality.ONE, relationships[0].cardinality)
    }

    @Test
    fun `should find relationships between DynamicType and JvmType`() {
        val jvmAddress = JvmType(Address::class.java)

        val personType = DynamicType(
            name = "Person",
            ownProperties = listOf(
                SimplePropertyDefinition(name = "name", type = "string"),
                DomainTypePropertyDefinition(name = "homeAddress", type = jvmAddress),
            ),
        )

        val dictionary = DataDictionaryImpl(listOf(personType, jvmAddress))
        val relationships = dictionary.allowedRelationships()

        assertEquals(1, relationships.size)
        assertEquals("Person", relationships[0].from.name)
        assertEquals(Address::class.java.name, relationships[0].to.name)
        assertEquals("homeAddress", relationships[0].name)
    }

    @Test
    fun `should include inherited relationships`() {
        val addressType = DynamicType(
            name = "Address",
            ownProperties = listOf(
                SimplePropertyDefinition(name = "street", type = "string"),
            ),
        )

        val basePersonType = DynamicType(
            name = "BasePerson",
            ownProperties = listOf(
                SimplePropertyDefinition(name = "name", type = "string"),
                DomainTypePropertyDefinition(name = "address", type = addressType),
            ),
        )

        val employeeType = DynamicType(
            name = "Employee",
            ownProperties = listOf(
                SimplePropertyDefinition(name = "employeeId", type = "string"),
            ),
            parents = listOf(basePersonType),
        )

        val dictionary = DataDictionaryImpl(listOf(employeeType, basePersonType, addressType))
        val relationships = dictionary.allowedRelationships()

        // Employee should have the inherited address relationship
        val employeeRelationships = relationships.filter { it.from.name == "Employee" }
        assertEquals(1, employeeRelationships.size)
        assertEquals("address", employeeRelationships[0].name)
        assertEquals("Address", employeeRelationships[0].to.name)

        // BasePerson also has the relationship
        val basePersonRelationships = relationships.filter { it.from.name == "BasePerson" }
        assertEquals(1, basePersonRelationships.size)

        // Total relationships
        assertEquals(2, relationships.size)
    }

    class Library(
        val name: String,
        val books: List<Address>,
    )

    @Test
    fun `should capture cardinality LIST for collection relationships`() {
        val dictionary = DataDictionaryImpl(Library::class.java, Address::class.java)
        val relationships = dictionary.allowedRelationships()

        assertEquals(1, relationships.size)
        val rel = relationships[0]
        assertEquals("Library", (rel.from as JvmType).clazz.simpleName)
        assertEquals("Address", (rel.to as JvmType).clazz.simpleName)
        assertEquals("books", rel.name)
        assertEquals(Cardinality.LIST, rel.cardinality)
    }

    @Test
    fun `should capture different cardinalities in DynamicType`() {
        val bookType = DynamicType(name = "Book")

        val libraryType = DynamicType(
            name = "Library",
            ownProperties = listOf(
                DomainTypePropertyDefinition(
                    name = "featuredBook",
                    type = bookType,
                    cardinality = Cardinality.ONE,
                ),
                DomainTypePropertyDefinition(
                    name = "optionalBook",
                    type = bookType,
                    cardinality = Cardinality.OPTIONAL,
                ),
                DomainTypePropertyDefinition(
                    name = "books",
                    type = bookType,
                    cardinality = Cardinality.LIST,
                ),
                DomainTypePropertyDefinition(
                    name = "uniqueBooks",
                    type = bookType,
                    cardinality = Cardinality.SET,
                ),
            ),
        )

        val dictionary = DataDictionaryImpl(listOf(libraryType, bookType))
        val relationships = dictionary.allowedRelationships()

        assertEquals(4, relationships.size)

        val featuredRel = relationships.find { it.name == "featuredBook" }!!
        assertEquals(Cardinality.ONE, featuredRel.cardinality)

        val optionalRel = relationships.find { it.name == "optionalBook" }!!
        assertEquals(Cardinality.OPTIONAL, optionalRel.cardinality)

        val listRel = relationships.find { it.name == "books" }!!
        assertEquals(Cardinality.LIST, listRel.cardinality)

        val setRel = relationships.find { it.name == "uniqueBooks" }!!
        assertEquals(Cardinality.SET, setRel.cardinality)
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/core/DomainTypeAssignabilityTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import kotlin.test.assertFalse
import kotlin.test.assertTrue

class DomainTypeAssignabilityTest {

    // Test class hierarchy for inheritance tests
    abstract class AbstractBase
    open class ConcreteBase : AbstractBase()
    class ConcreteDerived : ConcreteBase()
    class UnrelatedClass

    interface TestInterface
    class ImplementingClass : TestInterface

    @Nested
    inner class DynamicTypeAssignability {

        @Test
        fun `DynamicType isAssignableFrom Class always returns false`() {
            val dynamicType = DynamicType(name = "TestType")

            assertFalse(dynamicType.isAssignableFrom(String::class.java))
            assertFalse(dynamicType.isAssignableFrom(Int::class.java))
            assertFalse(dynamicType.isAssignableFrom(ConcreteBase::class.java))
            assertFalse(dynamicType.isAssignableFrom(Any::class.java))
        }

        @Test
        fun `DynamicType isAssignableTo Class always returns false`() {
            val dynamicType = DynamicType(name = "TestType")

            assertFalse(dynamicType.isAssignableTo(String::class.java))
            assertFalse(dynamicType.isAssignableTo(Int::class.java))
            assertFalse(dynamicType.isAssignableTo(ConcreteBase::class.java))
            assertFalse(dynamicType.isAssignableTo(Any::class.java))
        }

        @Test
        fun `DynamicType isAssignableFrom DynamicType with same name returns true`() {
            val type1 = DynamicType(name = "TestType")
            val type2 = DynamicType(name = "TestType")

            assertTrue(type1.isAssignableFrom(type2))
            assertTrue(type2.isAssignableFrom(type1))
        }

        @Test
        fun `DynamicType isAssignableTo DynamicType with same name returns true`() {
            val type1 = DynamicType(name = "TestType")
            val type2 = DynamicType(name = "TestType")

            assertTrue(type1.isAssignableTo(type2))
            assertTrue(type2.isAssignableTo(type1))
        }

        @Test
        fun `DynamicType isAssignableFrom DynamicType with different name returns false`() {
            val type1 = DynamicType(name = "TestType1")
            val type2 = DynamicType(name = "TestType2")

            assertFalse(type1.isAssignableFrom(type2))
            assertFalse(type2.isAssignableFrom(type1))
        }

        @Test
        fun `DynamicType isAssignableTo DynamicType with different name returns false`() {
            val type1 = DynamicType(name = "TestType1")
            val type2 = DynamicType(name = "TestType2")

            assertFalse(type1.isAssignableTo(type2))
            assertFalse(type2.isAssignableTo(type1))
        }

        @Test
        fun `DynamicType isAssignableFrom JvmType returns false`() {
            val dynamicType = DynamicType(name = "TestType")
            val jvmType = JvmType(String::class.java)

            assertFalse(dynamicType.isAssignableFrom(jvmType))
        }

        @Test
        fun `DynamicType isAssignableTo JvmType returns false`() {
            val dynamicType = DynamicType(name = "TestType")
            val jvmType = JvmType(String::class.java)

            assertFalse(dynamicType.isAssignableTo(jvmType))
        }
    }

    @Nested
    inner class JvmTypeAssignability {

        @Test
        fun `JvmType isAssignableFrom with same class returns true`() {
            val jvmType = JvmType(String::class.java)
            assertTrue(jvmType.isAssignableFrom(String::class.java))
        }

        @Test
        fun `JvmType isAssignableTo with same class returns true`() {
            val jvmType = JvmType(String::class.java)
            assertTrue(jvmType.isAssignableTo(String::class.java))
        }

        @Test
        fun `JvmType isAssignableFrom with subclass returns true`() {
            val jvmType = JvmType(ConcreteBase::class.java)
            assertTrue(jvmType.isAssignableFrom(ConcreteDerived::class.java))
        }

        @Test
        fun `JvmType isAssignableTo with superclass returns true`() {
            val jvmType = JvmType(ConcreteDerived::class.java)
            assertTrue(jvmType.isAssignableTo(ConcreteBase::class.java))
        }

        @Test
        fun `JvmType isAssignableFrom with superclass returns false`() {
            val jvmType = JvmType(ConcreteDerived::class.java)
            assertFalse(jvmType.isAssignableFrom(ConcreteBase::class.java))
        }

        @Test
        fun `JvmType isAssignableTo with subclass returns false`() {
            val jvmType = JvmType(ConcreteBase::class.java)
            assertFalse(jvmType.isAssignableTo(ConcreteDerived::class.java))
        }

        @Test
        fun `JvmType isAssignableFrom with unrelated class returns false`() {
            val jvmType = JvmType(ConcreteBase::class.java)
            assertFalse(jvmType.isAssignableFrom(UnrelatedClass::class.java))
        }

        @Test
        fun `JvmType isAssignableTo with unrelated class returns false`() {
            val jvmType = JvmType(ConcreteBase::class.java)
            assertFalse(jvmType.isAssignableTo(UnrelatedClass::class.java))
        }

        @Test
        fun `JvmType isAssignableFrom with abstract superclass`() {
            val jvmType = JvmType(AbstractBase::class.java)
            assertTrue(jvmType.isAssignableFrom(ConcreteBase::class.java))
            assertTrue(jvmType.isAssignableFrom(ConcreteDerived::class.java))
        }

        @Test
        fun `JvmType isAssignableTo with abstract superclass`() {
            val jvmType = JvmType(ConcreteBase::class.java)
            assertTrue(jvmType.isAssignableTo(AbstractBase::class.java))
        }

        @Test
        fun `JvmType isAssignableFrom with Object superclass`() {
            val jvmType = JvmType(Any::class.java)
            assertTrue(jvmType.isAssignableFrom(String::class.java))
            assertTrue(jvmType.isAssignableFrom(ConcreteBase::class.java))
            assertTrue(jvmType.isAssignableFrom(ConcreteDerived::class.java))
        }

        @Test
        fun `JvmType isAssignableTo with Object superclass`() {
            val jvmType = JvmType(String::class.java)
            assertTrue(jvmType.isAssignableTo(Any::class.java))

            val derivedType = JvmType(ConcreteDerived::class.java)
            assertTrue(derivedType.isAssignableTo(Any::class.java))
        }

        @Test
        fun `JvmType isAssignableFrom with interface`() {
            val jvmType = JvmType(TestInterface::class.java)
            assertTrue(jvmType.isAssignableFrom(ImplementingClass::class.java))
        }

        @Test
        fun `JvmType isAssignableTo with interface`() {
            val jvmType = JvmType(ImplementingClass::class.java)
            assertTrue(jvmType.isAssignableTo(TestInterface::class.java))
        }

        @Test
        fun `JvmType isAssignableFrom with non-implementing class and interface returns false`() {
            val jvmType = JvmType(TestInterface::class.java)
            assertFalse(jvmType.isAssignableFrom(ConcreteBase::class.java))
        }

        @Test
        fun `JvmType isAssignableTo with non-implementing class and interface returns false`() {
            val jvmType = JvmType(ConcreteBase::class.java)
            assertFalse(jvmType.isAssignableTo(TestInterface::class.java))
        }

        @Test
        fun `JvmType isAssignableFrom with multi-level inheritance`() {
            val jvmType = JvmType(AbstractBase::class.java)
            assertTrue(jvmType.isAssignableFrom(ConcreteBase::class.java))
            assertTrue(jvmType.isAssignableFrom(ConcreteDerived::class.java))

            val baseType = JvmType(ConcreteBase::class.java)
            assertTrue(baseType.isAssignableFrom(ConcreteDerived::class.java))
        }

        @Test
        fun `JvmType isAssignableTo with multi-level inheritance`() {
            val jvmType = JvmType(ConcreteDerived::class.java)
            assertTrue(jvmType.isAssignableTo(ConcreteBase::class.java))
            assertTrue(jvmType.isAssignableTo(AbstractBase::class.java))
        }

        @Test
        fun `JvmType isAssignableFrom JvmType with same class returns true`() {
            val type1 = JvmType(String::class.java)
            val type2 = JvmType(String::class.java)

            assertTrue(type1.isAssignableFrom(type2))
            assertTrue(type2.isAssignableFrom(type1))
        }

        @Test
        fun `JvmType isAssignableTo JvmType with same class returns true`() {
            val type1 = JvmType(String::class.java)
            val type2 = JvmType(String::class.java)

            assertTrue(type1.isAssignableTo(type2))
            assertTrue(type2.isAssignableTo(type1))
        }

        @Test
        fun `JvmType isAssignableFrom JvmType with subclass returns true`() {
            val baseType = JvmType(ConcreteBase::class.java)
            val derivedType = JvmType(ConcreteDerived::class.java)

            assertTrue(baseType.isAssignableFrom(derivedType))
        }

        @Test
        fun `JvmType isAssignableTo JvmType with superclass returns true`() {
            val derivedType = JvmType(ConcreteDerived::class.java)
            val baseType = JvmType(ConcreteBase::class.java)

            assertTrue(derivedType.isAssignableTo(baseType))
        }

        @Test
        fun `JvmType isAssignableFrom DynamicType returns false`() {
            val jvmType = JvmType(String::class.java)
            val dynamicType = DynamicType(name = "TestType")

            assertFalse(jvmType.isAssignableFrom(dynamicType))
        }

        @Test
        fun `JvmType isAssignableTo DynamicType returns false`() {
            val jvmType = JvmType(String::class.java)
            val dynamicType = DynamicType(name = "TestType")

            assertFalse(jvmType.isAssignableTo(dynamicType))
        }
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/core/DomainTypeSerializationTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.fasterxml.jackson.module.kotlin.readValue
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import kotlin.test.assertEquals
import kotlin.test.assertTrue

class DomainTypeSerializationTest {

    private val om = jacksonObjectMapper()

    @Nested
    inner class DynamicTypeSerialization {

        @Test
        fun `test simple DynamicType can be serialized and deserialized`() {
            val dynamicType = DynamicType(
                name = "TestType",
                description = "A test type",
            )
            val json = om.writeValueAsString(dynamicType)
            assertTrue(json.contains("TestType"))
            assertTrue(json.contains("A test type"))
            val deserialized = om.readValue<DynamicType>(json)
            assertEquals("TestType", deserialized.name)
            assertEquals("A test type", deserialized.description)
            assertEquals(emptyList(), deserialized.properties)
        }

        @Test
        fun `test DynamicType with simple properties can be serialized and deserialized`() {
            val dynamicType = DynamicType(
                name = "Person",
                description = "A person",
                ownProperties = listOf(
                    SimplePropertyDefinition(name = "firstName", type = "string", description = "First name"),
                    SimplePropertyDefinition(name = "age", type = "int", description = "Age"),
                ),
            )
            assertEquals(2, dynamicType.ownProperties.size, "Should have 2 properties of its own")
            assertEquals(2, dynamicType.properties.size, "Should not have inherited properties")

            val json = om.writeValueAsString(dynamicType)
            val deserialized = om.readValue<DomainType>(json)
            assertEquals("Person", deserialized.name)
            assertEquals(2, deserialized.ownProperties.size, "Deserialized should have 2 properties of its own")
            assertEquals(2, deserialized.properties.size, "Deserialized should not have inherited properties")
            assertEquals("firstName", deserialized.properties[0].name)
            assertEquals("age", deserialized.properties[1].name)
        }

        @Test
        fun `test DynamicType polymorphic serialization`() {
            val dynamicType: DomainType = DynamicType(name = "TestType")
            val json = om.writeValueAsString(dynamicType)
            val deserialized = om.readValue<DomainType>(json)
            assertTrue(deserialized is DynamicType)
            assertEquals("TestType", deserialized.name)
        }

        @Test
        fun `test DynamicType with parent includes inherited properties`() {
            val parentType = DynamicType(
                name = "Animal",
                ownProperties = listOf(
                    SimplePropertyDefinition(name = "name", type = "string"),
                    SimplePropertyDefinition(name = "age", type = "int"),
                ),
            )

            val childType = DynamicType(
                name = "Dog",
                ownProperties = listOf(
                    SimplePropertyDefinition(name = "breed", type = "string"),
                ),
                parents = listOf(parentType),
            )

            assertEquals(1, childType.ownProperties.size)
            assertEquals("breed", childType.ownProperties[0].name)

            assertEquals(3, childType.properties.size)
            val propertyNames = childType.properties.map { it.name }
            assertTrue(propertyNames.contains("breed"))
            assertTrue(propertyNames.contains("name"))
            assertTrue(propertyNames.contains("age"))
        }

        @Test
        fun `test DynamicType with multiple parents includes all inherited properties`() {
            val namedType = DynamicType(
                name = "Named",
                ownProperties = listOf(
                    SimplePropertyDefinition(name = "name", type = "string"),
                ),
            )

            val agedType = DynamicType(
                name = "Aged",
                ownProperties = listOf(
                    SimplePropertyDefinition(name = "age", type = "int"),
                ),
            )

            val personType = DynamicType(
                name = "Person",
                ownProperties = listOf(
                    SimplePropertyDefinition(name = "email", type = "string"),
                ),
                parents = listOf(namedType, agedType),
            )

            assertEquals(1, personType.ownProperties.size)
            assertEquals(3, personType.properties.size)
            val propertyNames = personType.properties.map { it.name }
            assertTrue(propertyNames.contains("email"))
            assertTrue(propertyNames.contains("name"))
            assertTrue(propertyNames.contains("age"))
        }

        @Test
        fun `test DynamicType with nested inheritance includes all properties`() {
            val grandparentType = DynamicType(
                name = "LivingThing",
                ownProperties = listOf(
                    SimplePropertyDefinition(name = "alive", type = "boolean"),
                ),
            )

            val parentType = DynamicType(
                name = "Animal",
                ownProperties = listOf(
                    SimplePropertyDefinition(name = "name", type = "string"),
                ),
                parents = listOf(grandparentType),
            )

            val childType = DynamicType(
                name = "Dog",
                ownProperties = listOf(
                    SimplePropertyDefinition(name = "breed", type = "string"),
                ),
                parents = listOf(parentType),
            )

            assertEquals(1, childType.ownProperties.size)
            assertEquals(3, childType.properties.size)
            val propertyNames = childType.properties.map { it.name }
            assertTrue(propertyNames.contains("breed"))
            assertTrue(propertyNames.contains("name"))
            assertTrue(propertyNames.contains("alive"))
        }

        @Test
        fun `test DynamicType with JvmType parent includes inherited properties`() {
            val jvmParent = JvmType(JvmTypeTest.Dog::class.java)

            val childType = DynamicType(
                name = "ServiceDog",
                ownProperties = listOf(
                    SimplePropertyDefinition(name = "serviceType", type = "string"),
                ),
                parents = listOf(jvmParent),
            )

            assertEquals(1, childType.ownProperties.size)
            assertEquals(3, childType.properties.size)
            val propertyNames = childType.properties.map { it.name }
            assertTrue(propertyNames.contains("serviceType"))
            assertTrue(propertyNames.contains("name"))
            assertTrue(propertyNames.contains("breed"))
        }

        @Test
        fun `test DynamicType does not duplicate properties when child overrides parent property`() {
            val parentType = DynamicType(
                name = "Animal",
                ownProperties = listOf(
                    SimplePropertyDefinition(name = "name", type = "string"),
                    SimplePropertyDefinition(name = "age", type = "int"),
                ),
            )

            val childType = DynamicType(
                name = "Dog",
                ownProperties = listOf(
                    SimplePropertyDefinition(name = "name", type = "string", description = "Dog's name"),
                    SimplePropertyDefinition(name = "breed", type = "string"),
                ),
                parents = listOf(parentType),
            )

            assertEquals(2, childType.ownProperties.size)
            assertEquals(3, childType.properties.size)

            val propertyNames = childType.properties.map { it.name }
            assertTrue(propertyNames.contains("name"))
            assertTrue(propertyNames.contains("age"))
            assertTrue(propertyNames.contains("breed"))

            // Verify no duplicates
            assertEquals(propertyNames.size, propertyNames.distinct().size)

            // Verify child's definition takes precedence
            val nameProperty = childType.properties.find { it.name == "name" }
            assertEquals("Dog's name", nameProperty?.description)
        }

        @Test
        fun `test DynamicType with multiple parents deduplicates properties`() {
            val namedType = DynamicType(
                name = "Named",
                ownProperties = listOf(
                    SimplePropertyDefinition(name = "name", type = "string"),
                ),
            )

            val identifiedType = DynamicType(
                name = "Identified",
                ownProperties = listOf(
                    SimplePropertyDefinition(name = "id", type = "string"),
                    SimplePropertyDefinition(name = "name", type = "string"),
                ),
            )

            val personType = DynamicType(
                name = "Person",
                ownProperties = listOf(
                    SimplePropertyDefinition(name = "email", type = "string"),
                ),
                parents = listOf(namedType, identifiedType),
            )

            assertEquals(1, personType.ownProperties.size)
            assertEquals(3, personType.properties.size)

            val propertyNames = personType.properties.map { it.name }
            assertTrue(propertyNames.contains("email"))
            assertTrue(propertyNames.contains("name"))
            assertTrue(propertyNames.contains("id"))

            // Verify no duplicates (name appears in both parents)
            assertEquals(propertyNames.size, propertyNames.distinct().size)
        }

        @Test
        fun `test DynamicType deduplicates properties across deep inheritance hierarchy`() {
            val livingType = DynamicType(
                name = "Living",
                ownProperties = listOf(
                    SimplePropertyDefinition(name = "alive", type = "boolean"),
                    SimplePropertyDefinition(name = "name", type = "string"),
                ),
            )

            val animalType = DynamicType(
                name = "Animal",
                ownProperties = listOf(
                    SimplePropertyDefinition(name = "name", type = "string"),
                    SimplePropertyDefinition(name = "species", type = "string"),
                ),
                parents = listOf(livingType),
            )

            val dogType = DynamicType(
                name = "Dog",
                ownProperties = listOf(
                    SimplePropertyDefinition(name = "breed", type = "string"),
                ),
                parents = listOf(animalType),
            )

            assertEquals(1, dogType.ownProperties.size)
            assertEquals(4, dogType.properties.size)

            val propertyNames = dogType.properties.map { it.name }
            assertTrue(propertyNames.contains("breed"))
            assertTrue(propertyNames.contains("name"))
            assertTrue(propertyNames.contains("species"))
            assertTrue(propertyNames.contains("alive"))

            // Verify no duplicates (name appears at multiple levels)
            assertEquals(propertyNames.size, propertyNames.distinct().size)
        }

        @Test
        fun `test DynamicType ownLabel extracts capitalized name after last dot`() {
            val type1 = DynamicType(name = "Person")
            assertEquals("Person", type1.ownLabel)

            val type2 = DynamicType(name = "com.example.User")
            assertEquals("User", type2.ownLabel)

            val type3 = DynamicType(name = "com.example.domain.Customer")
            assertEquals("Customer", type3.ownLabel)
        }

        @Test
        fun `test DynamicType labels includes own label`() {
            val type = DynamicType(name = "Person")
            val labels = type.labels
            assertEquals(1, labels.size)
            assertTrue(labels.contains("Person"))
        }

        @Test
        fun `test DynamicType labels includes parent labels`() {
            val animalType = DynamicType(name = "Animal")
            val dogType = DynamicType(
                name = "Dog",
                parents = listOf(animalType),
            )

            val labels = dogType.labels
            assertEquals(2, labels.size)
            assertTrue(labels.contains("Dog"))
            assertTrue(labels.contains("Animal"))
        }

        @Test
        fun `test DynamicType labels includes all ancestor labels`() {
            val livingType = DynamicType(name = "Living")
            val animalType = DynamicType(name = "Animal", parents = listOf(livingType))
            val dogType = DynamicType(name = "Dog", parents = listOf(animalType))

            val labels = dogType.labels
            assertEquals(3, labels.size)
            assertTrue(labels.contains("Dog"))
            assertTrue(labels.contains("Animal"))
            assertTrue(labels.contains("Living"))
        }

        @Test
        fun `test DynamicType labels deduplicates across multiple parents`() {
            val namedType = DynamicType(name = "Named")
            val livingType = DynamicType(name = "Living")
            val personType = DynamicType(
                name = "Person",
                parents = listOf(namedType, livingType),
            )

            val labels = personType.labels
            assertEquals(3, labels.size)
            assertTrue(labels.contains("Person"))
            assertTrue(labels.contains("Named"))
            assertTrue(labels.contains("Living"))
        }

        @Test
        fun `test DynamicType labels with JvmType parent`() {
            val jvmAnimal = JvmType(JvmTypeTest.Animal::class.java)
            val serviceDogType = DynamicType(
                name = "ServiceDog",
                parents = listOf(jvmAnimal),
            )

            val labels = serviceDogType.labels
            assertEquals(2, labels.size)
            assertTrue(labels.contains("ServiceDog"))
            assertTrue(labels.contains("Animal"))
        }

        @Test
        fun `test DynamicType ownLabel capitalizes first letter`() {
            val type = DynamicType(name = "person")
            assertEquals("Person", type.ownLabel)
        }
    }

    @Nested
    inner class JvmTypeSerialization {

        @Test
        fun `test JvmType can be serialized and deserialized`() {
            val jvmType = JvmType(String::class.java)
            val json = om.writeValueAsString(jvmType)
            assertTrue(json.contains("java.lang.String"))
            val deserialized = om.readValue<JvmType>(json)
            assertEquals("java.lang.String", deserialized.className)
            assertEquals(String::class.java, deserialized.clazz)
        }

        @Test
        fun `test JvmType polymorphic serialization`() {
            val jvmType: DomainType = JvmType(Integer::class.java)
            val json = om.writeValueAsString(jvmType)
            val deserialized = om.readValue<DomainType>(json)
            assertTrue(deserialized is JvmType)
            assertEquals("java.lang.Integer", deserialized.name)
        }
    }

    @Nested
    inner class MixedDomainTypeSerialization {

        @Test
        fun `test list of mixed DomainTypes can be serialized and deserialized`() {
            val types: List<DomainType> = listOf(
                DynamicType(name = "DynamicOne"),
                JvmType(String::class.java),
                DynamicType(
                    name = "DynamicTwo",
                    ownProperties = listOf(SimplePropertyDefinition("field", "string"))
                ),
                JvmType(Integer::class.java),
            )
            val json = om.writeValueAsString(types)
            val deserialized = om.readValue<List<DomainType>>(json)
            assertEquals(4, deserialized.size)
            assertTrue(deserialized[0] is DynamicType)
            assertTrue(deserialized[1] is JvmType)
            assertTrue(deserialized[2] is DynamicType)
            assertTrue(deserialized[3] is JvmType)
            assertEquals("DynamicOne", deserialized[0].name)
            assertEquals("java.lang.String", deserialized[1].name)
        }
    }

    @Nested
    inner class PropertyDefinitionSerialization {

        @Test
        fun `test PropertyDefinition can be serialized and deserialized`() {
            val property = SimplePropertyDefinition(
                name = "testField",
                type = "string",
                description = "A test field",
            )
            val json = om.writeValueAsString(property)
            val deserialized = om.readValue<PropertyDefinition>(json)
            assertEquals("testField", deserialized.name)
            assertEquals("string", (deserialized as SimplePropertyDefinition).type)
            assertEquals("A test field", deserialized.description)
        }
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/core/EarlyTerminationPolicyTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import io.mockk.every
import io.mockk.mockk
import org.junit.jupiter.api.Test
import kotlin.test.assertNull

class EarlyTerminationPolicyTest {

    @Test
    fun `test MaxActions`() {
        val policy = EarlyTerminationPolicy.firstOf(
            EarlyTerminationPolicy.maxActions(2),
        )
        val agentProcess: AgentProcess = mockk()
        every { agentProcess.history.size } returns 3
        val termination = policy.shouldTerminate(agentProcess)
        assert(termination != null)
    }

    @Test
    fun `test first of MaxAction`() {
        val policy = EarlyTerminationPolicy.firstOf(
            EarlyTerminationPolicy.maxActions(10),
            EarlyTerminationPolicy.maxActions(2),
        )
        val agentProcess: AgentProcess = mockk()
        every { agentProcess.history.size } returns 3
        val termination = policy.shouldTerminate(agentProcess)
        assert(termination != null)
    }

    @Test
    fun `test first of MaxAction and budget terminates`() {
        val policy = EarlyTerminationPolicy.firstOf(
            EarlyTerminationPolicy.maxActions(10),
            EarlyTerminationPolicy.hardBudgetLimit(0.20),
        )
        val agentProcess: AgentProcess = mockk()
        every { agentProcess.history.size } returns 3
        every { agentProcess.cost() } returns 0.25
        val termination = policy.shouldTerminate(agentProcess)
        assert(termination != null)
    }

    @Test
    fun `test first of MaxAction and budget does not terminate`() {
        val policy = EarlyTerminationPolicy.firstOf(
            EarlyTerminationPolicy.maxActions(10),
            EarlyTerminationPolicy.hardBudgetLimit(1.20),
        )
        val agentProcess: AgentProcess = mockk()
        every { agentProcess.history.size } returns 3
        every { agentProcess.cost() } returns 0.25
        val termination = policy.shouldTerminate(agentProcess)
        assertNull(termination)
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/core/ExtendedConditionTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import com.embabel.agent.api.common.OperationContext
import com.embabel.common.core.types.ZeroToOne
import com.embabel.plan.goap.ConditionDetermination
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Test
import org.mockito.Mockito.mock

/**
 * Extended tests for logical operators on [Condition] implementations.
 *
 * These tests focus on the logical operator overloading provided by the Condition interface,
 * validating the behavior of complex condition chains and short-circuit evaluation.
 * The tests verify:
 *
 * - NOT operator (!condition) for negating condition results
 * - Bitwise inverse operator (~condition) for handling UNKNOWN states
 * - OR operator (a or b) with short-circuit evaluation
 * - AND operator (a and b) with short-circuit evaluation
 * - Complex condition chains with multiple operators
 * - Handling of UNKNOWN conditions in logical operations
 * - String representation formatting
 *
 * These tests complement the basic [ConditionTest] by focusing on
 * the extended logical behavior and short-circuiting capabilities.
 */
class ExtendedConditionTest {

    private val mockProcessContext = mock<OperationContext>()

    @Test
    fun `test condition inverse operator (not)`() {
        val condition = ComputedBooleanCondition("testCondition") { it, condition -> true }
        val inverse = !condition

        assertEquals("!testCondition", inverse.name)
        assertEquals(condition.cost, inverse.cost)

        assertEquals(ConditionDetermination.FALSE, inverse.evaluate(mockProcessContext))
    }

    @Test
    fun `test condition bitwise inverse operator (unknown)`() {
        val condition = ComputedBooleanCondition("testCondition") { it, condition -> true }
        val unknown = condition.inv()

        assertEquals("!testCondition", unknown.name)
        assertEquals(condition.cost, unknown.cost)

        assertEquals(ConditionDetermination.FALSE, unknown.evaluate(mockProcessContext))
    }

    @Test
    fun `test OR operator short-circuit evaluation`() {
        var secondEvaluated = false

        val first = ComputedBooleanCondition("first") { it, condition -> true }
        val second = ComputedBooleanCondition("second") { it, condition ->
            secondEvaluated = true
            false
        }

        val combined = first or second

        assertEquals("(first OR second)", combined.name)

        val result = combined.evaluate(mockProcessContext)

        assertEquals(ConditionDetermination.TRUE, result)
        assertFalse(secondEvaluated, "Second condition should not be evaluated due to short-circuit")
    }

    @Test
    fun `test AND operator short-circuit evaluation`() {
        var secondEvaluated = false

        val first = ComputedBooleanCondition("first") { it, condition -> false }
        val second = ComputedBooleanCondition("second") { it, condition ->
            secondEvaluated = true
            true
        }

        val combined = first and second

        assertEquals("(first AND second)", combined.name)

        val result = combined.evaluate(mockProcessContext)

        assertEquals(ConditionDetermination.FALSE, result)
        assertFalse(secondEvaluated, "Second condition should not be evaluated due to short-circuit")
    }

    @Test
    fun `test complex condition chains`() {
        val a = ComputedBooleanCondition("a") { it, condition -> true }
        val b = ComputedBooleanCondition("b") { it, condition -> false }
        val c = ComputedBooleanCondition("c") { it, condition -> true }

        // (a AND !b) OR c
        val complex = (a and !b) or c

        assertEquals(ConditionDetermination.TRUE, complex.evaluate(mockProcessContext))

        // Verify name has correct parentheses
        assertTrue(complex.name.contains("a"))
        assertTrue(complex.name.contains("b"))
        assertTrue(complex.name.contains("c"))
        assertTrue(complex.name.contains("AND"))
        assertTrue(complex.name.contains("OR"))
    }

    @Test
    fun `test condition with UNKNOWN evaluation`() {
        // Create a condition that always returns UNKNOWN using a custom implementation
        val unknownCondition = object : Condition {
            override val name = "unknown"
            override val cost: ZeroToOne = 0.0
            override fun evaluate(context: OperationContext) = ConditionDetermination.UNKNOWN
        }

        assertEquals(ConditionDetermination.UNKNOWN, unknownCondition.evaluate(mockProcessContext))

        // Test NOT with UNKNOWN
        val notUnknown = !unknownCondition
        assertEquals(ConditionDetermination.UNKNOWN, notUnknown.evaluate(mockProcessContext))

        // Test AND with UNKNOWN
        val trueCondition = ComputedBooleanCondition("true") { it, condition -> true }
        val unknownAndTrue = unknownCondition and trueCondition
        assertEquals(ConditionDetermination.UNKNOWN, unknownAndTrue.evaluate(mockProcessContext))

        // Test OR with UNKNOWN
        val falseCondition = ComputedBooleanCondition("false") { it, condition -> false }
        val unknownOrFalse = unknownCondition or falseCondition
        assertEquals(ConditionDetermination.UNKNOWN, unknownOrFalse.evaluate(mockProcessContext))
    }

    @Test
    fun `test condition infoString`() {
        val condition = ComputedBooleanCondition("testCondition", cost = 0.5) { it, condition -> true }
        val infoString = condition.infoString(null)

        assertTrue(infoString.contains("testCondition"))
        assertTrue(infoString.contains("0.5"))
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/core/IoBindingTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows

/**
 * Tests for the [IoBinding] value class.
 *
 * The IoBinding class represents a binding of "name:Type" pairs used in actions
 * for defining inputs and outputs. These tests verify:
 *
 * - Basic extraction of name and type components from various formats
 * - Constructor overloads with Java Class and Kotlin KClass types
 * - Default naming behavior when only a type is provided
 * - Input validation for blank values
 * - Support for custom types and fully qualified names
 */
class IoBindingTest {

    @Test
    fun `test IoBinding extracts name and type correctly`() {
        // Test with explicit name and type
        val binding1 = IoBinding("person:java.lang.String")
        assertEquals("person", binding1.name)
        assertEquals("java.lang.String", binding1.type)

        // Test with simple type string (no explicit name)
        val binding2 = IoBinding("Integer")
        assertEquals(IoBinding.DEFAULT_BINDING, binding2.name)
        assertEquals("Integer", binding2.type)
    }

    @Test
    fun `test IoBinding constructor with name and type string`() {
        val binding = IoBinding("document", "java.lang.String")
        assertEquals("document", binding.name)
        assertEquals("java.lang.String", binding.type)
    }

    @Test
    fun `test IoBinding constructor with Java Class`() {
        // With explicit name
        val binding1 = IoBinding("document", String::class.java)
        assertEquals("document", binding1.name)
        assertEquals("java.lang.String", binding1.type)

        // With default name
        val binding2 = IoBinding(type = Integer::class.java)
        assertEquals(IoBinding.DEFAULT_BINDING, binding2.name)
        assertEquals("java.lang.Integer", binding2.type)
    }

    @Test
    fun `test IoBinding constructor with Kotlin KClass`() {
        // With explicit name
        val binding1 = IoBinding("document", String::class)
        assertEquals("document", binding1.name)
        assertEquals("java.lang.String", binding1.type)

        // With default name
        val binding2 = IoBinding(type = Int::class)
        assertEquals(IoBinding.DEFAULT_BINDING, binding2.name)
        assertEquals("int", binding2.type)
    }

    @Test
    fun `test IoBinding rejects blank values`() {
        assertThrows<IllegalArgumentException> {
            IoBinding("")
        }

        assertThrows<IllegalArgumentException> {
            IoBinding(" ")
        }
    }

    @Test
    fun `test DEFAULT_BINDING constant is 'it'`() {
        assertEquals(IoBinding.DEFAULT_BINDING, IoBinding.DEFAULT_BINDING)
    }

    // Test with a custom class to ensure full qualified name handling
    private class CustomTestClass

    @Test
    fun `test IoBinding with custom class types`() {
        val binding = IoBinding("myObject", CustomTestClass::class)

        assertEquals("myObject", binding.name)
        assertTrue(binding.type.endsWith("CustomTestClass"))
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/core/JvmTypeTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import com.fasterxml.jackson.annotation.JsonClassDescription
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertFalse
import org.junit.jupiter.api.Assertions.assertNotNull
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Test

class JvmTypeTest {

    class Dog(
        val name: String,
        val breed: String,
    )

    @JsonClassDescription("A feline creature")
    class Cat

    @Test
    fun `should default description`() {
        val type = JvmType(Dog::class.java)
        assertEquals(Dog::class.java.name, type.name)
        assertEquals(Dog::class.java.name, type.description)
    }

    @Test
    fun `should build description from annotation`() {
        val type = JvmType(Cat::class.java)
        assertEquals(Cat::class.java.name, type.name)
        assertEquals("Cat: A feline creature", type.description)
    }

    @Test
    fun `should list properties`() {
        val type = JvmType(Dog::class.java)
        assertEquals(2, type.ownProperties.size)
        assertEquals("name", type.ownProperties[0].name)
        assertEquals("breed", type.ownProperties[1].name)
    }

    @Test
    fun `should list scalar properties as SimplePropertyDefinition`() {
        val type = JvmType(Dog::class.java)
        val nameProperty = type.ownProperties[0]
        assertEquals("name", nameProperty.name)
        assert(nameProperty is SimplePropertyDefinition)
        assertEquals("String", (nameProperty as SimplePropertyDefinition).type)
    }

    class Owner(
        val name: String,
        val dog: Dog,
    )

    @Test
    fun `should nest entity properties as DomainTypePropertyDefinition`() {
        val type = JvmType(Owner::class.java)
        assertEquals(2, type.ownProperties.size)

        val nameProperty = type.ownProperties[0]
        assertEquals("name", nameProperty.name)
        assert(nameProperty is SimplePropertyDefinition)

        val dogProperty = type.ownProperties[1]
        assertEquals("dog", dogProperty.name)
        assert(dogProperty is DomainTypePropertyDefinition)

        val dogType = (dogProperty as DomainTypePropertyDefinition).type
        assert(dogType is JvmType)
        assertEquals(Dog::class.java.name, (dogType as JvmType).className)
    }

    class Kennel(
        val name: String,
        val capacity: Int,
        val dogs: List<Dog>,
    )

    @Test
    fun `should nest collection of entities with cardinality`() {
        val type = JvmType(Kennel::class.java)
        assertEquals(3, type.ownProperties.size)

        val nameProperty = type.ownProperties[0]
        assertEquals("name", nameProperty.name)
        assert(nameProperty is SimplePropertyDefinition)

        val capacityProperty = type.ownProperties[1]
        assertEquals("capacity", capacityProperty.name)
        assert(capacityProperty is SimplePropertyDefinition)

        val dogsProperty = type.ownProperties[2]
        assertEquals("dogs", dogsProperty.name)
        assert(dogsProperty is DomainTypePropertyDefinition)
        val domainProp = dogsProperty as DomainTypePropertyDefinition
        assertEquals(Dog::class.java.name, (domainProp.type as JvmType).className)
        assertEquals(Cardinality.LIST, domainProp.cardinality)
    }

    @Test
    fun `should verify nested entity has its own properties`() {
        val type = JvmType(Owner::class.java)
        val dogProperty = type.ownProperties[1] as DomainTypePropertyDefinition
        val dogType = dogProperty.type as JvmType

        assertEquals(2, dogType.ownProperties.size)
        assertEquals("name", dogType.ownProperties[0].name)
        assertEquals("breed", dogType.ownProperties[1].name)
    }

    open class Animal(
        val name: String,
    )

    class Horse(
        name: String,
        val breed: String,
    ) : Animal(name)

    @Test
    fun `should detect parent class`() {
        val type = JvmType(Horse::class.java)
        assertEquals(1, type.parents.size)
        assertEquals(Animal::class.java.name, type.parents[0].className)
    }

    @Test
    fun `should include inherited properties in properties`() {
        val type = JvmType(Horse::class.java)
        assertEquals(1, type.ownProperties.size)
        assertEquals("breed", type.ownProperties[0].name)

        assertEquals(2, type.properties.size)
        val propertyNames = type.properties.map { it.name }
        assert(propertyNames.contains("breed"))
        assert(propertyNames.contains("name"))
    }

    interface Vehicle {
        val wheels: Int
    }

    class Truck(
        override val wheels: Int,
        val capacity: Int,
    ) : Vehicle

    @Test
    fun `should detect interface parent`() {
        val type = JvmType(Truck::class.java)
        assertEquals(1, type.parents.size)
        assertEquals(Vehicle::class.java.name, type.parents[0].className)
    }

    @Test
    fun `should include interface properties in properties`() {
        val type = JvmType(Truck::class.java)
        assertEquals(2, type.ownProperties.size)

        // Note: Interface properties are not exposed as fields via reflection,
        // so they won't be included in the properties list
        assertEquals(2, type.properties.size)
        val propertyNames = type.properties.map { it.name }
        assert(propertyNames.contains("wheels"))
        assert(propertyNames.contains("capacity"))
    }

    open class Pet(
        val name: String,
        val age: Int,
    )

    class Parrot(
        name: String,
        age: Int,
        val color: String,
    ) : Pet(name, age)

    @Test
    fun `should not duplicate inherited properties`() {
        val type = JvmType(Parrot::class.java)
        assertEquals(1, type.ownProperties.size)
        assertEquals("color", type.ownProperties[0].name)

        assertEquals(3, type.properties.size)
        val propertyNames = type.properties.map { it.name }
        assert(propertyNames.contains("name"))
        assert(propertyNames.contains("age"))
        assert(propertyNames.contains("color"))

        // Verify no duplicates
        assertEquals(propertyNames.size, propertyNames.distinct().size)
    }

    open class BaseEntity(
        val id: String,
    )

    open class NamedEntity(
        id: String,
        val name: String,
    ) : BaseEntity(id)

    class Product(
        id: String,
        name: String,
        val price: Double,
    ) : NamedEntity(id, name)

    @Test
    fun `should deduplicate properties across multiple inheritance levels`() {
        val type = JvmType(Product::class.java)
        assertEquals(1, type.ownProperties.size)
        assertEquals("price", type.ownProperties[0].name)

        assertEquals(3, type.properties.size)
        val propertyNames = type.properties.map { it.name }
        assert(propertyNames.contains("id"))
        assert(propertyNames.contains("name"))
        assert(propertyNames.contains("price"))

        // Verify no duplicates
        assertEquals(propertyNames.size, propertyNames.distinct().size)
    }

    @Test
    fun `should return own label as simple class name`() {
        val type = JvmType(Dog::class.java)
        assertEquals("Dog", type.ownLabel)
    }

    @Test
    fun `should return labels including own type`() {
        val type = JvmType(Dog::class.java)
        val labels = type.labels
        assertEquals(1, labels.size)
        assert(labels.contains("Dog"))
    }

    @Test
    fun `should include parent labels in labels`() {
        val type = JvmType(Horse::class.java)
        val labels = type.labels
        assertEquals(2, labels.size)
        assert(labels.contains("Horse"))
        assert(labels.contains("Animal"))
    }

    @Test
    fun `should include all ancestor labels`() {
        val type = JvmType(Product::class.java)
        val labels = type.labels
        assertEquals(3, labels.size)
        assert(labels.contains("Product"))
        assert(labels.contains("NamedEntity"))
        assert(labels.contains("BaseEntity"))
    }

    @Test
    fun `should include interface labels`() {
        val type = JvmType(Truck::class.java)
        val labels = type.labels
        assertEquals(2, labels.size)
        assert(labels.contains("Truck"))
        assert(labels.contains("Vehicle"))
    }

    // Test classes for children method
    abstract class TestVehicle

    class TestCar : TestVehicle()

    class TestMotorcycle : TestVehicle()

    interface TestFlyable

    class TestAirplane : TestVehicle(), TestFlyable

    class TestBird : TestFlyable

    @Test
    fun `should find children classes in current package`() {
        val vehicleType = JvmType(TestVehicle::class.java)
        val children = vehicleType.children(listOf("com.embabel.agent.core"))

        assertNotNull(children, "Children should not be null")
        assertTrue(children.isNotEmpty(), "Should find some children")

        val childrenNames = children.map { it.name }.toSet()
        assertTrue(childrenNames.contains(TestCar::class.java.name), "Should find TestCar")
        assertTrue(childrenNames.contains(TestMotorcycle::class.java.name), "Should find TestMotorcycle")
        assertTrue(childrenNames.contains(TestAirplane::class.java.name), "Should find TestAirplane")
        assertFalse(childrenNames.contains(TestVehicle::class.java.name), "Should not include the parent class itself")
    }

    @Test
    fun `should find interface implementers`() {
        val flyableType = JvmType(TestFlyable::class.java)
        val children = flyableType.children(listOf("com.embabel.agent.core"))

        assertNotNull(children, "Children should not be null")
        assertTrue(children.isNotEmpty(), "Should find some children")

        val childrenNames = children.map { it.name }.toSet()
        assertTrue(childrenNames.contains(TestAirplane::class.java.name), "Should find TestAirplane")
        assertTrue(childrenNames.contains(TestBird::class.java.name), "Should find TestBird")
        assertFalse(childrenNames.contains(TestFlyable::class.java.name), "Should not include the interface itself")
    }

    @Test
    fun `should return empty list for leaf classes`() {
        val dogType = JvmType(Dog::class.java)
        val children = dogType.children(listOf("com.embabel.agent.core"))

        assertNotNull(children, "Children should not be null")
        assertTrue(children.isEmpty(), "Leaf classes should have no children")
    }

    @Test
    fun `should handle non-existent packages gracefully`() {
        val vehicleType = JvmType(TestVehicle::class.java)
        val children = vehicleType.children(listOf("com.nonexistent.package"))

        assertNotNull(children, "Children should not be null")
        assertTrue(children.isEmpty(), "Should return empty list for non-existent packages")
    }

    @Test
    fun `should find children across multiple packages`() {
        val vehicleType = JvmType(TestVehicle::class.java)
        val children = vehicleType.children(listOf("com.embabel.agent.core", "com.embabel"))

        assertNotNull(children, "Children should not be null")
        // Should at least find the test classes in the current package
        val childrenNames = children.map { it.name }.toSet()
        assertTrue(childrenNames.contains(TestCar::class.java.name), "Should find TestCar")
    }

    @Test
    fun `should handle java standard library classes`() {
        val listType = JvmType(java.util.List::class.java)
        val children = listType.children(listOf("java.util"))

        assertNotNull(children, "Children should not be null")
        // Note: Spring's classpath scanner might not find all standard library classes
        // This is expected behavior as it's designed for application classes
        // Just verify the method doesn't throw exceptions
        println("Found ${children.size} children of List: ${children.map { it.name }}")
    }

    @Test
    fun `should return distinct results`() {
        val vehicleType = JvmType(TestVehicle::class.java)
        // Use overlapping packages that might return duplicates
        val children = vehicleType.children(listOf("com.embabel.agent.core", "com.embabel.agent"))

        assertNotNull(children, "Children should not be null")
        val childrenNames = children.map { it.name }
        assertEquals(childrenNames.size, childrenNames.distinct().size, "Should not have duplicate children")
    }

    @Test
    fun `should work with concrete parent classes`() {
        val animalType = JvmType(Animal::class.java)
        val children = animalType.children(listOf("com.embabel.agent.core"))

        assertNotNull(children, "Children should not be null")
        val childrenNames = children.map { it.name }.toSet()
        assertTrue(childrenNames.contains(Horse::class.java.name), "Should find Horse as child of Animal")
    }

    @Test
    fun `should capitalize label from fully qualified class name`() {
        val type = JvmType(String::class.java)
        assertEquals("String", type.ownLabel)
        assert(type.labels.contains("String"))
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/core/ProcessContextTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core

import com.embabel.agent.api.dsl.evenMoreEvilWizard
import com.embabel.agent.event.AgentProcessCompletedEvent
import com.embabel.agent.testing.common.EventSavingAgenticEventListener
import com.embabel.agent.testing.integration.IntegrationTestUtils.dummyAgentProcessRunning
import com.embabel.agent.testing.integration.IntegrationTestUtils.dummyPlatformServices
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test

class ProcessContextTest {

    @Test
    fun `no additional listeners`() {
        val ese = EventSavingAgenticEventListener()
        val platformServices = dummyPlatformServices(eventListener = ese)
        val agentProcess = dummyAgentProcessRunning(evenMoreEvilWizard(), platformServices)
        val processContext = ProcessContext(
            ProcessOptions(),
            agentProcess = agentProcess,
            platformServices = platformServices,
        )
        assertEquals(0, ese.processEvents.size)
        processContext.onProcessEvent(
            AgentProcessCompletedEvent(
                agentProcess = agentProcess
            )
        )
        assertEquals(1, ese.processEvents.size)
    }

    @Test
    fun `additional listener`() {
        val ese = EventSavingAgenticEventListener()
        val platformServices = dummyPlatformServices(eventListener = ese)
        val agentProcess = dummyAgentProcessRunning(evenMoreEvilWizard(), platformServices)
        val localListener = EventSavingAgenticEventListener()
        val processContext = ProcessContext(
            ProcessOptions(listeners = listOf(localListener)),
            agentProcess = agentProcess,
            platformServices = platformServices,
        )
        assertEquals(0, ese.processEvents.size)
        processContext.onProcessEvent(
            AgentProcessCompletedEvent(
                agentProcess = agentProcess
            )
        )
        assertEquals(1, ese.processEvents.size)
        assertEquals(1, localListener.processEvents.size)
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/core/hitl/FormBindingRequestTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core.hitl

import com.embabel.agent.api.dsl.evenMoreEvilWizard
import com.embabel.agent.core.AgentProcess
import com.embabel.agent.core.ProcessContext
import com.embabel.agent.testing.integration.IntegrationTestUtils.dummyAgentProcessRunning
import com.embabel.ux.form.*
import io.mockk.every
import io.mockk.mockk
import io.mockk.mockkConstructor
import io.mockk.unmockkAll
import org.junit.jupiter.api.*
import org.junit.jupiter.api.Assertions.assertTrue
import java.util.*
import kotlin.test.assertEquals
import kotlin.test.assertNotNull

class FormBindingRequestTest {

    private lateinit var processContext: ProcessContext
    private lateinit var form: Form
    private lateinit var formProcessor: DefaultFormProcessor
    private lateinit var formBinder: FormBinder<TestData>

    @BeforeEach
    fun setUp() {
        processContext = mockk(relaxed = true)

        form = Form(
            title = "Test Form",
            controls = listOf(
                TextField(
                    id = "name",
                    label = "Name",
                    required = true
                ),
                TextField(
                    id = "email",
                    label = "Email",
                    required = true
                )
            )
        )

        formProcessor = mockk()
        mockkConstructor(DefaultFormProcessor::class)
        every { anyConstructed<DefaultFormProcessor>().processSubmission(any(), any()) } returns mockk(relaxed = true)

        formBinder = mockk()
        mockkConstructor(FormBinder::class)
    }

    @AfterEach
    fun tearDown() {
        unmockkAll()
    }

    @Nested
    inner class Constructor {
        @Test
        fun `should create FormBindingRequest with correct properties`() {
            val request = FormBindingRequest(form, TestData::class.java)

            assertEquals(form, request.payload)
            assertEquals(TestData::class.java, request.outputClass)
            assertEquals(false, request.persistent())
        }

        @Test
        fun `should create FormBindingRequest with persistent flag`() {
            val request = FormBindingRequest(form, TestData::class.java, persistent = true)

            assertEquals(true, request.persistent())
        }
    }

    @Nested
    inner class OnResponse {

        @Test
        fun `should process form submission and add bound instance to blackboard`() {
            val agentProcess = dummyAgentProcessRunning(evenMoreEvilWizard())
            val request = FormBindingRequest(form, TestData::class.java)
            val formSubmission = FormSubmission(
                formId = form.id,
                values = mapOf(
                    "name" to "John Doe",
                    "email" to "john@example.com"
                )
            )
            val response = FormResponse(
                awaitableId = request.id,
                formSubmission = formSubmission
            )

            val submissionResult = mockk<FormSubmissionResult>(relaxed = true)
            every { submissionResult.valid } returns true

            every {
                anyConstructed<DefaultFormProcessor>().processSubmission(
                    form,
                    formSubmission
                )
            } returns submissionResult

            val testData = TestData("John Doe", "john@example.com")
            every { anyConstructed<FormBinder<TestData>>().bind(submissionResult) } returns testData

            val result = request.onResponse(response, agentProcess)

            assertEquals(testData, agentProcess.lastResult())
            assertEquals(ResponseImpact.UPDATED, result)
        }

        @Test
        fun `should throw IllegalStateException when form submission is not valid`() {
            val agentProcess = mockk<AgentProcess>()
            val request = FormBindingRequest(form, TestData::class.java)
            val formSubmission = FormSubmission(
                formId = form.id,
                values = mapOf(
                    "name" to "John Doe"
                    // Missing required email field
                )
            )
            val response = FormResponse(
                awaitableId = request.id,
                formSubmission = formSubmission
            )

            val submissionResult = mockk<FormSubmissionResult>()
            every { submissionResult.valid } returns false
            every { submissionResult.validationErrors } returns mapOf("email" to "This field is required")

            every {
                anyConstructed<DefaultFormProcessor>().processSubmission(
                    form,
                    formSubmission
                )
            } returns submissionResult

            val exception = assertThrows<IllegalStateException> {
                request.onResponse(response, agentProcess)
            }

            assertTrue(exception.message!!.contains("Form submission is not valid"))
        }
    }

    @Nested
    inner class FormResponseClass {
        @Test
        fun `should create FormResponse with correct properties`() {
            // Arrange
            val awaitableId = UUID.randomUUID().toString()
            val formSubmission = mockk<FormSubmission>()

            // Act
            val response = FormResponse(
                awaitableId = awaitableId,
                formSubmission = formSubmission,
                persistent = true
            )

            // Assert
            assertEquals(awaitableId, response.awaitableId)
            assertEquals(formSubmission, response.formSubmission)
            assertEquals(true, response.persistent())
            assertNotNull(response.id)
            assertNotNull(response.timestamp)
        }
    }

    @Nested
    inner class `toString method` {
        @Test
        fun `should return infoString with verbose false`() {
            // Arrange
            val request = FormBindingRequest(form, TestData::class.java)

            // Act
            val result = request.toString()

            // Assert
            assertTrue(result.contains(request.id))
            assertTrue(result.contains("payload="))
        }
    }

    // Test data class used for binding
    data class TestData(
        val name: String,
        val email: String
    )
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/core/support/ConcurrentAgentProcessTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core.support

import com.embabel.agent.api.annotation.support.AgentMetadataReader
import com.embabel.agent.api.common.StuckHandler
import com.embabel.agent.api.common.StuckHandlerResult
import com.embabel.agent.api.common.StuckHandlingResultCode
import com.embabel.agent.api.dsl.Frog
import com.embabel.agent.api.dsl.evenMoreEvilWizard
import com.embabel.agent.core.*
import com.embabel.agent.core.hitl.ConfirmationRequest
import com.embabel.agent.domain.io.UserInput
import com.embabel.agent.event.ObjectAddedEvent
import com.embabel.agent.event.ObjectBoundEvent
import com.embabel.agent.spi.support.GoapPlannerFactory
import com.embabel.agent.support.SimpleTestAgent
import com.embabel.agent.testing.common.EventSavingAgenticEventListener
import com.embabel.agent.testing.integration.IntegrationTestUtils.dummyPlatformServices
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import java.io.IOException

class ConcurrentAgentProcessTest {

    @Nested
    inner class Serialization {

        @Test
        fun `should not be able to serialize AgentProcess`() {
            val cap = ConcurrentAgentProcess(
                id = "test",
                agent = SimpleTestAgent,
                processOptions = ProcessOptions(),
                blackboard = InMemoryBlackboard(),
                platformServices = dummyPlatformServices(),
                parentId = null,
                plannerFactory = GoapPlannerFactory,
            )
            assertThrows<IOException> {
                jacksonObjectMapper().writeValueAsString(cap)
            }
        }
    }

    @Nested
    inner class Waiting {

        @Test
        fun `wait on tick for DSL agent`() {
            waitOnTick(DslWaitingAgent)
        }

        @Test
        fun `wait on run for DSL agent`() {
            waitOnRun(DslWaitingAgent)
        }

        @Test
        fun `wait on tick for annotation agent`() {
            waitOnTick(AgentMetadataReader().createAgentMetadata(AnnotationWaitingAgent()) as Agent)
        }

        @Test
        fun `wait on run for annotation agent`() {
            waitOnRun(AgentMetadataReader().createAgentMetadata(AnnotationWaitingAgent()) as Agent)
        }

        private fun waitOnTick(agent: Agent) {
            val dummyPlatformServices = dummyPlatformServices()
            val blackboard = InMemoryBlackboard()
            blackboard += UserInput("Rod")
            val agentProcess = ConcurrentAgentProcess(
                id = "test",
                agent = agent,
                processOptions = ProcessOptions(),
                blackboard = blackboard,
                platformServices = dummyPlatformServices,
                parentId = null,
                plannerFactory = GoapPlannerFactory,
            )
            val agentStatus = agentProcess.tick()
            assertEquals(AgentProcessStatusCode.WAITING, agentStatus.status)
            val confirmation = blackboard.lastResult()
            assertTrue(confirmation is ConfirmationRequest<*>)
        }

        private fun waitOnRun(agent: Agent) {
            val dummyPlatformServices = dummyPlatformServices()
            val blackboard = InMemoryBlackboard()
            blackboard += (IoBinding.DEFAULT_BINDING to UserInput("Rod"))
            val agentProcess = ConcurrentAgentProcess(
                id = "test",
                agent = agent,
                processOptions = ProcessOptions(),
                blackboard = blackboard,
                platformServices = dummyPlatformServices,
                parentId = null,
                plannerFactory = GoapPlannerFactory,
            )
            val agentStatus = agentProcess.run()
            assertEquals(AgentProcessStatusCode.WAITING, agentStatus.status)
        }
    }

    @Nested
    inner class StuckHandling {

        @Test
        fun `expect stuck for DSL agent with no stuck handler`() {
            val agentProcess = run(DslWaitingAgent)
            assertEquals(AgentProcessStatusCode.STUCK, agentProcess.status)
        }

        @Test
        fun `expect stuck for annotation agent with no stuck handler`() {
            val agentProcess = run(AgentMetadataReader().createAgentMetadata(AnnotationWaitingAgent()) as Agent)
            assertEquals(AgentProcessStatusCode.STUCK, agentProcess.status)
        }

        @Test
        fun `expect unstuck for DSL agent with magic stuck handler`() {
            unstick(DslWaitingAgent)
        }

        @Test
        fun `expect unstuck for annotation agent with magic stuck handler`() {
            unstick(AgentMetadataReader().createAgentMetadata(AnnotationWaitingAgent()) as Agent)
        }

        @Test
        fun `agent implementing stuck handler unsticks itself`() {
            val sua = SelfUnstickingAgent()
            val agent = AgentMetadataReader().createAgentMetadata(sua) as Agent
            val agentProcess = run(agent)
            assertTrue(sua.called, "Stuck handler must have been called")
            assertEquals(AgentProcessStatusCode.COMPLETED, agentProcess.status)
            val last = agentProcess.lastResult()
            assertEquals(
                Frog("Duke"), last,
                "Last result should be the dog added by the stuck handler. Poor Duke was turned into a frog."
            )
        }

        private fun unstick(agent: Agent) {
            var called = false
            val stuckHandler = StuckHandler {
                called = true
                it.processContext.blackboard += UserInput("Rod")
                StuckHandlerResult(
                    message = "The magic unsticker unstuck the stuckness",
                    handler = null,
                    code = StuckHandlingResultCode.REPLAN,
                    agentProcess = it,
                )
            }
            val agentProcess = run(agent.copy(stuckHandler = stuckHandler))
            assertTrue(called, "Stuck handler must have been called")
            assertEquals(AgentProcessStatusCode.WAITING, agentProcess.status)
        }


        private fun run(agent: Agent): AgentProcess {
            val dummyPlatformServices = dummyPlatformServices()
            val blackboard = InMemoryBlackboard()
            // Don't add anything to the blackboard
            val agentProcess = ConcurrentAgentProcess(
                id = "test",
                agent = agent,
                processOptions = ProcessOptions(),
                blackboard = blackboard,
                platformServices = dummyPlatformServices,
                parentId = null,
                plannerFactory = GoapPlannerFactory,
            )
            return agentProcess.run()
        }

    }

    @Nested
    inner class Binding {

        @Test
        fun adds() {
            val ese = EventSavingAgenticEventListener()
            val dummyPlatformServices = dummyPlatformServices(ese)
            val blackboard = InMemoryBlackboard()
            val agentProcess = ConcurrentAgentProcess(
                id = "test",
                agent = SimpleTestAgent,
                processOptions = ProcessOptions(),
                blackboard = blackboard,
                platformServices = dummyPlatformServices,
                plannerFactory = GoapPlannerFactory,
                parentId = null,
            )
            val person = LocalPerson("John")
            agentProcess += person
            assertTrue(blackboard.objects.contains(person))
        }

        @Test
        fun `emits add event`() {
            val ese = EventSavingAgenticEventListener()
            val dummyPlatformServices = dummyPlatformServices(ese)
            val blackboard = InMemoryBlackboard()
            val agentProcess = ConcurrentAgentProcess(
                id = "test",
                agent = SimpleTestAgent,
                processOptions = ProcessOptions(),
                blackboard = blackboard,
                platformServices = dummyPlatformServices,
                plannerFactory = GoapPlannerFactory,
                parentId = null,
            )
            val person = LocalPerson("John")
            agentProcess += person
            val e = ese.processEvents.filterIsInstance<ObjectAddedEvent>().single()
            assertEquals(person, e.value)
        }

        @Test
        fun binds() {
            val dummyPlatformServices = dummyPlatformServices()
            val blackboard = InMemoryBlackboard()
            val agentProcess = ConcurrentAgentProcess(
                "test", agent = SimpleTestAgent,
                processOptions = ProcessOptions(),
                blackboard = blackboard,
                platformServices = dummyPlatformServices,
                plannerFactory = GoapPlannerFactory,
                parentId = null,
            )
            val person = LocalPerson("John")
            agentProcess += ("john" to person)
            assertTrue(blackboard.objects.contains(person))
            assertEquals(person, blackboard["john"])
        }

        @Test
        fun `emits binding event`() {
            val ese = EventSavingAgenticEventListener()
            val dummyPlatformServices = dummyPlatformServices(ese)
            val blackboard = InMemoryBlackboard()
            val agentProcess = ConcurrentAgentProcess(
                "test", agent = SimpleTestAgent,
                processOptions = ProcessOptions(),
                blackboard = blackboard,
                platformServices = dummyPlatformServices,
                plannerFactory = GoapPlannerFactory,
                parentId = null,
            )
            val person = LocalPerson("John")
            agentProcess += ("john" to person)
            assertTrue(blackboard.objects.contains(person))
            assertEquals(person, blackboard["john"])
            assertEquals(1, ese.processEvents.size, "Should have 1 event")
            val e = ese.processEvents.filterIsInstance<ObjectBoundEvent>().single()
            assertEquals(person, e.value)
            assertEquals("john", e.name)
        }
    }

    @Nested
    inner class ToolsStatsTest {

        @Test
        fun `no tools called`() {
            val ese = EventSavingAgenticEventListener()
            val dummyPlatformServices = dummyPlatformServices()
            val blackboard = InMemoryBlackboard()
            val agentProcess = ConcurrentAgentProcess(
                "test", agent = SimpleTestAgent,
                processOptions = ProcessOptions(),
                blackboard = blackboard,
                platformServices = dummyPlatformServices,
                plannerFactory = GoapPlannerFactory,
                parentId = null,
            )
            assertEquals(0, agentProcess.toolsStats.toolsStats.size, "No tools called yet")
        }
    }

    @Nested
    inner class Kill {

        @Test
        fun `cannot run killed process`() {
            val dummyPlatformServices = dummyPlatformServices()
            val blackboard = InMemoryBlackboard()
            blackboard += UserInput("Rod")
            val agentProcess = ConcurrentAgentProcess(
                id = "test",
                agent = evenMoreEvilWizard(),
                processOptions = ProcessOptions(),
                blackboard = blackboard,
                platformServices = dummyPlatformServices,
                plannerFactory = GoapPlannerFactory,
                parentId = null,
            )
            assertEquals(AgentProcessStatusCode.NOT_STARTED, agentProcess.status)
            agentProcess.kill()
            assertEquals(AgentProcessStatusCode.KILLED, agentProcess.status)
            for (i in 0..10) {
                val status = agentProcess.tick()
                assertEquals(AgentProcessStatusCode.KILLED, status.status, "Process should remain killed")
            }
            for (i in 0..10) {
                val status = agentProcess.run()
                assertEquals(AgentProcessStatusCode.KILLED, status.status, "Process should remain killed")
            }

        }

    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/core/support/DefaultAgentPlatformTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core.support

import com.embabel.agent.api.dsl.evenMoreEvilWizard
import com.embabel.agent.channel.DevNullOutputChannel
import com.embabel.agent.spi.config.spring.AgentPlatformProperties.ProcessType
import com.embabel.agent.core.AgentPlatform
import com.embabel.agent.core.Context
import com.embabel.agent.core.ContextId
import com.embabel.agent.core.ProcessOptions
import com.embabel.agent.event.AgenticEventListener
import com.embabel.agent.spi.ContextRepository
import com.embabel.agent.spi.support.InMemoryContextRepository
import com.embabel.agent.spi.support.SimpleContext
import com.embabel.agent.support.Dog
import com.embabel.agent.testing.common.EventSavingAgenticEventListener
import io.mockk.mockk
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test

class DefaultAgentPlatformTest {

    private fun raw(
        l: AgenticEventListener = EventSavingAgenticEventListener(),
        contextRepository: ContextRepository = InMemoryContextRepository(),
    ): AgentPlatform {
        return DefaultAgentPlatform(
            "name",
            "description",
            processType = ProcessType.SIMPLE,
            mockk(),
            mockk(relaxed = true),
            l,
            contextRepository = contextRepository,
            asyncer = mockk(),
            objectMapper = mockk(),
            outputChannel = DevNullOutputChannel,
            templateRenderer = mockk(),
        )
    }

    @Test
    fun `starts with empty blackboard`() {
        val dap = raw()
        val ap = dap.createAgentProcess(evenMoreEvilWizard(), ProcessOptions(), emptyMap())
        assertEquals(0, ap.objects.size)
    }

    @Test
    fun `binds parameters to blackboard`() {
        val dap = raw()
        val ap = dap.createAgentProcess(
            evenMoreEvilWizard(), ProcessOptions(), mapOf(
                "dog" to Dog("Duke")
            )
        )
        assertEquals(1, ap.objects.size)
        assertEquals("Duke", ((ap["dog"] as Dog).name))
    }

    @Nested
    inner class ContextLoading {

        @Test
        fun `loads context`() {
            val contextRepository = InMemoryContextRepository()
            var context: Context = SimpleContext(id = "1234")
            context.bind("otherDog", Dog("Apollo"))
            context = contextRepository.save(context)
            val dap = raw(contextRepository = contextRepository)
            val ap = dap.createAgentProcess(
                evenMoreEvilWizard(),
                ProcessOptions(contextId = ContextId(context.id)),
                mapOf(
                    "dog" to Dog("Duke")
                ),
            )
            assertEquals(2, ap.objects.size, "Should have 2 objects, not ${ap.objects.size}: ${ap.objects}")
            assertEquals("Duke", ((ap["dog"] as Dog).name))
            assertEquals("Apollo", ((ap["otherDog"] as Dog).name))
        }

    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/core/support/SimpleAgentProcessTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core.support

import com.embabel.agent.api.annotation.AchievesGoal
import com.embabel.agent.api.annotation.Action
import com.embabel.agent.api.annotation.confirm
import com.embabel.agent.api.annotation.support.AgentMetadataReader
import com.embabel.agent.api.annotation.waitFor
import com.embabel.agent.api.common.StuckHandler
import com.embabel.agent.api.common.StuckHandlerResult
import com.embabel.agent.api.common.StuckHandlingResultCode
import com.embabel.agent.api.dsl.Frog
import com.embabel.agent.api.dsl.agent
import com.embabel.agent.api.dsl.evenMoreEvilWizard
import com.embabel.agent.core.*
import com.embabel.agent.core.hitl.ConfirmationRequest
import com.embabel.agent.domain.io.UserInput
import com.embabel.agent.domain.library.Person
import com.embabel.agent.event.ObjectAddedEvent
import com.embabel.agent.event.ObjectBoundEvent
import com.embabel.agent.spi.support.GoapPlannerFactory
import com.embabel.agent.support.Dog
import com.embabel.agent.support.SimpleTestAgent
import com.embabel.agent.testing.common.EventSavingAgenticEventListener
import com.embabel.agent.testing.integration.IntegrationTestUtils.dummyPlatformServices
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import java.io.IOException

data class LocalPerson(
    override val name: String,
) : Person

@com.embabel.agent.api.annotation.Agent(
    description = "waiting agent",
    scan = false,
)
class AnnotationWaitingAgent {

    @Action
    fun fromInput(input: UserInput): LocalPerson {
        return confirm(
            LocalPerson(name = input.content),
            "Is this the right dude?"
        )
    }

    @Action
    @AchievesGoal(description = "the big goal in the sky")
    fun toFrog(person: LocalPerson): Frog {
        return Frog(person.name)
    }
}

@com.embabel.agent.api.annotation.Agent(
    description = "self unsticking agent",
    scan = false,
)
class SelfUnstickingAgent : StuckHandler {

    // Putting this here isn't threadsafe of course, but this is just a test
    var called = false

    @Action
    fun fromInput(input: UserInput): LocalPerson {
        return confirm(
            LocalPerson(name = input.content),
            "Is this the right dude?"
        )
    }

    // This agent will get stuck as there's no dog to convert to a frog
    @Action
    @AchievesGoal(description = "the big goal in the sky")
    fun toFrog(dog: Dog): Frog {
        return Frog(dog.name)
    }

    override fun handleStuck(agentProcess: AgentProcess): StuckHandlerResult {
        called = true
        agentProcess.addObject(Dog("Duke"))
        return StuckHandlerResult(
            message = "Unsticking myself",
            handler = this,
            code = StuckHandlingResultCode.REPLAN,
            agentProcess = agentProcess,
        )
    }
}

val DslWaitingAgent = agent("Waiter", description = "Simple test agent that waits") {
    transformation<UserInput, LocalPerson>(name = "thing") {
        val person = LocalPerson(name = "Rod")
        waitFor(
            ConfirmationRequest(
                person,
                "Is this the dude?"
            )
        )

    }

    transformation<LocalPerson, Frog>(name = "thing2") {
        Frog(name = it.input.name)
    }

    goal(name = "done", description = "done", satisfiedBy = Frog::class)
}

class SimpleAgentProcessTest {

    @Nested
    inner class Serialization {

        @Test
        fun `should not be able to serialize AgentProcess`() {
            val sap = SimpleAgentProcess(
                id = "test",
                agent = SimpleTestAgent,
                processOptions = ProcessOptions(),
                blackboard = InMemoryBlackboard(),
                platformServices = dummyPlatformServices(),
                plannerFactory = GoapPlannerFactory,
                parentId = null,
            )
            assertThrows<IOException> {
                jacksonObjectMapper().writeValueAsString(sap)
            }
        }
    }

    @Nested
    inner class Waiting {

        @Test
        fun `wait on tick for DSL agent`() {
            waitOnTick(DslWaitingAgent)
        }

        @Test
        fun `wait on run for DSL agent`() {
            waitOnRun(DslWaitingAgent)
        }

        @Test
        fun `wait on tick for annotation agent`() {
            waitOnTick(AgentMetadataReader().createAgentMetadata(AnnotationWaitingAgent()) as Agent)
        }

        @Test
        fun `wait on run for annotation agent`() {
            waitOnRun(AgentMetadataReader().createAgentMetadata(AnnotationWaitingAgent()) as Agent)
        }

        private fun waitOnTick(agent: Agent) {
            val dummyPlatformServices = dummyPlatformServices()
            val blackboard = InMemoryBlackboard()
            blackboard += UserInput("Rod")
            val agentProcess = SimpleAgentProcess(
                id = "test",
                agent = agent,
                processOptions = ProcessOptions(),
                blackboard = blackboard,
                platformServices = dummyPlatformServices,
                plannerFactory = GoapPlannerFactory,
                parentId = null,
            )
            val agentStatus = agentProcess.tick()
            assertEquals(AgentProcessStatusCode.WAITING, agentStatus.status)
            val confirmation = blackboard.lastResult()
            assertTrue(confirmation is ConfirmationRequest<*>)
        }

        private fun waitOnRun(agent: Agent) {
            val dummyPlatformServices = dummyPlatformServices()
            val blackboard = InMemoryBlackboard()
            blackboard += (IoBinding.DEFAULT_BINDING to UserInput("Rod"))
            val agentProcess = SimpleAgentProcess(
                id = "test",
                agent = agent,
                processOptions = ProcessOptions(),
                blackboard = blackboard,
                platformServices = dummyPlatformServices,
                plannerFactory = GoapPlannerFactory,
                parentId = null,
            )
            val agentStatus = agentProcess.run()
            assertEquals(AgentProcessStatusCode.WAITING, agentStatus.status)
        }
    }

    @Nested
    inner class StuckHandling {

        @Test
        fun `expect stuck for DSL agent with no stuck handler`() {
            val agentProcess = run(DslWaitingAgent)
            assertEquals(AgentProcessStatusCode.STUCK, agentProcess.status)
        }

        @Test
        fun `expect stuck for annotation agent with no stuck handler`() {
            val agentProcess = run(AgentMetadataReader().createAgentMetadata(AnnotationWaitingAgent()) as Agent)
            assertEquals(AgentProcessStatusCode.STUCK, agentProcess.status)
        }

        @Test
        fun `expect unstuck for DSL agent with magic stuck handler`() {
            unstick(DslWaitingAgent)
        }

        @Test
        fun `expect unstuck for annotation agent with magic stuck handler`() {
            unstick(AgentMetadataReader().createAgentMetadata(AnnotationWaitingAgent()) as Agent)
        }

        @Test
        fun `agent implementing stuck handler unsticks itself`() {
            val sua = SelfUnstickingAgent()
            val agent = AgentMetadataReader().createAgentMetadata(sua) as Agent
            val agentProcess = run(agent)
            assertTrue(sua.called, "Stuck handler must have been called")
            assertEquals(AgentProcessStatusCode.COMPLETED, agentProcess.status)
            val last = agentProcess.lastResult()
            assertEquals(
                Frog("Duke"), last,
                "Last result should be the dog added by the stuck handler. Poor Duke was turned into a frog."
            )
        }

        private fun unstick(agent: Agent) {
            var called = false
            val stuckHandler = StuckHandler {
                called = true
                it.processContext.blackboard += UserInput("Rod")
                StuckHandlerResult(
                    message = "The magic unsticker unstuck the stuckness",
                    handler = null,
                    code = StuckHandlingResultCode.REPLAN,
                    agentProcess = it,
                )
            }
            val agentProcess = run(agent.copy(stuckHandler = stuckHandler))
            assertTrue(called, "Stuck handler must have been called")
            assertEquals(AgentProcessStatusCode.WAITING, agentProcess.status)
        }


        private fun run(agent: Agent): AgentProcess {
            val dummyPlatformServices = dummyPlatformServices()
            val blackboard = InMemoryBlackboard()
            // Don't add anything to the blackboard
            val agentProcess = SimpleAgentProcess(
                id = "test",
                agent = agent,
                processOptions = ProcessOptions(),
                blackboard = blackboard,
                platformServices = dummyPlatformServices,
                plannerFactory = GoapPlannerFactory,
                parentId = null,
            )
            return agentProcess.run()
        }

    }

    @Nested
    inner class Binding {

        @Test
        fun adds() {
            val ese = EventSavingAgenticEventListener()
            val dummyPlatformServices = dummyPlatformServices(ese)
            val blackboard = InMemoryBlackboard()
            val agentProcess = SimpleAgentProcess(
                id = "test",
                agent = SimpleTestAgent,
                processOptions = ProcessOptions(),
                blackboard = blackboard,
                platformServices = dummyPlatformServices,
                plannerFactory = GoapPlannerFactory,
                parentId = null,
            )
            val person = LocalPerson("John")
            agentProcess += person
            assertTrue(blackboard.objects.contains(person))
        }

        @Test
        fun `emits add event`() {
            val ese = EventSavingAgenticEventListener()
            val dummyPlatformServices = dummyPlatformServices(ese)
            val blackboard = InMemoryBlackboard()
            val agentProcess = SimpleAgentProcess(
                id = "test",
                agent = SimpleTestAgent,
                processOptions = ProcessOptions(),
                blackboard = blackboard,
                platformServices = dummyPlatformServices,
                plannerFactory = GoapPlannerFactory,
                parentId = null,
            )
            val person = LocalPerson("John")
            agentProcess += person
            val e = ese.processEvents.filterIsInstance<ObjectAddedEvent>().single()
            assertEquals(person, e.value)
        }

        @Test
        fun binds() {
            val dummyPlatformServices = dummyPlatformServices()
            val blackboard = InMemoryBlackboard()
            val agentProcess = SimpleAgentProcess(
                "test", agent = SimpleTestAgent,
                processOptions = ProcessOptions(),
                blackboard = blackboard,
                platformServices = dummyPlatformServices,
                plannerFactory = GoapPlannerFactory,
                parentId = null,
            )
            val person = LocalPerson("John")
            agentProcess += ("john" to person)
            assertTrue(blackboard.objects.contains(person))
            assertEquals(person, blackboard["john"])
        }

        @Test
        fun `emits binding event`() {
            val ese = EventSavingAgenticEventListener()
            val dummyPlatformServices = dummyPlatformServices(ese)
            val blackboard = InMemoryBlackboard()
            val agentProcess = SimpleAgentProcess(
                "test", agent = SimpleTestAgent,
                processOptions = ProcessOptions(),
                blackboard = blackboard,
                platformServices = dummyPlatformServices,
                plannerFactory = GoapPlannerFactory,
                parentId = null,
            )
            val person = LocalPerson("John")
            agentProcess += ("john" to person)
            assertTrue(blackboard.objects.contains(person))
            assertEquals(person, blackboard["john"])
            assertEquals(1, ese.processEvents.size, "Should have 1 event")
            val e = ese.processEvents.filterIsInstance<ObjectBoundEvent>().single()
            assertEquals(person, e.value)
            assertEquals("john", e.name)
        }
    }

    @Nested
    inner class ToolsStatsTest {

        @Test
        fun `no tools called`() {
            val ese = EventSavingAgenticEventListener()
            val dummyPlatformServices = dummyPlatformServices()
            val blackboard = InMemoryBlackboard()
            val agentProcess = SimpleAgentProcess(
                "test", agent = SimpleTestAgent,
                processOptions = ProcessOptions(),
                blackboard = blackboard,
                platformServices = dummyPlatformServices,
                plannerFactory = GoapPlannerFactory,
                parentId = null,
            )
            assertEquals(0, agentProcess.toolsStats.toolsStats.size, "No tools called yet")
        }
    }

    @Nested
    inner class Kill {

        @Test
        fun `cannot run killed process`() {
            val dummyPlatformServices = dummyPlatformServices()
            val blackboard = InMemoryBlackboard()
            blackboard += UserInput("Rod")
            val agentProcess = SimpleAgentProcess(
                id = "test",
                agent = evenMoreEvilWizard(),
                processOptions = ProcessOptions(),
                blackboard = blackboard,
                platformServices = dummyPlatformServices,
                plannerFactory = GoapPlannerFactory,
                parentId = null,
            )
            assertEquals(AgentProcessStatusCode.NOT_STARTED, agentProcess.status)
            agentProcess.kill()
            assertEquals(AgentProcessStatusCode.KILLED, agentProcess.status)
            for (i in 0..10) {
                val status = agentProcess.tick()
                assertEquals(AgentProcessStatusCode.KILLED, status.status, "Process should remain killed")
            }
            for (i in 0..10) {
                val status = agentProcess.run()
                assertEquals(AgentProcessStatusCode.KILLED, status.status, "Process should remain killed")
            }

        }

    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/core/support/SpringAiUtilsKtTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.core.support

import com.embabel.agent.api.annotation.support.PersonWithReverseTool
import com.embabel.agent.api.common.ToolObject
import io.mockk.every
import io.mockk.mockk
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Test
import org.springframework.ai.tool.ToolCallback
import kotlin.test.assertEquals

class SpringAiUtilsKtTest {

    @Test
    fun `safelyGetTools from empty collection`() {
        val result = safelyGetToolCallbacks(emptySet())
        assertTrue(result.isEmpty())
    }

    @Test
    fun `safelyGetTools from single instance in set`() {
        val result = safelyGetToolCallbacks(
            setOf(
                ToolObject(PersonWithReverseTool("John Doe"))
            )
        )
        assertEquals(1, result.size)
    }

    @Test
    fun `safelyGetTools from single instance in ArrayList`() {
        val result = safelyGetToolCallbacks(arrayListOf(ToolObject.from(PersonWithReverseTool("John Doe"))))
        assertEquals(1, result.size)
    }

    @Test
    fun `safelyGetTools from single instance and tool callback`() {
        val tc = mockk<ToolCallback>()
        every { tc.toolDefinition.name() } returns "test"
        val result = safelyGetToolCallbacks(setOf(tc, PersonWithReverseTool("John Doe")).map { ToolObject.from(it) })
        assertEquals(2, result.size)
        assertEquals("test", result[1].toolDefinition.name())
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/domain/InMemoryCrudRepositoryTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.domain

import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import java.util.*

class InMemoryCrudRepositoryTest {

    private lateinit var repository: InMemoryCrudRepository<TestEntity>

    data class TestEntity(val id: String? = null, val name: String, val value: Int)

    @BeforeEach
    fun setup() {
        repository = InMemoryCrudRepository(
            idGetter = { it.id },
            idSetter = { entity, id -> entity.copy(id = id) }
        )
    }

    @Test
    fun testSaveNewEntity() {
        val entity = TestEntity(name = "test", value = 42)

        val saved = repository.save(entity)

        assertNotNull(saved.id)
        assertEquals("test", saved.name)
        assertEquals(42, saved.value)
        assertEquals(1, repository.count())
    }

    @Test
    fun testSaveExistingEntity() {
        val entity = TestEntity(id = "existing-id", name = "test", value = 42)

        val saved = repository.save(entity)

        assertEquals("existing-id", saved.id)
        assertEquals("test", saved.name)
        assertEquals(42, saved.value)
        assertEquals(1, repository.count())
    }

    @Test
    fun testSaveAll() {
        val entities = listOf(
            TestEntity(name = "first", value = 1),
            TestEntity(name = "second", value = 2)
        )

        val saved = repository.saveAll(entities)

        assertEquals(2, saved.count())
        assertEquals(2, repository.count())
        saved.forEach { assertNotNull(it.id) }
    }

    @Test
    fun testFindById() {
        val entity = TestEntity(name = "test", value = 42)
        val saved = repository.save(entity)

        val found = repository.findById(saved.id!!)

        assertTrue(found.isPresent)
        assertEquals(saved, found.get())
    }

    @Test
    fun testFindByIdNotFound() {
        val found = repository.findById("non-existent")

        assertFalse(found.isPresent)
    }

    @Test
    fun testExistsById() {
        val entity = TestEntity(name = "test", value = 42)
        val saved = repository.save(entity)

        assertTrue(repository.existsById(saved.id!!))
        assertFalse(repository.existsById("non-existent"))
    }

    @Test
    fun testFindAll() {
        val entities = listOf(
            TestEntity(name = "first", value = 1),
            TestEntity(name = "second", value = 2),
            TestEntity(name = "third", value = 3)
        )
        repository.saveAll(entities)

        val all = repository.findAll().toList()

        assertEquals(3, all.size)
        assertTrue(all.any { it.name == "first" })
        assertTrue(all.any { it.name == "second" })
        assertTrue(all.any { it.name == "third" })
    }

    @Test
    fun testFindAllByIds() {
        val entities = listOf(
            TestEntity(name = "first", value = 1),
            TestEntity(name = "second", value = 2),
            TestEntity(name = "third", value = 3)
        )
        val saved = repository.saveAll(entities).toList()
        val idsToFind = listOf(saved[0].id!!, saved[2].id!!)

        val found = repository.findAllById(idsToFind).toList()

        assertEquals(2, found.size)
        assertTrue(found.any { it.name == "first" })
        assertTrue(found.any { it.name == "third" })
        assertFalse(found.any { it.name == "second" })
    }

    @Test
    fun testFindAllByIdsWithNonExistentIds() {
        val entity = TestEntity(name = "test", value = 42)
        val saved = repository.save(entity)
        val idsToFind = listOf(saved.id!!, "non-existent")

        val found = repository.findAllById(idsToFind).toList()

        assertEquals(1, found.size)
        assertEquals("test", found[0].name)
    }

    @Test
    fun testCount() {
        assertEquals(0, repository.count())

        repository.save(TestEntity(name = "first", value = 1))
        assertEquals(1, repository.count())

        repository.save(TestEntity(name = "second", value = 2))
        assertEquals(2, repository.count())
    }

    @Test
    fun testDeleteById() {
        val entity = TestEntity(name = "test", value = 42)
        val saved = repository.save(entity)
        assertEquals(1, repository.count())

        repository.deleteById(saved.id!!)

        assertEquals(0, repository.count())
        assertFalse(repository.existsById(saved.id!!))
    }

    @Test
    fun testDeleteByIdNonExistent() {
        repository.deleteById("non-existent")

        assertEquals(0, repository.count())
    }

    @Test
    fun testDelete() {
        val entity = TestEntity(name = "test", value = 42)
        val saved = repository.save(entity)
        assertEquals(1, repository.count())

        repository.delete(saved)

        assertEquals(0, repository.count())
        assertFalse(repository.existsById(saved.id!!))
    }

    @Test
    fun testDeleteEntityWithoutId() {
        val entity = TestEntity(name = "test", value = 42)

        repository.delete(entity)

        assertEquals(0, repository.count())
    }

    @Test
    fun testDeleteAllByIds() {
        val entities = listOf(
            TestEntity(name = "first", value = 1),
            TestEntity(name = "second", value = 2),
            TestEntity(name = "third", value = 3)
        )
        val saved = repository.saveAll(entities).toList()
        assertEquals(3, repository.count())

        val idsToDelete = listOf(saved[0].id!!, saved[2].id!!)
        repository.deleteAllById(idsToDelete)

        assertEquals(1, repository.count())
        assertTrue(repository.existsById(saved[1].id!!))
        assertFalse(repository.existsById(saved[0].id!!))
        assertFalse(repository.existsById(saved[2].id!!))
    }

    @Test
    fun testDeleteAllByEntities() {
        val entities = listOf(
            TestEntity(name = "first", value = 1),
            TestEntity(name = "second", value = 2),
            TestEntity(name = "third", value = 3)
        )
        val saved = repository.saveAll(entities).toList()
        assertEquals(3, repository.count())

        val entitiesToDelete = listOf(saved[0], saved[2])
        repository.deleteAll(entitiesToDelete)

        assertEquals(1, repository.count())
        assertTrue(repository.existsById(saved[1].id!!))
        assertFalse(repository.existsById(saved[0].id!!))
        assertFalse(repository.existsById(saved[2].id!!))
    }

    @Test
    fun testDeleteAll() {
        val entities = listOf(
            TestEntity(name = "first", value = 1),
            TestEntity(name = "second", value = 2),
            TestEntity(name = "third", value = 3)
        )
        repository.saveAll(entities)
        assertEquals(3, repository.count())

        repository.deleteAll()

        assertEquals(0, repository.count())
        assertTrue(repository.findAll().toList().isEmpty())
    }

    @Test
    fun testUpdateExistingEntity() {
        val entity = TestEntity(name = "original", value = 42)
        val saved = repository.save(entity)

        val updated = saved.copy(name = "updated", value = 100)
        val savedUpdated = repository.save(updated)

        assertEquals(saved.id, savedUpdated.id)
        assertEquals("updated", savedUpdated.name)
        assertEquals(100, savedUpdated.value)
        assertEquals(1, repository.count())
    }

    @Test
    fun testConcurrentModification() {
        val entities = (1..100).map { TestEntity(name = "entity$it", value = it) }

        entities.parallelStream().forEach { repository.save(it) }

        assertEquals(100, repository.count())
        assertEquals(100, repository.findAll().toList().size)
    }

    @Test
    fun testIdGenerationUniqueness() {
        val entities = (1..10).map { TestEntity(name = "entity$it", value = it) }
        val saved = repository.saveAll(entities).toList()

        val ids = saved.map { it.id }.toSet()
        assertEquals(10, ids.size)
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/domain/io/UserInputSerializationTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.domain.io

import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import org.junit.Test
import kotlin.test.assertEquals

class UserInputSerializationTest {

    private val objectMapper = jacksonObjectMapper().registerModule(JavaTimeModule())

    @Test
    fun `can deserialize`() {
        val content = "Hello, world!"
        val json = """
            { "content": "$content" }
        """.trimIndent()
        val userInput = objectMapper.readValue(json, UserInput::class.java)
        assertEquals(content, userInput.content)
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/e2e/AgentPlatformIntegrationTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.e2e

import com.embabel.agent.api.annotation.support.AgentMetadataReader
import com.embabel.agent.api.common.AgentPlatformTypedOps
import com.embabel.agent.api.common.NoSuchAgentException
import com.embabel.agent.api.common.TypedOps
import com.embabel.agent.api.common.asFunction
import com.embabel.agent.api.common.autonomy.Autonomy
import com.embabel.agent.api.common.autonomy.GoalChoiceApprover
import com.embabel.agent.api.dsl.EvilWizardAgent
import com.embabel.agent.api.dsl.Frog
import com.embabel.agent.api.dsl.evenMoreEvilWizard
import com.embabel.agent.core.AgentPlatform
import com.embabel.agent.core.AgentProcessStatusCode
import com.embabel.agent.core.ProcessOptions
import com.embabel.agent.domain.io.UserInput
import com.embabel.agent.domain.library.HasContent
import com.embabel.agent.spi.LlmOperations
import com.embabel.agent.spi.Ranking
import com.embabel.agent.spi.Rankings
import com.embabel.agent.testing.integration.DummyObjectCreatingLlmOperations
import com.embabel.agent.testing.integration.FakeRanker
import com.embabel.common.core.types.Described
import com.embabel.common.core.types.Named
import com.embabel.example.simple.horoscope.TestHoroscopeService
import com.embabel.example.simple.horoscope.java.TestStarNewsFinder
import com.embabel.example.simple.horoscope.kotlin.Writeup
import org.junit.jupiter.api.*
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.boot.test.context.TestConfiguration
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Import
import org.springframework.context.annotation.Primary
import org.springframework.test.context.ActiveProfiles
import kotlin.test.assertNotNull

@TestConfiguration
class FakeConfig {

    @Bean
    @Primary
    fun fakeHoroscopeService() = TestHoroscopeService {
        """"
            |On Monday, try to avoid being eaten by wolves            .
        """.trimMargin()
    }

    @Bean
    @Primary
    fun fakeRanker() = object : FakeRanker {

        override fun <T> rank(
            description: String,
            userInput: String,
            rankables: Collection<T>,
        ): Rankings<T> where T : Named, T : Described {
            when (description) {
                "agent" -> {
                    val a = rankables.firstOrNull { it.name.contains("Star") } ?: fail { "No agent with Star found" }
                    return Rankings(
                        rankings = listOf(Ranking(a, .9))
                    )
                }

                "goal" -> {
                    val g =
                        rankables.firstOrNull { it.description.contains("horoscope") } ?: fail("No goal with horoscope")
                    return Rankings(
                        rankings = listOf(Ranking(g, .9))
                    )
                }

                else -> throw IllegalArgumentException("Unknown description $description")
            }
        }
    }

    @Bean
    fun llmOperations(): LlmOperations {
        return DummyObjectCreatingLlmOperations.LoremIpsum
    }

}

/**
 * Integration tests
 */
@SpringBootTest
@ActiveProfiles("test")
@Import(
    value = [
        FakeConfig::class,
    ]
)
class AgentPlatformIntegrationTest(
    @param:Autowired
    private val autonomy: Autonomy,
    @param:Autowired
    private val agentMetadataReader: AgentMetadataReader,
    @param:Autowired
    private val horoscopeService: TestHoroscopeService,
) {

    private val agentPlatform: AgentPlatform = autonomy.agentPlatform

    private val typedOps: TypedOps = AgentPlatformTypedOps(autonomy.agentPlatform)

    @BeforeEach
    fun setup() {
        agentMetadataReader.createAgentScopes(
            com.embabel.example.simple.horoscope.kotlin.TestStarNewsFinder(
                horoscopeService,
                wordCount = 100,
                storyCount = 5,
            ),
            TestStarNewsFinder(horoscopeService, 5),
        ).forEach { agentPlatform.deploy(it) }
    }

    @Nested
    inner class Repository {

        @Test
        fun `process not started`() {
            val ap = agentPlatform.createAgentProcess(evenMoreEvilWizard(), ProcessOptions(), emptyMap())
            assertEquals(AgentProcessStatusCode.NOT_STARTED, ap.status)
        }

        @Test
        fun `process not started via repository`() {
            val ap = agentPlatform.createAgentProcess(evenMoreEvilWizard(), ProcessOptions(), emptyMap())
            val ap2 = agentPlatform.getAgentProcess(ap.id)
            assertNotNull(ap2, "Process should be saved to repository")
            assertEquals(AgentProcessStatusCode.NOT_STARTED, ap2.status)
        }
    }


    @Nested
    inner class SmokeTest {

        @Test
        fun `AgentPlatform starts up`() {
            // Nothing to test
        }
    }

    @Nested
    inner class Transforms {

        @Test
        fun `run Java star finder as transform by name`() {
            val writeup = typedOps.asFunction<UserInput, HasContent>(
                outputClass = HasContent::class.java,
                agentName = "JavaTestStarNewsFinder",
            ).apply(
                UserInput("Lynda is a Scorpio, find some news for her"),
                ProcessOptions(),
            )
            assertNotNull(writeup)
            assertNotNull(writeup.content)
        }

        @Test
        fun `run Kotlin star finder as transform by name`() {
            val writeup = typedOps.asFunction<UserInput, HasContent>(
                outputClass = HasContent::class.java,
                agentName = "TestStarNewsFinder",
            ).apply(
                UserInput("Lynda is a Scorpio, find some news for her"),
                ProcessOptions(),
            )
            assertNotNull(writeup)
            assertNotNull(writeup.content)
        }

        @Test
        fun `reject unknown agent in transform by name`() {
            assertThrows<NoSuchAgentException> {
                typedOps.asFunction<UserInput, Writeup>(
                    outputClass = Writeup::class.java,
                    agentName = "stuff and nonsense",
                )
            }
        }

        @Test
        fun `run dsl agent as transform`() {
            autonomy.agentPlatform.deploy(EvilWizardAgent)
            val frog = typedOps.asFunction<UserInput, Frog>(
            ).apply(
                UserInput("Hamish a poor boy"),
                ProcessOptions(),
            )
            assertNotNull(frog)
        }
    }

    @Nested
    inner class ClosedRunAgent {

        @Test
        fun `choose and run star finder agent`() {
            val dynamicExecutionResult = autonomy.chooseAndRunAgent(
                "Lynda is a Scorpio, find some news for her",
                ProcessOptions(),
            )
            assertNotNull(dynamicExecutionResult.output)
            assertTrue(
                dynamicExecutionResult.output is HasContent,
                "Expected HasContent, got ${dynamicExecutionResult.output.javaClass.name}"
            )
        }
    }

    @Nested
    inner class OpenAccomplishGoal {

        @Test
        fun `run star finder agent`() {
            val dynamicExecutionResult = autonomy.chooseAndAccomplishGoal(
                processOptions = ProcessOptions(),
                goalChoiceApprover = GoalChoiceApprover.APPROVE_ALL,
                agentScope = agentPlatform,
                bindings = mapOf(
                    "userInput" to UserInput("Lynda is a Scorpio, find some news for her"),
                ),
            )
            assertNotNull(dynamicExecutionResult.output)
            assertTrue(
                dynamicExecutionResult.output is HasContent,
                "Expected HasContent, got ${dynamicExecutionResult.output.javaClass.name}"
            )
        }

    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/e2e/AiInjectionIntegrationTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.e2e

import com.embabel.agent.api.common.Ai
import com.embabel.agent.api.common.AiBuilder
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.context.annotation.Import
import org.springframework.stereotype.Component
import org.springframework.test.context.ActiveProfiles
import kotlin.test.assertNotNull

@Component
class TakesAi(
    val ai: Ai,
) {

    fun myMethod() {
        assertNotNull(ai.withAutoLlm())
    }

}

@Component
class TakesAiFactory(
    private val aiBuilder: AiBuilder,
) {

    fun myMethod() {
        assertNotNull(aiBuilder.ai().withAutoLlm())
    }

}

@SpringBootTest
@ActiveProfiles("test")
@Import(
    value = [
        FakeConfig::class,
        TakesAi::class,
    ]
)
class AiInjectionIntegrationTest(
    @param:Autowired
    private val takesAi: TakesAi,
    @param:Autowired
    private val takesAiFactory: TakesAiFactory,
) {

    @Test
    fun `test can inject Ai into action`() {
        assertNotNull(takesAi.ai, "Ai should be injected")
        assertNotNull(takesAi.myMethod())
        val text = takesAi.ai.withAutoLlm().generateText("some text")
        assertNotNull(text)
    }

    @Test
    fun `test can inject AiFactory into action`() {
        assertNotNull(takesAiFactory.myMethod(), "Ai should be injected")
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/e2e/OperationContextInjectionIntegrationTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.e2e

import com.embabel.agent.api.common.ExecutingOperationContext
import com.embabel.agent.core.AgentPlatform
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.context.annotation.Import
import org.springframework.stereotype.Component
import org.springframework.test.context.ActiveProfiles
import kotlin.test.assertNotNull

@Component
class TakesOperationContext(
    private val eop: ExecutingOperationContext,
) {

    fun myMethod() {
        assertNotNull(eop.ai().withAutoLlm())
    }

}

@SpringBootTest
@ActiveProfiles("test")
@Import(
    value = [
        FakeConfig::class,
        TakesOperationContext::class,
    ]
)
class OperationContextInjectionIntegrationTest(
    @param:Autowired
    private val agentPlatform: AgentPlatform,
) {

    @Test
    fun `test can inject operation context into action`() {

    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/event/AgenticEventListenerTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.event

import com.embabel.agent.api.dsl.evenMoreEvilWizard
import com.embabel.agent.testing.integration.IntegrationTestUtils.dummyAgentPlatform
import io.mockk.mockk
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test

class AgenticEventListenerTest {

    @Nested
    inner class MulticastAgenticEventListenerTest {

        @Test
        fun `can recover from errors in platform event`() {
            val l1 = object : AgenticEventListener {
                override fun onPlatformEvent(event: AgentPlatformEvent) {
                    TODO()
                }
            }
            val ml = AgenticEventListener.of(l1)
            ml.onPlatformEvent(
                AgentDeploymentEvent(
                    agentPlatform = dummyAgentPlatform(),
                    agent = evenMoreEvilWizard(),
                )
            )
        }

        @Test
        fun `can recover from errors in process event`() {
            val l1 = object : AgenticEventListener {
                override fun onProcessEvent(event: AgentProcessEvent) {
                    TODO()
                }
            }
            val ml = AgenticEventListener.of(l1)
            ml.onProcessEvent(
                AgentProcessCreationEvent(
                    agentProcess = mockk(relaxed = true),
                )
            )
        }
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/event/AgenticEventSerializationTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.event

import com.embabel.agent.api.dsl.evenMoreEvilWizard
import com.embabel.agent.domain.io.UserInput
import com.embabel.agent.testing.common.EventSavingAgenticEventListener
import com.embabel.agent.testing.integration.IntegrationTestUtils.dummyAgentPlatform
import com.embabel.common.util.loggerFor
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertNotNull
import kotlin.test.assertTrue

/**
 * Check that we can safely serialize AgentProcessEvent.
 * We don't need to deserialize it.
 */
class AgenticEventSerializationTest {

    @Test
    fun `test process events can be serialized`() {
        val om = jacksonObjectMapper().registerModule(JavaTimeModule())
        val fails = mutableListOf<String>()
        var agentProcessPlanFormulatedEventString: String? = null
        var agentProcessCompletedEventString: String? = null

        val serializingListener = object : AgenticEventListener {
            var count = 0
            override fun onProcessEvent(event: AgentProcessEvent) {
                val s = om.writeValueAsString(event)
                if (!s.contains("\"type\"")) {
                    fails.add(s)
                }
                count++
                loggerFor<AgenticEventSerializationTest>().info("Serialized event: $s")
                when (event) {
                    is AgentProcessPlanFormulatedEvent -> {
                        agentProcessPlanFormulatedEventString = s
                    }

                    is AgentProcessCompletedEvent -> {
                        agentProcessCompletedEventString = s
                    }

                    else -> {
                        // Other events are not required to have a plan or goal
                    }
                }
                assertTrue(s.contains("\"processId\""), "Process id is required")
            }
        }

        val saver = EventSavingAgenticEventListener()
        val ap = dummyAgentPlatform(listener = AgenticEventListener.of(saver, serializingListener))
        // If it doesn't die we're happy
        ap.runAgentFrom(
            agent = evenMoreEvilWizard(),
            bindings = mapOf("it" to UserInput("anything at all"))
        )
        assertTrue(serializingListener.count > 0, "Events were serialized")
        assertEquals(0, fails.size, "Untyped events:\n${fails.joinToString(", ")}")
        assertTrue(
            saver.processEvents.filterIsInstance<ObjectBindingEvent>().isNotEmpty(),
            "Object binding events were emitted"
        )

        assertNotNull(agentProcessPlanFormulatedEventString)
        assertTrue(
            agentProcessPlanFormulatedEventString.contains("\"plan\""),
            "Plan is required in $agentProcessCompletedEventString"
        )
        assertTrue(
            agentProcessPlanFormulatedEventString.contains("\"goal\""),
            "Goal is required in $agentProcessCompletedEventString"
        )
        assertNotNull(agentProcessCompletedEventString)
        assertTrue(
            agentProcessCompletedEventString.contains("\"history\""),
            "History is required in $agentProcessCompletedEventString"
        )
//        assertTrue(
//            agentProcessCompletedEventString.contains("\"goal\""),
//            "Goal is required in $agentProcessCompletedEventString"
//        )
    }

    @Test
    fun `test platform events can be serialized`() {
        val om = jacksonObjectMapper().registerModule(JavaTimeModule())
        val fails = mutableListOf<String>()

        val serializingListener = object : AgenticEventListener {
            var count = 0
            override fun onPlatformEvent(event: AgentPlatformEvent) {
                val s = om.writeValueAsString(event)
                if (!s.contains("\"type\"")) {
                    fails.add(s)
                }
                count++
                loggerFor<AgenticEventSerializationTest>().info("Serialized event: $s")
            }
        }
        val ap = dummyAgentPlatform(listener = serializingListener)
        // If it doesn't die we're happy
        ap.deploy(evenMoreEvilWizard())
        assertTrue(serializingListener.count > 0, "Events were serialized")
        assertEquals(0, fails.size, "Untyped events:\n${fails.joinToString(", ")}")
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/experimental/InjectionUtilsTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.experimental.util

import org.junit.jupiter.api.Assertions.assertNotNull
import org.junit.jupiter.api.Assertions.assertNull
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import org.springframework.beans.factory.InitializingBean
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.beans.factory.annotation.Configurable
import org.springframework.beans.factory.annotation.Value
import org.springframework.context.annotation.AnnotationConfigApplicationContext
import org.springframework.stereotype.Service

@Service
class Bar {
    val foo = Foo()
}

@Configurable
class TestEntity : InitializingBean, Injectable {
    var afterPropertiesSetCalled = false

    @Autowired
    lateinit var bar: Bar

    @Value("\${foo}")
    lateinit var fooValue: String

    override fun afterPropertiesSet() {
        this.afterPropertiesSetCalled = true
    }

    override fun additionalInjectees(): List<Any> {
        return listOf(this.bar.foo)
    }
}

@Service
class Baz

@Configurable
class Foo {
    @Autowired
    lateinit var baz: Baz
}

class NotAtConfigurableFoo {
    @Autowired
    lateinit var baz: Baz
}

@Configurable
class Complex : Injectable {
    @Autowired
    lateinit var bar: Bar

    @Value("\${foo}")
    lateinit var fooValue: String

    override fun additionalInjectees(): List<Any> {
        return listOf(this.bar.foo)
    }
}

class InjectionUtilsTest {

    @Nested
    inner class ViaInjectingListener {

        @Test
        fun `test @Value`() {
            val ac = AnnotationConfigApplicationContext()
            ac.register(Bar::class.java, Baz::class.java)
            ac.refresh()
            val complex = Complex()
            Injector(ac).inject(complex)
            assertNotNull(complex.fooValue, "@Value should have been injected")
        }

        @Test
        fun `test @Autowired`() {
            val ac = AnnotationConfigApplicationContext()
            ac.register(Bar::class.java, Baz::class.java)
            ac.refresh()
            val foo = Foo()
            Injector(ac).inject(foo)
            assertNotNull(foo.baz, "Baz should have been injected")
        }

        @Test
        fun `test with additional injectees`() {
            val ac = AnnotationConfigApplicationContext()
            ac.register(Bar::class.java, Baz::class.java)
            ac.refresh()
            val complex = Complex()
            Injector(ac).inject(complex)
            assertNotNull(complex.bar.foo.baz, "Should have injected additional injectees")
        }

        @Test
        fun `test ignore without @Configurable`() {
            val ac = AnnotationConfigApplicationContext()
            ac.register(Baz::class.java)
            ac.refresh()
            val notfoo = NotAtConfigurableFoo()
            Injector(ac).inject(notfoo)
            assertThrows<UninitializedPropertyAccessException> {
                assertNull(notfoo.baz, "Should not have injected unannotated bean")
            }
        }
    }

    @Nested
    inner class Direct {

        @Nested
        inner class Autowiring {

            @Test
            fun `test @Value`() {
                val ac = AnnotationConfigApplicationContext()
                ac.register(Bar::class.java, Baz::class.java)
                ac.refresh()
                val complex = Complex()
                val wired = InjectionUtils.wire(complex, ac)
                assertNotNull(wired!!.fooValue, "@Value should have been injected")
            }

            @Test
            fun `test @Autowired`() {
                val ac = AnnotationConfigApplicationContext()
                ac.register(Bar::class.java, Baz::class.java)
                ac.refresh()
                val foo = Foo()
                val wired = InjectionUtils.wire(foo, ac)
                assertNotNull(wired!!.baz, "Baz should have been injected")
            }

            @Test
            fun `test with additional injectees`() {
                val ac = AnnotationConfigApplicationContext()
                ac.register(Bar::class.java, Baz::class.java)
                ac.refresh()
                val complex = Complex()
                val wired = InjectionUtils.wire(complex, ac)
                assertNotNull(wired!!.bar.foo.baz, "Should have injected additional injectees")
            }
        }
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/model/TestModels.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.model

import com.embabel.agent.spi.support.FakeChatModel
import com.embabel.common.ai.model.DefaultOptionsConverter
import com.embabel.common.ai.model.Llm
import com.embabel.common.ai.model.PricingModel
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.context.annotation.Profile

@Configuration
@Profile("test")
class TestModels {

    @Bean
    fun testLlm(): Llm {
        return Llm(
            name = "test-llm",
            model = FakeChatModel("I am a fake chat model"),
            pricingModel = PricingModel.usdPer1MTokens(.1, .1),
            provider = "test",
            optionsConverter = DefaultOptionsConverter,
        )
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/prompt/persona/CoStarTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.prompt.persona

import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Test

class CoStarTest {

    @Test
    fun `should create CoStar with all required fields`() {
        val coStar = CoStar(
            context = "Software development team",
            objective = "Write clean code",
            style = "Professional",
            tone = "Helpful",
            audience = "Developers"
        )

        assertEquals("Software development team", coStar.context)
        assertEquals("Write clean code", coStar.objective)
        assertEquals("Professional", coStar.style)
        assertEquals("Helpful", coStar.tone)
        assertEquals("Developers", coStar.audience)
        assertEquals("Markdown", coStar.response) // default value
    }

    @Test
    fun `should create CoStar with custom response format`() {
        val coStar = CoStar(
            context = "Technical documentation",
            objective = "Explain complex concepts",
            style = "Clear and concise",
            tone = "Educational",
            audience = "Beginners",
            response = "JSON"
        )

        assertEquals("JSON", coStar.response)
    }

    @Test
    fun `should create CoStar with custom separator`() {
        val coStar = CoStar(
            context = "Test context",
            objective = "Test objective",
            style = "Test style",
            tone = "Test tone",
            audience = "Test audience",
            separator = "---"
        )

        val contribution = coStar.contribution()
        assertTrue(contribution.contains("---"))
        assertFalse(contribution.contains("#".repeat(12)))
    }

    @Test
    fun `should generate correct prompt contribution with default separator`() {
        val coStar = CoStar(
            context = "E-commerce platform",
            objective = "Improve user experience",
            style = "Data-driven",
            tone = "Analytical",
            audience = "Product managers"
        )

        val contribution = coStar.contribution()
        val separator = "#".repeat(12)

        assertTrue(contribution.contains("# CONTEXT #"))
        assertTrue(contribution.contains("E-commerce platform"))
        assertTrue(contribution.contains("# OBJECTIVE #"))
        assertTrue(contribution.contains("Improve user experience"))
        assertTrue(contribution.contains("# STYLE #"))
        assertTrue(contribution.contains("Data-driven"))
        assertTrue(contribution.contains("# TONE #"))
        assertTrue(contribution.contains("Analytical"))
        assertTrue(contribution.contains("# AUDIENCE #"))
        assertTrue(contribution.contains("Product managers"))
        assertTrue(contribution.contains("# RESPONSE FORMAT #"))
        assertTrue(contribution.contains("Markdown"))
        assertTrue(contribution.contains(separator))
    }

    @Test
    fun `should generate correct prompt contribution with custom response format`() {
        val coStar = CoStar(
            context = "API documentation",
            objective = "Document endpoints",
            style = "Technical",
            tone = "Precise",
            audience = "API consumers",
            response = "OpenAPI Specification"
        )

        val contribution = coStar.contribution()
        assertTrue(contribution.contains("# RESPONSE FORMAT #"))
        assertTrue(contribution.contains("OpenAPI Specification"))
        assertFalse(contribution.contains("Markdown"))
    }

    @Test
    fun `should handle empty strings in all fields`() {
        val coStar = CoStar(
            context = "",
            objective = "",
            style = "",
            tone = "",
            audience = "",
            response = ""
        )

        assertEquals("", coStar.context)
        assertEquals("", coStar.objective)
        assertEquals("", coStar.style)
        assertEquals("", coStar.tone)
        assertEquals("", coStar.audience)
        assertEquals("", coStar.response)

        val contribution = coStar.contribution()
        assertTrue(contribution.contains("# CONTEXT #"))
        assertTrue(contribution.contains("# OBJECTIVE #"))
        assertTrue(contribution.contains("# STYLE #"))
        assertTrue(contribution.contains("# TONE #"))
        assertTrue(contribution.contains("# AUDIENCE #"))
        assertTrue(contribution.contains("# RESPONSE FORMAT #"))
    }

    @Test
    fun `should handle special characters and newlines`() {
        val coStar = CoStar(
            context = "Multi-line\ncontext with & special chars",
            objective = "Handle edge cases @ runtime",
            style = "Defensive & robust",
            tone = "Careful, thorough",
            audience = "QA Engineers & Developers"
        )

        assertEquals("Multi-line\ncontext with & special chars", coStar.context)
        assertEquals("Handle edge cases @ runtime", coStar.objective)
        assertEquals("Defensive & robust", coStar.style)
        assertEquals("Careful, thorough", coStar.tone)
        assertEquals("QA Engineers & Developers", coStar.audience)
    }

    @Test
    fun `should handle multiline content properly in contribution`() {
        val coStar = CoStar(
            context = """
                Large enterprise application
                with complex business rules
                and multiple integrations
            """.trimIndent(),
            objective = """
                Refactor legacy code
                Improve maintainability
                Add comprehensive tests
            """.trimIndent(),
            style = "Incremental and methodical",
            tone = "Cautious but determined",
            audience = "Senior developers and architects"
        )

        val contribution = coStar.contribution()
        assertTrue(contribution.contains("Large enterprise application"))
        assertTrue(contribution.contains("with complex business rules"))
        assertTrue(contribution.contains("Refactor legacy code"))
        assertTrue(contribution.contains("Improve maintainability"))
    }

    @Test
    fun `should maintain equality for same content`() {
        val coStar1 = CoStar(
            context = "Same context",
            objective = "Same objective",
            style = "Same style",
            tone = "Same tone",
            audience = "Same audience"
        )
        val coStar2 = CoStar(
            context = "Same context",
            objective = "Same objective",
            style = "Same style",
            tone = "Same tone",
            audience = "Same audience"
        )

        assertEquals(coStar1, coStar2)
        assertEquals(coStar1.hashCode(), coStar2.hashCode())
    }

    @Test
    fun `should not be equal for different content`() {
        val coStar1 = CoStar(
            context = "Context 1",
            objective = "Same objective",
            style = "Same style",
            tone = "Same tone",
            audience = "Same audience"
        )
        val coStar2 = CoStar(
            context = "Context 2",
            objective = "Same objective",
            style = "Same style",
            tone = "Same tone",
            audience = "Same audience"
        )

        assertNotEquals(coStar1, coStar2)
    }

    @Test
    fun `should have proper toString representation`() {
        val coStar = CoStar(
            context = "Test context",
            objective = "Test objective",
            style = "Test style",
            tone = "Test tone",
            audience = "Test audience"
        )

        val toString = coStar.toString()
        assertTrue(toString.contains("Test context"))
        assertTrue(toString.contains("Test objective"))
        assertTrue(toString.contains("Test style"))
        assertTrue(toString.contains("Test tone"))
        assertTrue(toString.contains("Test audience"))
    }

    @Test
    fun `should support copy functionality`() {
        val original = CoStar(
            context = "Original context",
            objective = "Original objective",
            style = "Original style",
            tone = "Original tone",
            audience = "Original audience"
        )

        val copied = original.copy(context = "New context")

        assertEquals("New context", copied.context)
        assertEquals("Original objective", copied.objective)
        assertEquals("Original style", copied.style)
        assertEquals("Original tone", copied.tone)
        assertEquals("Original audience", copied.audience)
        assertNotEquals(original, copied)
    }

    @Test
    fun `should handle very long text content`() {
        val longText = "A".repeat(1000)
        val coStar = CoStar(
            context = longText,
            objective = longText,
            style = longText,
            tone = longText,
            audience = longText
        )

        assertEquals(longText, coStar.context)
        assertEquals(longText, coStar.objective)
        assertEquals(longText, coStar.style)
        assertEquals(longText, coStar.tone)
        assertEquals(longText, coStar.audience)

        val contribution = coStar.contribution()
        assertTrue(contribution.contains(longText))
    }

    @Test
    fun `should use default response format when not specified`() {
        val coStar = CoStar(
            context = "Test",
            objective = "Test",
            style = "Test",
            tone = "Test",
            audience = "Test"
        )

        assertEquals("Markdown", coStar.response)
        val contribution = coStar.contribution()
        assertTrue(contribution.contains("Markdown"))
    }

    @Test
    fun `should preserve separator in contribution`() {
        val customSeparator = "===="
        val coStar = CoStar(
            context = "Test",
            objective = "Test",
            style = "Test",
            tone = "Test",
            audience = "Test",
            separator = customSeparator
        )

        val contribution = coStar.contribution()
        val separatorCount = contribution.split(customSeparator).size - 1
        assertEquals(6, separatorCount) // Should appear 6 times (after each section except the last)
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/prompt/persona/PersonaTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.prompt.persona

import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test

class PersonaTest {

    private val objectMapper = jacksonObjectMapper()

    @Nested
    inner class SerializationTests {

        @Test
        fun `should serialize and deserialize Persona with defaults`() {
            val persona = Persona(
                name = "Alice",
                persona = "Friendly and helpful",
                voice = "Calm and clear",
                objective = "Assist users with their queries"
            )

            val serialized = objectMapper.writeValueAsString(persona)
            val deserialized = objectMapper.readValue(serialized, Persona::class.java)
            Assertions.assertEquals(persona, deserialized, "Should be able to serialize and deserialize Persona")
        }

        @Test
        fun `should serialize and deserialize Persona with overrides`() {
            val persona = Persona(
                name = "Alice",
                persona = "Friendly and helpful",
                voice = "Calm and clear",
                objective = "Assist users with their queries",
            )

            val serialized = objectMapper.writeValueAsString(persona)
            val deserialized = objectMapper.readValue(serialized, Persona::class.java)
            Assertions.assertEquals(persona, deserialized, "Should be able to serialize and deserialize Persona")
        }
    }

    @Test
    fun `should create persona using create factory method`() {
        val persona = Persona(
            name = "TestBot",
            persona = "Helpful assistant",
            voice = "Professional",
            objective = "Help users"
        )

        Assertions.assertEquals("TestBot", persona.name)
        Assertions.assertEquals("Helpful assistant", persona.persona)
        Assertions.assertEquals("Professional", persona.voice)
        Assertions.assertEquals("Help users", persona.objective)
    }

    @Test
    fun `should create persona using invoke operator`() {
        val persona = Persona(
            name = "InvokeBot",
            persona = "Friendly helper",
            voice = "Casual",
            objective = "Assist with tasks"
        )

        Assertions.assertEquals("InvokeBot", persona.name)
        Assertions.assertEquals("Friendly helper", persona.persona)
        Assertions.assertEquals("Casual", persona.voice)
        Assertions.assertEquals("Assist with tasks", persona.objective)
    }

    @Test
    fun `should generate correct prompt contribution`() {
        val persona = Persona(
            name = "Alice",
            persona = "Friendly and helpful",
            voice = "Calm and clear",
            objective = "Assist users with their queries"
        )

        val contribution = persona.contribution()
        val expectedContribution = """
            You are Alice.
            Your persona: Friendly and helpful.
            Your objective is Assist users with their queries.
            Your voice: Calm and clear.
        """.trimIndent()

        Assertions.assertEquals(expectedContribution, contribution)
    }

    @Test
    fun `should handle empty strings in fields`() {
        val persona = Persona(
            name = "",
            persona = "",
            voice = "",
            objective = ""
        )

        Assertions.assertEquals("", persona.name)
        Assertions.assertEquals("", persona.persona)
        Assertions.assertEquals("", persona.voice)
        Assertions.assertEquals("", persona.objective)

        val contribution = persona.contribution()
        Assertions.assertTrue(contribution.contains("You are ."))
    }

    @Test
    fun `should handle special characters and newlines`() {
        val persona = Persona(
            name = "Test\nBot",
            persona = "Helpful & friendly!",
            voice = "Calm, clear & professional",
            objective = "Help users @work"
        )

        Assertions.assertEquals("Test\nBot", persona.name)
        Assertions.assertEquals("Helpful & friendly!", persona.persona)
        Assertions.assertEquals("Calm, clear & professional", persona.voice)
        Assertions.assertEquals("Help users @work", persona.objective)
    }

    @Test
    fun `should maintain equality for same content`() {
        val persona1 = Persona(
            name = "Alice",
            persona = "Helpful",
            voice = "Clear",
            objective = "Assist"
        )
        val persona2 = Persona(
            name = "Alice",
            persona = "Helpful",
            voice = "Clear",
            objective = "Assist"
        )

        Assertions.assertEquals(persona1, persona2)
        Assertions.assertEquals(persona1.hashCode(), persona2.hashCode())
    }

    @Test
    fun `should not be equal for different content`() {
        val persona1 = Persona(
            name = "Alice",
            persona = "Helpful",
            voice = "Clear",
            objective = "Assist"
        )
        val persona2 = Persona(
            name = "Bob",
            persona = "Helpful",
            voice = "Clear",
            objective = "Assist"
        )

        Assertions.assertNotEquals(persona1, persona2)
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/prompt/persona/RoleGoalBackstoryTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.prompt.persona

import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Test

class RoleGoalBackstoryTest {

    @Test
    fun `should create RoleGoalBackstory with direct constructor`() {
        val roleGoalBackstory = RoleGoalBackstory(
            role = "Software Engineer",
            goal = "Build high-quality applications",
            backstory = "I have 10 years of experience in software development"
        )

        assertEquals("Software Engineer", roleGoalBackstory.role)
        assertEquals("Build high-quality applications", roleGoalBackstory.goal)
        assertEquals("I have 10 years of experience in software development", roleGoalBackstory.backstory)
    }

    @Test
    fun `should create RoleGoalBackstory using fluent builder`() {
        val roleGoalBackstory = RoleGoalBackstory.withRole("Data Scientist")
            .andGoal("Analyze data to drive business decisions")
            .andBackstory("PhD in Statistics with expertise in machine learning")

        assertEquals("Data Scientist", roleGoalBackstory.role)
        assertEquals("Analyze data to drive business decisions", roleGoalBackstory.goal)
        assertEquals("PhD in Statistics with expertise in machine learning", roleGoalBackstory.backstory)
    }

    @Test
    fun `should generate correct prompt contribution`() {
        val roleGoalBackstory = RoleGoalBackstory(
            role = "Technical Writer",
            goal = "Create clear documentation",
            backstory = "Former developer turned writer"
        )

        val contribution = roleGoalBackstory.contribution()
        val expectedContribution = """
            Role: Technical Writer
            Goal: Create clear documentation
            Backstory: Former developer turned writer
        """.trimIndent()

        assertEquals(expectedContribution, contribution)
    }

    @Test
    fun `should handle empty strings in all fields`() {
        val roleGoalBackstory = RoleGoalBackstory(
            role = "",
            goal = "",
            backstory = ""
        )

        assertEquals("", roleGoalBackstory.role)
        assertEquals("", roleGoalBackstory.goal)
        assertEquals("", roleGoalBackstory.backstory)

        val contribution = roleGoalBackstory.contribution()
        // The actual format includes a space after the colon
        assertTrue(contribution.contains("Role: "))
        assertTrue(contribution.contains("Goal: "))
        assertTrue(contribution.contains("Backstory: "))
    }

    @Test
    fun `should handle special characters and newlines`() {
        val roleGoalBackstory = RoleGoalBackstory(
            role = "DevOps\nEngineer",
            goal = "Automate & streamline deployments",
            backstory = "Experience with AWS, Docker & Kubernetes"
        )

        assertEquals("DevOps\nEngineer", roleGoalBackstory.role)
        assertEquals("Automate & streamline deployments", roleGoalBackstory.goal)
        assertEquals("Experience with AWS, Docker & Kubernetes", roleGoalBackstory.backstory)
    }

    @Test
    fun `should handle multiline strings properly`() {
        val roleGoalBackstory = RoleGoalBackstory(
            role = "Product Manager",
            goal = """
                Define product strategy
                Coordinate with stakeholders
                Drive product development
            """.trimIndent(),
            backstory = """
                10+ years in product management
                Led multiple successful product launches
                Strong technical and business background
            """.trimIndent()
        )

        val contribution = roleGoalBackstory.contribution()
        assertTrue(contribution.contains("Define product strategy"))
        assertTrue(contribution.contains("Coordinate with stakeholders"))
        assertTrue(contribution.contains("10+ years in product management"))
    }

    @Test
    fun `should maintain equality for same content`() {
        val roleGoalBackstory1 = RoleGoalBackstory(
            role = "Designer",
            goal = "Create beautiful UIs",
            backstory = "5 years of design experience"
        )
        val roleGoalBackstory2 = RoleGoalBackstory(
            role = "Designer",
            goal = "Create beautiful UIs",
            backstory = "5 years of design experience"
        )

        assertEquals(roleGoalBackstory1, roleGoalBackstory2)
        assertEquals(roleGoalBackstory1.hashCode(), roleGoalBackstory2.hashCode())
    }

    @Test
    fun `should not be equal for different content`() {
        val roleGoalBackstory1 = RoleGoalBackstory(
            role = "Designer",
            goal = "Create beautiful UIs",
            backstory = "5 years of design experience"
        )
        val roleGoalBackstory2 = RoleGoalBackstory(
            role = "Developer",
            goal = "Create beautiful UIs",
            backstory = "5 years of design experience"
        )

        assertNotEquals(roleGoalBackstory1, roleGoalBackstory2)
    }

    @Test
    fun `should have proper toString representation`() {
        val roleGoalBackstory = RoleGoalBackstory(
            role = "QA Engineer",
            goal = "Ensure software quality",
            backstory = "Experienced in automation testing"
        )

        val toString = roleGoalBackstory.toString()
        assertTrue(toString.contains("QA Engineer"))
        assertTrue(toString.contains("Ensure software quality"))
        assertTrue(toString.contains("Experienced in automation testing"))
    }

    @Test
    fun `should support copy functionality`() {
        val original = RoleGoalBackstory(
            role = "Original Role",
            goal = "Original Goal",
            backstory = "Original Backstory"
        )

        val copied = original.copy(role = "New Role")

        assertEquals("New Role", copied.role)
        assertEquals("Original Goal", copied.goal)
        assertEquals("Original Backstory", copied.backstory)
        assertNotEquals(original, copied)
    }

    @Test
    fun `builder should chain methods correctly`() {
        val roleBuilder = RoleGoalBackstory.withRole("Test Role")
        assertNotNull(roleBuilder)

        val goalBuilder = roleBuilder.andGoal("Test Goal")
        assertNotNull(goalBuilder)

        val finalBackstory = goalBuilder.andBackstory("Test Backstory")
        assertNotNull(finalBackstory)
        assertEquals("Test Role", finalBackstory.role)
        assertEquals("Test Goal", finalBackstory.goal)
        assertEquals("Test Backstory", finalBackstory.backstory)
    }

    @Test
    fun `should handle very long text content`() {
        val longText = "A".repeat(1000)
        val roleGoalBackstory = RoleGoalBackstory(
            role = longText,
            goal = longText,
            backstory = longText
        )

        assertEquals(longText, roleGoalBackstory.role)
        assertEquals(longText, roleGoalBackstory.goal)
        assertEquals(longText, roleGoalBackstory.backstory)

        val contribution = roleGoalBackstory.contribution()
        assertTrue(contribution.contains(longText))
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/rag/ContentElementPropertiesToPersistTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag

import com.embabel.agent.rag.ingestion.DefaultMaterializedContainerSection
import com.embabel.agent.rag.ingestion.MaterializedDocument
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Test

class ContentElementPropertiesToPersistTest {

    @Test
    fun `test LeafSection propertiesToPersist includes all required properties`() {
        val leafSection = LeafSection(
            id = "leaf-1",
            uri = "http://example.com/doc",
            title = "Section Title",
            text = "This is the content of the section",
            parentId = "parent-1",
            metadata = mapOf(
                "author" to "John Doe",
                "tags" to listOf("important", "test")
            )
        )

        val properties = leafSection.propertiesToPersist()

        // Base ContentElement properties
        assertEquals("leaf-1", properties["id"])
        assertEquals("http://example.com/doc", properties["uri"])

        // Metadata properties should be included
        assertEquals("John Doe", properties["author"])
        assertEquals(listOf("important", "test"), properties["tags"])

        // HierarchicalContentElement properties
        assertEquals("parent-1", properties["parentId"])

        // Section properties
        assertEquals("Section Title", properties["title"])

        // LeafSection specific properties
        assertEquals("This is the content of the section", properties["text"])

        // Verify all expected keys are present
        val expectedKeys = setOf("id", "uri", "author", "tags", "parentId", "title", "text")
        assertEquals(expectedKeys, properties.keys)
    }

    @Test
    fun `test LeafSection propertiesToPersist handles null values correctly`() {
        val leafSection = LeafSection(
            id = "leaf-2",
            uri = null,
            title = "Title Only",
            text = "Content only",
            parentId = null,
            metadata = emptyMap()
        )

        val properties = leafSection.propertiesToPersist()

        assertEquals("leaf-2", properties["id"])
        assertNull(properties["uri"])
        assertNull(properties["parentId"])
        assertEquals("Title Only", properties["title"])
        assertEquals("Content only", properties["text"])

        // Should only have base properties when metadata is empty
        val expectedKeys = setOf("id", "uri", "parentId", "title", "text")
        assertEquals(expectedKeys, properties.keys)
    }

    @Test
    fun `test DefaultMaterializedContainerSection propertiesToPersist`() {
        val childSection = LeafSection(
            id = "child-1",
            title = "Child",
            text = "Child content"
        )

        val containerSection = DefaultMaterializedContainerSection(
            id = "container-1",
            uri = "http://example.com/container",
            title = "Container Title",
            children = listOf(childSection),
            parentId = "root-1",
            metadata = mapOf("type" to "container")
        )

        val properties = containerSection.propertiesToPersist()

        // Base ContentElement properties
        assertEquals("container-1", properties["id"])
        assertEquals("http://example.com/container", properties["uri"])

        // Metadata
        assertEquals("container", properties["type"])

        // HierarchicalContentElement properties
        assertEquals("root-1", properties["parentId"])

        // Section properties
        assertEquals("Container Title", properties["title"])

        // Note: children are not persisted in propertiesToPersist
        assertFalse(properties.containsKey("children"))

        val expectedKeys = setOf("id", "uri", "type", "parentId", "title")
        assertEquals(expectedKeys, properties.keys)
    }

    @Test
    fun `test MaterializedContentRoot propertiesToPersist`() {
        val childSection = LeafSection(
            id = "child-1",
            title = "Child",
            text = "Child content"
        )

        val contentRoot = MaterializedDocument(
            id = "root-1",
            uri = "http://example.com/document",
            title = "Document Title",
            children = listOf(childSection),
            metadata = mapOf(
                "document-type" to "article",
                "version" to "1.0"
            )
        )

        val properties = contentRoot.propertiesToPersist()

        // Base ContentElement properties
        assertEquals("root-1", properties["id"])
        assertEquals("http://example.com/document", properties["uri"])

        // Metadata
        assertEquals("article", properties["document-type"])
        assertEquals("1.0", properties["version"])

        // HierarchicalContentElement properties
        // ContentRoot always has null parentId
        assertNull(properties["parentId"])

        // Section properties
        assertEquals("Document Title", properties["title"])

        // Children are not persisted
        assertFalse(properties.containsKey("children"))

        val expectedKeys = setOf("id", "uri", "document-type", "version", "parentId", "title")
        assertEquals(expectedKeys, properties.keys)
    }

    @Test
    fun `test Chunk propertiesToPersist includes hierarchical properties`() {
        val chunk = Chunk(
            id = "chunk-1",
            text = "This is a chunk of text content",
            metadata = mapOf(
                "url" to "http://example.com/source",
                "chunk_index" to 0,
                "total_chunks" to 5
            ),
            parentId = "section-1"
        )

        val properties = chunk.propertiesToPersist()

        // Base ContentElement properties
        assertEquals("chunk-1", properties["id"])
        assertEquals("http://example.com/source", properties["uri"]) // Note: derived from metadata["url"]

        // Metadata properties should be included
        assertEquals("http://example.com/source", properties["url"])
        assertEquals(0, properties["chunk_index"])
        assertEquals(5, properties["total_chunks"])

        // HierarchicalContentElement properties
        assertEquals("section-1", properties["parentId"])

        val expectedKeys = setOf("id", "uri", "url", "chunk_index", "total_chunks", "parentId", "text")
        assertEquals(expectedKeys, properties.keys)
    }

    @Test
    fun `test Fact propertiesToPersist includes base properties`() {
        val fact = Fact(
            assertion = "The sky is blue",
            authority = "Weather Service",
            uri = "http://weather.gov/facts/1",
            metadata = mapOf(
                "confidence" to 0.95,
                "verified" to true
            ),
            id = "fact-1"
        )

        val properties = fact.propertiesToPersist()

        // Base ContentElement properties
        assertEquals("fact-1", properties["id"])
        assertEquals("http://weather.gov/facts/1", properties["uri"])

        // Metadata
        assertEquals(0.95, properties["confidence"])
        assertEquals(true, properties["verified"])

        // Note: Fact doesn't override propertiesToPersist to include assertion/authority
        // This might be a gap that should be addressed
        assertFalse(properties.containsKey("assertion"))
        assertFalse(properties.containsKey("authority"))

        val expectedKeys = setOf("id", "uri", "confidence", "verified")
        assertEquals(expectedKeys, properties.keys)
    }

    @Test
    fun `test propertiesToPersist inheritance chain works correctly`() {
        // Create a leaf section with comprehensive metadata
        val leafSection = LeafSection(
            id = "test-leaf",
            uri = "http://test.com/leaf",
            title = "Test Leaf",
            text = "Test content",
            parentId = "test-parent",
            metadata = mapOf(
                "custom1" to "value1",
                "custom2" to 42,
                "custom3" to null
            )
        )

        val properties = leafSection.propertiesToPersist()

        // Verify inheritance chain:
        // ContentElement -> HierarchicalContentElement -> Section -> LeafSection

        // Each level should contribute its properties:
        assertTrue(properties.containsKey("id"))          // ContentElement
        assertTrue(properties.containsKey("uri"))         // ContentElement
        assertTrue(properties.containsKey("custom1"))     // ContentElement (metadata)
        assertTrue(properties.containsKey("custom2"))     // ContentElement (metadata)
        assertTrue(properties.containsKey("custom3"))     // ContentElement (metadata)
        assertTrue(properties.containsKey("parentId"))    // HierarchicalContentElement
        assertTrue(properties.containsKey("title"))       // Section
        assertTrue(properties.containsKey("text"))     // LeafSection

        // Verify correct values
        assertEquals("test-leaf", properties["id"])
        assertEquals("http://test.com/leaf", properties["uri"])
        assertEquals("value1", properties["custom1"])
        assertEquals(42, properties["custom2"])
        assertNull(properties["custom3"]) // null values should be preserved
        assertEquals("test-parent", properties["parentId"])
        assertEquals("Test Leaf", properties["title"])
        assertEquals("Test content", properties["text"])
    }

    @Test
    fun `test empty metadata doesn't break propertiesToPersist`() {
        val leafSection = LeafSection(
            id = "empty-meta",
            uri = "http://example.com",
            title = "No Metadata",
            text = "text",
            parentId = "parent",
            metadata = emptyMap()
        )

        val properties = leafSection.propertiesToPersist()

        // Should still have all the required properties from the inheritance chain
        assertEquals(5, properties.size)
        assertEquals("empty-meta", properties["id"])
        assertEquals("http://example.com", properties["uri"])
        assertEquals("parent", properties["parentId"])
        assertEquals("No Metadata", properties["title"])
        assertEquals("text", properties["text"])
    }

    @Test
    fun `test metadata overrides behavior - WARNING this may be a bug`() {
        // Test case where metadata has keys that conflict with class properties
        // This documents the current behavior where metadata OVERRIDES class properties
        // This might be a bug in the implementation!
        val leafSection = LeafSection(
            id = "override-test",
            uri = "http://example.com",
            title = "Real Title",
            text = "Real Content",
            parentId = "real-parent",
            metadata = mapOf(
                "title" to "Metadata Title", // This DOES override the actual title (possibly bug!)
                "text" to "Metadata Content", // This DOES override the actual content (possibly bug!)
                "id" to "metadata-id" // This DOES override the actual id (definitely a bug!)
            )
        )

        val properties = leafSection.propertiesToPersist()

        assertEquals("metadata-id", properties["id"]) // BUG: metadata should not override id!
        assertEquals("http://example.com", properties["uri"]) // uri not in metadata, so works correctly
        assertEquals("real-parent", properties["parentId"]) // HierarchicalContentElement overrides metadata
        assertEquals("Real Title", properties["title"]) // Section overrides metadata
        assertEquals("Real Content", properties["text"]) // LeafSection overrides metadata
    }

    @Test
    fun `test proper metadata merge behavior when no conflicts`() {
        // Test that metadata works correctly when not conflicting with class properties
        val leafSection = LeafSection(
            id = "test-id",
            uri = "http://example.com",
            title = "Title",
            text = "text",
            parentId = "parent",
            metadata = mapOf(
                "author" to "John Doe",
                "tags" to listOf("tag1", "tag2"),
                "custom" to "value"
            )
        )

        val properties = leafSection.propertiesToPersist()

        // These should work correctly
        assertEquals("test-id", properties["id"])
        assertEquals("http://example.com", properties["uri"])
        assertEquals("parent", properties["parentId"])
        assertEquals("Title", properties["title"])
        assertEquals("text", properties["text"])
        assertEquals("John Doe", properties["author"])
        assertEquals(listOf("tag1", "tag2"), properties["tags"])
        assertEquals("value", properties["custom"])
    }

    @Test
    fun `test Chunk missing text property in propertiesToPersist - POTENTIAL BUG`() {
        // This test documents that Chunk doesn't include its 'text' property
        // in propertiesToPersist, which might be a bug since text is the main content
        val chunk = Chunk(
            id = "chunk-test",
            text = "Important chunk text content",
            metadata = mapOf("source" to "document"),
            parentId = "section-1"
        )

        val properties = chunk.propertiesToPersist()


        // But other properties are included correctly
        assertTrue(properties.containsKey("id"))
        assertTrue(properties.containsKey("parentId"))
        assertTrue(properties.containsKey("source"))

        // If this is intentional, there should be a comment explaining why
        // text content is not persisted with propertiesToPersist
    }

    @Test
    fun `test Fact missing assertion and authority properties - POTENTIAL BUG`() {
        // This test documents that Fact doesn't include its 'assertion' and 'authority'
        // properties in propertiesToPersist, which is likely a bug
        val fact = Fact(
            assertion = "Critical fact assertion",
            authority = "Authoritative source",
            uri = "http://facts.com/1",
            metadata = mapOf("confidence" to 0.9),
            id = "fact-test"
        )

        val properties = fact.propertiesToPersist()

        // The core Fact properties are NOT included - this is likely a bug!
        assertFalse(properties.containsKey("assertion"))
        assertFalse(properties.containsKey("authority"))

        // But base properties are included
        assertTrue(properties.containsKey("id"))
        assertTrue(properties.containsKey("uri"))
        assertTrue(properties.containsKey("confidence"))

        // Fact should probably override propertiesToPersist to include assertion and authority
    }

    @Test
    fun `test comprehensive property coverage for all hierarchy levels`() {
        // This test verifies that each level of the hierarchy contributes the expected properties
        val leafSection = LeafSection(
            id = "comprehensive-test",
            uri = "http://comprehensive.com",
            title = "Comprehensive Title",
            text = "Comprehensive Content",
            parentId = "comprehensive-parent",
            metadata = mapOf("level" to "comprehensive")
        )

        val properties = leafSection.propertiesToPersist()

        // ContentElement level (2 properties + metadata)
        assertTrue(properties.containsKey("id"))
        assertTrue(properties.containsKey("uri"))
        assertTrue(properties.containsKey("level")) // from metadata

        // HierarchicalContentElement level (1 property)
        assertTrue(properties.containsKey("parentId"))

        // Section level (1 property)
        assertTrue(properties.containsKey("title"))

        // LeafSection level (1 property)
        assertTrue(properties.containsKey("text"))

        // Total: 6 properties expected
        assertEquals(6, properties.size)

        // Verify values are correct
        assertEquals("comprehensive-test", properties["id"])
        assertEquals("http://comprehensive.com", properties["uri"])
        assertEquals("comprehensive", properties["level"])
        assertEquals("comprehensive-parent", properties["parentId"])
        assertEquals("Comprehensive Title", properties["title"])
        assertEquals("Comprehensive Content", properties["text"])
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/rag/FakeRagService.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag

import com.embabel.common.ai.model.EmbeddingService
import com.embabel.common.test.ai.FakeEmbeddingModel
import com.embabel.common.util.indent
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.context.annotation.Profile
import org.springframework.stereotype.Service

@Configuration
@Profile("test")
class FakeEmbeddingConfig {

    @Bean
    fun fakeEmbeddingService(): EmbeddingService {
        return EmbeddingService("test", "test-provider", FakeEmbeddingModel())
    }
}

@Service
@Profile("test")
class FakeRagService : RagService {
    override val name: String
        get() = "test"

    override fun search(ragRequest: RagRequest): RagResponse {
        return RagResponse(
            request = ragRequest,
            service = name,
            results = emptyList(),
        )
    }

    override val description: String
        get() = "test RAG"

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String {
        return "RAG service: $name".indent(indent)
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/rag/ingestion/ContentChunkerTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.ingestion

import com.embabel.agent.rag.LeafSection
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Test

class ContentChunkerTest {

    private val chunker = ContentChunker()

    @Test
    fun `test single chunk for container with small total content`() {
        val leaf1 = LeafSection(
            id = "leaf-1",
            title = "Introduction",
            text = "This is a short introduction section."
        )
        val leaf2 = LeafSection(
            id = "leaf-2",
            title = "Overview",
            text = "This is a brief overview section."
        )

        val container = MaterializedDocument(
            id = "container-1",
            title = "Small Document",
            children = listOf(leaf1, leaf2),
            metadata = mapOf("source" to "test"),
            uri = "foo",
        )

        val chunks = chunker.chunk(container)

        assertEquals(1, chunks.size)
        val chunk = chunks.first()
        assertTrue(chunk.text.contains("Introduction"))
        assertTrue(chunk.text.contains("This is a short introduction section."))
        assertTrue(chunk.text.contains("Overview"))
        assertTrue(chunk.text.contains("This is a brief overview section."))
        assertEquals("container-1", chunk.parentId)
        assertEquals(0, chunk.metadata["chunk_index"])
        assertEquals(1, chunk.metadata["total_chunks"])
        assertEquals("Small Document", chunk.metadata["container_section_title"])
        assertEquals("test", chunk.metadata["source"])
    }

    @Test
    fun `test individual leaf processing for container with large total content`() {
        // Create one small leaf and one large leaf
        val smallLeaf = LeafSection(
            id = "leaf-small",
            title = "Small Section",
            text = "This is small content that won't be split."
        )

        // Create a large leaf that will be split
        val largeContent = buildString {
            repeat(10) { paragraphIndex ->
                appendLine("This is paragraph number $paragraphIndex of a very long leaf section that will definitely exceed the minimum chunk size threshold.")
                appendLine("It contains multiple sentences and should be split appropriately. The content is designed to test the paragraph-based splitting logic.")
                appendLine("Each paragraph has substantial content to ensure we reach the minimum threshold for splitting.")
                appendLine("The splitter should handle this gracefully and create multiple chunks with proper overlap and metadata preservation.")
                appendLine("This ensures we have comprehensive test coverage for the splitting functionality.")
                if (paragraphIndex < 9) appendLine() // Add paragraph break except for last one
            }
        }

        val largeLeaf = LeafSection(
            id = "leaf-large",
            title = "Large Section",
            text = largeContent,
            metadata = mapOf("category" to "long")
        )

        val container = MaterializedDocument(
            id = "container-2",
            title = "Mixed Document",
            children = listOf(smallLeaf, largeLeaf),
            metadata = mapOf("source" to "test"),
            uri = "foo",
        )

        val chunks = chunker.chunk(container)

        // Should have at least 2 chunks: 1 for small leaf, multiple for large leaf
        assertTrue(chunks.size >= 2, "Should create multiple chunks for mixed content")

        // Find the small leaf chunk
        val smallLeafChunks = chunks.filter { it.metadata["leaf_section_id"] == "leaf-small" }
        assertEquals(1, smallLeafChunks.size, "Small leaf should create exactly 1 chunk")
        val smallChunk = smallLeafChunks.first()
        assertTrue(smallChunk.text.contains("Small Section"))
        assertTrue(smallChunk.text.contains("This is small content"))
        assertEquals("leaf-small", smallChunk.parentId)

        // Find the large leaf chunks
        val largeLeafChunks = chunks.filter { it.metadata["leaf_section_id"] == "leaf-large" }
        assertTrue(largeLeafChunks.size > 1, "Large leaf should be split into multiple chunks")

        // Verify metadata for all chunks
        chunks.forEach { chunk ->
            assertEquals("container-2", chunk.metadata["container_section_id"])
            assertEquals("Mixed Document", chunk.metadata["container_section_title"])
            assertTrue(chunk.text.length <= 1500, "Chunk should not exceed max size: ${chunk.text.length}")
            assertNotNull(chunk.id)
            assertTrue(chunk.text.isNotBlank())
        }
    }

    @Test
    fun `test empty container handling`() {
        val container = MaterializedDocument(
            id = "empty-container",
            title = "Empty Document",
            children = emptyList(),
            uri = "foo",
        )

        val chunks = chunker.chunk(container)

        assertEquals(1, chunks.size)
        val chunk = chunks.first()
        assertTrue(chunk.text.trim().isEmpty())
        assertEquals("empty-container", chunk.parentId)
        assertEquals("Empty Document", chunk.metadata["container_section_title"])
    }

    @Test
    fun `test multiple leaf sections in container`() {
        val leaf1 = LeafSection(
            id = "leaf-1",
            title = "Section A",
            text = "Content for section A."
        )

        val leaf2 = LeafSection(
            id = "leaf-2",
            title = "Section B",
            text = "Content for section B."
        )

        val leaf3 = LeafSection(
            id = "leaf-3",
            title = "Section C",
            text = "Content for section C."
        )

        val rootContainer = MaterializedDocument(
            id = "root-1",
            title = "Multi-Section Document",
            children = listOf(leaf1, leaf2, leaf3),
            uri = "foo",
        )

        val chunks = chunker.chunk(rootContainer)

        assertEquals(1, chunks.size) // Small total content should create single chunk
        val chunk = chunks.first()
        assertTrue(chunk.text.contains("Section A"))
        assertTrue(chunk.text.contains("Content for section A."))
        assertTrue(chunk.text.contains("Section B"))
        assertTrue(chunk.text.contains("Content for section B."))
        assertTrue(chunk.text.contains("Section C"))
        assertTrue(chunk.text.contains("Content for section C."))
        assertEquals("root-1", chunk.parentId)
    }

    @Test
    fun `test multiple containers processing`() {
        val container1 = MaterializedDocument(
            uri = "foo",
            id = "container-1",
            title = "Document 1",
            children = listOf(
                LeafSection(id = "l1", title = "Title 1", text = "Content 1")
            )
        )

        val container2 = MaterializedDocument(
            uri = "foo",
            id = "container-2",
            title = "Document 2",
            children = listOf(
                LeafSection(id = "l2", title = "Title 2", text = "Content 2")
            )
        )

        val chunks = chunker.splitSections(listOf(container1, container2))

        assertEquals(2, chunks.size)
        assertTrue(chunks.any { it.text.contains("Content 1") })
        assertTrue(chunks.any { it.text.contains("Content 2") })
        assertEquals("container-1", chunks[0].parentId)
        assertEquals("container-2", chunks[1].parentId)
    }

    @Test
    fun `test custom splitter configuration`() {
        val config = ContentChunker.DefaultConfig(
            maxChunkSize = 100,
            overlapSize = 20,
        )
        val customSplitter = ContentChunker(config)

        // Create content longer than minChunkSize (150) in a single leaf
        val content = buildString {
            repeat(10) {
                append("This is sentence number $it that should be split with the custom configuration settings. ")
            }
        }

        val largeLeaf = LeafSection(
            id = "large-leaf",
            title = "Large Leaf",
            text = content
        )

        val container = MaterializedDocument(
            id = "custom-container",
            uri = "custom-container",
            title = "Custom Config Test",
            children = listOf(largeLeaf)
        )

        val chunks = customSplitter.chunk(container)

        assertTrue(chunks.size > 1, "Should create multiple chunks with custom config")
        chunks.forEach { chunk ->
            assertTrue(chunk.text.length <= 100, "Chunk should respect custom max size")
        }
    }

    @Test
    fun `test configuration validation`() {
        // Test invalid configurations
        assertThrows(IllegalArgumentException::class.java) {
            ContentChunker.DefaultConfig(maxChunkSize = 0)
        }

        assertThrows(IllegalArgumentException::class.java) {
            ContentChunker.DefaultConfig(overlapSize = -1)
        }

        assertThrows(IllegalArgumentException::class.java) {
            ContentChunker.DefaultConfig(maxChunkSize = 100)
        }

        assertThrows(IllegalArgumentException::class.java) {
            ContentChunker.DefaultConfig(maxChunkSize = 100, overlapSize = 150)
        }
    }

    @Test
    fun `test metadata preservation from leaves`() {
        val leaf1 = LeafSection(
            id = "metadata-leaf-1",
            title = "First Section",
            text = "First content",
            metadata = mapOf("author" to "John", "type" to "intro")
        )

        val leaf2 = LeafSection(
            id = "metadata-leaf-2",
            title = "Second Section",
            text = "Second content",
            metadata = mapOf("author" to "Jane", "type" to "body")
        )

        val container = MaterializedDocument(
            id = "metadata-container",
            uri = "mc",
            title = "Metadata Test",
            children = listOf(leaf1, leaf2),
            metadata = mapOf("document" to "test", "version" to "1.0")
        )

        val chunks = chunker.chunk(container)

        assertEquals(1, chunks.size) // Small content should be combined
        val chunk = chunks.first()

        // Container metadata should be preserved
        assertEquals("test", chunk.metadata["document"])
        assertEquals("1.0", chunk.metadata["version"])
        assertEquals("metadata-container", chunk.metadata["container_section_id"])
        assertEquals("Metadata Test", chunk.metadata["container_section_title"])
    }

    @Test
    fun `test chunk boundaries respect sentence endings`() {
        val longContent = buildString {
            repeat(100) {
                append("This is a test sentence. ")
            }
        }

        val largeLeaf = LeafSection(
            id = "sentence-test",
            title = "Sentence Test",
            text = longContent
        )

        val container = MaterializedDocument(
            id = "sentence-container",
            title = "Sentence Boundary Test",
            children = listOf(largeLeaf),
            uri = "sentence-container"
        )

        val chunks = chunker.chunk(container)

        assertTrue(chunks.size > 1, "Should create multiple chunks")

        // Most chunks should end with sentence endings (allowing for some overlap cases)
        val chunksEndingWithPeriod = chunks.count { it.text.trim().endsWith('.') }
        assertTrue(
            chunksEndingWithPeriod >= chunks.size * 0.8,
            "Most chunks should end at sentence boundaries"
        )
    }

    @Test
    fun `test chunking too fine with large chunk sizes`() {
        // Create a chunker with larger chunk sizes that should create fewer, larger chunks
        val chunker = ContentChunker(
            ContentChunker.DefaultConfig(
                maxChunkSize = 5000,
                overlapSize = 200,
            )
        )

        // Create medium-sized content that could reasonably fit in one chunk
        val mediumContent = buildString {
            repeat(20) { paragraphIndex ->
                appendLine("This is paragraph $paragraphIndex containing reasonable amounts of text content.")
                appendLine("Each paragraph has enough substance to be meaningful but not overwhelming.")
                appendLine("The goal is to test whether the chunker creates appropriately sized chunks.")
                appendLine("With a max chunk size of 5000 characters, this should not be overly fragmented.")
                appendLine("")
            }
        }

        println("Medium content length: ${mediumContent.length}")

        val leaf = LeafSection(
            id = "medium-leaf",
            title = "Medium Section",
            text = mediumContent
        )

        val container = MaterializedDocument(
            id = "medium-container",
            title = "Medium Document",
            children = listOf(leaf),
            uri = "medium-container",
        )

        val chunks = chunker.chunk(container)

        println("Number of chunks created: ${chunks.size}")
        chunks.forEachIndexed { index, chunk ->
            println("Chunk $index size: ${chunk.text.length}")
        }

        // With content around 2000-3000 chars and maxChunkSize=5000, should create fewer chunks
        assertTrue(
            chunks.size <= 2,
            "Should create at most 2 chunks for medium content with large max chunk size, but got ${chunks.size}"
        )

        // Verify chunks are reasonably sized
        chunks.forEach { chunk ->
            assertTrue(chunk.text.length <= 5000, "Chunk should not exceed max size: ${chunk.text.length}")
            assertTrue(chunk.text.length >= 500, "Chunk should be reasonably substantial: ${chunk.text.length}")
        }
    }

    @Test
    fun `test large content with generous chunk settings`() {
        // Even more generous settings
        val chunker = ContentChunker(
            ContentChunker.DefaultConfig(
                maxChunkSize = 8000,
                overlapSize = 400,
            )
        )

        // Create larger content that should still result in reasonably few chunks
        val largeContent = buildString {
            repeat(50) { paragraphIndex ->
                appendLine("This is substantial paragraph number $paragraphIndex in a comprehensive document.")
                appendLine("Each paragraph contains detailed information and explanations that provide value.")
                appendLine("The content is designed to test chunking behavior with generous size limits.")
                appendLine("We want to ensure that the chunker doesn't over-fragment content needlessly.")
                appendLine("Good chunking should balance between size constraints and content coherence.")
                appendLine("")
            }
        }

        println("Large content length: ${largeContent.length}")

        val leaf = LeafSection(
            id = "large-leaf",
            title = "Large Section",
            text = largeContent
        )

        val container = MaterializedDocument(
            id = "large-container",
            title = "Large Document",
            children = listOf(leaf),
            uri = "large-container",
        )

        val chunks = chunker.chunk(container)

        println("Number of chunks for large content: ${chunks.size}")
        chunks.forEachIndexed { index, chunk ->
            println("Large chunk $index size: ${chunk.text.length}")
        }

        // Should create reasonable number of chunks, not over-fragment
        val expectedMaxChunks = (largeContent.length / 6000) + 2 // Rough estimate with some buffer
        assertTrue(
            chunks.size <= expectedMaxChunks,
            "Should not over-fragment large content. Expected max: $expectedMaxChunks, got: ${chunks.size}"
        )

        chunks.forEach { chunk ->
            assertTrue(chunk.text.length <= 8000, "Chunk should not exceed max size: ${chunk.text.length}")
        }
    }

    @Test
    fun `test multiple medium leaves should not over-fragment`() {
        val chunker = ContentChunker(
            ContentChunker.DefaultConfig(
                maxChunkSize = 5000,
                overlapSize = 200,
            )
        )

        // Create several medium-sized leaves
        val leaves = (1..3).map { leafNum ->
            val content = buildString {
                repeat(10) { paraNum ->
                    appendLine("Leaf $leafNum paragraph $paraNum with moderate content length.")
                    appendLine("This paragraph provides sufficient detail without being excessive.")
                    appendLine("The content should be chunked efficiently without over-fragmentation.")
                    appendLine("")
                }
            }

            LeafSection(
                id = "leaf-$leafNum",
                title = "Section $leafNum",
                text = content
            )
        }

        val totalContentLength = leaves.sumOf { it.content.length }
        println("Total content length for multiple leaves: $totalContentLength")

        val container = MaterializedDocument(
            id = "multi-medium-container",
            title = "Multiple Medium Sections",
            children = leaves,
            uri = "multi-medium-container",
        )

        val chunks = chunker.chunk(container)

        println("Number of chunks for multiple medium sections: ${chunks.size}")
        chunks.forEachIndexed { index, chunk ->
            println("Multi-medium chunk $index size: ${chunk.text.length}")
        }

        // Should create fewer chunks by intelligently grouping leaves
        assertTrue(chunks.size >= 1, "Should create at least one chunk")
        assertTrue(chunks.size < leaves.size, "Should create fewer chunks than leaves by grouping them intelligently")
        assertTrue(chunks.size <= 3, "Should not create excessive chunks for medium content")

        chunks.forEach { chunk ->
            assertTrue(chunk.text.length <= 5000, "Chunk should not exceed max size: ${chunk.text.length}")
        }
    }

    @Test
    fun `demonstrate over-chunking issue with large chunk sizes`() {
        // This test specifically shows the over-chunking problem
        val chunker = ContentChunker(
            ContentChunker.DefaultConfig(maxChunkSize = 5000, overlapSize = 200)
        )

        // Create content that SHOULD fit in a single large chunk but gets split unnecessarily
        val content1 = "Section 1 content that is substantial but not huge. ".repeat(30) // ~1600 chars
        val content2 = "Section 2 content with different but related information. ".repeat(30) // ~1740 chars
        val content3 = "Section 3 content that complements the other sections. ".repeat(30) // ~1650 chars

        val leaves = listOf(
            LeafSection(id = "s1", title = "Section 1", text = content1),
            LeafSection(id = "s2", title = "Section 2", text = content2),
            LeafSection(id = "s3", title = "Section 3", text = content3)
        )

        val totalLength = leaves.sumOf { it.content.length + it.title.length + 1 } // +1 for newline after title
        println("Total combined length: $totalLength")

        val container = MaterializedDocument(
            id = "over-chunk-test",
            title = "Should Be One Chunk",
            children = leaves,
            uri = "over-chunk-test",
        )

        val chunks = chunker.chunk(container)

        println("Over-chunking demo:")
        println("- Total content length: $totalLength characters")
        println("- Max chunk size: 5000 characters")
        println("- Min chunk size: 1500 characters")
        println("- Content could easily fit in 1 chunk, but got: ${chunks.size} chunks")

        chunks.forEachIndexed { index, chunk ->
            println("  Chunk $index: ${chunk.text.length} characters")
        }

        // FIXED: Content that fits in maxChunkSize should now create a single chunk
        assertTrue(totalLength <= 5000, "Total content should fit in one chunk")
        assertEquals(1, chunks.size, "Fixed implementation should create 1 chunk for content that fits in maxChunkSize")

        val chunk = chunks.first()
        assertTrue(chunk.text.length <= 5000, "Chunk should not exceed max size")
        assertTrue(chunk.text.contains("Section 1"), "Should contain all sections")
        assertTrue(chunk.text.contains("Section 2"), "Should contain all sections")
        assertTrue(chunk.text.contains("Section 3"), "Should contain all sections")

        println("\n*** CHUNKING ISSUE FIXED ***")
        println("Content of $totalLength chars now creates ${chunks.size} optimal chunk(s)")
        println("This improves retrieval effectiveness and reduces storage/processing overhead")
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/rag/ingestion/MultiIngesterTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.ingestion

import com.embabel.agent.rag.WritableStore
import io.mockk.*
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Disabled
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.springframework.ai.document.Document
import org.springframework.ai.transformer.splitter.TextSplitter
import java.util.*

class MultiIngesterTest {

    private lateinit var mockWritableStore1: WritableStore
    private lateinit var mockWritableStore2: WritableStore
    private lateinit var mockTextSplitter: TextSplitter

    @BeforeEach
    fun setup() {
        mockWritableStore1 = mockk()
        mockWritableStore2 = mockk()
        mockTextSplitter = mockk()

        every { mockWritableStore1.name } returns "rag-service-1"
        every { mockWritableStore2.name } returns "rag-service-2"
        every { mockWritableStore1.write(any()) } just Runs
        every { mockWritableStore2.write(any()) } just Runs
    }

    @Disabled("Implement tests")
    @Nested
    inner class WriteContentTests {
        // Placeholder for future tests of writeContent if needed
    }


    @Nested
    inner class ConstructorAndInitializationTests {

        @Test
        fun `test constructor with empty rag services list`() {
            val multiIngester = MultiIngester(emptyList())

            assertFalse(multiIngester.active(), "Should not be active with empty rag services")
            assertTrue(multiIngester.stores.isEmpty(), "Should have empty rag services list")
        }

        @Test
        fun `test constructor with single rag service`() {
            val multiIngester = MultiIngester(listOf(mockWritableStore1))

            assertTrue(multiIngester.active(), "Should be active with one rag service")
            assertEquals(1, multiIngester.stores.size, "Should have one rag service")
            assertEquals(mockWritableStore1, multiIngester.stores[0], "Should contain the correct rag service")
        }

        @Test
        fun `test constructor with multiple rag services`() {
            val multiIngester = MultiIngester(listOf(mockWritableStore1, mockWritableStore2))

            assertTrue(multiIngester.active(), "Should be active with multiple rag services")
            assertEquals(2, multiIngester.stores.size, "Should have two rag services")
            assertTrue(multiIngester.stores.contains(mockWritableStore1), "Should contain first rag service")
            assertTrue(multiIngester.stores.contains(mockWritableStore2), "Should contain second rag service")
        }

        @Test
        fun `test constructor with custom text splitter`() {
            // NOTE: Constructor API changed from passing TextSplitter object to lambda provider
            // OLD: MultiIngester(stores, splitter)
            // NEW: MultiIngester(stores) { splitter }
            // This change enables lazy initialization to avoid 350MB memory allocation until needed
            val multiIngester = MultiIngester(listOf(mockWritableStore1)) { mockTextSplitter }

            // NOTE: Testing strategy changed from direct property access to behavioral testing
            // OLD: multiIngester.splitter (accessing private internal state)
            // NEW: Test behavior through public API methods (ingest/accept)
            // This approach tests actual functionality rather than implementation details
            every { mockTextSplitter.split(any<List<Document>>()) } returns listOf(Document("test content"))
            val result = multiIngester.accept(listOf(Document("test")))

            // Verify the custom splitter provider was used through observable behavior
            // We can confirm custom splitter works by verifying documents were written to store
            verify { mockWritableStore1.write(any()) }
        }

        @Test
        fun `test constructor with default text splitter`() {
            val multiIngester = MultiIngester(listOf(mockWritableStore1))

            // NOTE: Testing strategy for default splitter changed due to lazy initialization
            // OLD: assertNotNull(multiIngester.splitter) - direct property access
            // NEW: Test through behavioral verification - splitter created only when needed
            // This confirms lazy loading works: no 350MB TokenTextSplitter created until actual use
            assertTrue(multiIngester.active(), "Should be active with stores")

            // Default TokenTextSplitter will be created lazily when ingest() calls splitter.split()
            // This test verifies constructor succeeds without immediate memory allocation
        }
    }

    @Nested
    inner class ActiveStatusTests {

        @Test
        fun `test active returns false with empty rag services`() {
            val multiIngester = MultiIngester(emptyList())

            assertFalse(multiIngester.active(), "Should not be active with no rag services")
        }

        @Test
        fun `test active returns true with rag services`() {
            val multiIngester = MultiIngester(listOf(mockWritableStore1))

            assertTrue(multiIngester.active(), "Should be active with rag services")
        }

        @Test
        fun `test active returns true with multiple rag services`() {
            val multiIngester = MultiIngester(listOf(mockWritableStore1, mockWritableStore2))

            assertTrue(multiIngester.active(), "Should be active with multiple rag services")
        }
    }

    @Nested
    inner class DocumentProcessingTests {

        @Test
        fun `test accept with documents writes to all services`() {
            // Create test documents directly (no files)
            val doc1 = Document("This is a test document", mapOf("id" to "chunk-1"))
            val doc2 = Document("for ingestion.", mapOf("id" to "chunk-2"))
            val documents = listOf(doc1, doc2)

            val multiIngester = MultiIngester(listOf(mockWritableStore1, mockWritableStore2))

            val result = multiIngester.accept(documents)

            // Verify services were called with the documents
            verify { mockWritableStore1.write(documents) }
            verify { mockWritableStore2.write(documents) }
        }

        @Test
        fun `test accept with no rag services processes but doesn't write`() {
            val documents = listOf(Document("Test content", mapOf("id" to "test-1")))
            val multiIngester = MultiIngester(emptyList())

            // Should not throw exception
            assertDoesNotThrow {
                multiIngester.accept(documents)
            }
        }

        @Test
        fun `test accept with large document list processes all`() {
            // Create multiple documents to simulate splitting
            val documents = (1..5).map {
                Document("Chunk $it content", mapOf("id" to "chunk-$it"))
            }

            val multiIngester = MultiIngester(listOf(mockWritableStore1))

            multiIngester.accept(documents)

            verify { mockWritableStore1.write(documents) }
        }

        @Test
        fun `test accept with empty document list`() {
            val multiIngester = MultiIngester(listOf(mockWritableStore1))

            multiIngester.accept(emptyList())

            verify { mockWritableStore1.write(emptyList()) }
        }

        @Test
        fun `test accept with single document`() {
            val document = Document("Single document", mapOf("id" to "single"))
            val multiIngester = MultiIngester(listOf(mockWritableStore1))

            multiIngester.accept(listOf(document))

            verify { mockWritableStore1.write(listOf(document)) }
        }

        @Test
        fun `test accept with different document types and metadata`() {
            val documents = listOf(
                Document("Text content", mapOf("type" to "txt", "id" to "text-1")),
                Document("# Markdown content", mapOf("type" to "md", "id" to "md-1")),
                Document("public class Test {}", mapOf("type" to "java", "id" to "java-1")),
                Document("{\"key\": \"value\"}", mapOf("type" to "json", "id" to "json-1"))
            )

            val multiIngester = MultiIngester(listOf(mockWritableStore1, mockWritableStore2))

            multiIngester.accept(documents)

            verify { mockWritableStore1.write(documents) }
            verify { mockWritableStore2.write(documents) }
        }
    }


    @Nested
    inner class ErrorHandlingTests {

        @Test
        fun `test accept throws exception when rag service fails`() {
            val document = Document("Test content", mapOf("id" to "test-1"))
            every { mockWritableStore1.write(any()) } throws RuntimeException("Write failed")

            val multiIngester = MultiIngester(listOf(mockWritableStore1))

            assertThrows(RuntimeException::class.java) {
                multiIngester.accept(listOf(document))
            }

            verify { mockWritableStore1.write(listOf(document)) }
        }

        @Test
        fun `test accept with multiple services fails fast on first exception`() {
            val documents = listOf(Document("Test content", mapOf("id" to "test-1")))

            // Make first service throw exception
            every { mockWritableStore1.write(any()) } throws RuntimeException("Service 1 failed")
            every { mockWritableStore2.write(any()) } just Runs

            val multiIngester = MultiIngester(listOf(mockWritableStore1, mockWritableStore2))

            assertThrows(RuntimeException::class.java) {
                multiIngester.accept(documents)
            }

            verify { mockWritableStore1.write(documents) }
            // Second service should not be called due to exception in first
            verify(exactly = 0) { mockWritableStore2.write(any()) }
        }
    }

    @Nested
    inner class InfoStringTests {

        @Test
        fun `test infoString with no rag services`() {
            val multiIngester = MultiIngester(emptyList())

            val infoString = multiIngester.infoString(verbose = false, indent = 0)

            assertEquals("No RAG services", infoString, "Should indicate no RAG services")
        }

    }

    @Nested
    inner class IntegrationTests {

        @Test
        fun `test complete workflow with realistic document scenario`() {
            // Create realistic document chunks as they would come from a splitter
            val chunks = listOf(
                Document(
                    "# Introduction\nThis is a comprehensive document about testing.",
                    mapOf("id" to UUID.randomUUID().toString(), "type" to "header")
                ),
                Document(
                    "## Section 1\nContent for section 1 with important information.",
                    mapOf("id" to UUID.randomUUID().toString(), "type" to "section")
                ),
                Document(
                    "## Section 2\nMore content with different topics and details.",
                    mapOf("id" to UUID.randomUUID().toString(), "type" to "section")
                ),
                Document(
                    "## Conclusion\nFinal thoughts and summary of the document.",
                    mapOf("id" to UUID.randomUUID().toString(), "type" to "conclusion")
                )
            )

            val multiIngester = MultiIngester(listOf(mockWritableStore1, mockWritableStore2))

            multiIngester.accept(chunks)

            // Verify both services received all chunks
            verify { mockWritableStore1.write(chunks) }
            verify { mockWritableStore2.write(chunks) }
        }

        @Test
        fun `test workflow with mixed service types and configurations`() {
            // Create additional mock services with different characteristics
            val mockVectorService = mockk<WritableStore>()
            val mockGraphService = mockk<WritableStore>()

            every { mockVectorService.name } returns "vector-store"
            every { mockGraphService.name } returns "knowledge-graph"
            every { mockVectorService.write(any()) } just Runs
            every { mockGraphService.write(any()) } just Runs

            val chunk = Document("Content for mixed service ingestion", mapOf("id" to "mixed-1"))
            val documents = listOf(chunk)

            val multiIngester = MultiIngester(
                listOf(mockWritableStore1, mockVectorService, mockGraphService)
            )

            multiIngester.accept(documents)

            // Verify all services were called
            verify { mockWritableStore1.write(documents) }
            verify { mockVectorService.write(documents) }
            verify { mockGraphService.write(documents) }
        }

        @Test
        fun `test performance characteristics with large number of services`() {
            // Create multiple mock services
            val services = (1..10).map { index ->
                mockk<WritableStore>().also { service ->
                    every { service.name } returns "service-$index"
                    every { service.write(any()) } just Runs
                }
            }

            val document = Document("Performance test content", mapOf("id" to "perf-1"))
            val documents = listOf(document)

            val multiIngester = MultiIngester(services)

            val startTime = System.currentTimeMillis()
            multiIngester.accept(documents)
            val endTime = System.currentTimeMillis()

            // Verify reasonable performance (should complete quickly with mocks)
            val duration = endTime - startTime
            assertTrue(duration < 1000, "Should complete within 1 second for 10 mock services")

            // Verify all services were called
            services.forEach { service ->
                verify { service.write(documents) }
            }
        }
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/rag/tools/RagServiceSearchToolsTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.tools

import com.embabel.agent.rag.*
import com.embabel.common.core.types.SimpleSimilaritySearchResult
import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Test
import kotlin.test.assertNull

class RagServiceSearchToolsTest {

    @Test
    fun `should create RagServiceTools`() {
        val mockRagService = mockk<RagService>()
        val options = RagOptions(mockRagService)

        val ragTools = SingleShotRagServiceSearchTools(options)

        assertEquals(options, ragTools.options)
        assertEquals(SimpleRagResponseFormatter, ragTools.options.ragResponseFormatter)
    }

    @Test
    fun `should search with default options`() {
        val mockRagService = mockk<RagService>()
        val options = RagOptions(mockRagService)
        val ragTools = SingleShotRagServiceSearchTools(options)

        val mockChunk = mockk<Chunk>()
        every { mockChunk.text } returns "Test chunk content"
        every { mockChunk.infoString(any(), any()) } returns "Test chunk info"

        val searchResults = listOf(
            SimpleSimilaritySearchResult(match = mockChunk, score = 0.9)
        )
        val mockResponse = RagResponse(RagRequest("test"), "test-service", searchResults)

        every { mockRagService.search(any()) } returns mockResponse

        val result = ragTools.search("test query")

        assertTrue(result.contains("0.9"))
        assertTrue(result.contains("Test chunk content"))
        verify { mockRagService.search(any()) }
    }

    @Test
    fun `should search with empty results`() {
        val mockRagService = mockk<RagService>()
        val options = RagOptions(mockRagService)
        val ragTools = SingleShotRagServiceSearchTools(options)

        val mockResponse = RagResponse(RagRequest("test query"), "test-service", emptyList())
        every { mockRagService.search(any()) } returns mockResponse

        val result = ragTools.search("test query")

        assertEquals(SimpleRagResponseFormatter.NO_RESULTS_FOUND, result)
        verify { mockRagService.search(any()) }
    }

    @Test
    fun `should pass correct parameters to RagService search`() {
        val entitySearch = EntitySearch(setOf("label1", "label2"))
        val mockRagService = mockk<RagService>()
        val options = RagOptions(
            ragService = mockRagService,
            similarityThreshold = 0.8,
            topK = 5,
            entitySearch = entitySearch,
        )
        val ragTools = SingleShotRagServiceSearchTools(options)

        val mockResponse = RagResponse(RagRequest("test query"), "test-service", emptyList())
        every { mockRagService.search(any()) } returns mockResponse

        ragTools.search("test query")

        verify {
            mockRagService.search(match<RagRequest> { request ->
                request.query == "test query" &&
                        request.similarityThreshold == 0.8 &&
                        request.topK == 5 &&
                        request.entitySearch == entitySearch
            })
        }
    }

    @Test
    fun `should create default RagServiceToolsOptions`() {
        val mockRagService = mockk<RagService>()
        val options = RagOptions(mockRagService)

        assertEquals(0.7, options.similarityThreshold.toDouble(), 0.001)
        assertEquals(8, options.topK)
        assertNull(options.entitySearch)
        assertEquals(SimpleRagResponseFormatter, options.ragResponseFormatter)
    }

    @Test
    fun `should create RagServiceToolsOptions with custom values`() {
        val mockRagService = mockk<RagService>()
        val entitySearch = EntitySearch(setOf("custom-label"))
        val customFormatter = mockk<RagResponseFormatter>()
        val options = RagOptions(
            ragService = mockRagService,
            similarityThreshold = 0.9,
            topK = 10,
            entitySearch = entitySearch,
            ragResponseFormatter = customFormatter
        )

        assertEquals(0.9, options.similarityThreshold.toDouble(), 0.001)
        assertEquals(10, options.topK)
        assertEquals(entitySearch, options.entitySearch)
        assertEquals(customFormatter, options.ragResponseFormatter)
    }

    @Test
    fun `should update similarityThreshold using withSimilarityThreshold`() {
        val mockRagService = mockk<RagService>()
        val options = RagOptions(mockRagService)
        val newThreshold = 0.9

        val updatedOptions = options.withSimilarityThreshold(newThreshold)

        assertEquals(newThreshold, updatedOptions.similarityThreshold)
        assertEquals(options.topK, updatedOptions.topK)
        assertEquals(options.entitySearch, updatedOptions.entitySearch)
        assertEquals(options.ragResponseFormatter, updatedOptions.ragResponseFormatter)
    }

    @Test
    fun `should update topK using withTopK`() {
        val mockRagService = mockk<RagService>()
        val options = RagOptions(mockRagService)
        val newTopK = 15

        val updatedOptions = options.withTopK(newTopK)

        assertEquals(options.similarityThreshold, updatedOptions.similarityThreshold)
        assertEquals(newTopK, updatedOptions.topK)
        assertEquals(options.entitySearch, updatedOptions.entitySearch)
        assertEquals(options.ragResponseFormatter, updatedOptions.ragResponseFormatter)
    }

    @Test
    fun `should chain option modifications`() {
        val mockRagService = mockk<RagService>()
        val options = RagOptions(mockRagService)

        val updatedOptions = options
            .withSimilarityThreshold(0.95)
            .withTopK(20)

        assertEquals(0.95, updatedOptions.similarityThreshold.toDouble(), 0.001)
        assertEquals(20, updatedOptions.topK)
        assertEquals(options.entitySearch, updatedOptions.entitySearch)
    }

    @Test
    fun `should use custom formatter when provided in options`() {
        val mockRagService = mockk<RagService>()
        val customFormatter = mockk<RagResponseFormatter>()
        val options = RagOptions(mockRagService, ragResponseFormatter = customFormatter)
        val ragTools = SingleShotRagServiceSearchTools(options)

        val mockResponse = RagResponse(RagRequest("test query"), "test-service", emptyList())
        every { mockRagService.search(any()) } returns mockResponse
        every { customFormatter.format(any()) } returns "Custom formatted response"

        val result = ragTools.search("test query")

        assertEquals("Custom formatted response", result)
        verify { customFormatter.format(mockResponse) }
    }

    @Test
    fun `should handle multiple search results with different types`() {
        val mockRagService = mockk<RagService>()
        val options = RagOptions(mockRagService)
        val ragTools = SingleShotRagServiceSearchTools(options)

        val mockChunk1 = mockk<Chunk>()
        every { mockChunk1.text } returns "First chunk"
        every { mockChunk1.infoString(any(), any()) } returns "First chunk info"

        val mockChunk2 = mockk<Chunk>()
        every { mockChunk2.text } returns "Second chunk"
        every { mockChunk2.infoString(any(), any()) } returns "Second chunk info"

        val searchResults = listOf(
            SimpleSimilaritySearchResult(match = mockChunk1, score = 0.95),
            SimpleSimilaritySearchResult(match = mockChunk2, score = 0.85)
        )
        val mockResponse = RagResponse(RagRequest("test query"), "test-service", searchResults)

        every { mockRagService.search(any()) } returns mockResponse

        val result = ragTools.search("test query")

        assertTrue(result.contains("0.95"))
        assertTrue(result.contains("First chunk"))
        assertTrue(result.contains("0.85"))
        assertTrue(result.contains("Second chunk"))
        assertTrue(result.contains("\n\n")) // Results should be separated by double newlines
    }

    @Test
    fun `should validate RagServiceToolsOptions implements RagRequestRefinement`() {
        val options = RagOptions(
            ragService = mockk<RagService>(),
            similarityThreshold = 0.85,
            topK = 12,
            entitySearch = EntitySearch(setOf("test-label"))

        )

        // Test that it properly implements RagRequestRefinement interface
        val request = options.toRequest("test query")

        assertEquals("test query", request.query)
        assertEquals(0.85, request.similarityThreshold)
        assertEquals(12, request.topK)
        assertEquals(setOf("test-label"), request.entitySearch?.labels)
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/spi/support/AgenticEventListenerToolsStatsTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support

import com.embabel.agent.api.dsl.evenMoreEvilWizard
import com.embabel.agent.event.ToolCallRequestEvent
import com.embabel.agent.event.ToolCallResponseEvent
import com.embabel.agent.testing.integration.IntegrationTestUtils.dummyAgentProcessRunning
import io.mockk.mockk
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import java.time.Duration

class AgenticEventListenerToolsStatsTest {

    private fun newEvent(
        function: String,
        isFailure: Boolean = false,
        runningTime: Duration = Duration.ofMillis(100)
    ): ToolCallResponseEvent {
        val toolCallRequestEvent = ToolCallRequestEvent(
            agentProcess = dummyAgentProcessRunning(evenMoreEvilWizard()),
            action = null,
            tool = function,
            toolGroupMetadata = null,
            toolInput = "{}",
            llmOptions = mockk()
        )
        return ToolCallResponseEvent(
            request = toolCallRequestEvent,
            result = if (isFailure) Result.failure(Exception("fail")) else Result.success("ok"),
            runningTime = runningTime
        )
    }

    @Nested
    inner class BasicStatsTracking {
        @Test
        fun `records calls and failures correctly`() {
            val statsListener = AgenticEventListenerToolsStats()
            statsListener.onProcessEvent(newEvent("toolA"))
            statsListener.onProcessEvent(newEvent("toolA", isFailure = true, runningTime = Duration.ofMillis(200)))
            statsListener.onProcessEvent(newEvent("toolB"))

            val stats = statsListener.toolsStats
            assertEquals(2, stats["toolA"]?.calls)
            assertEquals(1, stats["toolA"]?.failures)
            assertEquals(1, stats["toolB"]?.calls)
            assertEquals(0, stats["toolB"]?.failures)
        }

        @Test
        fun `computes average response time correctly`() {
            val statsListener = AgenticEventListenerToolsStats()
            statsListener.onProcessEvent(newEvent("toolA", runningTime = Duration.ofMillis(100)))
            statsListener.onProcessEvent(newEvent("toolA", runningTime = Duration.ofMillis(300)))
            val avg = statsListener.toolsStats["toolA"]?.averageResponseTime
            assertEquals(200, avg)
        }
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/spi/support/ChatClientLlmOperationsTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support

import com.embabel.agent.api.annotation.support.Wumpus
import com.embabel.agent.api.common.InteractionId
import com.embabel.agent.core.AgentProcess
import com.embabel.agent.core.ProcessContext
import com.embabel.agent.spi.InvalidLlmReturnFormatException
import com.embabel.agent.spi.InvalidLlmReturnTypeException
import com.embabel.agent.spi.LlmInteraction
import com.embabel.agent.spi.LlmOperations
import com.embabel.agent.spi.support.springai.ChatClientLlmOperations
import com.embabel.agent.spi.support.springai.DefaultToolDecorator
import com.embabel.agent.spi.support.springai.MaybeReturn
import com.embabel.agent.spi.validation.DefaultValidationPromptGenerator
import com.embabel.agent.support.SimpleTestAgent
import com.embabel.agent.testing.common.EventSavingAgenticEventListener
import com.embabel.chat.SystemMessage
import com.embabel.chat.UserMessage
import com.embabel.common.ai.model.*
import com.embabel.common.textio.template.JinjavaTemplateRenderer
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import io.mockk.every
import io.mockk.mockk
import io.mockk.slot
import jakarta.validation.Validation
import jakarta.validation.constraints.Pattern
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.springframework.ai.chat.messages.AssistantMessage
import org.springframework.ai.chat.model.ChatModel
import org.springframework.ai.chat.model.ChatResponse
import org.springframework.ai.chat.model.Generation
import org.springframework.ai.chat.prompt.ChatOptions
import org.springframework.ai.chat.prompt.DefaultChatOptions
import org.springframework.ai.chat.prompt.Prompt
import org.springframework.ai.model.tool.ToolCallingChatOptions
import org.springframework.ai.support.ToolCallbacks
import java.time.LocalDate
import kotlin.test.assertEquals

/**
 * Fake ChatModel with fixed response that captures prompts
 * and tools passed to it.
 * @param responses if > 1 element, they'll be returned in turn.
 * Otherwise, the single response will be returned on every request
 */
class FakeChatModel(
    val responses: List<String>,
    private val options: ChatOptions = DefaultChatOptions(),
) : ChatModel {

    constructor(
        response: String,
        options: ChatOptions = DefaultChatOptions(),
    ) : this(
        listOf(response), options
    )

    val response: String get() = responses.single()

    private var index = 0

    val promptsPassed = mutableListOf<Prompt>()
    val optionsPassed = mutableListOf<ToolCallingChatOptions>()

    override fun getDefaultOptions(): ChatOptions = options

    override fun call(prompt: Prompt): ChatResponse {
        promptsPassed.add(prompt)
        val options = prompt.options as? ToolCallingChatOptions
            ?: throw IllegalArgumentException("Expected ToolCallingChatOptions")
        optionsPassed.add(options)
        return ChatResponse(
            listOf(
                Generation(AssistantMessage(responses[index])).also {
                    // If we have more than one response, step through them
                    if (responses.size > 1) ++index
                }
            )
        )
    }
}


class ChatClientLlmOperationsTest {

    data class Setup(
        val llmOperations: LlmOperations,
        val mockAgentProcess: AgentProcess,
        val mutableLlmInvocationHistory: MutableLlmInvocationHistory,
    )

    private fun createChatClientLlmOperations(
        fakeChatModel: FakeChatModel,
        dataBindingProperties: LlmDataBindingProperties = LlmDataBindingProperties(),
    ): Setup {
        val ese = EventSavingAgenticEventListener()
        val mutableLlmInvocationHistory = MutableLlmInvocationHistory()
        val mockProcessContext = mockk<ProcessContext>()
        every { mockProcessContext.platformServices } returns mockk()
        every { mockProcessContext.platformServices.agentPlatform } returns mockk()
        every { mockProcessContext.platformServices.agentPlatform.toolGroupResolver } returns RegistryToolGroupResolver(
            "mt",
            emptyList()
        )
        every { mockProcessContext.platformServices.eventListener } returns ese
        val mockAgentProcess = mockk<AgentProcess>()
        every { mockAgentProcess.recordLlmInvocation(any()) } answers {
            mutableLlmInvocationHistory.invocations.add(firstArg())
        }
        every { mockProcessContext.onProcessEvent(any()) } answers { ese.onProcessEvent(firstArg()) }
        every { mockProcessContext.agentProcess } returns mockAgentProcess

        every { mockAgentProcess.agent } returns SimpleTestAgent
        every { mockAgentProcess.processContext } returns mockProcessContext

        val mockModelProvider = mockk<ModelProvider>()
        val crit = slot<ModelSelectionCriteria>()
        val fakeLlm = Llm("fake", "provider", fakeChatModel, DefaultOptionsConverter)
        every { mockModelProvider.getLlm(capture(crit)) } returns fakeLlm
        val cco = ChatClientLlmOperations(
            modelProvider = mockModelProvider,
            toolDecorator = DefaultToolDecorator(),
            validator = Validation.buildDefaultValidatorFactory().validator,
            validationPromptGenerator = DefaultValidationPromptGenerator(),
            templateRenderer = JinjavaTemplateRenderer(),
            objectMapper = jacksonObjectMapper().registerModule(JavaTimeModule()),
            dataBindingProperties = dataBindingProperties,
        )
        return Setup(cco, mockAgentProcess, mutableLlmInvocationHistory)
    }

    data class Dog(val name: String)

    data class TemporalDog(
        val name: String,
        val birthDate: LocalDate,
    )

    @Nested
    inner class CreateObject {

        @Test
        fun `passes correct prompt`() {
            val duke = Dog("Duke")

            val fakeChatModel = FakeChatModel(jacksonObjectMapper().writeValueAsString(duke))

            val prompt =
                "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."
            val setup = createChatClientLlmOperations(fakeChatModel)
            setup.llmOperations.createObject(
                messages = listOf(UserMessage(prompt)),
                interaction = LlmInteraction(
                    id = InteractionId("id"), llm = LlmOptions()
                ),
                outputClass = Dog::class.java,
                action = SimpleTestAgent.actions.first(),
                agentProcess = setup.mockAgentProcess,
            )

            val promptText = fakeChatModel.promptsPassed[0].toString()
            assertTrue(promptText.contains("\$schema"), "Prompt contains JSON schema")
            assertTrue(promptText.contains(promptText), "Prompt contains user prompt:\n$promptText")
        }

        @Test
        fun `returns string`() {
            val fakeChatModel = FakeChatModel("fake response")

            val setup = createChatClientLlmOperations(fakeChatModel)
            val result = setup.llmOperations.createObject(
                messages = listOf(UserMessage("prompt")),
                interaction = LlmInteraction(
                    id = InteractionId("id"), llm = LlmOptions()
                ),
                outputClass = String::class.java,
                action = SimpleTestAgent.actions.first(),
                agentProcess = setup.mockAgentProcess,
            )
            assertEquals(fakeChatModel.response, result)
        }

        @Test
        fun `handles ill formed JSON when returning data class`() {
            val fakeChatModel = FakeChatModel("This ain't no JSON")

            val setup = createChatClientLlmOperations(fakeChatModel)
            try {
                setup.llmOperations.createObject(
                    messages = listOf(UserMessage("prompt")),
                    interaction = LlmInteraction(
                        id = InteractionId("id"), llm = LlmOptions()
                    ),
                    outputClass = Dog::class.java,
                    action = SimpleTestAgent.actions.first(),
                    agentProcess = setup.mockAgentProcess,
                )
                fail("Should have thrown exception")
            } catch (e: InvalidLlmReturnFormatException) {
                assertEquals(fakeChatModel.response, e.llmReturn)
                assertTrue(e.infoString(verbose = true).contains(fakeChatModel.response))
            }
        }

        @Test
        fun `returns data class`() {
            val duke = Dog("Duke")

            val fakeChatModel = FakeChatModel(jacksonObjectMapper().writeValueAsString(duke))

            val setup = createChatClientLlmOperations(fakeChatModel)
            val result = setup.llmOperations.createObject(
                messages = listOf(UserMessage("prompt")),
                interaction = LlmInteraction(
                    id = InteractionId("id"), llm = LlmOptions()
                ),
                outputClass = Dog::class.java,
                action = SimpleTestAgent.actions.first(),
                agentProcess = setup.mockAgentProcess,
            )
            assertEquals(duke, result)
        }

        @Test
        fun `passes JSON few shot example`() {
            val duke = Dog("Duke")

            val fakeChatModel = FakeChatModel(jacksonObjectMapper().writeValueAsString(duke))

            val setup = createChatClientLlmOperations(fakeChatModel)
            val result = setup.llmOperations.createObject(
                messages = listOf(
                    UserMessage(
                        """
                    Return a dog. Dogs look like this:
                {
                    "name": "Duke",
                    "type": "Dog"
                }
                """.trimIndent()
                    )
                ),
                interaction = LlmInteraction(
                    id = InteractionId("id"), llm = LlmOptions()
                ),
                outputClass = Dog::class.java,
                action = SimpleTestAgent.actions.first(),
                agentProcess = setup.mockAgentProcess,
            )
            assertEquals(duke, result)
        }

        @Test
        fun `presents no tools to ChatModel`() {
            val duke = Dog("Duke")

            val fakeChatModel = FakeChatModel(jacksonObjectMapper().writeValueAsString(duke))

            val setup = createChatClientLlmOperations(fakeChatModel)
            val result = setup.llmOperations.createObject(
                messages = listOf(UserMessage("prompt")),
                interaction = LlmInteraction(
                    id = InteractionId("id"), llm = LlmOptions()
                ),
                outputClass = Dog::class.java,
                action = SimpleTestAgent.actions.first(),
                agentProcess = setup.mockAgentProcess,
            )
            assertEquals(duke, result)
            assertEquals(1, fakeChatModel.promptsPassed.size)
            val tools = fakeChatModel.optionsPassed[0].toolCallbacks
            assertEquals(0, tools.size)
        }

        @Test
        fun `presents tools to ChatModel via doTransform`() {
            val duke = Dog("Duke")

            val fakeChatModel = FakeChatModel(jacksonObjectMapper().writeValueAsString(duke))

            // Wumpus's have tools
            val toolCallbacks = ToolCallbacks.from(Wumpus("wumpy")).toList()
            val setup = createChatClientLlmOperations(fakeChatModel)
            val result = setup.llmOperations.doTransform(
                messages = listOf(
                    SystemMessage("do whatever"),
                    UserMessage("prompt"),
                ),
                interaction = LlmInteraction(
                    id = InteractionId("id"),
                    llm = LlmOptions(),
                    toolCallbacks = toolCallbacks,
                ),
                outputClass = Dog::class.java,
                llmRequestEvent = null,
            )
            assertEquals(duke, result)
            assertEquals(1, fakeChatModel.promptsPassed.size)
            val tools = fakeChatModel.optionsPassed[0].toolCallbacks
            assertEquals(toolCallbacks.size, tools.size, "Must have passed same number of tools")
            assertEquals(
                toolCallbacks.map { it.toolDefinition.name() }.toSet(),
                tools.map { it.toolDefinition.name() }.toSet(),
            )
        }

        @Test
        fun `presents tools to ChatModel when given multiple messages`() {
            val duke = Dog("Duke")

            val fakeChatModel = FakeChatModel(jacksonObjectMapper().writeValueAsString(duke))

            // Wumpus's have tools
            val toolCallbacks = ToolCallbacks.from(Wumpus("wumpy")).toList()
            val setup = createChatClientLlmOperations(fakeChatModel)
            val result = setup.llmOperations.createObject(
                messages = listOf(UserMessage("prompt")),
                interaction = LlmInteraction(
                    id = InteractionId("id"),
                    llm = LlmOptions(),
                    toolCallbacks = toolCallbacks,
                ),
                outputClass = Dog::class.java,
                action = SimpleTestAgent.actions.first(),
                agentProcess = setup.mockAgentProcess,
            )
            assertEquals(duke, result)
            assertEquals(1, fakeChatModel.promptsPassed.size)
            val tools = fakeChatModel.optionsPassed[0].toolCallbacks
            assertEquals(toolCallbacks.size, tools.size, "Must have passed same number of tools")
            assertEquals(
                toolCallbacks.map { it.toolDefinition.name() }.sorted(),
                tools.map { it.toolDefinition.name() })
        }

        @Test
        fun `handles reasoning model return`() {
            val duke = Dog("Duke")

            val fakeChatModel = FakeChatModel(
                "<think>Deep thoughts</think>\n" + jacksonObjectMapper().writeValueAsString(duke)
            )

            val setup = createChatClientLlmOperations(fakeChatModel)
            val result = setup.llmOperations.createObject(
                messages = listOf(UserMessage("prompt")),
                interaction = LlmInteraction(
                    id = InteractionId("id"), llm = LlmOptions()
                ),
                outputClass = Dog::class.java,
                action = SimpleTestAgent.actions.first(),
                agentProcess = setup.mockAgentProcess,
            )
            assertEquals(duke, result)
        }

        @Test
        fun `handles LocalDate return`() {
            val duke = TemporalDog("Duke", birthDate = LocalDate.of(2021, 2, 26))

            val fakeChatModel = FakeChatModel(
                jacksonObjectMapper().registerModule(JavaTimeModule()).writeValueAsString(duke)
            )

            val setup = createChatClientLlmOperations(fakeChatModel)
            val result = setup.llmOperations.createObject(
                messages = listOf(UserMessage("prompt")),
                interaction = LlmInteraction(
                    id = InteractionId("id"), llm = LlmOptions()
                ),
                outputClass = TemporalDog::class.java,
                action = SimpleTestAgent.actions.first(),
                agentProcess = setup.mockAgentProcess,
            )
            assertEquals(duke, result)
        }
    }

    @Nested
    inner class CreateObjectIfPossible {

        @Test
        fun `should have correct prompt with success and failure`() {
            val fakeChatModel =
                FakeChatModel(
                    jacksonObjectMapper().writeValueAsString(
                        MaybeReturn<Dog>(
                            failure = "didn't work"
                        )
                    )
                )

            val prompt = "The quick brown fox jumped over the lazy dog"
            val setup = createChatClientLlmOperations(fakeChatModel)
            val result = setup.llmOperations.createObjectIfPossible(
                messages = listOf(UserMessage(prompt)),
                interaction = LlmInteraction(
                    id = InteractionId("id"), llm = LlmOptions()
                ),
                outputClass = Dog::class.java,
                action = SimpleTestAgent.actions.first(),
                agentProcess = setup.mockAgentProcess,
            )
            assertTrue(result.isFailure)
            val promptText = fakeChatModel.promptsPassed[0].toString()
            assertTrue(promptText.contains("\$schema"), "Prompt contains JSON schema")
            assertTrue(promptText.contains(promptText), "Prompt contains user prompt:\n$promptText")

            assertTrue(promptText.contains("possible"), "Prompt mentions possible")
            assertTrue(promptText.contains("success"), "Prompt mentions success")
            assertTrue(promptText.contains("failure"), "Prompt mentions failure")
        }

        @Test
        fun `returns data class - success`() {
            val duke = Dog("Duke")

            val fakeChatModel = FakeChatModel(
                jacksonObjectMapper().writeValueAsString(
                    MaybeReturn(
                        success = duke
                    )
                )
            )

            val setup = createChatClientLlmOperations(fakeChatModel)
            val result = setup.llmOperations.createObjectIfPossible(
                messages = listOf(UserMessage("prompt")),
                interaction = LlmInteraction(
                    id = InteractionId("id"), llm = LlmOptions()
                ),
                outputClass = Dog::class.java,
                action = SimpleTestAgent.actions.first(),
                agentProcess = setup.mockAgentProcess,
            )
            assertEquals(duke, result.getOrThrow())
        }

        @Test
        fun `handles reasoning model success return`() {
            val duke = Dog("Duke")

            val fakeChatModel = FakeChatModel(
                "<think>More deep thoughts</think>\n" + jacksonObjectMapper().writeValueAsString(
                    MaybeReturn(
                        success = duke
                    )
                )
            )

            val setup = createChatClientLlmOperations(fakeChatModel)
            val result = setup.llmOperations.createObjectIfPossible(
                messages = listOf(UserMessage("prompt")),
                interaction = LlmInteraction(
                    id = InteractionId("id"), llm = LlmOptions()
                ),
                outputClass = Dog::class.java,
                action = SimpleTestAgent.actions.first(),
                agentProcess = setup.mockAgentProcess,
            )
            assertEquals(duke, result.getOrThrow())
        }

        @Test
        fun `handles LocalDate return`() {
            val duke = TemporalDog("Duke", birthDate = LocalDate.of(2021, 2, 26))

            val fakeChatModel = FakeChatModel(
                jacksonObjectMapper().registerModule(JavaTimeModule()).writeValueAsString(
                    MaybeReturn(duke)
                )
            )

            val setup = createChatClientLlmOperations(fakeChatModel)
            val result = setup.llmOperations.createObjectIfPossible(
                messages = listOf(UserMessage("prompt")),
                interaction = LlmInteraction(
                    id = InteractionId("id"), llm = LlmOptions()
                ),
                outputClass = TemporalDog::class.java,
                action = SimpleTestAgent.actions.first(),
                agentProcess = setup.mockAgentProcess,
            )
            assertEquals(duke, result.getOrThrow())
        }

        @Test
        fun `handles ill formed JSON when returning data class`() {
            val fakeChatModel = FakeChatModel("This ain't no JSON")

            val setup = createChatClientLlmOperations(fakeChatModel)
            try {
                setup.llmOperations.createObjectIfPossible(
                    messages = listOf(UserMessage("prompt")),
                    interaction = LlmInteraction(
                        id = InteractionId("id"), llm = LlmOptions()
                    ),
                    outputClass = Dog::class.java,
                    action = SimpleTestAgent.actions.first(),
                    agentProcess = setup.mockAgentProcess,
                )
                fail("Should have thrown exception")
            } catch (e: InvalidLlmReturnFormatException) {
                assertEquals(fakeChatModel.response, e.llmReturn)
                assertTrue(e.infoString(verbose = true).contains(fakeChatModel.response))
            }
        }

        @Test
        fun `returns data class - failure`() {
            val fakeChatModel =
                FakeChatModel(
                    jacksonObjectMapper().writeValueAsString(
                        MaybeReturn<Dog>(
                            failure = "didn't work"
                        )
                    )
                )

            val setup = createChatClientLlmOperations(fakeChatModel)
            val result = setup.llmOperations.createObjectIfPossible(
                messages = listOf(UserMessage("prompt")),
                interaction = LlmInteraction(
                    id = InteractionId("id"), llm = LlmOptions()
                ),
                outputClass = Dog::class.java,
                action = SimpleTestAgent.actions.first(),
                agentProcess = setup.mockAgentProcess,
            )
            assertTrue(result.isFailure)
        }

        @Test
        fun `presents tools to ChatModel`() {
            val duke = Dog("Duke")

            val fakeChatModel = FakeChatModel(
                jacksonObjectMapper().writeValueAsString(
                    MaybeReturn(duke)
                )
            )

            // Wumpus's have tools
            val toolCallbacks = ToolCallbacks.from(Wumpus("wumpy")).toList()
            val setup = createChatClientLlmOperations(fakeChatModel)
            setup.llmOperations.createObjectIfPossible(
                messages = listOf(UserMessage("prompt")),
                interaction = LlmInteraction(
                    id = InteractionId("id"),
                    llm = LlmOptions(),
                    toolCallbacks = toolCallbacks,
                ),
                outputClass = Dog::class.java,
                action = SimpleTestAgent.actions.first(),
                agentProcess = setup.mockAgentProcess,
            )
            assertEquals(1, fakeChatModel.promptsPassed.size)
            val tools = fakeChatModel.optionsPassed[0].toolCallbacks
            assertEquals(toolCallbacks.size, tools.size, "Must have passed same number of tools")
            assertEquals(
                toolCallbacks.map { it.toolDefinition.name() }.sorted(),
                tools.map { it.toolDefinition.name() })
        }
    }

    @Nested
    inner class ReturnValidation {

        @Test
        fun `validates with no rules`() {
            val duke = Dog("Duke")
            val fakeChatModel = FakeChatModel(jacksonObjectMapper().writeValueAsString(duke))
            val prompt =
                "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."
            val setup = createChatClientLlmOperations(fakeChatModel)
            val createdDog = setup.llmOperations.createObject(
                messages = listOf(UserMessage(prompt)),
                interaction = LlmInteraction(
                    id = InteractionId("id"), llm = LlmOptions()
                ),
                outputClass = Dog::class.java,
                action = SimpleTestAgent.actions.first(),
                agentProcess = setup.mockAgentProcess,
            )

            assertEquals(duke, createdDog)
        }

        @Test
        fun `validated field with no violation`() {
            // Picky eater
            data class BorderCollie(
                val name: String,
                @field:Pattern(regexp = "^mince$", message = "eats field must be 'mince'")
                val eats: String,
            )

            // This is OK
            val husky = BorderCollie("Husky", eats = "mince")
            val fakeChatModel = FakeChatModel(jacksonObjectMapper().writeValueAsString(husky))
            val prompt =
                "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."
            val setup = createChatClientLlmOperations(fakeChatModel)
            val createdDog = setup.llmOperations.createObject(
                messages = listOf(UserMessage(prompt)),
                interaction = LlmInteraction(
                    id = InteractionId("id"), llm = LlmOptions()
                ),
                outputClass = BorderCollie::class.java,
                action = SimpleTestAgent.actions.first(),
                agentProcess = setup.mockAgentProcess,
            )
            assertEquals(husky, createdDog)
        }

        @Test
        fun `corrects validated field with violation`() {
            // Picky eater
            data class BorderCollie(
                val name: String,
                @field:Pattern(regexp = "^mince$", message = "eats field must be 'mince'")
                val eats: String,
            )

            val invalidHusky = BorderCollie("Husky", eats = "kibble")
            val validHusky = BorderCollie("Husky", eats = "mince")
            val fakeChatModel = FakeChatModel(
                responses = listOf(
                    jacksonObjectMapper().writeValueAsString(invalidHusky),
                    jacksonObjectMapper().writeValueAsString(validHusky),
                )
            )
            val prompt =
                "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."
            val setup = createChatClientLlmOperations(fakeChatModel)
            val createdDog = setup.llmOperations.createObject(
                messages = listOf(UserMessage(prompt)),
                interaction = LlmInteraction(
                    id = InteractionId("id"), llm = LlmOptions()
                ),
                outputClass = BorderCollie::class.java,
                action = SimpleTestAgent.actions.first(),
                agentProcess = setup.mockAgentProcess,
            )

            assertEquals(validHusky, createdDog, "Invalid response should have been corrected")
        }

        @Test
        fun `fails to correct validated field with violation`() {
            // Picky eater
            data class BorderCollie(
                val name: String,
                @field:Pattern(regexp = "^mince$", message = "eats field must be 'mince'")
                val eats: String,
            )

            val invalidHusky = BorderCollie("Husky", eats = "kibble")
            val fakeChatModel = FakeChatModel(
                response = jacksonObjectMapper().writeValueAsString(invalidHusky)
            )

            val prompt =
                "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."
            val setup = createChatClientLlmOperations(fakeChatModel)
            try {
                setup.llmOperations.createObject(
                    messages = listOf(UserMessage(prompt)),
                    interaction = LlmInteraction(
                        id = InteractionId("id"), llm = LlmOptions()
                    ),
                    outputClass = BorderCollie::class.java,
                    action = SimpleTestAgent.actions.first(),
                    agentProcess = setup.mockAgentProcess,
                )
                fail("Should have thrown an exception on invalid object")
            } catch (e: InvalidLlmReturnTypeException) {
                assertEquals(invalidHusky, e.returnedObject, "Invalid response should have been corrected")
                assertTrue(e.constraintViolations.isNotEmpty())
            }
        }

        @Test
        fun `passes correct description of violation to LLM`() {
            // Picky eater
            data class BorderCollie(
                val name: String,
                @field:Pattern(regexp = "^mince$", message = "eats field must be 'mince'")
                val eats: String,
            )

            val invalidHusky = BorderCollie("Husky", eats = "kibble")
            val validHusky = BorderCollie("Husky", eats = "mince")
            val fakeChatModel = FakeChatModel(
                responses = listOf(
                    jacksonObjectMapper().writeValueAsString(invalidHusky),
                    jacksonObjectMapper().writeValueAsString(validHusky),
                )
            )
            val prompt =
                "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."
            val setup = createChatClientLlmOperations(fakeChatModel)
            val createdDog = setup.llmOperations.createObject(
                messages = listOf(UserMessage(prompt)),
                interaction = LlmInteraction(
                    id = InteractionId("id"), llm = LlmOptions()
                ),
                outputClass = BorderCollie::class.java,
                action = SimpleTestAgent.actions.first(),
                agentProcess = setup.mockAgentProcess,
            )
            val secondPrompt = fakeChatModel.promptsPassed[1].toString()
            assertTrue(secondPrompt.contains("eats field must be 'mince'"), "Prompt mentions validation violation")

            assertEquals(validHusky, createdDog, "Invalid response should have been corrected")
        }

        @Test
        fun `doesnt pass description of validation rules to LLM if so configured`() {
            // Picky eater
            data class BorderCollie(
                val name: String,
                @field:Pattern(regexp = "^mince$", message = "eats field must be 'mince'")
                val eats: String,
            )

            val validHusky = BorderCollie("Husky", eats = "mince")
            val fakeChatModel = FakeChatModel(
                jacksonObjectMapper().writeValueAsString(validHusky)
            )
            val prompt =
                "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."
            val setup = createChatClientLlmOperations(fakeChatModel)
            val createdDog = setup.llmOperations.createObject(
                messages = listOf(UserMessage(prompt)),
                interaction = LlmInteraction(
                    id = InteractionId("id"), llm = LlmOptions()
                ),
                outputClass = BorderCollie::class.java,
                action = SimpleTestAgent.actions.first(),
                agentProcess = setup.mockAgentProcess,
            )
            val firstPrompt = fakeChatModel.promptsPassed[0].toString()
            assertFalse(firstPrompt.contains("eats field must be 'mince'"), "Prompt mentions validation violation")
            assertEquals(validHusky, createdDog, "Invalid response should have been corrected")
        }

        @Test
        fun `passes correct description of validation rules to LLM if so configured`() {
            // Picky eater
            data class BorderCollie(
                val name: String,
                @field:Pattern(regexp = "^mince$", message = "eats field must be 'mince'")
                val eats: String,
            )

            val validHusky = BorderCollie("Husky", eats = "mince")
            val fakeChatModel = FakeChatModel(
                jacksonObjectMapper().writeValueAsString(validHusky)
            )
            val prompt =
                "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."
            val setup = createChatClientLlmOperations(
                fakeChatModel = fakeChatModel,
                dataBindingProperties = LlmDataBindingProperties(
                    sendValidationInfo = true,
                )
            )
            val createdDog = setup.llmOperations.createObject(
                messages = listOf(UserMessage(prompt)),
                interaction = LlmInteraction(
                    id = InteractionId("id"), llm = LlmOptions()
                ),
                outputClass = BorderCollie::class.java,
                action = SimpleTestAgent.actions.first(),
                agentProcess = setup.mockAgentProcess,
            )
            val firstPrompt = fakeChatModel.promptsPassed[0].toString()
            assertTrue(firstPrompt.contains("eats field must be 'mince'"), "Prompt mentions validation violation")

            assertEquals(validHusky, createdDog, "Invalid response should have been corrected")
        }
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/spi/support/ChatClientLlmTransformerTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support

import com.embabel.agent.api.common.InteractionId
import com.embabel.agent.api.common.PlatformServices
import com.embabel.agent.api.common.ToolsStats
import com.embabel.agent.core.*
import com.embabel.agent.event.AgenticEventListener
import com.embabel.agent.spi.LlmInteraction
import com.embabel.agent.spi.support.springai.ChatClientLlmOperations
import com.embabel.agent.spi.support.springai.DefaultToolDecorator
import com.embabel.agent.spi.support.springai.MaybeReturn
import com.embabel.agent.testing.common.EventSavingAgenticEventListener
import com.embabel.chat.UserMessage
import com.embabel.common.ai.model.DefaultOptionsConverter
import com.embabel.common.ai.model.Llm
import com.embabel.common.ai.model.ModelProvider
import com.embabel.common.textio.template.JinjavaTemplateRenderer
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import io.mockk.every
import io.mockk.mockk
import io.mockk.slot
import jakarta.validation.Validation
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Disabled
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.springframework.ai.chat.messages.AssistantMessage
import org.springframework.ai.chat.model.ChatModel
import org.springframework.ai.chat.model.ChatResponse
import org.springframework.ai.chat.model.Generation
import org.springframework.ai.chat.prompt.DefaultChatOptions
import org.springframework.ai.chat.prompt.Prompt

class MutableLlmInvocationHistory : LlmInvocationHistory {
    val invocations = mutableListOf<LlmInvocation>()
    override val llmInvocations: List<LlmInvocation>
        get() = invocations

    override val toolsStats: ToolsStats
        get() = TODO("Not yet implemented")
}

data class SpiPerson(val name: String)

data class WierdPerson(
    val name: String,
    val age: Int,
    val weirdness: String,
)

data class Return(
    val result: Result<*>,
    val capturedPrompt: String,
)

class ChatClientLlmTransformerTest {

    val llmInvocationHistory = MutableLlmInvocationHistory()

    @Nested
    inner class Transform {

        @Nested
        inner class HappyPath {

            @Test
            fun `happy path`() {
                val person = SpiPerson("John")
                val result = runWithPromptReturning(jacksonObjectMapper().writeValueAsString(person))
                assertEquals(person, result)
            }

            @Test
            fun `events emitted`() {
                val ese = EventSavingAgenticEventListener()
                val person = SpiPerson("John")
                val result = runWithPromptReturning(
                    llmReturn = jacksonObjectMapper().writeValueAsString(person),
                    eventListener = ese,
                )
                assertEquals(person, result)
                assertEquals(3, ese.processEvents.size)
            }

            @Test
            fun `records usage`() {
                val person = SpiPerson("John")
                val result = runWithPromptReturning(jacksonObjectMapper().writeValueAsString(person))
                assertEquals(person, result)
                assertTrue(llmInvocationHistory.invocations.isNotEmpty())
            }

        }

        @Nested
        inner class Errors {

            @Test
            @Disabled("Decide on correct behavior")
            fun `non JSON return`() {
                val result = runWithPromptReturning("This ain't no JSON")
            }

            @Test
            @Disabled("Decide on correct behavior")
            fun `irrelevant JSON return`() {
                runWithPromptReturning(
                    jacksonObjectMapper().writeValueAsString(
                        mapOf(
                            "foo" to "bar",
                        ),
                    ),
                )
            }

        }

        fun runWithPromptReturning(
            llmReturn: String,
            eventListener: AgenticEventListener = EventSavingAgenticEventListener(),
        ): Any {
            llmInvocationHistory.invocations.clear()
            val mockPlatformServices = mockk<PlatformServices>()
            every { mockPlatformServices.eventListener } returns eventListener
            val mockAgentPlatform = mockk<AgentPlatform>()
            every { mockAgentPlatform.toolGroupResolver } returns RegistryToolGroupResolver("mt", emptyList())
            every { mockPlatformServices.agentPlatform } returns mockAgentPlatform
            val mockAgentProcess = mockk<AgentProcess>()
            every { mockAgentProcess.recordLlmInvocation(any()) } answers {
                llmInvocationHistory.invocations.add(
                    firstArg()
                )
            }
            every { mockAgentProcess.processContext.platformServices } returns mockPlatformServices
            val mockAgent = mockk<Agent>()
            every { mockAgent.name } returns "whatever"
            every { mockAgentProcess.agent } returns mockAgent
            val mockProcessContext = mockk<ProcessContext>()
            every { mockProcessContext.onProcessEvent(any()) } answers { eventListener.onProcessEvent(firstArg()) }
            every { mockProcessContext.platformServices } returns mockPlatformServices
            every { mockProcessContext.agentProcess } returns mockAgentProcess
            every { mockAgentProcess.processContext } returns mockProcessContext
            val mockModelProvider = mockk<ModelProvider>()
            val mockChatModel = mockk<ChatModel>()
            every { mockChatModel.defaultOptions } returns DefaultChatOptions()
            val promptSlot = slot<Prompt>()
            every { mockChatModel.call(capture(promptSlot)) } returns ChatResponse(
                listOf(
                    Generation(AssistantMessage(llmReturn)),
                ),
            )
            every { mockModelProvider.getLlm(any()) } returns Llm(
                "test", "provider", mockChatModel,
                DefaultOptionsConverter
            )

            val transformer = ChatClientLlmOperations(
                modelProvider = mockModelProvider,
                toolDecorator = DefaultToolDecorator(),
                validator = Validation.buildDefaultValidatorFactory().validator,
                templateRenderer = JinjavaTemplateRenderer(),
            )
            return transformer.createObject(
                messages = listOf(UserMessage("Say hello")),
                interaction = LlmInteraction(id = InteractionId("test")),
                agentProcess = mockAgentProcess,
                action = null,
                outputClass = SpiPerson::class.java,
            )
        }
    }

    @Nested
    inner class MaybeTransform {

        @Nested
        inner class HappyPath {

            @Test
            fun `happy path`() {
                val person = SpiPerson("John")
                val result = runWithPromptReturning(
                    llmReturn = jacksonObjectMapper().writeValueAsString(
                        MaybeReturn(
                            person
                        )
                    ),
                    outputClass = SpiPerson::class.java,
                )
                assertEquals(Result.success(person), result.result)
            }

            @Test
            fun `events emitted`() {
                val ese = EventSavingAgenticEventListener()
                val person = SpiPerson("John")
                val result = runWithPromptReturning(
                    llmReturn = jacksonObjectMapper().writeValueAsString(
                        MaybeReturn(
                            person
                        )
                    ),
                    eventListener = ese,
                    outputClass = SpiPerson::class.java,
                )
                assertEquals(Result.success(person), result.result)
                assertEquals(3, ese.processEvents.size)
            }

            @Test
            fun `records usage`() {
                val person = SpiPerson("John")
                val result = runWithPromptReturning(
                    llmReturn = jacksonObjectMapper().writeValueAsString(
                        MaybeReturn(
                            person
                        )
                    ),
                    eventListener = EventSavingAgenticEventListener(),
                    outputClass = SpiPerson::class.java,
                )
                assertEquals(Result.success(person), result.result)
                assertTrue(llmInvocationHistory.invocations.isNotEmpty())
            }

            @Test
            fun `schema contains type info`() {
                val ese = EventSavingAgenticEventListener()
                val person = WierdPerson("Marmaduke", 24, "weird")
                val result = runWithPromptReturning(
                    llmReturn = jacksonObjectMapper().writeValueAsString(
                        MaybeReturn(
                            success = person
                        )
                    ),
                    eventListener = ese,
                    outputClass = WierdPerson::class.java,
                )
                assertEquals(Result.success(person), result.result)
                assertTrue(
                    result.capturedPrompt.contains("weirdness"),
                    "Prompt should contain 'weirdness' field:\n${result.capturedPrompt}",
                )
            }

            @Test
            fun `schema contains alternative option`() {
                val ese = EventSavingAgenticEventListener()
                val result = runWithPromptReturning(
                    llmReturn =
                        jacksonObjectMapper().writeValueAsString(
                            MaybeReturn(
                                success = null,
                                failure = "couldn't do it"
                            )
                        ),
                    eventListener = ese,
                    outputClass = WierdPerson::class.java,
                )
                assertTrue(result.result.isFailure)
                assertTrue(
                    result.capturedPrompt.contains("impossible"),
                    "Prompt should contain the word 'impossible':\n${result.capturedPrompt}",
                )
            }

        }

        @Nested
        inner class Errors {

            @Test
            @Disabled("Decide on correct behavior")
            fun `non JSON return`() {
                val result = runWithPromptReturning(
                    llmReturn = "This ain't no JSON",
                    outputClass = SpiPerson::class.java,
                )
            }

            @Test
            @Disabled("Decide on correct behavior")
            fun `irrelevant JSON return`() {
                runWithPromptReturning(
                    llmReturn = jacksonObjectMapper().writeValueAsString(
                        mapOf(
                            "foo" to "bar",
                        ),
                    ),
                    outputClass = SpiPerson::class.java,
                )
            }

        }


        fun runWithPromptReturning(
            llmReturn: String,
            eventListener: AgenticEventListener = EventSavingAgenticEventListener(),
            outputClass: Class<*>,
        ): Return {
            val mockPlatformServices = mockk<PlatformServices>()
            every { mockPlatformServices.eventListener } returns eventListener
            val mockAgentPlatform = mockk<AgentPlatform>()
            every { mockAgentPlatform.toolGroupResolver } returns RegistryToolGroupResolver("mt", emptyList())
            every { mockPlatformServices.agentPlatform } returns mockAgentPlatform
            val mockAgentProcess = mockk<AgentProcess>()
            every { mockAgentProcess.processContext.platformServices } returns mockPlatformServices
            val mockAgent = mockk<Agent>()
            every { mockAgent.name } returns "whatever"
            every { mockAgentProcess.agent } returns mockAgent
            val mockProcessContext = mockk<ProcessContext>()
            every { mockProcessContext.onProcessEvent(any()) } answers { eventListener.onProcessEvent(firstArg()) }
            every { mockProcessContext.platformServices } returns mockPlatformServices
            every { mockProcessContext.agentProcess } returns mockAgentProcess
            every { mockAgentProcess.processContext } returns mockProcessContext
            every { mockAgentProcess.recordLlmInvocation(any()) } answers {
                llmInvocationHistory.invocations.add(
                    firstArg()
                )
            }
            val mockModelProvider = mockk<ModelProvider>()
            val mockChatModel = mockk<ChatModel>()
            every { mockChatModel.defaultOptions } returns DefaultChatOptions()
            val promptSlot = slot<Prompt>()
            every { mockChatModel.call(capture(promptSlot)) } returns ChatResponse(
                listOf(
                    Generation(AssistantMessage(llmReturn)),
                ),
            )
            every { mockModelProvider.getLlm(any()) } returns Llm(
                "test", "provider", mockChatModel,
                DefaultOptionsConverter
            )

            val transformer =
                ChatClientLlmOperations(
                    modelProvider = mockModelProvider,
                    toolDecorator = DefaultToolDecorator(),
                    templateRenderer = JinjavaTemplateRenderer(),
                    validator = Validation.buildDefaultValidatorFactory().validator,
                )
            val result = transformer.createObjectIfPossible(
                messages = listOf(UserMessage("Say hello")),
                interaction = LlmInteraction(id = InteractionId("test")),
                agentProcess = mockAgentProcess,
                action = null,
                outputClass = outputClass,
            )
            return Return(
                result = result,
                capturedPrompt = promptSlot.captured.toString(),
            )
        }
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/spi/support/CustomValidationAnnotationTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support

import com.embabel.agent.api.common.Ai
import jakarta.validation.*
import org.junit.jupiter.api.Assertions.assertNotNull
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.autoconfigure.EnableAutoConfiguration
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.context.annotation.Import
import org.springframework.stereotype.Component
import org.springframework.test.context.ActiveProfiles
import kotlin.reflect.KClass

data class Palindromic(
    @field:MustBePalindrome
    val eats: String,
)

@Target(AnnotationTarget.FIELD, AnnotationTarget.VALUE_PARAMETER)
@Retention(AnnotationRetention.RUNTIME)
@Constraint(validatedBy = [PalindromeValidator::class])
annotation class MustBePalindrome(
    val message: String = "Must be a palindrome",
    val groups: Array<KClass<*>> = [],
    val payload: Array<KClass<out Payload>> = [],
)

@Component
class PalindromeValidator(
    val ai: Ai,
) : ConstraintValidator<MustBePalindrome, String> {

    override fun isValid(
        field: String?,
        context: ConstraintValidatorContext,
    ): Boolean {
        assertNotNull(ai, "AI instance should be injected")
        return field != null && field == field.reversed()
    }
}


@SpringBootTest
@ActiveProfiles(value = ["test"])
@AutoConfigureMockMvc(addFilters = false)
@EnableAutoConfiguration
@Import(
    value = [

    ]
)
class CustomValidationAnnotationTest {

    @Autowired
    private lateinit var validator: Validator

    @Test
    fun `custom annotated validated field with violation`() {
        val invalidPalindromic = Palindromic("able was i ere i saw st helena")
        val violations = validator.validate(invalidPalindromic)
        assert(violations.isNotEmpty())
    }

    @Test
    fun `custom annotated validated field without violation`() {
        val validPalindromic = Palindromic("able was i ere i saw elba")
        val violations = validator.validate(validPalindromic)
        assert(violations.isEmpty())
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/spi/support/DefaultToolDecoratorTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support

import com.embabel.agent.api.dsl.evenMoreEvilWizard
import com.embabel.agent.core.AgentProcess
import com.embabel.agent.spi.support.springai.DefaultToolDecorator
import com.embabel.agent.testing.integration.IntegrationTestUtils.dummyAgentProcessRunning
import com.embabel.common.ai.model.LlmOptions
import org.junit.jupiter.api.Test
import org.springframework.ai.support.ToolCallbacks
import org.springframework.ai.tool.annotation.Tool
import kotlin.test.assertNotNull
import kotlin.test.assertTrue

object RuntimeExceptionTool {
    @Tool
    fun toolThatThrowsRuntimeException(input: String): String {
        throw RuntimeException("This tool always fails")
    }
}


class DefaultToolDecoratorTest {

    @Test
    fun `test handle runtime exception from tool`() {
        val toolDecorator = DefaultToolDecorator()
        val badToolCallback = ToolCallbacks.from(RuntimeExceptionTool).single()
        val decorated = toolDecorator.decorate(
            tool = badToolCallback,
            agentProcess = dummyAgentProcessRunning(evenMoreEvilWizard()),
            action = null, llmOptions = LlmOptions(),
        )
        val result = decorated.call(
            """
            { "input": "anything at all" }
        """.trimIndent()
        )
        assertTrue(
            result.contains("This tool always fails"),
            "Expected result to contain the exception message: Got '$result'"
        )
    }

    @Test
    fun `test AgentContext is bound`() {
        val toolDecorator = DefaultToolDecorator()

        class NeedsAgentProcess {
            @Tool
            fun toolThatNeedsAgentProcess(input: String): String {
                assertNotNull(AgentProcess.get(), "Agent process must have been bound")
                return "AgentProcess is bound"
            }
        }

        val toolCallback = ToolCallbacks.from(NeedsAgentProcess()).single()
        val decorated = toolDecorator.decorate(
            tool = toolCallback,
            agentProcess = dummyAgentProcessRunning(evenMoreEvilWizard()),
            action = null, llmOptions = LlmOptions(),
        )
        val result = decorated.call(
            """
            { "input": "anything at all" }
        """.trimIndent()
        )
        assertTrue(result.contains("AgentProcess is bound"))
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/spi/support/InMemoryAgentProcessRepositoryTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support

import com.embabel.agent.spi.config.spring.ProcessRepositoryProperties
import com.embabel.agent.core.AgentProcess
import io.mockk.every
import io.mockk.mockk
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test

class InMemoryAgentProcessRepositoryTest {

    private lateinit var repository: InMemoryAgentProcessRepository

    @BeforeEach
    fun setUp() {
        repository = InMemoryAgentProcessRepository()
    }

    @Test
    fun `save and find agent process`() {
        val process = mockk<AgentProcess> {
            every { id } returns "test-id"
        }

        val saved = repository.save(process)
        assertEquals(process, saved)
        assertEquals(1, repository.size())

        val found = repository.findById("test-id")
        assertEquals(process, found)
    }

    @Test
    fun `find non-existent process returns null`() {
        val found = repository.findById("non-existent")
        assertNull(found)
    }

    @Test
    fun `delete agent process`() {
        val process = mockk<AgentProcess> {
            every { id } returns "test-id"
        }

        repository.save(process)
        assertEquals(1, repository.size())

        repository.delete(process)
        assertEquals(0, repository.size())
        assertNull(repository.findById("test-id"))
    }

    @Test
    fun `eviction when window size exceeded`() {
        val windowSize = 3
        repository = InMemoryAgentProcessRepository(ProcessRepositoryProperties(windowSize = windowSize))

        // Add processes up to the window size
        val processes = (1..windowSize).map { i ->
            mockk<AgentProcess> {
                every { id } returns "process-$i"
            }
        }

        processes.forEach { repository.save(it) }
        assertEquals(windowSize, repository.size())

        // Verify all processes are findable
        processes.forEach { process ->
            assertNotNull(repository.findById(process.id))
        }

        // Add one more process to trigger eviction
        val extraProcess = mockk<AgentProcess> {
            every { id } returns "extra-process"
        }
        repository.save(extraProcess)

        // Repository should still be at window size
        assertEquals(windowSize, repository.size())

        // The first (oldest) process should be evicted
        assertNull(repository.findById("process-1"))

        // The remaining processes should still be there
        assertNotNull(repository.findById("process-2"))
        assertNotNull(repository.findById("process-3"))
        assertNotNull(repository.findById("extra-process"))
    }

    @Test
    fun `multiple evictions when many processes added`() {
        val windowSize = 2
        repository = InMemoryAgentProcessRepository(ProcessRepositoryProperties(windowSize = windowSize))

        // Add many processes at once
        val processes = (1..5).map { i ->
            mockk<AgentProcess> {
                every { id } returns "process-$i"
            }
        }

        processes.forEach { repository.save(it) }

        // Repository should be at window size
        assertEquals(windowSize, repository.size())

        // Only the last two processes should remain
        assertNull(repository.findById("process-1"))
        assertNull(repository.findById("process-2"))
        assertNull(repository.findById("process-3"))
        assertNotNull(repository.findById("process-4"))
        assertNotNull(repository.findById("process-5"))
    }

    @Test
    fun `updating existing process does not trigger eviction`() {
        val windowSize = 2
        repository = InMemoryAgentProcessRepository(ProcessRepositoryProperties(windowSize = windowSize))

        val process1 = mockk<AgentProcess> {
            every { id } returns "process-1"
        }
        val process2 = mockk<AgentProcess> {
            every { id } returns "process-2"
        }

        repository.save(process1)
        repository.save(process2)
        assertEquals(2, repository.size())

        // Update process1 (should move it to the end of access order)
        val updatedProcess1 = mockk<AgentProcess> {
            every { id } returns "process-1"
        }
        repository.save(updatedProcess1)

        // Should still have 2 processes
        assertEquals(2, repository.size())
        assertNotNull(repository.findById("process-1"))
        assertNotNull(repository.findById("process-2"))

        // Add a third process
        val process3 = mockk<AgentProcess> {
            every { id } returns "process-3"
        }
        repository.save(process3)

        // process2 should be evicted (it was oldest in access order)
        assertEquals(2, repository.size())
        assertNotNull(repository.findById("process-1"))
        assertNull(repository.findById("process-2"))
        assertNotNull(repository.findById("process-3"))
    }

    @Test
    fun `clear removes all processes`() {
        val processes = (1..5).map { i ->
            mockk<AgentProcess> {
                every { id } returns "process-$i"
            }
        }

        processes.forEach { repository.save(it) }
        assertEquals(5, repository.size())

        repository.clear()
        assertEquals(0, repository.size())

        processes.forEach { process ->
            assertNull(repository.findById(process.id))
        }
    }

    @Test
    fun `default window size is 1000`() {
        val defaultRepo = InMemoryAgentProcessRepository()
        val properties = ProcessRepositoryProperties()
        assertEquals(1000, properties.windowSize)
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/spi/support/InMemoryContextRepositoryTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support

import com.embabel.agent.spi.config.spring.ContextRepositoryProperties
import com.embabel.agent.core.Context
import io.mockk.every
import io.mockk.mockk
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test

class InMemoryContextRepositoryTest {

    private lateinit var repository: InMemoryContextRepository

    @BeforeEach
    fun setUp() {
        repository = InMemoryContextRepository()
    }

    @Test
    fun `save and find context`() {
        val context = mockk<Context> {
            every { id } returns "test-id"
        }

        val saved = repository.save(context)
        assertEquals(context, saved)
        assertEquals(1, repository.size())

        val found = repository.findById("test-id")
        assertEquals(context, found)
    }

    @Test
    fun `save context without id assigns new id`() {
        val context = mockk<Context> {
            every { id } returns "1234"
        }

        val saved = repository.save(context)
        assertEquals(context, saved)
        assertEquals(1, repository.size())
    }

    @Test
    fun `find non-existent context returns null`() {
        val found = repository.findById("non-existent")
        assertNull(found)
    }

    @Test
    fun `delete context`() {
        val context = mockk<Context> {
            every { id } returns "test-id"
        }

        repository.save(context)
        assertEquals(1, repository.size())

        repository.delete(context)
        assertEquals(0, repository.size())
        assertNull(repository.findById("test-id"))
    }

    @Test
    fun `eviction when window size exceeded`() {
        val windowSize = 3
        repository = InMemoryContextRepository(ContextRepositoryProperties(windowSize = windowSize))

        // Add contexts up to the window size
        val contexts = (1..windowSize).map { i ->
            mockk<Context> {
                every { id } returns "context-$i"
            }
        }

        contexts.forEach { repository.save(it) }
        assertEquals(windowSize, repository.size())

        // Verify all contexts are findable
        contexts.forEach { context ->
            assertNotNull(repository.findById(context.id!!))
        }

        // Add one more context to trigger eviction
        val extraContext = mockk<Context> {
            every { id } returns "extra-context"
        }
        repository.save(extraContext)

        // Repository should still be at window size
        assertEquals(windowSize, repository.size())

        // The first (oldest) context should be evicted
        assertNull(repository.findById("context-1"))

        // The remaining contexts should still be there
        assertNotNull(repository.findById("context-2"))
        assertNotNull(repository.findById("context-3"))
        assertNotNull(repository.findById("extra-context"))
    }

    @Test
    fun `multiple evictions when many contexts added`() {
        val windowSize = 2
        repository = InMemoryContextRepository(ContextRepositoryProperties(windowSize = windowSize))

        // Add many contexts at once
        val contexts = (1..5).map { i ->
            mockk<Context> {
                every { id } returns "context-$i"
            }
        }

        contexts.forEach { repository.save(it) }

        // Repository should be at window size
        assertEquals(windowSize, repository.size())

        // Only the last two contexts should remain
        assertNull(repository.findById("context-1"))
        assertNull(repository.findById("context-2"))
        assertNull(repository.findById("context-3"))
        assertNotNull(repository.findById("context-4"))
        assertNotNull(repository.findById("context-5"))
    }

    @Test
    fun `updating existing context does not trigger eviction`() {
        val windowSize = 2
        repository = InMemoryContextRepository(ContextRepositoryProperties(windowSize = windowSize))

        val context1 = mockk<Context> {
            every { id } returns "context-1"
        }
        val context2 = mockk<Context> {
            every { id } returns "context-2"
        }

        repository.save(context1)
        repository.save(context2)
        assertEquals(2, repository.size())

        // Update context1 (should move it to the end of access order)
        val updatedContext1 = mockk<Context> {
            every { id } returns "context-1"
        }
        repository.save(updatedContext1)

        // Should still have 2 contexts
        assertEquals(2, repository.size())
        assertNotNull(repository.findById("context-1"))
        assertNotNull(repository.findById("context-2"))

        // Add a third context
        val context3 = mockk<Context> {
            every { id } returns "context-3"
        }
        repository.save(context3)

        // context2 should be evicted (it was oldest in access order)
        assertEquals(2, repository.size())
        assertNotNull(repository.findById("context-1"))
        assertNull(repository.findById("context-2"))
        assertNotNull(repository.findById("context-3"))
    }

    @Test
    fun `clear removes all contexts`() {
        val contexts = (1..5).map { i ->
            mockk<Context> {
                every { id } returns "context-$i"
            }
        }

        contexts.forEach { repository.save(it) }
        assertEquals(5, repository.size())

        repository.clear()
        assertEquals(0, repository.size())

        contexts.forEach { context ->
            assertNull(repository.findById(context.id!!))
        }
    }

    @Test
    fun `default window size is 1000`() {
        val defaultRepo = InMemoryContextRepository()
        val properties = ContextRepositoryProperties()
        assertEquals(1000, properties.windowSize)
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/spi/support/LlmRankerTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support

import com.embabel.agent.core.Goal
import com.embabel.agent.spi.LlmOperations
import io.mockk.every
import io.mockk.mockk
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Disabled
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import kotlin.test.assertEquals

class LlmRankerTest {

    @Nested
    inner class Errors {

        @Test
        @Disabled("not yet implemented")
        fun `on llm error`() {
        }

        @Test
        fun `no goals`() {
            val llmt = mockk<LlmOperations>()
            val ranker = LlmRanker(llmt, RankingProperties(llm = "whatever"))
            val result = ranker.rank(
                "goal",
                userInput = "whatever", emptySet(),
            )
            assertTrue(result.rankings().isEmpty())
        }
    }

    @Nested
    inner class HappyPath {
        @Test
        fun `successful choice`() {
            val llmt = mockk<LlmOperations>()
            val llmr = RankingsResponse(
                rankings = listOf(
                    RankedChoiceResponse("horoscope", .2),
                    RankedChoiceResponse("weather", .8),
                )
            )
            every {
                llmt.doTransform<RankingsResponse>(
                    prompt = any(),
                    interaction = any(),
                    outputClass = RankingsResponse::class.java,
                    llmRequestEvent = null,
                )
            } returns llmr
            val ranker = LlmRanker(llmt, RankingProperties(llm = "whatever"))
            val rankings = ranker.rank(
                "goal",
                "What is my horoscope for today?",
                setOf(
                    Goal(
                        name = "horoscope",
                        description = "Get a horoscope",
                    ),
                    Goal(
                        name = "weather",
                        description = "Get the weather",
                    ),
                ),
            )
            assertEquals("weather", rankings.rankings()[0].match.name)
        }
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/spi/support/ObservabilityToolCallbackTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support

import io.micrometer.observation.ObservationRegistry
import io.mockk.clearMocks
import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.springframework.ai.tool.ToolCallback
import org.springframework.ai.tool.definition.ToolDefinition

class ObservabilityToolCallbackTest {

    private lateinit var mockDelegate: ToolCallback
    private lateinit var mockObservationRegistry: ObservationRegistry
    private lateinit var mockToolDefinition: ToolDefinition

    @BeforeEach
    fun setUp() {
        mockDelegate = mockk(relaxed = true)
        mockObservationRegistry = mockk(relaxed = true)
        mockToolDefinition = mockk(relaxed = true)

        every { mockDelegate.toolDefinition } returns mockToolDefinition
        every { mockToolDefinition.name() } returns "test-tool"
    }

    @Test
    fun `should delegate getToolDefinition to underlying callback`() {
        val observabilityCallback = ObservabilityToolCallback(mockDelegate, mockObservationRegistry)
        val result = observabilityCallback.toolDefinition
        assertEquals(mockToolDefinition, result)
        verify { mockDelegate.toolDefinition }
    }

    @Test
    fun `should handle null observation registry`() {
        val observabilityCallback = ObservabilityToolCallback(mockDelegate, null)
        assertNotNull(observabilityCallback)
    }

    @Test
    fun `toString should return descriptive string with tool name`() {
        val observabilityCallback = ObservabilityToolCallback(mockDelegate, mockObservationRegistry)

        val result = observabilityCallback.toString()

        assertEquals("ObservabilityToolCallback(delegate=test-tool)", result)
    }

    @Test
    fun `should call delegate directly when observation registry is null`() {
        val observabilityCallback = ObservabilityToolCallback(mockDelegate, null)
        every { mockDelegate.call("test input") } returns "test output"

        val result = observabilityCallback.call("test input")

        assertEquals("test output", result)
        verify { mockDelegate.call("test input") }
    }

    @Test
    fun `should preserve delegate behavior exactly`() {
        val observabilityCallback = ObservabilityToolCallback(mockDelegate, null)
        every { mockDelegate.call("specific input") } returns "specific output"

        val result = observabilityCallback.call("specific input")

        assertEquals("specific output", result)
        verify(exactly = 1) { mockDelegate.call("specific input") }
    }

    @Test
    fun `should handle exceptions from delegate when no observation registry`() {
        val observabilityCallback = ObservabilityToolCallback(mockDelegate, null)
        val testException = RuntimeException("Test error")
        every { mockDelegate.call("error input") } throws testException

        val exception = assertThrows(RuntimeException::class.java) {
            observabilityCallback.call("error input")
        }

        assertEquals("Test error", exception.message)
        verify { mockDelegate.call("error input") }
    }

    @Test
    fun `should handle empty input and output strings`() {
        val observabilityCallback = ObservabilityToolCallback(mockDelegate, null)
        every { mockDelegate.call("") } returns ""

        val result = observabilityCallback.call("")

        assertEquals("", result)
        verify { mockDelegate.call("") }
    }

    @Test
    fun `should handle long input and output strings`() {
        val observabilityCallback = ObservabilityToolCallback(mockDelegate, null)
        val longInput = "x".repeat(10000)
        val longOutput = "y".repeat(10000)
        every { mockDelegate.call(longInput) } returns longOutput

        val result = observabilityCallback.call(longInput)

        assertEquals(longOutput, result)
        verify { mockDelegate.call(longInput) }
    }

    @Test
    fun `should not access tool definition unnecessarily`() {
        // Test that creating the callback doesn't immediately access tool definition
        clearMocks(mockDelegate)

        val observabilityCallback = ObservabilityToolCallback(mockDelegate, null)

        // Verify tool definition was not accessed during construction
        verify(exactly = 0) { mockDelegate.toolDefinition }

        // Now access it explicitly
        observabilityCallback.toolDefinition
        verify(exactly = 1) { mockDelegate.toolDefinition }
    }

    @Test
    fun `should handle multiple calls correctly`() {
        val observabilityCallback = ObservabilityToolCallback(mockDelegate, null)
        every { mockDelegate.call("call1") } returns "result1"
        every { mockDelegate.call("call2") } returns "result2"

        val result1 = observabilityCallback.call("call1")
        val result2 = observabilityCallback.call("call2")

        assertEquals("result1", result1)
        assertEquals("result2", result2)
        verify(exactly = 1) { mockDelegate.call("call1") }
        verify(exactly = 1) { mockDelegate.call("call2") }
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/spi/support/ToolDecoratorsKtTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support

import com.embabel.agent.api.common.PlatformServices
import com.embabel.agent.core.AgentProcess
import com.embabel.agent.event.ToolCallRequestEvent
import com.embabel.agent.event.ToolCallResponseEvent
import com.embabel.agent.spi.OperationScheduler
import com.embabel.agent.spi.support.springai.withEventPublication
import com.embabel.agent.testing.common.EventSavingAgenticEventListener
import com.embabel.common.ai.model.LlmOptions
import io.mockk.every
import io.mockk.mockk
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test
import org.springframework.ai.support.ToolCallbacks
import org.springframework.ai.tool.annotation.Tool

class SimpleTools {

    @Tool
    fun testTool(
    ): String {
        return "foobar"
    }
}

class ToolDecoratorsKtTest {

    @Test
    fun `preserves metadata`() {
        val tool = ToolCallbacks.from(SimpleTools()).single()
        val agentProcess = mockk<AgentProcess>()
        val llm = LlmOptions()
        val decorated = tool.withEventPublication(agentProcess, null, llm)
        assertEquals(tool.toolDefinition.name(), decorated.toolDefinition.name())
        assertEquals(tool.toolDefinition.inputSchema(), decorated.toolDefinition.inputSchema())
    }

    @Test
    fun `has same return`() {
        val tool = ToolCallbacks.from(SimpleTools()).single()
        val mockPlatformServices = mockk<PlatformServices>()
        every { mockPlatformServices.eventListener } returns EventSavingAgenticEventListener()
        val agentProcess = mockk<AgentProcess>()
        every { agentProcess.id } returns "test-process-id"
        every { agentProcess.processContext.platformServices } returns mockPlatformServices
        every { agentProcess.processContext.onProcessEvent(any()) } answers {
            // Do nothing
        }
        every { agentProcess.processContext.platformServices } returns mockPlatformServices
        every { mockPlatformServices.operationScheduler } returns OperationScheduler.PRONTO
        val llm = LlmOptions()
        val decorated = tool.withEventPublication(agentProcess, null, llm)
        val rawResult = tool.call("{}")
        val decoratedRest = decorated.call("{}")
        assertEquals(rawResult, decoratedRest)
    }

    @Test
    fun `emits events`() {
        val ese = EventSavingAgenticEventListener()
        val tool = ToolCallbacks.from(SimpleTools()).single()
        val mockPlatformServices = mockk<PlatformServices>()
        every { mockPlatformServices.eventListener } returns ese
        val agentProcess = mockk<AgentProcess>()
        every { agentProcess.processContext.onProcessEvent(any()) } answers {
            ese.onProcessEvent(firstArg())
        }
        every { agentProcess.id } returns "test-process-id"
        every { agentProcess.processContext.platformServices } returns mockPlatformServices
        every { mockPlatformServices.operationScheduler } returns OperationScheduler.PRONTO
        val llm = LlmOptions()
        val decorated = tool.withEventPublication(agentProcess, null, llm)
        decorated.call("{}")
        assertEquals(2, ese.processEvents.size)
        assertEquals(0, ese.platformEvents.size)
        val fce = ese.processEvents.filterIsInstance<ToolCallRequestEvent>().single()
        val fre = ese.processEvents.filterIsInstance<ToolCallResponseEvent>().single()
        assertEquals(decorated.toolDefinition.name(), fce.tool)
        assertEquals(decorated.toolDefinition.name(), fre.request.tool, decorated.toolDefinition.name())
        assertEquals(llm, fce.llmOptions)
        assertEquals(llm, fre.request.llmOptions)
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/spi/support/WithExampleConverterTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support

import com.embabel.agent.domain.library.Person
import com.embabel.agent.spi.support.springai.WithExampleConverter
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.springframework.ai.converter.BeanOutputConverter
import kotlin.test.assertFalse
import kotlin.test.assertNotNull
import kotlin.test.assertNull

class WithExampleConverterTest {
    private val validJson = "{\"name\": \"test person\"}"
    private val invalidJson = "{name: invalid json}"
    private val personClass = Person::class.java
    private fun makeConverter(ifPossible: Boolean, generateExamples: Boolean) =
        WithExampleConverter(
            BeanOutputConverter<Person>(personClass),
            personClass,
            ifPossible = ifPossible,
            generateExamples = generateExamples
        )

    @Nested
    inner class IfPossibleFalseGenerateExamplesFalse {
        private val converter = makeConverter(false, false)

        @Test
        fun `test valid JSON conversion`() {
            val result = converter.convert(validJson)
            assertNotNull(result)
            assertEquals("test person", result!!.name)
        }

        @Test
        fun `test invalid JSON conversion`() {
            try {
                val result = converter.convert(invalidJson)
                assertNull(result)
            } catch (e: Exception) {
                // Expected behavior - Jackson throws JsonParseException for invalid JSON
                assertTrue(e.message?.contains("Unexpected character") ?: false)
            }
        }

        @Test
        fun `format string does not contain example`() {
            val format = converter.getFormat()
            assertFalse(format.contains("Example"), "Format should not contain any example")
            assertFalse(format.contains("Examples:"), "Format should not contain multiple examples")
            assertFalse(format.contains("success:"), "Format should not contain success label")
            assertFalse(format.contains("failure:"), "Format should not contain failure label")
        }
    }

    @Nested
    inner class IfPossibleFalseGenerateExamplesTrue {
        private val converter = makeConverter(false, true)

        @Test
        fun `test valid JSON conversion`() {
            val result = converter.convert(validJson)
            assertNotNull(result)
            assertEquals("test person", result!!.name)
        }

        @Test
        fun `test invalid JSON conversion`() {
            try {
                val result = converter.convert(invalidJson)
                assertNull(result)
            } catch (e: Exception) {
                // Expected behavior - Jackson throws JsonParseException for invalid JSON
                assertTrue(e.message?.contains("Unexpected character") ?: false)
            }
        }

        @Test
        fun `format string contains single example and JSON structure`() {
            val format = converter.getFormat()
            assertTrue(format.contains("Example:"), "Format should contain single example header")
            assertTrue(format.contains("{"), "Format should contain JSON opening brace")
            assertTrue(format.contains("}"), "Format should contain JSON closing brace")
            assertFalse(format.contains("Examples:"), "Format should not contain multiple examples header")
            assertFalse(format.contains("success:"), "Format should not contain success label")
            assertFalse(format.contains("failure:"), "Format should not contain failure label")
        }
    }

    @Nested
    inner class IfPossibleTrueGenerateExamplesFalse {
        private val converter = makeConverter(true, false)

        @Test
        fun `test valid JSON conversion`() {
            val result = converter.convert(validJson)
            assertNotNull(result)
            assertEquals("test person", result.name)
        }

        @Test
        fun `test invalid JSON conversion`() {
            try {
                val result = converter.convert(invalidJson)
                assertNull(result)
            } catch (e: Exception) {
                // Expected behavior - Jackson throws JsonParseException for invalid JSON
                assertTrue(e.message?.contains("Unexpected character") ?: false)
            }
        }

        @Test
        fun `format string does not contain any example`() {
            val format = converter.getFormat()
            assertFalse(format.contains("Example"), "Format should not contain example header")
            assertFalse(format.contains("Examples:"), "Format should not contain multiple examples header")
            assertFalse(format.contains("success:"), "Format should not contain success label")
            assertFalse(format.contains("failure:"), "Format should not contain failure label")
        }
    }

    @Nested
    inner class IfPossibleTrueGenerateExamplesTrue {
        private val converter = makeConverter(true, true)

        @Test
        fun `test valid JSON conversion`() {
            val result = converter.convert(validJson)
            assertNotNull(result)
            assertEquals("test person", result.name)
        }

        @Test
        fun `test invalid JSON conversion`() {
            try {
                val result = converter.convert(invalidJson)
                assertNull(result)
            } catch (e: Exception) {
                // Expected behavior - Jackson throws JsonParseException for invalid JSON
                assertTrue(e.message?.contains("Unexpected character") == true)
            }
        }

        @Test
        fun `format string contains multiple examples and correct structure`() {
            val format = converter.getFormat()
            assertTrue(format.contains("Examples:"), "Format should contain multiple examples header")
            assertTrue(format.contains("success:"), "Format should contain success label")
            assertTrue(format.contains("failure:"), "Format should contain failure label")
            assertTrue(format.contains("\"success\""), "Format should contain 'success' field in JSON")
            assertTrue(format.contains("\"failure\""), "Format should contain 'failure' field in JSON")
            assertTrue(format.contains("Insufficient context"), "Format should contain failure message")
        }
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/spi/support/springai/ChatClientLlmOperationsIT.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support.springai

import com.embabel.agent.api.dsl.evenMoreEvilWizard
import com.embabel.agent.core.ProcessOptions
import com.embabel.agent.spi.LlmInteraction
import com.embabel.agent.testing.integration.IntegrationTestUtils.dummyAgentPlatform
import com.embabel.chat.UserMessage
import com.embabel.common.ai.model.LlmOptions
import com.embabel.example.simple.horoscope.kotlin.StarPerson
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import kotlin.test.assertFalse
import kotlin.test.assertTrue

@SpringBootTest
internal class ChatClientLlmOperationsIT {
    @Autowired
    private lateinit var clientLlmOperations: ChatClientLlmOperations

    private val llm = LlmOptions("gpt-4.1-nano")


    @Nested
    inner class CreateObjectIfPossible {
        @Test
        fun `sufficient data`() {
            val agentProcess =
                dummyAgentPlatform().createAgentProcess(evenMoreEvilWizard(), ProcessOptions(), emptyMap())
            val r = clientLlmOperations.createObjectIfPossible(
                messages = listOf(
                    UserMessage(
                        """
                Create a person from this user input, extracting their name and star sign:
                You are a wizard who can tell me about the stars. Bob is a Cancer.
                """.trimIndent()
                    )
                ),
                LlmInteraction.using(llm),
                StarPerson::class.java,
                agentProcess,
                null,
            )
            assertTrue(r.isSuccess, "Expected to be able to create a StarPerson, but got: $r")
            val starPerson = r.getOrThrow()
            assertEquals("Bob", starPerson.name, "Expected StarPerson to be Bob, but got: $starPerson")
            assertEquals("Cancer", starPerson.sign, "Expected StarPerson to be Cancer, but got: $starPerson")
        }

        @Test
        fun `insufficient data`() {
            val agentProcess =
                dummyAgentPlatform().createAgentProcess(evenMoreEvilWizard(), ProcessOptions(), emptyMap())
            val r = clientLlmOperations.createObjectIfPossible(
                messages = listOf(
                    UserMessage(
                        """
                Create a person from this user input, extracting their name and star sign:
                You are a wizard who can tell me about the stars.
                """.trimIndent()
                    )
                ),
                LlmInteraction.using(llm),
                StarPerson::class.java,
                agentProcess,
                null,
            )
            assertFalse(r.isSuccess, "Expected not to be able to create a StarPerson, but got: $r")
        }
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/spi/support/springai/FilteringJacksonOutputConverterTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support.springai

import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import org.junit.jupiter.api.Assertions.assertFalse
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Test

class FilteringJacksonOutputConverterTest {

    private val objectMapper = jacksonObjectMapper()

    data class Person(
        val name: String,
        val age: Int,
        val email: String,
        val address: String
    )

    @Test
    fun `test schema should include only specified properties`() {
        val converter = FilteringJacksonOutputConverter<Person>(
            clazz = Person::class.java,
            objectMapper = objectMapper,
            propertyFilter = { it == "name" || it == "age" }
        )

        val schema = converter.jsonSchema

        assertTrue(schema.contains("name"))
        assertTrue(schema.contains("age"))
        assertFalse(schema.contains("email"))
        assertFalse(schema.contains("address"))
    }

    @Test
    fun `test schema should exclude specified properties`() {
        val converter = FilteringJacksonOutputConverter<Person>(
            clazz = Person::class.java,
            objectMapper = objectMapper,
            propertyFilter = { it != "email" && it != "address" }
        )

        val schema = converter.jsonSchema

        assertTrue(schema.contains("name"))
        assertTrue(schema.contains("age"))
        assertFalse(schema.contains("email"))
        assertFalse(schema.contains("address"))
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/spi/support/springai/SuppressThinkingConverterTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.support.springai

import com.embabel.agent.support.Dog
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertNotNull
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.springframework.ai.converter.BeanOutputConverter

class SuppressThinkingConverterTest {

    @Nested
    inner class WithoutThinkingBlock {

        @Test
        fun `works with no thinking`() {
            val converter = SuppressThinkingConverter(BeanOutputConverter(Dog::class.java))
            val input = """{"name": "Rex"}"""
            val result = converter.convert(input)
            assertNotNull(result!!)
            assertEquals("Rex", result.name)
        }
    }

    @Nested
    inner class WithThinkingBlocks {

        fun checkThinkContent(thinkContent: String) {
            val converter = SuppressThinkingConverter(BeanOutputConverter(Dog::class.java))
            val input = """$thinkContent
                {"name": "Rex"}""".trimMargin()
            val result = converter.convert(input)
            assertNotNull(result!!)
            assertEquals("Rex", result.name)
        }

        @Test
        fun `with think markup block`() {
            checkThinkContent("<think>I am thinking</think>")
        }

        @Test
        fun `with preface think blog`() {
            checkThinkContent("I am thinking")
        }
    }

    @Nested
    inner class StringWithoutThinkBlocks {

        fun checkStringThinkContent(thinkContent: String) {
            val input = """$thinkContent
                You are a dog""".trimMargin()
            val result = stringWithoutThinkBlocks(input)
            assertNotNull(result)
            assertEquals("You are a dog", result.trim())
        }

        @Test
        fun `with think markup block`() {
            checkStringThinkContent("<think>I am thinking</think>")
        }

        @Test
        fun `simple string without think block`() {
            val input = "fake response"
            val result = stringWithoutThinkBlocks(input)
            assertNotNull(result)
            assertEquals("fake response", result.trim())
        }
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/spi/validation/DefaultValidationPromptGeneratorTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.spi.validation

import jakarta.validation.ConstraintViolation
import jakarta.validation.Valid
import jakarta.validation.Validation
import jakarta.validation.Validator
import jakarta.validation.constraints.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import java.time.LocalDate
import kotlin.test.assertEquals
import kotlin.test.assertTrue

class DefaultValidationPromptGeneratorTest {

    private lateinit var generator: DefaultValidationPromptGenerator
    private lateinit var validator: Validator

    @BeforeEach
    fun setUp() {
        generator = DefaultValidationPromptGenerator()
        validator = Validation.buildDefaultValidatorFactory().validator
    }

    // Test data classes with various validation annotations
    data class SimpleUser(
        @field:NotBlank(message = "Name cannot be blank")
        val name: String,

        @field:Email(message = "Must be a valid email address")
        val email: String
    )

    data class ComplexUser(
        @field:NotNull(message = "ID is required")
        @field:Min(value = 1, message = "ID must be positive")
        val id: Long?,

        @field:NotBlank(message = "Username cannot be blank")
        @field:Size(min = 3, max = 20, message = "Username must be between 3 and 20 characters")
        @field:Pattern(regexp = "^[a-zA-Z0-9_]+$", message = "Username can only contain letters, numbers, and underscores")
        val username: String,

        @field:Email(message = "Must be a valid email address")
        val email: String,

        @field:Min(value = 0, message = "Age cannot be negative")
        @field:Max(value = 150, message = "Age cannot exceed 150")
        val age: Int,

        @field:Past(message = "Birth date must be in the past")
        val birthDate: LocalDate,

        @field:DecimalMin(value = "0.0", message = "Balance cannot be negative")
        @field:DecimalMax(value = "1000000.0", message = "Balance cannot exceed 1,000,000")
        val balance: Double
    )

    data class ProductInfo(
        @field:NotBlank(message = "Product name is required")
        @field:Size(min = 2, max = 100, message = "Product name must be between 2 and 100 characters")
        val name: String,

        @field:NotNull(message = "Price is required")
        @field:DecimalMin(value = "0.01", message = "Price must be at least 0.01")
        val price: Double?,

        @field:Size(max = 500, message = "Description cannot exceed 500 characters")
        val description: String?
    )

    class EmptyClass

    @Nested
    inner class GenerateRequirementsPrompt {

        @Test
        fun `should generate requirements for simple validation constraints`() {
            val result = generator.generateRequirementsPrompt(validator, SimpleUser::class.java)

            assertTrue(result.startsWith("Validation Requirements:"))
            assertTrue(result.contains("Field 'name': NotBlank constraint"))
            assertTrue(result.contains("Name cannot be blank"))
            assertTrue(result.contains("Field 'email': Email constraint"))
            assertTrue(result.contains("Must be a valid email address"))
        }

        @Test
        fun `should generate requirements for complex validation constraints`() {
            val result = generator.generateRequirementsPrompt(validator, ComplexUser::class.java)

            assertTrue(result.startsWith("Validation Requirements:"))

            // Check for all field constraints
            assertTrue(result.contains("Field 'id': NotNull constraint"))
            assertTrue(result.contains("Field 'id': Min constraint"))
            assertTrue(result.contains("ID is required"))
            assertTrue(result.contains("ID must be positive"))

            assertTrue(result.contains("Field 'username': NotBlank constraint"))
            assertTrue(result.contains("Field 'username': Size constraint"))
            assertTrue(result.contains("Field 'username': Pattern constraint"))
            assertTrue(result.contains("Username cannot be blank"))
            assertTrue(result.contains("Username must be between 3 and 20 characters"))
            assertTrue(result.contains("Username can only contain letters, numbers, and underscores"))

            assertTrue(result.contains("Field 'email': Email constraint"))
            assertTrue(result.contains("Must be a valid email address"))

            assertTrue(result.contains("Field 'age': Min constraint"))
            assertTrue(result.contains("Field 'age': Max constraint"))
            assertTrue(result.contains("Age cannot be negative"))
            assertTrue(result.contains("Age cannot exceed 150"))

            assertTrue(result.contains("Field 'birthDate': Past constraint"))
            assertTrue(result.contains("Birth date must be in the past"))

            assertTrue(result.contains("Field 'balance': DecimalMin constraint"))
            assertTrue(result.contains("Field 'balance': DecimalMax constraint"))
            assertTrue(result.contains("Balance cannot be negative"))
            assertTrue(result.contains("Balance cannot exceed 1,000,000"))
        }

        @Test
        fun `should handle nullable fields with constraints`() {
            val result = generator.generateRequirementsPrompt(validator, ProductInfo::class.java)

            assertTrue(result.startsWith("Validation Requirements:"))
            assertTrue(result.contains("Field 'name': NotBlank constraint"))
            assertTrue(result.contains("Field 'name': Size constraint"))
            assertTrue(result.contains("Field 'price': NotNull constraint"))
            assertTrue(result.contains("Field 'price': DecimalMin constraint"))
            assertTrue(result.contains("Field 'description': Size constraint"))
        }

        @Test
        fun `should return no constraints message for class without validation annotations`() {
            val result = generator.generateRequirementsPrompt(validator, EmptyClass::class.java)

            assertEquals("No validation constraints defined.", result)
        }

        @Test
        fun `should handle class with only one constraint`() {
            data class SingleConstraintClass(
                @field:NotNull(message = "Value is required")
                val value: String?
            )

            val result = generator.generateRequirementsPrompt(validator, SingleConstraintClass::class.java)

            assertTrue(result.startsWith("Validation Requirements:"))
            assertTrue(result.contains("Field 'value': NotNull constraint"))
            assertTrue(result.contains("Value is required"))
        }
    }

    @Nested
    inner class GenerateViolationsReport {

        @Test
        fun `should generate violations report for simple constraint violations`() {
            val user = SimpleUser("", "invalid-email")
            val violations = validator.validate(user)

            val result = generator.generateViolationsReport(violations)

            assertTrue(result.startsWith("Validation Violations:"))
            assertTrue(violations.isNotEmpty())

            // Check that violations are properly formatted
            violations.forEach { violation ->
                val propertyPath = violation.propertyPath.toString()
                val invalidValue = violation.invalidValue
                val message = violation.message
                assertTrue(result.contains("Field '$propertyPath' with value '$invalidValue': $message"))
            }
        }

        @Test
        fun `should generate violations report for complex constraint violations`() {
            val user = ComplexUser(
                id = null,
                username = "a", // too short
                email = "invalid-email",
                age = -5, // negative
                birthDate = LocalDate.now().plusDays(1), // future date
                balance = -100.0 // negative balance
            )
            val violations = validator.validate(user)

            val result = generator.generateViolationsReport(violations)

            assertTrue(result.startsWith("Validation Violations:"))
            assertTrue(violations.isNotEmpty())

            // Verify all violations are included
            violations.forEach { violation ->
                val propertyPath = violation.propertyPath.toString()
                val invalidValue = violation.invalidValue
                val message = violation.message
                assertTrue(result.contains("Field '$propertyPath' with value '$invalidValue': $message"))
            }
        }

        @Test
        fun `should handle multiple violations on same field`() {
            val user = ComplexUser(
                id = 1L,
                username = "a!", // too short and invalid pattern
                email = "valid@example.com",
                age = 25,
                birthDate = LocalDate.of(1990, 1, 1),
                balance = 100.0
            )
            val violations = validator.validate(user)

            val result = generator.generateViolationsReport(violations)

            if (violations.isNotEmpty()) {
                assertTrue(result.startsWith("Validation Violations:"))
                // Should contain violations for username (both size and pattern)
                assertTrue(result.contains("username"))
            }
        }

        @Test
        fun `should return no violations message for valid object`() {
            val user = SimpleUser("John Doe", "john@example.com")
            val violations = validator.validate(user)

            val result = generator.generateViolationsReport(violations)

            assertEquals("No validation violations.", result)
        }

        @Test
        fun `should handle empty violations set`() {
            val emptyViolations = emptySet<ConstraintViolation<Any>>()

            val result = generator.generateViolationsReport(emptyViolations)

            assertEquals("No validation violations.", result)
        }

        @Test
        fun `should handle null values in violations correctly`() {
            val product = ProductInfo("A", null, "Valid description")
            val violations = validator.validate(product)

            val result = generator.generateViolationsReport(violations)

            if (violations.isNotEmpty()) {
                assertTrue(result.startsWith("Validation Violations:"))
                // Should handle null price value
                violations.forEach { violation ->
                    if (violation.propertyPath.toString() == "price") {
                        assertTrue(result.contains("with value 'null'"))
                    }
                }
            }
        }

        @Test
        fun `should format violations with complex property paths`() {
            data class NestedClass(
                @field:NotBlank(message = "Nested value cannot be blank")
                val nestedValue: String
            )

            data class ContainerClass(
                @field:Valid
                val nested: NestedClass
            )

            val container = ContainerClass(NestedClass(""))
            val violations = validator.validate(container)

            val result = generator.generateViolationsReport(violations)

            if (violations.isNotEmpty()) {
                assertTrue(result.startsWith("Validation Violations:"))
                // Should handle nested property paths
                assertTrue(result.contains("nested.nestedValue"))
            }
        }
    }

    // Validation groups for testing
    interface CreateGroup
    interface UpdateGroup

    @Nested
    inner class EdgeCases {

        @Test
        fun `should handle class with inherited constraints`() {
            open class BaseUser(
                @field:NotBlank(message = "Base name is required")
                open val name: String
            )

            data class ExtendedUser(
                override val name: String,
                @field:Email(message = "Email is required")
                val email: String
            ) : BaseUser(name)

            val result = generator.generateRequirementsPrompt(validator, ExtendedUser::class.java)

            assertTrue(result.contains("Field 'name': NotBlank constraint"))
            assertTrue(result.contains("Field 'email': Email constraint"))
        }

        @Test
        fun `should handle custom validation messages with special characters`() {
            data class SpecialMessageClass(
                @field:NotBlank(message = "Name cannot be blank! Must contain: letters, numbers & symbols.")
                val name: String
            )

            val result = generator.generateRequirementsPrompt(validator, SpecialMessageClass::class.java)

            assertTrue(result.contains("Name cannot be blank! Must contain: letters, numbers & symbols."))
        }

        @Test
        fun `should handle validation groups (basic test)`() {
            data class GroupedValidationClass(
                @field:Null(groups = [CreateGroup::class], message = "ID must be null for creation")
                @field:NotNull(groups = [UpdateGroup::class], message = "ID is required for update")
                val id: Long?,

                @field:NotBlank(message = "Name is always required")
                val name: String
            )

            val result = generator.generateRequirementsPrompt(validator, GroupedValidationClass::class.java)

            // Default validation should show constraints that apply to Default group
            assertTrue(result.contains("Field 'name': NotBlank constraint"))
        }
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/support/AbstractBlackboardTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.support

import com.embabel.agent.api.annotation.support.PersonWithReverseTool
import com.embabel.agent.core.Blackboard
import com.embabel.agent.core.DataDictionaryImpl
import com.embabel.agent.core.IoBinding
import com.embabel.agent.core.JvmType
import com.embabel.agent.domain.io.UserInput
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertNull
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import java.awt.Point
import kotlin.test.assertNotNull

/**
 * Abstract test class for testing Blackboard implementations.
 * Subclasses must implement createBlackboard() to provide the specific implementation to test.
 */
abstract class AbstractBlackboardTest {

    /**
     * Factory method to create a blackboard instance for testing.
     * Subclasses override this to test different blackboard implementations.
     */
    protected abstract fun createBlackboard(): Blackboard

    @Nested
    inner class AggregationHandling {
        @Test
        fun `empty blackboard`() {
            val bb = createBlackboard()
            assertNull(
                bb.getValue(
                    IoBinding.DEFAULT_BINDING,
                    "AllOfTheAbove",
                    DataDictionaryImpl(
                        listOf(
                            AllOfTheAbove::class.java,
                            UserInput::class.java,
                            PersonWithReverseTool::class.java
                        ).map { JvmType(it) },
                    )
                )
            )
        }

        @Test
        fun `not satisfied`() {
            val bb = createBlackboard()
            bb += UserInput("John is a man")
            assertNull(
                bb.getValue(
                    IoBinding.DEFAULT_BINDING,
                    "AllOfTheAbove",

                    DataDictionaryImpl(
                        AllOfTheAbove::class.java,
                        UserInput::class.java,
                        PersonWithReverseTool::class.java
                    ),
                )
            )
        }

        @Test
        fun satisfied() {
            val bb = createBlackboard()
            bb += UserInput("John is a man")
            bb += PersonWithReverseTool("John")
            val aota = bb.getValue(
                IoBinding.DEFAULT_BINDING,
                "AllOfTheAbove",
                DataDictionaryImpl(AllOfTheAbove::class.java, UserInput::class.java, PersonWithReverseTool::class.java),
            )
            assertNotNull(aota)
            aota as AllOfTheAbove
            assertEquals("John", aota.person.name)
            assertEquals("John is a man", aota.userInput.content)

        }

    }

    @Nested
    inner class TypeResolution {

        @Test
        fun `empty blackboard, no domain objects`() {
            val bb = createBlackboard()
            assertNull(bb.getValue(IoBinding.DEFAULT_BINDING, "Person", DataDictionaryImpl()))
        }

        @Test
        fun `empty blackboard, relevant domain object`() {
            val bb = createBlackboard()
            assertNull(
                bb.getValue(
                    IoBinding.DEFAULT_BINDING,
                    "Person",
                    DataDictionaryImpl(PersonWithReverseTool::class.java)
                )
            )
        }

        @Test
        fun `exact type match on it`() {
            val bb = createBlackboard()
            val john = PersonWithReverseTool("John")
            bb += john
            assertEquals(
                john,
                bb.getValue(
                    IoBinding.DEFAULT_BINDING,
                    PersonWithReverseTool::class.java.simpleName,
                    DataDictionaryImpl(PersonWithReverseTool::class.java)
                )
            )
        }

        @Test
        fun `exact type match on variable name`() {
            val bb = createBlackboard()
            val duke = Dog("Duke")
            bb += duke
            assertEquals(duke, bb.getValue(IoBinding.DEFAULT_BINDING, "Dog", DataDictionaryImpl(Dog::class.java)))
        }


        @Test
        fun `interface type match on variable name`() {
            val bb = createBlackboard()
            val duke = Dog("Duke")
            bb += duke
            assertEquals(duke, bb.getValue(IoBinding.DEFAULT_BINDING, "Organism", DataDictionaryImpl(Dog::class.java)))
        }

        @Test
        fun `superclass type match on variable name`() {
            val bb = createBlackboard()
            val duke = Dog("Duke")
            bb += duke
            assertEquals(duke, bb.getValue(IoBinding.DEFAULT_BINDING, "Animal", DataDictionaryImpl(Dog::class.java)))
        }

        @Test
        fun `no type match`() {
            val bb = createBlackboard()
            val john = PersonWithReverseTool("John")
            bb += john
            assertNull(
                bb.getValue(
                    "person",
                    "Point",
                    DataDictionaryImpl(PersonWithReverseTool::class.java, Point::class.java)
                )
            )
        }

    }

    @Nested
    inner class HideOperations {

        @Test
        fun `hide prevents retrieval by getValue`() {
            val bb = createBlackboard()
            val john = PersonWithReverseTool("John")
            bb += john

            // Verify object can be retrieved before hiding
            assertEquals(
                john,
                bb.getValue(
                    IoBinding.DEFAULT_BINDING,
                    PersonWithReverseTool::class.java.simpleName,
                    DataDictionaryImpl(PersonWithReverseTool::class.java)
                )
            )

            // Hide the object
            bb.hide(john)

            // Verify object cannot be retrieved after hiding
            assertNull(
                bb.getValue(
                    IoBinding.DEFAULT_BINDING,
                    PersonWithReverseTool::class.java.simpleName,
                    DataDictionaryImpl(PersonWithReverseTool::class.java)
                )
            )
        }

        @Test
        fun `hide prevents retrieval by type`() {
            val bb = createBlackboard()
            val duke = Dog("Duke")
            bb += duke

            // Verify retrieval works before hiding
            assertEquals(duke, bb.getValue(IoBinding.DEFAULT_BINDING, "Dog", DataDictionaryImpl(Dog::class.java)))

            // Hide the object
            bb.hide(duke)

            // Verify retrieval fails after hiding
            assertNull(bb.getValue(IoBinding.DEFAULT_BINDING, "Dog", DataDictionaryImpl(Dog::class.java)))
        }

        @Test
        fun `hide specific object leaves others visible`() {
            val bb = createBlackboard()
            val john = PersonWithReverseTool("John")
            val jane = PersonWithReverseTool("Jane")
            bb += john
            bb += jane

            // Hide only john
            bb.hide(john)

            // jane should still be retrievable
            val retrieved = bb.getValue(
                IoBinding.DEFAULT_BINDING,
                PersonWithReverseTool::class.java.simpleName,
                DataDictionaryImpl(PersonWithReverseTool::class.java)
            )
            assertNotNull(retrieved)
            assertEquals(jane, retrieved)
        }

        @Test
        fun `hide multiple objects`() {
            val bb = createBlackboard()
            val duke = Dog("Duke")
            val rex = Dog("Rex")
            val john = PersonWithReverseTool("John")
            bb += duke
            bb += rex
            bb += john

            // Hide both dogs
            bb.hide(duke)
            bb.hide(rex)

            // Dogs should not be retrievable
            assertNull(bb.getValue(IoBinding.DEFAULT_BINDING, "Dog", DataDictionaryImpl(Dog::class.java)))

            // Person should still be retrievable
            assertEquals(
                john,
                bb.getValue(
                    IoBinding.DEFAULT_BINDING,
                    PersonWithReverseTool::class.java.simpleName,
                    DataDictionaryImpl(PersonWithReverseTool::class.java)
                )
            )
        }

        @Test
        fun `hide does not affect aggregation - aggregations use all objects`() {
            val bb = createBlackboard()
            val userInput = UserInput("John is a man")
            val person = PersonWithReverseTool("John")
            bb += userInput
            bb += person

            // Verify aggregation works before hiding
            val aotaBefore = bb.getValue(
                IoBinding.DEFAULT_BINDING,
                "AllOfTheAbove",
                DataDictionaryImpl(AllOfTheAbove::class.java, UserInput::class.java, PersonWithReverseTool::class.java),
            )
            assertNotNull(aotaBefore)

            // Hide the person
            bb.hide(person)

            // Note: Aggregations still work even with hidden objects
            // This is by design - aggregations compose from all available objects
            val aotaAfter = bb.getValue(
                IoBinding.DEFAULT_BINDING,
                "AllOfTheAbove",
                DataDictionaryImpl(AllOfTheAbove::class.java, UserInput::class.java, PersonWithReverseTool::class.java),
            )
            assertNotNull(aotaAfter)
        }

        @Test
        fun `hide on empty blackboard does not cause error`() {
            val bb = createBlackboard()
            val john = PersonWithReverseTool("John")

            // Should not throw exception
            bb.hide(john)

            // Verify blackboard is still empty
            assertNull(
                bb.getValue(
                    IoBinding.DEFAULT_BINDING,
                    PersonWithReverseTool::class.java.simpleName,
                    DataDictionaryImpl(PersonWithReverseTool::class.java)
                )
            )
        }

        @Test
        fun `hide same object multiple times`() {
            val bb = createBlackboard()
            val john = PersonWithReverseTool("John")
            bb += john

            // Hide multiple times
            bb.hide(john)
            bb.hide(john)
            bb.hide(john)

            // Should still be hidden
            assertNull(
                bb.getValue(
                    IoBinding.DEFAULT_BINDING,
                    PersonWithReverseTool::class.java.simpleName,
                    DataDictionaryImpl(PersonWithReverseTool::class.java)
                )
            )
        }
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/support/BlackboardTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.support

import com.embabel.agent.core.Blackboard
import com.embabel.agent.core.support.InMemoryBlackboard

/**
 * Tests for InMemoryBlackboard implementation.
 */
class BlackboardTest : AbstractBlackboardTest() {

    override fun createBlackboard(): Blackboard {
        return InMemoryBlackboard()
    }
}

interface Organism {
}

open class Animal(
    val name: String,
) : Organism

class Dog(name: String) : Animal(name) {
    override fun toString(): String {
        return "Dog(name='$name')"
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/support/BlackboardWorldStateDeterminerTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.support

import com.embabel.agent.api.annotation.support.PersonWithReverseTool
import com.embabel.agent.api.common.Aggregation
import com.embabel.agent.api.common.PlatformServices
import com.embabel.agent.api.dsl.agent
import com.embabel.agent.channel.DevNullOutputChannel
import com.embabel.agent.core.AgentProcess
import com.embabel.agent.core.Blackboard
import com.embabel.agent.core.ProcessContext
import com.embabel.agent.core.ProcessOptions
import com.embabel.agent.core.support.BlackboardWorldStateDeterminer
import com.embabel.agent.core.support.InMemoryBlackboard
import com.embabel.agent.domain.io.UserInput
import com.embabel.agent.testing.common.EventSavingAgenticEventListener
import com.embabel.plan.goap.ConditionDetermination
import io.mockk.every
import io.mockk.mockk
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import kotlin.test.assertEquals

data class AllOfTheAbove(
    val userInput: UserInput,
    val person: PersonWithReverseTool,
) : Aggregation

val SimpleTestAgent = agent("SimpleTest", description = "Simple test agent") {
    transformation<UserInput, PersonWithReverseTool>(name = "thing") {
        PersonWithReverseTool(name = "Rod")
    }

    transformation<AllOfTheAbove, PersonWithReverseTool>(name = "reverse-name") {
        PersonWithReverseTool(it.input.person.name.reversed())

    }

    goal(name = "done", description = "done", satisfiedBy = PersonWithReverseTool::class)
}

interface Fancy

data class FancyPerson(
    val name: String,
) : Fancy

val InterfaceTestAgent = agent("SimpleTest", description = "Simple test agent") {
    transformation<UserInput, FancyPerson>(name = "thing") {
        FancyPerson(name = "Rod")
    }

    transformation<AllOfTheAbove, FancyPerson>(name = "reverse-name") {
        FancyPerson(it.input.person.name.reversed())
    }

    goal(name = "done", description = "done", satisfiedBy = FancyPerson::class)
}

class BlackboardWorldStateDeterminerTest {

    val eventListener = EventSavingAgenticEventListener()
    val mockPlatformServices = mockk<PlatformServices>()

    init {
        every { mockPlatformServices.eventListener } returns eventListener
        every { mockPlatformServices.llmOperations } returns mockk()
        every { mockPlatformServices.outputChannel } returns DevNullOutputChannel
    }

    private fun createBlackboardWorldStateDeterminer(blackboard: Blackboard): BlackboardWorldStateDeterminer {
        val mockAgentProcess = mockk<AgentProcess>()
        every { mockAgentProcess.history } returns emptyList()
        every { mockAgentProcess.infoString(any()) } returns ""
        every { mockAgentProcess.getValue(any(), any(), any()) } answers {
            blackboard.getValue(
                firstArg(),
                secondArg(),
                thirdArg(),
            )
        }
        every { mockAgentProcess.get(any()) } answers {
            blackboard.get(firstArg())
        }
        every { mockAgentProcess.agent } returns SimpleTestAgent
        val bsb = BlackboardWorldStateDeterminer(
            processContext = ProcessContext(
                platformServices = mockPlatformServices,
                agentProcess = mockAgentProcess,
                processOptions = ProcessOptions()
            )
        )
        return bsb
    }

    @Nested
    inner class Worlds {

        @Test
        fun `negative world`() {
            val blackboard = InMemoryBlackboard()
            val bsb = createBlackboardWorldStateDeterminer(blackboard)
            val worldState = bsb.determineWorldState().state
            assertTrue(
                worldState.containsAll(
                    mapOf(
                        "it:${UserInput::class.qualifiedName}" to ConditionDetermination.FALSE,
                        "it:${PersonWithReverseTool::class.qualifiedName}" to ConditionDetermination.FALSE,
                    )
                ),
                "World state must use qualified names",
            )

        }

        @Test
        fun `one element world`() {
            val blackboard = InMemoryBlackboard()

            val bsb = createBlackboardWorldStateDeterminer(blackboard)

            blackboard += UserInput("xyz")
            val worldState = bsb.determineWorldState().state
            assertTrue(
                worldState.containsAll(
                    mapOf(
                        "it:${UserInput::class.qualifiedName}" to ConditionDetermination.TRUE,
                        "it:${PersonWithReverseTool::class.qualifiedName}" to ConditionDetermination.FALSE,
                    )
                ),
                "World state must use qualified names"
            )
        }

        @Test
        fun `activated megazord`() {
            val blackboard = InMemoryBlackboard()

            val bsb = createBlackboardWorldStateDeterminer(blackboard)

            blackboard["input"] = UserInput("xyz")
            blackboard["person"] = PersonWithReverseTool("Rod")
            val worldState = bsb.determineWorldState()
            assertTrue(
                worldState.state.containsAll(
                    mapOf(
                        "it:${UserInput::class.qualifiedName}" to ConditionDetermination.TRUE,
                        "it:${PersonWithReverseTool::class.qualifiedName}" to ConditionDetermination.TRUE,
                    )
                ),
                "World state must use qualified names",
            )
            val action = SimpleTestAgent.actions.single { it.name == "reverse-name" }
            assertTrue(
                action.isAchievable(worldState)
            )
        }
    }

    @Nested
    inner class TypeChecks {

        @Test
        fun `exact type match with simple name`() {
            val blackboard = InMemoryBlackboard()
            val bsb = createBlackboardWorldStateDeterminer(blackboard)

            blackboard["input"] = UserInput("xyz")
            blackboard["person"] = PersonWithReverseTool("Rod")
            val pc = bsb.determineCondition("it:${PersonWithReverseTool::class.simpleName}")
            assertEquals(ConditionDetermination.TRUE, pc)
        }

        @Test
        fun `subclass match`() {
            val blackboard = InMemoryBlackboard()
            val bsb = createBlackboardWorldStateDeterminer(blackboard)

            blackboard["input"] = UserInput("xyz")
            blackboard["person"] = FancyPerson("Rod")
            val pc = bsb.determineCondition("it:${FancyPerson::class.simpleName}")
            assertEquals(ConditionDetermination.FALSE, bsb.determineCondition("it:Person"))
            assertEquals(ConditionDetermination.TRUE, pc)
            assertEquals(
                ConditionDetermination.TRUE, bsb.determineCondition("it:${Fancy::class.simpleName}"),
                "Should match against interface",
            )
        }


        @Test
        fun `exact type match with fqn`() {
            val blackboard = InMemoryBlackboard()
            val bsb = createBlackboardWorldStateDeterminer(blackboard)

            blackboard["input"] = UserInput("xyz")
            blackboard["person"] = PersonWithReverseTool("Rod")
            assertEquals(
                ConditionDetermination.TRUE,
                bsb.determineCondition("it:${PersonWithReverseTool::class.qualifiedName}"),
                "Should match against fully qualified name",
            )
        }
    }

    @Nested
    inner class MapValue {

        @Test
        fun `failed match by name`() {
            val blackboard = InMemoryBlackboard()
            val bsb = createBlackboardWorldStateDeterminer(blackboard)

            blackboard["story"] = UserInput("xyz")
            assertEquals(
                ConditionDetermination.FALSE,
                bsb.determineCondition("story:Story"),
                "Should not match against non map",
            )
        }

        @Test
        fun `match by name`() {
            val blackboard = InMemoryBlackboard()
            val bsb = createBlackboardWorldStateDeterminer(blackboard)

            blackboard["story"] = mapOf("content " to "xyz")
            assertEquals(
                ConditionDetermination.TRUE,
                bsb.determineCondition("story:Story"),
                "Should match against map with name",
            )
        }
    }

}

fun <K, V> Map<K, V>.containsAll(other: Map<K, V>): Boolean {
    return other.all { (key, value) ->
        this.containsKey(key) && this[key] == value
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/support/DefaultProcessIdGeneratorTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.support

import com.embabel.agent.core.Agent
import com.embabel.agent.core.ProcessOptions
import com.embabel.agent.spi.support.DefaultAgentProcessIdGenerator
import com.embabel.agent.testing.integration.forProcessIdGenerationTesting
import com.embabel.common.core.MobyNameGenerator
import io.mockk.mockk
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Disabled
import org.junit.jupiter.api.Test
import kotlin.test.assertFalse

class DefaultProcessIdGeneratorTest {

    @Test
    fun `without agent name or version`() {
        val generator = DefaultAgentProcessIdGenerator(
            properties = forProcessIdGenerationTesting(
                includeVersion = false,
                includeAgentName = false,
            ),
            nameGenerator = MobyNameGenerator,
        )
        val mockAgent = mockk<Agent>()
        val mockProcessOptions = mockk<ProcessOptions>()
        val processId = generator.createProcessId(mockAgent, mockProcessOptions)
        assertTrue(processId.length <= 100, "Process ID should be short: '$processId'")
        assertFalse(processId.contains(" "), "Process ID should not contain spaces: '$processId'")
        assertFalse(processId.startsWith("-"), "Process ID should not start with a dash: '$processId'")
    }

    @Test
    @Disabled("not yet implemented")
    fun `with agent name but without version`() {
    }

    @Test
    @Disabled("not yet implemented")
    fun `with agent name and version`() {
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/support/LlmInvocationHistoryTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.support

import com.embabel.agent.api.common.ToolsStats
import com.embabel.agent.core.LlmInvocation
import com.embabel.agent.core.LlmInvocationHistory
import com.embabel.agent.core.support.toEmbabelUsage
import com.embabel.common.ai.model.Llm
import com.embabel.common.ai.model.PricingModel
import io.mockk.every
import io.mockk.mockk
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Test
import org.springframework.ai.chat.metadata.DefaultUsage
import java.time.Duration
import java.time.Instant

class LlmInvocationHistoryImpl(
    override val llmInvocations: MutableList<LlmInvocation> = mutableListOf(),
    override val toolsStats: ToolsStats = mockk(),
) : LlmInvocationHistory

class LlmInvocationHistoryTest {

    @Test
    fun `empty history`() {
        val llmih = LlmInvocationHistoryImpl()
        assertEquals(0.0, llmih.cost(), "No cost yet")
        assertTrue(llmih.modelsUsed().isEmpty(), "No models used yet")
        assertEquals(0, llmih.usage().promptTokens, "No prompt tokens yet")
        assertEquals(0, llmih.usage().completionTokens, "No completion tokens yet")
        assertEquals(
            "LLMs: [] across 0 calls; prompt tokens: 0; completion tokens: 0; cost: $${"%.4f".format(0.0)}",
            llmih.costInfoString(false),
            "No cost info yet"
        )
    }

    @Test
    fun `one call`() {
        val llmih = LlmInvocationHistoryImpl()
        val mockLlm = mockk<Llm>()
        every { mockLlm.name } returns "Mock LLM"
        every { mockLlm.pricingModel } returns PricingModel.ALL_YOU_CAN_EAT
        val usage = DefaultUsage(100, 200)
        llmih.llmInvocations += LlmInvocation(
            llm = mockLlm,
            timestamp = Instant.now(),
            runningTime = Duration.ofMillis(100),
            usage = usage.toEmbabelUsage(),
        )
        assertEquals(0.0, llmih.cost(), "No cost as it's an all you can eat model")
        assertEquals(setOf(mockLlm), llmih.modelsUsed().toSet(), "Model used")
        assertEquals(100, llmih.usage().promptTokens, "Correct prompt tokens")
        assertEquals(200, llmih.usage().completionTokens, "Correct completion tokens")
        assertEquals(
            "LLMs: [Mock LLM] across 1 calls; prompt tokens: ${usage.promptTokens}; completion tokens: ${usage.completionTokens}; cost: $${
                "%.4f".format(
                    0.0
                )
            }",
            llmih.costInfoString(false),
            "No cost info yet"
        )
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/testing/unit/OperationContextTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.testing.unit

import com.embabel.agent.api.common.PromptRunner
import com.embabel.common.ai.model.LlmOptions
import org.junit.jupiter.api.Test
import kotlin.test.assertEquals

class OperationContextTest {

    @Test
    fun `ai uses correct LLM`() {
        val oc = FakeOperationContext()
        val llmo = LlmOptions.withModel("foobar")
        val pr: PromptRunner = oc.ai().withLlm(llmo)
        assertEquals(llmo, pr.llm)

    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/tools/agent/PerGoalToolFactoryTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.tools.agent

import com.embabel.agent.api.common.autonomy.Autonomy
import com.embabel.agent.api.dsl.evenMoreEvilWizard
import com.embabel.agent.api.dsl.evenMoreEvilWizardWithStructuredInput
import com.embabel.agent.api.dsl.exportedEvenMoreEvilWizard
import com.embabel.agent.api.dsl.userInputToFrogOrPersonBranch
import com.embabel.agent.testing.integration.IntegrationTestUtils
import com.embabel.agent.testing.integration.RandomRanker
import com.embabel.agent.testing.integration.forAutonomyTesting
import org.junit.Test
import org.junit.jupiter.api.Assertions.*


class PerGoalToolFactoryTest {

    @Test
    fun `test local export by default`() {
        val agentPlatform = IntegrationTestUtils.dummyAgentPlatform()
        agentPlatform.deploy(evenMoreEvilWizard())
        agentPlatform.deploy(userInputToFrogOrPersonBranch())
        val autonomy = Autonomy(agentPlatform, RandomRanker(), forAutonomyTesting())

        val provider = PerGoalToolCallbackFactory(autonomy, "testApp")

        val toolCallbacks = provider.toolCallbacks(remoteOnly = false, listeners = emptyList())
        assertEquals(
            3, toolCallbacks.size,
            "Should not have 1 tool callback with no export defined: have ${toolCallbacks.map { it.toolDefinition.name() }}"
        )
    }

    @Test
    fun `test no remote export by default`() {
        val agentPlatform = IntegrationTestUtils.dummyAgentPlatform()
        agentPlatform.deploy(evenMoreEvilWizard())
        agentPlatform.deploy(userInputToFrogOrPersonBranch())
        val autonomy = Autonomy(agentPlatform, RandomRanker(), forAutonomyTesting())

        val provider = PerGoalToolCallbackFactory(autonomy, "testApp")

        val toolCallbacks = provider.toolCallbacks(remoteOnly = true, listeners = emptyList())
        assertEquals(
            0,
            toolCallbacks.size,
            "Should not have any tool callbacks with no export defined: ${toolCallbacks.map { it.toolDefinition.name() }}"
        )
    }

    @Test
    fun `test explicit remote export`() {
        val agentPlatform = IntegrationTestUtils.dummyAgentPlatform()
        agentPlatform.deploy(exportedEvenMoreEvilWizard())
        agentPlatform.deploy(userInputToFrogOrPersonBranch())
        val autonomy = Autonomy(agentPlatform, RandomRanker(), forAutonomyTesting())

        val provider = PerGoalToolCallbackFactory(autonomy, "testApp")

        val toolCallbacks = provider.toolCallbacks(remoteOnly = true, listeners = emptyList())
        assertEquals(
            3,
            toolCallbacks.size,
            "Should have tool callbacks with export defined: ${toolCallbacks.map { it.toolDefinition.name() }}"
        )
    }

    @Test
    fun `test user input function per goal`() {
        val agentPlatform = IntegrationTestUtils.dummyAgentPlatform()
        agentPlatform.deploy(exportedEvenMoreEvilWizard())
        agentPlatform.deploy(userInputToFrogOrPersonBranch())
        val autonomy = Autonomy(agentPlatform, RandomRanker(), forAutonomyTesting())

        val provider = PerGoalToolCallbackFactory(autonomy, "testApp")

        val toolCallbacks = provider.toolCallbacks(remoteOnly = false, listeners = emptyList())

        assertNotNull(toolCallbacks)
        assertEquals(
            autonomy.agentPlatform.goals.size + 1,
            toolCallbacks.size,
            "Should have one tool callback per goal plus continue"
        )

        for (toolCallback in toolCallbacks) {
            assertFalse(
                toolCallback.toolDefinition.inputSchema().contains("timestamp"),
                "Tool callback should not have timestamp in input schema: ${toolCallback.toolDefinition.inputSchema()}"
            )
            val toolDefinition = toolCallback.toolDefinition
            if (toolCallback.toolDefinition.name()
                    .contains(FORM_SUBMISSION_TOOL_NAME) || toolCallback.toolDefinition.name()
                    .contains(CONFIRMATION_TOOL_NAME)
            ) {
                // This is a special case
                break
            }
            val goal = autonomy.agentPlatform.goals.find { toolCallback.toolDefinition.name().contains(it.name) }
            assertNotNull(
                goal,
                "Tool callback should correspond to a platform goal: Offending tool callback: $toolCallback"
            )
            assertNotNull(toolCallback.toolDefinition.inputSchema(), "Should have generated schema")
        }
    }

    @Test
    fun `test structured input type function for goal`() {
        val agentPlatform = IntegrationTestUtils.dummyAgentPlatform()
        agentPlatform.deploy(evenMoreEvilWizardWithStructuredInput())
        val autonomy = Autonomy(agentPlatform, RandomRanker(), forAutonomyTesting())

        val provider = PerGoalToolCallbackFactory(autonomy, "testApp")
        val toolCallbacks = provider.toolCallbacks(remoteOnly = false, listeners = emptyList())

        assertNotNull(toolCallbacks)
        assertEquals(
            2 + 1, // 2 functions for the goal + 1 continuation
            toolCallbacks.size,
            "Should have 2 tool callback for the one goal plus continuation: Have ${toolCallbacks.map { it.toolDefinition.name() }}"
        )

        // Tool callbacks should have distinct names
        val toolNames = toolCallbacks.map { it.toolDefinition.name() }
        assertEquals(
            toolNames.toSet().size,
            toolNames.size,
            "Tool callbacks should have distinct names: $toolNames"
        )

        for (toolCallback in toolCallbacks) {
            if (toolCallback.toolDefinition.name()
                    .contains(FORM_SUBMISSION_TOOL_NAME) || toolCallback.toolDefinition.name()
                    .contains(CONFIRMATION_TOOL_NAME)
            ) {
                // This is a special case
                break
            }

            assertFalse(
                toolCallback.toolDefinition.inputSchema().contains("timestamp"),
                "Tool callback should not have timestamp in input schema: ${toolCallback.toolDefinition.inputSchema()}"
            )
            val toolDefinition = toolCallback.toolDefinition
            val goalName = toolDefinition.name()
            val goal = autonomy.agentPlatform.goals.find { toolDefinition.name().contains(it.name) }
            assertNotNull(
                goal,
                "Tool callback should correspond to a platform goal: $goalName, Offending tool callback: ${toolCallback.toolDefinition.name()}",
            )
            assertNotNull(toolCallback.toolDefinition.inputSchema(), "Should have generated schema")
        }
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/tools/file/FileReadToolsTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.tools.file

import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import org.junit.jupiter.api.io.TempDir
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths

class FileReadToolsTest {

    @TempDir
    lateinit var tempDir: Path

    private lateinit var fileReadTools: FileReadTools
    private lateinit var rootPath: String

    @BeforeEach
    fun setUp() {
        rootPath = tempDir.toString()
        fileReadTools = FileTools.readOnly(
            rootPath,
            emptyList()
        )
    }

    @Nested
    inner class FindFiles {

        @BeforeEach
        fun setupFiles() {
            // Create directory structure
            Files.createDirectories(tempDir.resolve("dir1"))
            Files.createDirectories(tempDir.resolve(Paths.get("dir2", "subdir")))

            // Create files
            Files.writeString(tempDir.resolve("file1.txt"), "content1")
            Files.writeString(tempDir.resolve("file2.md"), "content2")
            Files.writeString(tempDir.resolve(Paths.get("dir1", "file3.txt")), "content3")
            Files.writeString(tempDir.resolve(Paths.get("dir2", "file4.txt")), "content4")
            Files.writeString(tempDir.resolve(Paths.get("dir2", "subdir", "file5.txt")), "content5")
        }

        @Test
        fun `should find files by extension excluding root`() {
            val result = fileReadTools.findFiles("**/*.txt")

            assertEquals(3, result.size)

            val paths = result.toPaths()

            assertTrue(paths.any { it.endsWith(Paths.get("dir1", "file3.txt")) })
            assertTrue(paths.any { it.endsWith(Paths.get("dir2", "file4.txt")) })
            assertTrue(paths.any { it.endsWith(Paths.get("dir2", "subdir", "file5.txt")) })
            assertTrue(
                paths.none { it.endsWith(Paths.get("dir1")) }, "" +
                        "Expected file1.txt NOT to be found:\n${result.joinToString("\n")}"
            )
        }

        @Test
        fun `should find files by extension in root`() {
            val result = fileReadTools.findFiles("*.txt")
            assertEquals(1, result.size)

            val paths = result.toPaths()
            assertTrue(
                paths.any { it.endsWith(Paths.get("file1.txt")) }, "" +
                        "Expected file1.txt to be found:\n${result.joinToString("\n")}"
            )
        }

        @Test
        fun `should find files in specific directory`() {
            val result = fileReadTools.findFiles("dir1/*")
            assertEquals(1, result.size)

            val paths = result.toPaths()
            assertTrue(paths[0].endsWith(Paths.get("dir1", "file3.txt")))
        }

        @Test
        fun `should return empty list when no matches`() {
            val result = fileReadTools.findFiles("**/*.java")

            assertTrue(result.isEmpty())
        }

        @Test
        fun `should not exclude under`() {
            Files.createDirectories(tempDir.resolve("thing"))
            Files.createDirectories(tempDir.resolve(Paths.get("thing", "foo")))
            Files.writeString(tempDir.resolve(Paths.get("thing", "pom.xml")), "maven stuff")
            Files.writeString(tempDir.resolve(Paths.get("thing", "foo", "pom.xml")), "maven stuff")
            val result = fileReadTools.findFiles("**/pom.xml")
            assertEquals(2, result.size, "Should not exclude under directories by default")
        }

        @Test
        fun `should exclude under when requested`() {
            Files.createDirectories(tempDir.resolve("thing"))
            Files.createDirectories(tempDir.resolve(Paths.get("thing", "foo")))
            Files.writeString(tempDir.resolve(Paths.get("thing", "pom.xml")), "maven stuff")
            Files.writeString(tempDir.resolve(Paths.get("thing", "foo", "pom.xml")), "maven stuff")

            val result = fileReadTools.findFiles("**/pom.xml", findHighest = true)

            assertEquals(1, result.size, "Should only find highest level pom.xml")
            val resultPath = Paths.get(result[0])
            val expectedPath = Paths.get("thing", "pom.xml")
            assertTrue(resultPath.endsWith(expectedPath), "Should exclude under directories when requested")
        }

        @Test
        fun `should not exclude under when parallel`() {
            Files.createDirectories(tempDir.resolve("thing"))
            Files.createDirectories(tempDir.resolve(Paths.get("thing", "foo")))
            Files.createDirectories(tempDir.resolve("that"))
            Files.createDirectories(tempDir.resolve(Paths.get("that", "foo")))
            Files.writeString(tempDir.resolve(Paths.get("thing", "pom.xml")), "maven stuff")
            // Not parallel
            Files.writeString(tempDir.resolve(Paths.get("that", "foo", "pom.xml")), "maven stuff")
            val result = fileReadTools.findFiles("**/pom.xml")
            assertEquals(2, result.size, "Should not exclude when not nested")
        }
    }

    @Nested
    inner class ReadFile {

        private val testContent = "test content"
        private lateinit var testFile: Path

        @BeforeEach
        fun setupFile() {
            testFile = tempDir.resolve("test.txt")
            Files.writeString(testFile, testContent)
        }

        @Test
        fun `should read file content`() {
            val result = fileReadTools.readFile("test.txt")

            assertEquals(testContent, result)
        }

        @Test
        fun `should throw exception when file does not exist`() {
            assertThrows<IllegalArgumentException> {
                fileReadTools.readFile("nonexistent.txt")
            }
        }

        @Test
        fun `should throw exception when path is a directory`() {
            Files.createDirectory(tempDir.resolve("testdir"))

            assertThrows<IllegalArgumentException> {
                fileReadTools.readFile("testdir")
            }
        }

        @Test
        fun `should prevent path traversal attacks`() {
            assertThrows<SecurityException> {
                fileReadTools.readFile("../../../etc/passwd")
            }
        }
    }

    @Nested
    inner class ListFiles {

        @BeforeEach
        fun setupDirectoryStructure() {
            // Create directory structure
            Files.createDirectories(tempDir.resolve("emptydir"))
            Files.createDirectories(tempDir.resolve("nonemptydir"))

            // Create files
            Files.writeString(tempDir.resolve("file1.txt"), "content1")
            Files.writeString(tempDir.resolve(Paths.get("nonemptydir", "file2.txt")), "content2")
        }

        @Test
        fun `should list files and directories in root`() {
            val result = fileReadTools.listFiles(".")

            assertEquals(3, result.size)
            assertTrue(result.contains("f:file1.txt"))
            assertTrue(result.contains("d:emptydir"))
            assertTrue(result.contains("d:nonemptydir"))
        }

        @Test
        fun `should list files in subdirectory`() {
            val result = fileReadTools.listFiles("nonemptydir")

            assertEquals(1, result.size)
            assertTrue(result.contains("f:file2.txt"))
        }

        @Test
        fun `should return empty list for empty directory`() {
            val result = fileReadTools.listFiles("emptydir")

            assertTrue(result.isEmpty())
        }

        @Test
        fun `should throw exception when directory does not exist`() {
            assertThrows<IllegalArgumentException> {
                fileReadTools.listFiles("nonexistentdir")
            }
        }

        @Test
        fun `should throw exception when path is a file`() {
            assertThrows<IllegalArgumentException> {
                fileReadTools.listFiles("file1.txt")
            }
        }
    }

    @Nested
    inner class ResolvePath {

        @Test
        fun `should resolve relative path`() {
            val relativePath = Paths.get("subdir", "file.txt").toString()
            val result = fileReadTools.resolvePath(relativePath)

            assertEquals(tempDir.resolve(relativePath), result)
        }

        @Test
        fun `should prevent path traversal`() {
            assertThrows<SecurityException> {
                fileReadTools.resolvePath("../../../etc/passwd")
            }
        }
    }

    @Nested
    inner class ResolveAndValidateFile {

        @BeforeEach
        fun setupFile() {
            Files.createDirectories(tempDir.resolve("subdir"))
            Files.writeString(tempDir.resolve("file.txt"), "content")
        }

        @Test
        fun `should throw exception when file does not exist`() {
            assertThrows<IllegalArgumentException> {
                fileReadTools.resolveAndValidateFile("nonexistent.txt")
            }
        }

        @Test
        fun `should throw exception when path is a directory`() {
            assertThrows<IllegalArgumentException> {
                fileReadTools.resolveAndValidateFile("subdir")
            }
        }

        @Test
        fun `should return path when file exists`() {
            val result = fileReadTools.resolveAndValidateFile("file.txt")
            assertEquals(tempDir.resolve("file.txt"), result)
        }
    }

    @Nested
    inner class FileReadLog {

        private val testContent = "test content"
        private lateinit var testFile: Path

        @BeforeEach
        fun setupFile() {
            fileReadTools.flushReads()
            testFile = tempDir.resolve("test.txt")
            Files.writeString(testFile, testContent)
        }

        @Test
        fun `should read file content`() {
            assertTrue(fileReadTools.getReads().isEmpty(), "Reads should be empty")
            val result = fileReadTools.readFile("test.txt")
            assertEquals(1, fileReadTools.getReads().size, "Should have recorded read")
            assertEquals("test.txt", fileReadTools.getReads()[0].path)
            assertEquals("test.txt", fileReadTools.getPathsRead().single())
            assertEquals(testContent, result)
        }

        @Test
        fun `should count reads`() {
            assertTrue(fileReadTools.getReads().isEmpty(), "Reads should be empty")
            val result = fileReadTools.readFile("test.txt")
            assertEquals(1, fileReadTools.getReads().size, "Should have recorded read")
            fileReadTools.readFile("test.txt")
            assertEquals(1, fileReadTools.getReads().size, "Should still have one read")

            val read = fileReadTools.getReads().single()
            assertEquals("test.txt", read.path)
            assertEquals(2, read.count())
        }

        @Test
        fun `should throw exception when file does not exist`() {
            assertThrows<IllegalArgumentException> {
                fileReadTools.readFile("nonexistent.txt")
            }
            assertTrue(fileReadTools.getReads().isEmpty(), "Reading a non-existent file should not count")

        }

        @Test
        fun `should throw exception when path is a directory`() {
            Files.createDirectory(tempDir.resolve("testdir"))
            assertThrows<IllegalArgumentException> {
                fileReadTools.readFile("testdir")
            }
            assertTrue(fileReadTools.getReads().isEmpty(), "Writing a directory should not count")
        }
    }

    @Nested
    inner class AccessLog {

        private val testContent = "test content"
        private lateinit var testFile: Path

        @BeforeEach
        fun setupFile() {
            fileReadTools.flushReads()
            testFile = tempDir.resolve("test.txt")
            Files.writeString(testFile, testContent)
        }

        @Test
        fun `should read file content`() {
            assertTrue(fileReadTools.getPathsAccessed().isEmpty(), "Reads should be empty")
            val result = fileReadTools.readFile("test.txt")
            assertEquals(1, fileReadTools.getPathsAccessed().size, "Should have recorded read")
        }

        @Test
        fun `should throw exception when file does not exist`() {
            assertThrows<IllegalArgumentException> {
                fileReadTools.readFile("nonexistent.txt")
            }
            assertTrue(fileReadTools.getPathsAccessed().isEmpty(), "Reading a non-existent file should not count")

        }

        @Test
        fun `should throw exception when path is a directory`() {
            Files.createDirectory(tempDir.resolve("testdir"))
            assertThrows<IllegalArgumentException> {
                fileReadTools.readFile("testdir")
            }
            assertTrue(fileReadTools.getPathsAccessed().isEmpty(), "Writing a directory should not count")
        }
    }

    @Nested
    inner class FileCount {

        @BeforeEach
        fun setupFiles() {
            // Create directory structure
            Files.createDirectories(tempDir.resolve("dir1"))
            Files.createDirectories(tempDir.resolve(Paths.get("dir2", "subdir")))
            Files.createDirectories(tempDir.resolve(".git"))
            Files.createDirectories(tempDir.resolve(Paths.get(".git", "objects")))

            // Create regular files
            Files.writeString(tempDir.resolve("file1.txt"), "content1")
            Files.writeString(tempDir.resolve("file2.md"), "content2")
            Files.writeString(tempDir.resolve(Paths.get("dir1", "file3.txt")), "content3")
            Files.writeString(tempDir.resolve(Paths.get("dir2", "file4.txt")), "content4")
            Files.writeString(tempDir.resolve(Paths.get("dir2", "subdir", "file5.txt")), "content5")

            // Create files in .git directory that should be excluded
            Files.writeString(tempDir.resolve(Paths.get(".git", "config")), "git config")
            Files.writeString(tempDir.resolve(Paths.get(".git", "objects", "abc123")), "git object")
        }

        @Test
        fun `should count all files excluding git directory`() {
            val count = fileReadTools.fileCount()

            // Should count: file1.txt, file2.md, dir1/file3.txt, dir2/file4.txt, dir2/subdir/file5.txt
            // Should exclude: .git/config, .git/objects/abc123
            assertEquals(5, count)
        }

        @Test
        fun `should return 0 for empty directory`(@TempDir emptyDir: Path) {
            val emptyFileReadTools = FileTools.readOnly(emptyDir.toString())

            val count = emptyFileReadTools.fileCount()

            assertEquals(0, count)
        }

        @Test
        fun `should handle directory with only git files`(@TempDir gitOnlyDir: Path) {
            // Create only .git directory and files
            Files.createDirectories(gitOnlyDir.resolve(".git"))
            Files.writeString(gitOnlyDir.resolve(Paths.get(".git", "config")), "git config")

            val gitOnlyFileReadTools = FileTools.readOnly(gitOnlyDir.toString())

            val count = gitOnlyFileReadTools.fileCount()

            assertEquals(0, count)
        }

        @Test
        fun `should handle deeply nested directories`() {
            // Create deeply nested structure
            val deepPath = Paths.get("level1", "level2", "level3", "level4")
            Files.createDirectories(tempDir.resolve(deepPath))
            Files.writeString(tempDir.resolve(deepPath.resolve("deep-file.txt")), "deep content")

            val count = fileReadTools.fileCount()

            // Original 5 files plus the new deep file
            assertEquals(6, count)
        }

        @Test
        fun `should exclude git directory regardless of location`() {
            // Create .git directory in subdirectory
            Files.createDirectories(tempDir.resolve(Paths.get("subproject", ".git")))
            Files.writeString(tempDir.resolve(Paths.get("subproject", ".git", "config")), "subproject git config")
            Files.writeString(tempDir.resolve(Paths.get("subproject", "README.md")), "subproject readme")

            val count = fileReadTools.fileCount()

            // Original 5 files plus subproject/README.md (but not the .git/config)
            assertEquals(6, count)
        }
    }
}

private fun List<String>.toPaths(): List<Path> = map { Paths.get(it) }



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/tools/file/FileWriteToolsTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.tools.file

import org.junit.jupiter.api.*
import org.junit.jupiter.api.Assertions.*
import java.io.File
import java.nio.file.Files
import java.util.zip.ZipEntry
import java.util.zip.ZipOutputStream

class FileWriteToolsTest {

    private lateinit var tempDir: File
    private lateinit var fileWriteTools: FileWriteTools
    private lateinit var rootPath: String

    @BeforeEach
    fun setUp() {
        tempDir = FileWriteTools.createTempDir("file-write-tools-test")
        rootPath = tempDir.absolutePath
        fileWriteTools = FileTools.readWrite(rootPath)
    }

    @AfterEach
    fun tearDown() {
        tempDir.deleteRecursively()
    }

    @Nested
    inner class CreateFile {

        @Test
        fun `should create file with content`() {
            val path = "test.txt"
            val content = "test content"

            val result = fileWriteTools.createFile(path, content)

            assertEquals("file created", result)
            val file = File(tempDir, path)
            assertTrue(file.exists())
            assertEquals(content, Files.readString(file.toPath()))
        }

        @Test
        fun `should create file and track changes`() {
            val path = "tracked-test.txt"
            val content = "test content"

            // Clear any existing changes
            fileWriteTools.flushChanges()

            val result = fileWriteTools.createFile(path, content)

            assertEquals("file created", result)
            assertEquals(1, fileWriteTools.getChanges().size, "Should track one change")
            val change = fileWriteTools.getChanges().first()
            assertEquals(
                FileModificationType.CREATE, change.type,
                "Change type should be CREATE"
            )
            assertEquals(
                path,
                change.path,
                "Change path should match created file path"
            )
        }

        @Test
        fun `should create file in subdirectory`() {
            val path = "subdir/test.txt"
            val content = "test content"

            val result = fileWriteTools.createFile(path, content)

            assertEquals("file created", result)
            val file = File(tempDir, path)
            assertTrue(file.exists())
            assertEquals(content, Files.readString(file.toPath()))
        }

        @Test
        fun `should not overwrite file in subdirectory unless asked`() {
            val path = "subdir/test.txt"
            val content = "test content"

            fileWriteTools.createFile(path, content)
            assertThrows<Exception> { fileWriteTools.createFile(path, content) }
        }

        @Test
        fun `should overwrite file in subdirectory if asked`() {
            val path = "subdir/test.txt"
            val content = "test content"

            val result1 = fileWriteTools.createFile(path, content)
            val result2 = fileWriteTools.createFile(path, content, overwrite = true)
            val file = File(tempDir, path)
            assertTrue(file.exists())
            assertEquals(content, Files.readString(file.toPath()))
        }

//        @Test
//        fun `should throw exception when file already exists`() {
//            val path = "existing.txt"
//            Files.writeString(tempDir.resolve(path), "existing content")
//
//            assertThrows<IllegalArgumentException> {
//                fileWriteTools.createFile(path, "new content")
//            }
//        }
    }

    @Nested
    inner class EditFile {

        private val originalContent = "This is the original content."
        private val path = "edit-test.txt"
        private lateinit var file: File

        @BeforeEach
        fun setupFile() {
            file = File(tempDir, path)
            Files.writeString(file.toPath(), originalContent)
        }

        @Test
        fun `should replace content in file`() {
            val oldContent = "original content"
            val newContent = "modified content"
            val fullContent = "This is the $oldContent"
            Files.writeString(file.toPath(), fullContent)

            val result = fileWriteTools.editFile(path, oldContent, newContent)

            assertEquals("file edited", result)
            val loadedContent = Files.readString(file.toPath())
            assertEquals(
                "This is the $newContent",
                loadedContent,
                "File content is [$loadedContent]"
            )
        }

        @Test
        fun `should edit file and track changes`() {
            val oldContent = "original content"
            val newContent = "modified content"
            val fullContent = "This is the $oldContent"
            Files.writeString(file.toPath(), fullContent)

            // Clear any existing changes
            fileWriteTools.flushChanges()

            val result = fileWriteTools.editFile(path, oldContent, newContent)

            assertEquals("file edited", result)
            assertEquals(1, fileWriteTools.getChanges().size, "Should track one change")
            val change = fileWriteTools.getChanges().first()
            assertEquals(
                FileModificationType.EDIT, change.type,
                "Change type should be EDIT"
            )
            assertEquals(
                path,
                change.path,
                "Change path should match edited file path"
            )
        }

        @Test
        fun `should throw exception when file does not exist`() {
            assertThrows<IllegalArgumentException> {
                fileWriteTools.editFile("nonexistent.txt", "old", "new")
            }
        }
    }

    @Nested
    inner class CreateDirectory {

        @Test
        fun `should create directory`() {
            val path = "newdir"

            val result = fileWriteTools.createDirectory(path)

            assertEquals("directory created", result)
            val dir = File(tempDir, path)
            assertTrue(dir.exists())
            assertTrue(dir.isDirectory)
        }

        @Test
        fun `should create directory and track changes`() {
            val path = "tracked-newdir"

            // Clear any existing changes
            fileWriteTools.flushChanges()

            val result = fileWriteTools.createDirectory(path)

            assertEquals("directory created", result)
            assertEquals(1, fileWriteTools.getChanges().size, "Should track one change")
            val change = fileWriteTools.getChanges().first()
            assertEquals(
                FileModificationType.CREATE_DIRECTORY, change.type,
                "Change type should be CREATE_DIRECTORY"
            )
            assertEquals(
                path,
                change.path,
                "Change path should match created directory path"
            )
        }

        @Test
        fun `should create nested directories`() {
            val path = "parent/child/grandchild"

            val result = fileWriteTools.createDirectory(path)

            assertEquals("directory created", result)
            val dir = File(tempDir, path)
            assertTrue(dir.exists())
            assertTrue(dir.isDirectory)
        }

        @Test
        fun `should return message when directory already exists`() {
            val path = "existingdir"
            File(tempDir, path).mkdir()

            val result = fileWriteTools.createDirectory(path)

            assertEquals("directory already exists", result)
        }

//        @Test
//        fun `should throw exception when path exists as file`() {
//            val path = "existing.txt"
//            Files.writeString(tempDir.resolve(path), "content")
//
//            assertThrows<IllegalArgumentException> {
//                fileWriteTools.createDirectory(path)
//            }
//        }
    }

    @Nested
    inner class AppendFile {

        private val originalContent = "Original content\n"
        private val path = "append-test.txt"
        private lateinit var file: File

        @BeforeEach
        fun setupFile() {
            file = File(tempDir, path)
            Files.writeString(file.toPath(), originalContent)
        }

        @Test
        fun `should append content to file`() {
            val appendedContent = "Appended content"
            val result = fileWriteTools.appendFile(path, appendedContent)
            assertEquals("content appended to file", result)
            assertEquals(originalContent + appendedContent, Files.readString(file.toPath()))
        }

        @Test
        fun `should append content to file and track changes`() {
            val appendedContent = "Appended content"

            // Clear any existing changes
            fileWriteTools.flushChanges()

            val result = fileWriteTools.appendFile(path, appendedContent)
            assertEquals("content appended to file", result)
            assertEquals(originalContent + appendedContent, Files.readString(file.toPath()))
            assertEquals(1, fileWriteTools.getChanges().size, "Should track one change")
            val change = fileWriteTools.getChanges().first()
            assertEquals(
                FileModificationType.APPEND, change.type,
                "Change type should be APPEND"
            )
            assertEquals(
                path,
                change.path,
                "Change path should match appended file path"
            )
        }

        @Test
        fun `should throw exception when file does not exist`() {
            assertThrows<IllegalArgumentException> {
                fileWriteTools.appendFile("nonexistent.txt", "content")
            }
        }

        @Test
        fun `should create if required when file does not exist`() {
            val path = "new-file.txt"
            val appendedContent = "Appended content"
            fileWriteTools.appendToFile(path, appendedContent, true)
            assertEquals(
                appendedContent,
                Files.readString(
                    File(tempDir, path).toPath()
                ),
                "Content should be appended to new file",
            )
        }

        @Test
        fun `appendToFile should never throw exception if file exists`() {
            val path = "new-file.txt"
            fileWriteTools.createFile(path, "")
            val appendedContent = "Appended content"
            fileWriteTools.appendToFile(path, appendedContent, true)
            assertEquals(
                appendedContent,
                Files.readString(
                    File(tempDir, path).toPath()
                ),
                "Content should be appended to new file",
            )
        }
    }

    @Nested
    inner class Delete {

        private val path = "to-delete.txt"
        private lateinit var file: File

        @BeforeEach
        fun setupFile() {
            file = File(tempDir, path)
            Files.writeString(file.toPath(), "content to delete")
        }

        @Test
        fun `should delete file`() {
            val result = fileWriteTools.delete(path)

            assertEquals("file deleted", result)
            assertFalse(file.exists())
        }

        @Test
        fun `should delete file and track changes`() {
            // Clear any existing changes
            fileWriteTools.flushChanges()

            val result = fileWriteTools.delete(path)

            assertEquals("file deleted", result)
            assertEquals(1, fileWriteTools.getChanges().size, "Should track one change")
            val change = fileWriteTools.getChanges().first()
            assertEquals(
                FileModificationType.DELETE, change.type,
                "Change type should be DELETE"
            )
            assertEquals(
                path,
                change.path,
                "Change path should match deleted file path"
            )
        }

        @Test
        fun `should throw exception when file does not exist`() {
            assertThrows<IllegalArgumentException> {
                fileWriteTools.delete("nonexistent.txt")
            }
        }
    }

    @Nested
    inner class CreateTempDir {

        private lateinit var createdTempDir: File

        @AfterEach
        fun cleanupTempDir() {
            if (::createdTempDir.isInitialized) {
                createdTempDir.deleteRecursively()
            }
        }

        @Test
        fun `should create temporary directory with seed name`() {
            val seed = "test-seed"

            createdTempDir = FileWriteTools.createTempDir(seed)

            assertTrue(createdTempDir.exists())
            assertTrue(createdTempDir.isDirectory)
            assertTrue(createdTempDir.absolutePath.contains(seed))
        }
    }

    @Nested
    inner class ExtractZipFile {

        private lateinit var zipFile: File
        private lateinit var extractDir: File

        @BeforeEach
        fun createZipFile() {
            // Create a zip file with test content
            zipFile = File(tempDir, "test.zip")
            ZipOutputStream(zipFile.outputStream()).use { zipOut ->
                // Add a file
                val entry1 = ZipEntry("file1.txt")
                zipOut.putNextEntry(entry1)
                zipOut.write("content1".toByteArray())
                zipOut.closeEntry()

                // Add a file in a subdirectory
                val entry2 = ZipEntry("subdir/file2.txt")
                zipOut.putNextEntry(entry2)
                zipOut.write("content2".toByteArray())
                zipOut.closeEntry()
            }

            extractDir = FileWriteTools.createTempDir("extract-test")
        }

        @AfterEach
        fun cleanup() {
            extractDir.deleteRecursively()
        }

        @Test
        @Disabled("not yet working")
        fun `should extract zip file contents`() {
            val result = FileWriteTools.extractZipFile(
                zipFile,
                extractDir,
                delete = false
            )

            assertTrue(
                result.exists(),
                "Zip file content should exist at ${result.absolutePath}",
            )
            assertEquals("test", result.name)

            val file1 = File(extractDir, "file1.txt")
            val file2 = File(extractDir, "subdir/file2.txt")

            assertTrue(file1.exists())
            assertTrue(file2.exists())
            assertEquals("content1", Files.readString(file1.toPath()))
            assertEquals("content2", Files.readString(file2.toPath()))
        }

        @Test
        fun `should delete zip file when delete is true`() {
            FileWriteTools.extractZipFile(zipFile, extractDir, true)
            assertFalse(zipFile.exists())
        }
    }

    @Nested
    inner class FlushChanges {

        @Test
        fun `should clear tracked changes`() {
            // Create a file to generate a change
            val path = "flush-test.txt"
            val content = "test content"
            fileWriteTools.createFile(path, content)

            // Verify change was tracked
            assertEquals(1, fileWriteTools.getChanges().size, "Should have one change before flush")

            // Flush changes
            fileWriteTools.flushChanges()

            // Verify changes were cleared
            assertEquals(0, fileWriteTools.getChanges().size, "Should have no changes after flush")
        }

        @Test
        fun `should track new changes after flush`() {
            // Create a file to generate a change
            val path1 = "flush-test1.txt"
            val content = "test content"
            fileWriteTools.createFile(path1, content)

            // Flush changes
            fileWriteTools.flushChanges()

            // Create another file
            val path2 = "flush-test2.txt"
            fileWriteTools.createFile(path2, content)

            // Verify only the new change is tracked
            assertEquals(1, fileWriteTools.getChanges().size, "Should have one change after flush")
            val change = fileWriteTools.getChanges().first()
            assertEquals(path2, change.path, "Change should be for the second file")
        }
    }

    @Nested
    inner class ChangLogDoesNotDuplicate {

        @Test
        fun `should not duplicate add`() {
            val ft = FileTools.readWrite(rootPath)
            ft.recordChange(
                FileModification(
                    type = FileModificationType.CREATE,
                    path = "test.txt",
                )
            )
            assertEquals(1, ft.getChanges().size, "Should have one change after first add")
            ft.recordChange(
                FileModification(
                    type = FileModificationType.CREATE,
                    path = "test.txt",
                )
            )
            assertEquals(1, ft.getChanges().size, "Should still have one change after duplicate add")
        }

        @Test
        fun `should not duplicate add and modify`() {
            val ft = FileTools.readWrite(rootPath)
            ft.recordChange(
                FileModification(
                    type = FileModificationType.CREATE,
                    path = "test.txt",
                )
            )
            assertEquals(1, ft.getChanges().size, "Should have one change after first add")
            ft.recordChange(
                FileModification(
                    type = FileModificationType.EDIT,
                    path = "test.txt",
                )
            )
            assertEquals(1, ft.getChanges().size, "Should still have one change after add and modify")
        }

    }

    @Nested
    inner class AccessLog {

        @Test
        fun `log write`() {
            val ft = FileTools.readWrite(rootPath)
            assertEquals(0, ft.getPathsAccessed().size, "Should have 0 access before doing anything")
            ft.createFile("thing", "content")
            assertEquals(1, ft.getPathsAccessed().size, "Should have 1 access")
            ft.createFile("thing2", "content")
            assertEquals(2, ft.getPathsAccessed().size, "Should have 2 accesses")
        }

        @Test
        fun `log duplicates only once`() {
            val ft = FileTools.readWrite(rootPath)
            ft.createFile("thing", "content")
            ft.readFile("thing")
            ft.readFile("thing")
            ft.readFile("thing")
            assertEquals(1, ft.getPathsAccessed().size, "Should have 1 access after read")
        }

        @Test
        fun `log duplicate read and write only once`() {
            val ft = FileTools.readWrite(rootPath)
            ft.createFile("thing", "content")
            ft.readFile("thing")
            assertEquals(1, ft.getPathsAccessed().size, "Should have 1 access after duplicate read")
        }

    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/tools/file/PatternSearchTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.tools.file

import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.io.TempDir
import java.nio.file.Files
import java.nio.file.Path

class PatternSearchTest {

    @TempDir
    lateinit var tempDir: Path

    private lateinit var patternSearch: PatternSearch
    private lateinit var rootPath: String

    @BeforeEach
    fun setUp() {
        rootPath = tempDir.toString()
        patternSearch = object : PatternSearch {
            override val root: String = rootPath
        }
    }

    @Nested
    inner class FindFiles {

        @BeforeEach
        fun setupFiles() {
            // Create directory structure
            Files.createDirectories(tempDir.resolve("dir1"))
            Files.createDirectories(tempDir.resolve("dir2/subdir"))

            // Create files
            Files.writeString(tempDir.resolve("file1.txt"), "content1")
            Files.writeString(tempDir.resolve("file2.md"), "content2")
            Files.writeString(tempDir.resolve("dir1/file3.txt"), "content3")
            Files.writeString(tempDir.resolve("dir2/file4.txt"), "content4")
            Files.writeString(tempDir.resolve("dir2/subdir/file5.txt"), "content5")
        }

        @Test
        fun `should find literal pattern in single file`() {
            val matches = patternSearch.findPatternInProject(Regex("content1"), "**/*.txt")

            assertEquals(1, matches.size)

            val m1 = matches.first()
            assertEquals(m1.file.name, "file1.txt")
            assertEquals(1, m1.matchedLine)
        }
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/tools/file/WellKnownFileContentTransformersTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.tools.file

import com.embabel.common.util.StringTransformer
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import kotlin.test.assertEquals

class WellKnownFileContentTransformersTest {

    @Nested
    inner class ApacheLicenseHeader {

        @Test
        fun `should not strip`() {
            val notTheres = listOf(
                "Wake in Fright",
                "Walkabout",
                "The Cars That Ate Paris",
                "Max Max",
                "Picnic at Hanging Rock",
                "Dead Calm",
            )
            notTheres.forEach {
                assertEquals(it, WellKnownFileContentTransformers.removeApacheLicenseHeader.transform(it))
            }
        }

        @Test
        fun `should strip`() {
            val it = """
                /*
                 * Copyright 2024-2025 Embabel Software, Inc.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 * http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */
                class Foo
            """.trimIndent()
            assertEquals("class Foo", WellKnownFileContentTransformers.removeApacheLicenseHeader.transform(it))
        }
    }

    @Nested
    inner class AllSanitizers {

        @Test
        fun `should not strip`() {
            val notTheres = listOf(
                "Wake in Fright",
                "Walkabout",
                "The Cars That Ate Paris",
                "Max Max",
                "Picnic at Hanging Rock",
                "Dead Calm",
            )
            notTheres.forEach {
                assertEquals(
                    it,
                    StringTransformer.transform(it, WellKnownFileContentTransformers.allSanitizers())
                )
            }
        }

        @Test
        fun `should strip`() {
            val it = """
                /*
                 * Copyright 2024-2025 Embabel Software, Inc.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License");
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 * http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */
                class Foo
            """.trimIndent()
            assertEquals(
                "class Foo",
                StringTransformer.transform(it, WellKnownFileContentTransformers.allSanitizers())
            )
        }
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/tools/math/MathToolsTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.tools.math

import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test
import kotlin.test.assertContentEquals

class MathToolsTest {

    private val mathTools = MathTools()

    @Test
    fun testMean() {
        assertEquals(3.0, mathTools.mean(listOf(1.0, 2.0, 3.0, 4.0, 5.0)))
        assertEquals(2.5, mathTools.mean(listOf(1.0, 2.0, 3.0, 4.0)))
        assertEquals(0.0, mathTools.mean(emptyList()))
        assertEquals(42.0, mathTools.mean(listOf(42.0)))
        assertEquals(0.0, mathTools.mean(listOf(-5.0, 5.0)))
    }

    @Test
    fun testMin() {
        assertEquals(1.0, mathTools.min(listOf(1.0, 2.0, 3.0, 4.0, 5.0)))
        assertEquals(-5.0, mathTools.min(listOf(1.0, -5.0, 3.0, 4.0)))
        assertEquals(42.0, mathTools.min(listOf(42.0)))
        assertEquals(Double.NaN, mathTools.min(emptyList()))
    }

    @Test
    fun testMax() {
        assertEquals(5.0, mathTools.max(listOf(1.0, 2.0, 3.0, 4.0, 5.0)))
        assertEquals(10.0, mathTools.max(listOf(1.0, -5.0, 3.0, 10.0)))
        assertEquals(42.0, mathTools.max(listOf(42.0)))
        assertEquals(Double.NaN, mathTools.max(emptyList()))
    }

    @Test
    fun testFloor() {
        assertEquals(3.0, mathTools.floor(3.7))
        assertEquals(3.0, mathTools.floor(3.0))
        assertEquals(-4.0, mathTools.floor(-3.2))
        assertEquals(0.0, mathTools.floor(0.9))
    }

    @Test
    fun testCeiling() {
        assertEquals(4.0, mathTools.ceiling(3.7))
        assertEquals(3.0, mathTools.ceiling(3.0))
        assertEquals(-3.0, mathTools.ceiling(-3.2))
        assertEquals(1.0, mathTools.ceiling(0.9))
    }

    @Test
    fun testRound() {
        assertEquals(4.0, mathTools.round(3.7))
        assertEquals(3.0, mathTools.round(3.0))
        assertEquals(-3.0, mathTools.round(-3.2))
        assertEquals(1.0, mathTools.round(0.9))
        assertEquals(0.0, mathTools.round(0.4))
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/tools/osx/AppleScriptToolsTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.tools.osx

import com.embabel.agent.common.Constants
import com.embabel.agent.core.ToolGroupPermission
import com.embabel.common.core.types.Semver
import io.mockk.*
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test

class AppleScriptToolsTest {

    private lateinit var appleScriptTools: AppleScriptTools

    @BeforeEach
    fun setup() {
        appleScriptTools = AppleScriptTools()
    }

    @Test
    fun testToolGroupMetadata() {
        assertEquals(Semver(0, 1, 0), appleScriptTools.version)
        assertEquals(Constants.EMBABEL_PROVIDER, appleScriptTools.provider)
        assertEquals("AppleScript", appleScriptTools.description.role)
        assertEquals("Run AppleScript commands", appleScriptTools.description.description)
        assertTrue(appleScriptTools.permissions.contains(ToolGroupPermission.HOST_ACCESS))
    }

    @Test
    fun testRunAppleScriptSuccess() {
        val mockRuntime = mockk<Runtime>()
        val mockProcess = mockk<Process>()

        mockkStatic(Runtime::class) {
            every { Runtime.getRuntime() } returns mockRuntime
            every { mockRuntime.exec(arrayOf("osascript", "-e", "display dialog \"Hello World\"")) } returns mockProcess
            every { mockProcess.waitFor() } returns 0

            val result = appleScriptTools.runAppleScript("display dialog \"Hello World\"")

            assertEquals("Script executed with exit code: 0", result)
            verify { mockRuntime.exec(arrayOf("osascript", "-e", "display dialog \"Hello World\"")) }
            verify { mockProcess.waitFor() }
        }
    }

    @Test
    fun testRunAppleScriptWithError() {
        val mockRuntime = mockk<Runtime>()
        val mockProcess = mockk<Process>()

        mockkStatic(Runtime::class) {
            every { Runtime.getRuntime() } returns mockRuntime
            every { mockRuntime.exec(arrayOf("osascript", "-e", "invalid script")) } returns mockProcess
            every { mockProcess.waitFor() } returns 1

            val result = appleScriptTools.runAppleScript("invalid script")

            assertEquals("Script executed with exit code: 1", result)
            verify { mockRuntime.exec(arrayOf("osascript", "-e", "invalid script")) }
            verify { mockProcess.waitFor() }
        }
    }

    @Test
    fun testRunAppleScriptWithComplexScript() {
        val complexScript = "tell application \"Finder\" to get name of every folder of desktop"
        val mockRuntime = mockk<Runtime>()
        val mockProcess = mockk<Process>()

        mockkStatic(Runtime::class) {
            every { Runtime.getRuntime() } returns mockRuntime
            every { mockRuntime.exec(arrayOf("osascript", "-e", complexScript)) } returns mockProcess
            every { mockProcess.waitFor() } returns 0

            val result = appleScriptTools.runAppleScript(complexScript)

            assertEquals("Script executed with exit code: 0", result)
            verify { mockRuntime.exec(arrayOf("osascript", "-e", complexScript)) }
        }
    }

    @Test
    fun testRunAppleScriptProcessException() {
        val mockRuntime = mockk<Runtime>()

        mockkStatic(Runtime::class) {
            every { Runtime.getRuntime() } returns mockRuntime
            every { mockRuntime.exec(arrayOf("osascript", "-e", "test script")) } throws RuntimeException("Process execution failed")

            try {
                appleScriptTools.runAppleScript("test script")
            } catch (e: RuntimeException) {
                assertEquals("Process execution failed", e.message)
            }
        }
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/validation/AgentStructureValidatorTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.validation

import com.embabel.agent.api.dsl.evenMoreEvilWizard
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.springframework.context.support.GenericApplicationContext

class AgentStructureValidatorTest {

    @Nested
    inner class Valid {

        @Test
        fun `no agents`() {
            val applicationContext = GenericApplicationContext()
            applicationContext.refresh()
            val validator = AgentStructureValidator(applicationContext)
            validator.afterPropertiesSet()
        }

        @Test
        fun `evil wizard`() {
            val applicationContext = GenericApplicationContext()
            applicationContext.refresh()
            val validator = AgentStructureValidator(applicationContext)
            val result = validator.validate(evenMoreEvilWizard())
            assertEquals(0, result.errors.size, "Expected no validation errors for evenMoreEvilWizard")
        }
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/validation/DefaultAgentValidationManagerTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.validation

import com.embabel.agent.api.dsl.evenMoreEvilWizard
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Test
import org.springframework.context.support.GenericApplicationContext

class DefaultAgentValidationManagerTest {

    @Test
    fun `evil wizard`() {
        val ac = GenericApplicationContext()
        ac.refresh()
        val manager = DefaultAgentValidationManager(
            validators = listOf(
                AgentStructureValidator(ac),
                GoapPathToCompletionValidator(),
            )
        )
        val r = manager.validateWithDetails(evenMoreEvilWizard())
        assertTrue(
            r.isValid,
            "Evil wizards are valid"
        )
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/web/rest/AgentProcessControllerIntegrationTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.web.rest

import com.embabel.agent.api.dsl.evenMoreEvilWizard
import com.embabel.agent.core.AgentPlatform
import com.embabel.agent.core.AgentProcessStatusCode
import com.embabel.agent.core.AgentProcessStatusReport
import com.embabel.agent.core.ProcessOptions
import com.embabel.agent.domain.io.UserInput
import com.fasterxml.jackson.databind.ObjectMapper
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.autoconfigure.EnableAutoConfiguration
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.ActiveProfiles
import org.springframework.test.web.servlet.MockMvc
import org.springframework.test.web.servlet.delete
import org.springframework.test.web.servlet.get
import org.springframework.test.web.servlet.result.MockMvcResultMatchers.status
import kotlin.test.assertNotNull
import kotlin.test.assertNull
import kotlin.test.assertTrue

@SpringBootTest
@ActiveProfiles("test")
@AutoConfigureMockMvc(addFilters = false)
@EnableAutoConfiguration
class AgentProcessControllerIntegrationTest(
    @param:Autowired
    private val mockMvc: MockMvc,
    @param:Autowired
    private val objectMapper: ObjectMapper,
    @param:Autowired
    private val agentPlatform: AgentPlatform,
) {

    @Nested
    inner class GetStatus {

        @Test
        fun `no such process`() {
            mockMvc.get("/api/v1/process/i_made_this_up")
                .andExpect {
                    status().isNotFound()
                }
        }

        @Test
        fun `should find process not started`() {
            val process = agentPlatform.createAgentProcess(agent = evenMoreEvilWizard(), ProcessOptions(), emptyMap())
            val result = mockMvc.get("/api/v1/process/${process.id}")
                .andExpect {
                    status().isOk()
                }.andReturn()
            val content = result.response.contentAsString
            val status = objectMapper.readValue(content, AgentProcessStatus::class.java)
            assertEquals(AgentProcessStatusCode.NOT_STARTED, status.status)
            assertNull(status.result)
        }

        @Test
        fun `should return valid status endpoint`() {
            val process = agentPlatform.createAgentProcess(agent = evenMoreEvilWizard(), ProcessOptions(), emptyMap())
            val result = mockMvc.get("/api/v1/process/${process.id}")
                .andExpect {
                    status().isOk()
                }.andReturn()
            val content = result.response.contentAsString
            val status = objectMapper.readValue(content, AgentProcessStatus::class.java)
            val result2 = mockMvc.get(status.statusUrl)
                .andExpect {
                    status().isOk()
                }.andReturn()
            assertEquals(result.response.contentAsString, result2.response.contentAsString)
        }

        @Test
        fun `should return valid SSE endpoint`() {
            val process = agentPlatform.createAgentProcess(agent = evenMoreEvilWizard(), ProcessOptions(), emptyMap())
            val result = mockMvc.get("/api/v1/process/${process.id}")
                .andExpect {
                    status().isOk()
                }.andReturn()
            val content = result.response.contentAsString
            val status = objectMapper.readValue(content, AgentProcessStatus::class.java)
            mockMvc.get(status.sseUrl)
                .andExpect {
                    status().isOk()
                }.andReturn()
        }

        @Test
        fun `should find process finished`() {
            val process = agentPlatform.createAgentProcess(
                agent = evenMoreEvilWizard(), ProcessOptions(), mapOf(
                    "it" to UserInput("Hamish will be consumed!")
                )
            )
            process.run()
            val result = mockMvc.get("/api/v1/process/${process.id}")
                .andExpect {
                    status().isOk()
                }.andReturn()
            val content = result.response.contentAsString
            val status = objectMapper.readValue(content, AgentProcessStatus::class.java)
            assertEquals(AgentProcessStatusCode.COMPLETED, status.status)
            assertNotNull(status.result)
            val snakeMeal = status.result
            assertTrue(snakeMeal.toString().contains("Hamish"), "Unexpected result: $snakeMeal")
        }
    }

    @Test
    fun `kill no such process`() {
        mockMvc.delete("/api/v1/process/i-made-this-up")
            .andExpect {
                status().isNotFound()
            }.andReturn()
    }

    @Test
    fun `should kill existing process`() {
        val agentProcess = agentPlatform.createAgentProcess(evenMoreEvilWizard(), ProcessOptions(), emptyMap())
        val result = mockMvc.delete("/api/v1/process/${agentProcess.id}")
            .andExpect {
                status().isOk()
            }.andReturn()
        val content = result.response.contentAsString
        val retrievedProcess = objectMapper.readValue(content, AgentProcessStatus::class.java)
        assertEquals(agentProcess.id, retrievedProcess.id)
        assertEquals(AgentProcessStatusCode.KILLED, retrievedProcess.status)

        val result2 = mockMvc.get("/api/v1/process/${agentProcess.id}")
            .andExpect {
                status().isOk()
            }.andReturn()
        val content2 = result2.response.contentAsString
        val retrievedProcess2 = objectMapper.readValue(content2, AgentProcessStatusReport::class.java)
        assertEquals(agentProcess.id, retrievedProcess2.id)
        assertEquals(AgentProcessStatusCode.KILLED, retrievedProcess2.status)
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/web/rest/PlatformInfoControllerIntegrationTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.web.rest

import com.embabel.agent.api.dsl.evenMoreEvilWizard
import com.embabel.agent.core.*
import com.fasterxml.jackson.core.type.TypeReference
import com.fasterxml.jackson.databind.ObjectMapper
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.autoconfigure.EnableAutoConfiguration
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.ActiveProfiles
import org.springframework.test.web.servlet.MockMvc
import org.springframework.test.web.servlet.get
import org.springframework.test.web.servlet.result.MockMvcResultMatchers.status
import kotlin.test.assertEquals

@SpringBootTest
@ActiveProfiles("test")
@AutoConfigureMockMvc(addFilters = false)
@EnableAutoConfiguration
class PlatformInfoControllerIntegrationTest(
    @param:Autowired
    private val mockMvc: MockMvc,
    @param:Autowired
    private val objectMapper: ObjectMapper,
    @param:Autowired
    private val agentPlatform: AgentPlatform,
) {

    @Test
    fun `should return agents`() {
        agentPlatform.deploy(evenMoreEvilWizard())
        val result = mockMvc.get("/api/v1/platform-info/agents")
            .andExpect {
                status().isOk()
            }.andReturn()
        val content = result.response.contentAsString
        val retrievedAgents = objectMapper.readValue(content, object : TypeReference<List<AgentMetadata>>() {})
        assertTrue(retrievedAgents.isNotEmpty(), "Must have some agents in $content")
    }

    @Test
    fun `should return goals`() {
        agentPlatform.deploy(evenMoreEvilWizard())
        val result = mockMvc.get("/api/v1/platform-info/goals")
            .andExpect {
                status().isOk()
            }.andReturn()
        val content = result.response.contentAsString
        val retrievedGoals = objectMapper.readValue(content, object : TypeReference<List<Goal>>() {})
        assertTrue(retrievedGoals.isNotEmpty(), "Must have some goals in $content")
    }

    @Test
    fun `should return conditions`() {
        agentPlatform.deploy(evenMoreEvilWizard())
        val result = mockMvc.get("/api/v1/platform-info/conditions")
            .andExpect {
                status().isOk()
            }.andReturn()
        val content = result.response.contentAsString
        val retrievedGoals = objectMapper.readValue(content, object : TypeReference<List<ConditionMetadata>>() {})
        assertTrue(retrievedGoals.isNotEmpty(), "Must have some conditions in $content")
    }

    @Test
    fun `should return actions`() {
        agentPlatform.deploy(evenMoreEvilWizard())
        val result = mockMvc.get("/api/v1/platform-info/actions")
            .andExpect {
                status().isOk()
            }.andReturn()
        val content = result.response.contentAsString
        val retrievedActions = objectMapper.readValue(content, object : TypeReference<List<ActionMetadata>>() {})
        assertTrue(retrievedActions.isNotEmpty(), "Must have some actions in $content")
    }

    @Test
    fun `should return models`() {
        val result = mockMvc.get("/api/v1/platform-info/models")
            .andExpect {
                status().isOk()
            }.andReturn()
        val content = result.response.contentAsString
        assertTrue(content.contains("LLM"))
        assertTrue(content.contains("EMBEDDING"))
    }

    @Test
    fun `should return tool groups`() {
        val result = mockMvc.get("/api/v1/platform-info/tool-groups")
            .andExpect {
                status().isOk()
            }.andReturn()
        val content = result.response.contentAsString
        val retrievedActions = objectMapper.readValue(content, object : TypeReference<List<ToolGroupMetadata>>() {})
        assertTrue(retrievedActions.isNotEmpty(), "Must have some tool groups in $content")
    }


    @Test
    fun `should return PlatformInfo`() {
        agentPlatform.deploy(evenMoreEvilWizard())
        val result = mockMvc.get("/api/v1/platform-info")
            .andExpect {
                status().isOk()
            }.andReturn()
        val content = result.response.contentAsString
        val platformInfo = objectMapper.readValue(content, PlatformInfoSummary::class.java)
        assertEquals(1, platformInfo.agentCount)
        assertTrue(platformInfo.actionCount > 1)
//        assertTrue(platformInfo.goalCount > 1)
        assertTrue(platformInfo.domainTypes.isNotEmpty())
        assertTrue(platformInfo.toolGroups.isNotEmpty(), "Must have some tool groups")
        assertTrue(platformInfo.models.isNotEmpty(), "Must have some models in $content")
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/agent/web/sse/SseControllerTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.web.sse

import com.embabel.agent.spi.config.spring.AgentPlatformProperties
import com.embabel.agent.event.AgentProcessEvent
import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter
import java.time.Instant

class SseControllerTest {

    private lateinit var mockPlatformProperties: AgentPlatformProperties
    private lateinit var mockSseConfig: AgentPlatformProperties.SseConfig
    private lateinit var sseProperties: SseProperties
    private lateinit var sseController: SSEController
    private lateinit var mockAgentProcessEvent: AgentProcessEvent

    @BeforeEach
    fun setUp() {
        mockPlatformProperties = mockk(relaxed = true)
        mockSseConfig = mockk(relaxed = true)
        mockAgentProcessEvent = mockk(relaxed = true)

        every { mockPlatformProperties.sse } returns mockSseConfig
        every { mockSseConfig.maxBufferSize } returns 100
        every { mockSseConfig.maxProcessBuffers } returns 1000

        sseProperties = SseProperties(mockPlatformProperties)
        sseController = SSEController(sseProperties)
    }

    @Nested
    inner class SsePropertiesTests {

        @Test
        fun `should initialize with default values from platform properties`() {
            assertEquals(100, sseProperties.maxBufferSize)
            assertEquals(1000, sseProperties.maxProcessBuffers)
        }

        @Test
        fun `should use custom values from platform properties`() {
            val customSseConfig = mockk<AgentPlatformProperties.SseConfig>()
            every { customSseConfig.maxBufferSize } returns 50
            every { customSseConfig.maxProcessBuffers } returns 500

            val customPlatformProperties = mockk<AgentPlatformProperties>()
            every { customPlatformProperties.sse } returns customSseConfig

            val customProperties = SseProperties(customPlatformProperties)

            assertEquals(50, customProperties.maxBufferSize)
            assertEquals(500, customProperties.maxProcessBuffers)
        }
    }

    @Nested
    inner class StreamEndpointTests {

        @Test
        fun `should create SSE emitter for valid process ID`() {
            val emitter = sseController.streamEventsForId("test-process-123")

            assertNotNull(emitter)
            assertEquals(Long.MAX_VALUE, emitter.timeout)
        }

        @Test
        fun `should handle multiple concurrent connections for same process`() {
            val processId = "test-process-456"

            val emitter1 = sseController.streamEventsForId(processId)
            val emitter2 = sseController.streamEventsForId(processId)

            assertNotNull(emitter1)
            assertNotNull(emitter2)
            assertNotSame(emitter1, emitter2)
        }

        @Test
        fun `should handle connections for different processes`() {
            val emitter1 = sseController.streamEventsForId("process-1")
            val emitter2 = sseController.streamEventsForId("process-2")

            assertNotNull(emitter1)
            assertNotNull(emitter2)
            assertNotSame(emitter1, emitter2)
        }

        @Test
        fun `should send connection confirmation message`() {
            val processId = "test-process-789"
            val mockEmitter = mockk<SseEmitter>(relaxed = true)

            // We can't easily test the actual send behavior without more complex mocking,
            // but we can verify the emitter is created
            val emitter = sseController.streamEventsForId(processId)
            assertNotNull(emitter)
        }
    }

    @Nested
    inner class EventProcessingTests {

        @Test
        fun `should buffer events for process`() {
            val processId = "buffer-test-process"
            every { mockAgentProcessEvent.processId } returns processId
            every { mockAgentProcessEvent.timestamp } returns Instant.now()

            // Create a connection first to initialize the emitter list
            sseController.streamEventsForId(processId)

            // Send an event
            sseController.onProcessEvent(mockAgentProcessEvent)

            // The event should be buffered (we can't easily verify this without exposing internal state)
            // But we can verify the processId was accessed
            verify { mockAgentProcessEvent.processId }
        }

        @Test
        fun `should handle multiple events for same process`() {
            val processId = "multi-event-process"
            val event1 = mockk<AgentProcessEvent>(relaxed = true)
            val event2 = mockk<AgentProcessEvent>(relaxed = true)

            every { event1.processId } returns processId
            every { event1.timestamp } returns Instant.now()
            every { event2.processId } returns processId
            every { event2.timestamp } returns Instant.now().plusSeconds(1)

            // Create connection
            sseController.streamEventsForId(processId)

            // Send multiple events
            sseController.onProcessEvent(event1)
            sseController.onProcessEvent(event2)

            verify { event1.processId }
            verify { event2.processId }
        }

        @Test
        fun `should handle events for different processes`() {
            val process1Id = "process-1"
            val process2Id = "process-2"
            val event1 = mockk<AgentProcessEvent>(relaxed = true)
            val event2 = mockk<AgentProcessEvent>(relaxed = true)

            every { event1.processId } returns process1Id
            every { event1.timestamp } returns Instant.now()
            every { event2.processId } returns process2Id
            every { event2.timestamp } returns Instant.now()

            // Create connections
            sseController.streamEventsForId(process1Id)
            sseController.streamEventsForId(process2Id)

            // Send events to different processes
            sseController.onProcessEvent(event1)
            sseController.onProcessEvent(event2)

            verify { event1.processId }
            verify { event2.processId }
        }

        @Test
        fun `should handle events when no emitters are connected`() {
            val processId = "no-emitters-process"
            every { mockAgentProcessEvent.processId } returns processId
            every { mockAgentProcessEvent.timestamp } returns Instant.now()

            // Send event without creating any emitters
            assertDoesNotThrow {
                sseController.onProcessEvent(mockAgentProcessEvent)
            }

            verify { mockAgentProcessEvent.processId }
        }
    }

    @Nested
    inner class BufferManagementTests {

        @Test
        fun `should respect max buffer size per process`() {
            val processId = "buffer-size-test"
            every { mockSseConfig.maxBufferSize } returns 2 // Small buffer for testing
            val testProperties = SseProperties(mockPlatformProperties)
            val testController = SSEController(testProperties)

            // Create connection
            testController.streamEventsForId(processId)

            // Create events that exceed buffer size
            val events = (1..5).map { index ->
                mockk<AgentProcessEvent>(relaxed = true).also { event ->
                    every { event.processId } returns processId
                    every { event.timestamp } returns Instant.now().plusSeconds(index.toLong())
                }
            }

            // Send all events
            events.forEach { testController.onProcessEvent(it) }

            // Verify all events were processed (they all had their processId accessed)
            events.forEach { event ->
                verify { event.processId }
            }
        }

        @Test
        fun `should respect max process buffers limit`() {
            every { mockSseConfig.maxProcessBuffers } returns 2 // Small limit for testing
            val testProperties = SseProperties(mockPlatformProperties)
            val testController = SSEController(testProperties)

            // Create events for multiple processes
            val processIds = (1..5).map { "process-$it" }
            val events = processIds.map { processId ->
                mockk<AgentProcessEvent>(relaxed = true).also { event ->
                    every { event.processId } returns processId
                    every { event.timestamp } returns Instant.now()
                }
            }

            // Create connections and send events
            processIds.forEach { testController.streamEventsForId(it) }
            events.forEach { testController.onProcessEvent(it) }

            // Verify all events were processed
            events.forEach { event ->
                verify { event.processId }
            }
        }
    }

    @Nested
    inner class ErrorHandlingTests {

        @Test
        fun `should handle IOException when sending events`() {
            val processId = "io-error-test"
            every { mockAgentProcessEvent.processId } returns processId
            every { mockAgentProcessEvent.timestamp } returns Instant.now()

            // We can't easily simulate IOException without more complex setup,
            // but we can verify the event processing doesn't throw
            assertDoesNotThrow {
                sseController.onProcessEvent(mockAgentProcessEvent)
            }
        }

        @Test
        fun `should handle general exceptions when sending events`() {
            val processId = "general-error-test"
            every { mockAgentProcessEvent.processId } returns processId
            every { mockAgentProcessEvent.timestamp } returns Instant.now()

            assertDoesNotThrow {
                sseController.onProcessEvent(mockAgentProcessEvent)
            }
        }

        @Test
        fun `should handle null or empty process IDs`() {
            val eventWithNullId = mockk<AgentProcessEvent>(relaxed = true)
            every { eventWithNullId.processId } returns ""
            every { eventWithNullId.timestamp } returns Instant.now()

            assertDoesNotThrow {
                sseController.onProcessEvent(eventWithNullId)
            }

            verify { eventWithNullId.processId }
        }
    }

    @Nested
    inner class EmitterLifecycleTests {

        @Test
        fun `should set up emitter callbacks correctly`() {
            val processId = "lifecycle-test"
            val emitter = sseController.streamEventsForId(processId)

            // We can't easily test the callback behavior without more complex mocking,
            // but we can verify the emitter was created and is properly configured
            assertNotNull(emitter)
            assertEquals(Long.MAX_VALUE, emitter.timeout)
        }

        @Test
        fun `should handle emitter completion`() {
            val processId = "completion-test"
            val emitter = sseController.streamEventsForId(processId)

            assertNotNull(emitter)
            // The completion callback is set up internally and hard to test directly
        }

        @Test
        fun `should handle emitter timeout`() {
            val processId = "timeout-test"
            val emitter = sseController.streamEventsForId(processId)

            assertNotNull(emitter)
            // The timeout callback is set up internally and hard to test directly
        }

        @Test
        fun `should handle emitter error`() {
            val processId = "error-test"
            val emitter = sseController.streamEventsForId(processId)

            assertNotNull(emitter)
            // The error callback is set up internally and hard to test directly
        }
    }

    @Nested
    inner class ConcurrencyTests {

        @Test
        fun `should handle concurrent event processing`() {
            val processId = "concurrency-test"
            val events = (1..10).map { index ->
                mockk<AgentProcessEvent>(relaxed = true).also { event ->
                    every { event.processId } returns processId
                    every { event.timestamp } returns Instant.now().plusMillis(index.toLong())
                }
            }

            // Create connection
            sseController.streamEventsForId(processId)

            // Process events concurrently (simulated)
            assertDoesNotThrow {
                events.forEach { sseController.onProcessEvent(it) }
            }

            // Verify all events were processed
            events.forEach { event ->
                verify { event.processId }
            }
        }

        @Test
        fun `should handle concurrent connections to same process`() {
            val processId = "concurrent-connections-test"

            // Create multiple connections simultaneously
            val emitters = (1..5).map {
                sseController.streamEventsForId(processId)
            }

            // Verify all emitters were created
            emitters.forEach { emitter ->
                assertNotNull(emitter)
            }
        }
    }

    @Nested
    inner class ConstantsAndStaticTests {

        @Test
        fun `should have correct SSE event name constant`() {
            assertEquals("agent-process-event", SSEController.SSE_EVENT_NAME)
        }
    }

    @Nested
    inner class IntegrationScenarioTests {

        @Test
        fun `should handle typical usage scenario`() {
            val processId = "integration-test"

            // Create connection
            val emitter = sseController.streamEventsForId(processId)
            assertNotNull(emitter)

            // Create and send events
            val events = (1..3).map { index ->
                mockk<AgentProcessEvent>(relaxed = true).also { event ->
                    every { event.processId } returns processId
                    every { event.timestamp } returns Instant.now().plusSeconds(index.toLong())
                    every { event.toString() } returns "Event $index"
                }
            }

            events.forEach { sseController.onProcessEvent(it) }

            // Verify events were processed
            events.forEach { event ->
                verify { event.processId }
            }
        }

        @Test
        fun `should handle mixed process scenario`() {
            val processes = listOf("proc-1", "proc-2", "proc-3")

            // Create connections for all processes
            val emitters = processes.associateWith { processId -> sseController.streamEventsForId(processId) }

            // Verify all emitters created
            emitters.values.forEach { emitter ->
                assertNotNull(emitter)
            }

            // Create events for different processes
            val events = processes.flatMap { processId ->
                (1..2).map { index ->
                    mockk<AgentProcessEvent>(relaxed = true).also { event ->
                        every { event.processId } returns processId
                        every { event.timestamp } returns Instant.now().plusSeconds(index.toLong())
                    }
                }
            }

            // Send all events
            events.forEach { sseController.onProcessEvent(it) }

            // Verify all events were processed
            events.forEach { event ->
                verify { event.processId }
            }
        }
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/chat/WindowingConversationFormatterTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.chat

import com.embabel.chat.support.InMemoryConversation
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Test

class WindowingConversationFormatterTest {

    @Test
    fun empty() {
        val formatter = WindowingConversationFormatter(windowSize = 2)
        val conversation = InMemoryConversation()
        val formatted = formatter.format(conversation)
        assertEquals("", formatted)
    }

    @Test
    fun `does not cut off`() {
        val formatter = WindowingConversationFormatter(windowSize = 20)
        val conversation = InMemoryConversation()
            .addMessage(UserMessage("hello", "Bill"))
            .addMessage(AssistantMessage("Hi there!"))
            .addMessage(UserMessage("How are you?", "Bill"))
            .addMessage(UserMessage("I'm great", "Bill"))
        val formatted = formatter.format(conversation)
        assertTrue(formatted.contains("Bill"))
        assertTrue(formatted.contains("Hi there!"))
        assertTrue(formatted.contains("How are you?"))
        assertTrue(formatted.contains("I'm great"))
    }

    @Test
    fun `cuts off`() {
        val formatter = WindowingConversationFormatter(windowSize = 2)
        val conversation = InMemoryConversation()
            .addMessage(UserMessage("hello", "Bill"))
            .addMessage(AssistantMessage("Hi there!"))
            .addMessage(UserMessage("How are you?", "Bill"))
            .addMessage(UserMessage("I'm great", "Bill"))
        val formatted = formatter.format(conversation)
        assertTrue(formatted.contains("Bill"))
        assertFalse(formatted.contains("Hi there!"), "Should cut off first message:\n$formatted")
        assertTrue(formatted.contains("How are you?"))
        assertTrue(formatted.contains("I'm great"))
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/chat/agent/DefaultChatAgentBuilderTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.chat.agent

import com.embabel.agent.core.AgentProcessStatusCode
import com.embabel.agent.core.ProcessOptions
import com.embabel.agent.testing.integration.IntegrationTestUtils.dummyAgentPlatform
import com.embabel.chat.UserMessage
import com.embabel.chat.support.InMemoryConversation
import com.embabel.common.ai.model.LlmOptions
import io.mockk.mockk
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test

class DefaultChatAgentBuilderTest {

    @Test
    fun `emits one message`() {
        val agentPlatform = dummyAgentPlatform()
        val cab = DefaultChatAgentBuilder(
            mockk(),
            llm = LlmOptions(),
            persona = MARVIN,
        )
        val chatAgent = cab.build()
        val m = UserMessage("Hello")
        val conversation = InMemoryConversation.of(messages = listOf(m))
        val agentProcess = agentPlatform.runAgentFrom(
            agent = chatAgent,
            processOptions = ProcessOptions(),
            bindings = mapOf(
                "conversation" to conversation,
            )
        )
        assertEquals(
            AgentProcessStatusCode.STUCK, agentProcess.status,
            "It's OK to be stuck waiting for another user message"
        )
    }


}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/example/README.md
================================================
# Example agents

These will eventually be moved to the `agent-api-examples` repository.


================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/example/common/README.md
================================================
# Common classes for demos

Not necessarily for production use, such as in memory repository implementation.


================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/example/common/InMemoryCrudRepository.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.example.common

import org.springframework.data.repository.CrudRepository
import java.util.*
import java.util.concurrent.ConcurrentHashMap

/**
 * Spring Data CrudRepository with in memory storage.
 * Not itself intended for production usage, but can be used
 * in demos to minimize dependencies, and ultimately swapped out
 * for serious use.
 */
open class InMemoryCrudRepository<T : Any>(
    private val idGetter: (T) -> String?,
    private val idSetter: ((T, String) -> T),
) : CrudRepository<T, String> {

    private val storage = ConcurrentHashMap<String, T>()

    @Suppress("UNCHECKED_CAST")
    override fun <S : T> save(entity: S): S {
        var savedEntity = entity
        val existingId = idGetter.invoke(entity)
        val id = existingId ?: UUID.randomUUID().toString()
        savedEntity = (if (existingId == null) idSetter.invoke(savedEntity, id) else entity) as S
        storage[id] = savedEntity
        return savedEntity
    }

    override fun <S : T> saveAll(entities: Iterable<S>): Iterable<S> {
        return entities.map { save(it) }
    }

    override fun findById(id: String): Optional<T> {
        return Optional.ofNullable(storage[id])
    }

    override fun existsById(id: String): Boolean {
        return storage.containsKey(id)
    }

    override fun findAll(): Iterable<T> {
        return ArrayList(storage.values)
    }

    override fun findAllById(ids: Iterable<String>): Iterable<T> {
        return ids.mapNotNull { storage[it] }
    }

    override fun count(): Long {
        return storage.size.toLong()
    }

    override fun deleteById(id: String) {
        storage.remove(id)
    }

    override fun delete(entity: T) {
        val id = idGetter.invoke(entity)
        if (id != null) {
            deleteById(id)
        }
    }

    override fun deleteAllById(ids: Iterable<String>) {
        ids.forEach { deleteById(it) }
    }

    override fun deleteAll(entities: Iterable<T>) {
        entities.forEach { delete(it) }
    }

    override fun deleteAll() {
        storage.clear()
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/example/dogfood/factchecker/factChecker.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.example.dogfood.factchecker

import com.embabel.agent.api.common.createObject
import com.embabel.agent.api.dsl.agent
import com.embabel.agent.api.dsl.aggregate
import com.embabel.agent.api.dsl.parallelMap
import com.embabel.agent.api.models.AnthropicModels
import com.embabel.agent.core.Agent
import com.embabel.agent.core.CoreToolGroups
import com.embabel.agent.core.ToolGroupRequirement
import com.embabel.agent.domain.io.UserInput
import com.embabel.agent.domain.library.InternetResource
import com.embabel.agent.domain.library.InternetResources
import com.embabel.common.ai.model.LlmOptions
import com.embabel.common.ai.model.ModelSelectionCriteria
import com.embabel.common.core.types.ZeroToOne
import com.fasterxml.jackson.annotation.JsonPropertyDescription
import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.context.annotation.Profile

data class FactualAssertion(val standaloneAssertion: String)

data class FactualAssertions(val factualAssertions: List<FactualAssertion>)

data class RationalizedFactualAssertions(
    val factualAssertions: List<FactualAssertion>,
    @JsonPropertyDescription("factual assertions that were merged")
    val numberMerged: Int,
)

data class AssertionCheck(
    val assertion: String,
    val isTrue: Boolean,
    @JsonPropertyDescription("confidence in your judgment as to whether the assertion true or false. From 0-1")
    val confidence: ZeroToOne,
    @JsonPropertyDescription("reasoning for your scoring")
    val reasoning: String,
    override val links: List<InternetResource>,
) : InternetResources

data class FactCheck(
    val checks: List<AssertionCheck>,
)

@ConfigurationProperties("embabel.fact-checker")
data class FactCheckerProperties(
    val reasoningWordCount: Int = 30,
    val trustedSources: List<String> = listOf(
        "Wikipedia",
        "Wikidata",
        "Britannica",
        "BBC",
        "Reuters",
        "ABC Australia",
    ),
    val untrustedSources: List<String> = listOf(
        "Reddit",
        "4chan",
        "Twitter",
    ),
)

@Configuration
@Profile("!test")
class FactCheckerAgentConfiguration {
    @Bean
    fun factChecker(factCheckerProperties: FactCheckerProperties): Agent {
        return factCheckerAgent(
            llms = listOf(
                LlmOptions(AnthropicModels.CLAUDE_35_HAIKU).withTemperature(.3),
                LlmOptions(AnthropicModels.CLAUDE_35_HAIKU).withTemperature(.0),
            ),
            properties = factCheckerProperties,
        )
    }
}


/**
 * Naming agent that generates names for a company or project.
 */
fun factCheckerAgent(
    llms: List<LlmOptions>,
    properties: FactCheckerProperties,
) = agent(
    name = "FactChecker",
    description = "Check content for factual accuracy",
) {

    flow {

//        referencedAgentAction<UserInput, ResearchReport>(agentName = Researcher::class.java.name)

        aggregate<UserInput, FactualAssertions, RationalizedFactualAssertions>(
            transforms = llms.map { llm ->
                { context ->
                    context.promptRunner(llm = llm, toolGroups = setOf(ToolGroupRequirement(CoreToolGroups.WEB)))
                        .createObject(
                            """
            Given the following content, identify any factual assertions.
            Phrase them as standalone assertions.
            Do not duplicate assertions.
            Use the minimum number of assertions possible, with no overlap.

            # Content
            ${context.input.content}
            """.trimIndent()
                        )
                }
            },
            merge = { list, context ->
                context.promptRunner().createObject<RationalizedFactualAssertions>(
                    """
                    Given the following factual assertions, merge them into a single list if
                    any are the same. Condense into one assertion if one assertion negates another.
                    Count the number you merged.

                    # Assertions
                    ${list.flatMap { it.factualAssertions }.joinToString("\n") { "- " + it.standaloneAssertion }}
                    """.trimIndent()
                )
            },
        )
    }

    transformation<RationalizedFactualAssertions, FactCheck> { operationContext ->
        val promptRunner = operationContext.promptRunner(
            LlmOptions(ModelSelectionCriteria.Auto),
            toolGroups = setOf(CoreToolGroups.WEB, CoreToolGroups.BROWSER_AUTOMATION).map { ToolGroupRequirement(it) }
                .toSet(),
        )
        val checks = operationContext.input.factualAssertions.parallelMap(operationContext) { assertion ->
            promptRunner.createObject<AssertionCheck>(
                """
                Given the following assertion, check if it is true or false and explain why in ${properties.reasoningWordCount} words
                Express your confidence in your determination as a number between 0 and 1.
                Use web tools.

                Be guided by the following regarding sources:
                - Trusted sources: ${properties.trustedSources.joinToString(", ")}
                - Untrusted sources: ${properties.untrustedSources.joinToString(", ")}
                Assertion: <${assertion.standaloneAssertion}>
                """
            )
        }
        FactCheck(checks)
    }

    goal(
        name = "factCheckingDone",
        description = "Content was fact checked",
        satisfiedBy = FactCheck::class,
    )

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/example/simple/horoscope/TestHoroscopeService.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.example.simple.horoscope

import org.springframework.stereotype.Service
import org.springframework.web.client.RestClient

fun interface TestHoroscopeService {

    fun dailyHoroscope(sign: String): String
}

@Service
class HoroscopeAppApiHoroscopeService : TestHoroscopeService {

    private val restClient = RestClient.builder()
        .baseUrl("https://horoscope-app-api.vercel.app")
        .build()

    override fun dailyHoroscope(sign: String): String {
        val response = restClient.get()
            .uri("/api/v1/get-horoscope/daily?sign={sign}", sign.lowercase())
            .retrieve()
            .body(HoroscopeResponse::class.java)

        return response?.data?.horoscope_data
            ?: "Unable to retrieve horoscope for $sign today."
    }
}

private data class HoroscopeResponse(
    val success: Boolean,
    val status: Int,
    val data: HoroscopeData?
)

private data class HoroscopeData(
    val date: String,
    val horoscope_data: String
)



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/example/simple/horoscope/kotlin/TestStarNewsFinder.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.example.simple.horoscope.kotlin

import com.embabel.agent.api.annotation.AchievesGoal
import com.embabel.agent.api.annotation.Action
import com.embabel.agent.api.annotation.Agent
import com.embabel.agent.api.annotation.fromForm
import com.embabel.agent.api.common.OperationContext
import com.embabel.agent.api.common.createObject
import com.embabel.agent.api.common.createObjectIfPossible
import com.embabel.agent.core.CoreToolGroups
import com.embabel.agent.domain.io.UserInput
import com.embabel.agent.domain.library.HasContent
import com.embabel.agent.domain.library.Person
import com.embabel.agent.domain.library.RelevantNewsStories
import com.embabel.common.ai.model.LlmOptions
import com.embabel.common.ai.model.ModelSelectionCriteria.Companion.Auto
import com.embabel.example.simple.horoscope.TestHoroscopeService
import com.embabel.ux.form.Text
import com.fasterxml.jackson.annotation.JsonClassDescription
import com.fasterxml.jackson.annotation.JsonPropertyDescription
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import org.springframework.beans.factory.annotation.Value

/**
 * Data class representing astrological details for a person.
 * Used to capture star sign information through a form interface.
 */
@JsonClassDescription("Astrological details for a person")
data class Starry(
    @Text(label = "Star sign")
    val sign: String,
)

/**
 * Data class representing a person with their astrological details.
 * Implements the Person interface to maintain compatibility with the agent framework's
 * person-related operations.
 */
@JsonClassDescription("Person with astrology details")
@JsonDeserialize(`as` = StarPerson::class)
data class StarPerson(
    override val name: String,
    @get:JsonPropertyDescription("Star sign")
    val sign: String,
) : Person

/**
 * Data class containing a person's horoscope summary.
 * Acts as a container for the horoscope text retrieved from the HoroscopeService.
 */
data class Horoscope(
    val summary: String,
)

/**
 * Data class representing the final output of the agent's workflow.
 * Implements HasContent interface to provide standardized access to the text content.
 */
data class Writeup(
    override val content: String,
) : HasContent

/**
 * An agent that finds personalized news stories based on a person's star sign.
 */
@Agent(
    description = "Find news based on a person's star sign",
    scan = true,
    beanName = "KotlinStarNewsFinder",
)
class TestStarNewsFinder(
    private val horoscopeService: TestHoroscopeService,
    @param:Value("\${star-news-finder.story.count:5}")
    private val storyCount: Int,
    @param:Value("\${star-news-finder.word.count:100}")
    private val wordCount: Int,
) {

    @Action
    fun extractPerson(
        userInput: UserInput,
        context: OperationContext,
    ): Person? =
        // All prompts are typesafe
        context.ai().withDefaultLlm().createObjectIfPossible(
            """
            Create a person from this user input, extracting their name:
            ${userInput.content}
            """.trimIndent()
        )

    /**
     * Collects astrological details for a person through a form interface.
     *
     * This method is marked with a high cost (100.0) to indicate that it should
     * only be used when no other path is available in the agent's planning process.
     * The high cost discourages the agent from asking for user input unless necessary.
     *
     * @param person The person for whom to collect star sign information
     * @return A Starry object containing the person's star sign
     */
    @Action(cost = 100.0) // Make it costly so it won't be used in a plan unless there's no other path
    internal fun makeStarry(
        person: Person,
    ): Starry =
        fromForm("Let's get some astrological details for ${person.name}")

    /**
     * Combines a person and their astrological details into a StarPerson object.
     *
     * This method serves as a data transformation step in the agent workflow,
     * creating a specialized person object that includes star sign information.
     *
     * @param person The basic person information
     * @param starry The astrological details
     * @return A StarPerson object combining both sets of information
     */
    @Action
    fun assembleStarPerson(
        person: Person,
        starry: Starry,
    ): StarPerson {
        return StarPerson(
            name = person.name,
            sign = starry.sign,
        )
    }

    /**
     * Extracts both person information and star sign directly from user input.
     *
     * This method provides an alternative entry point to the agent workflow,
     * allowing the extraction of both name and star sign in a single step when
     * that information is present in the user's input.
     *
     * @param userInput The user's text input
     * @return A StarPerson object if extraction is successful, null otherwise
     */
    @Action
    fun extractStarPerson(
        userInput: UserInput,
        context: OperationContext,
    ): StarPerson? =
        context.ai().withAutoLlm().createObjectIfPossible(
            """
            Create a person from this user input, extracting their name and star sign:
            ${userInput.content}
            """.trimIndent()
        )

    /**
     * Retrieves a daily horoscope for a person based on their star sign.
     *
     * This method calls the injected HoroscopeService to get the actual horoscope text,
     * wrapping it in a Horoscope data class for use in subsequent steps.
     *
     * @param starPerson The person with their star sign information
     * @return A Horoscope object containing the daily horoscope text
     */
    @Action
    fun retrieveHoroscope(starPerson: StarPerson) =
        Horoscope(horoscopeService.dailyHoroscope(starPerson.sign))

    /**
     * Finds news stories relevant to a person's horoscope using web search tools.
     *
     * This method requires web tools (specified by toolGroups) to search for and
     * summarize news stories that relate to themes in the person's horoscope.
     * It uses the LLM to interpret the horoscope, generate appropriate search
     * queries, and summarize the results.
     *
     * @param person The person with their star sign
     * @param horoscope The person's daily horoscope
     * @return A collection of relevant news stories with summaries and URLs
     */
    // toolGroups specifies tools that are required for this action to run
    @Action(toolGroups = [CoreToolGroups.WEB, CoreToolGroups.BROWSER_AUTOMATION])
    internal fun findNewsStories(
        person: StarPerson,
        horoscope: Horoscope,
        context: OperationContext,
    ): RelevantNewsStories =
        context.ai().withDefaultLlm() createObject (
                """
            ${person.name} is an astrology believer with the sign ${person.sign}.
            Their horoscope for today is:
                <horoscope>${horoscope.summary}</horoscope>
            Given this, use web tools and generate search queries
            to find $storyCount relevant news stories summarize them in a few sentences.
            Include the URL for each story.
            Do not look for another horoscope reading or return results directly about astrology;
            find stories relevant to the reading above.

            For example:
            - If the horoscope says that they may
            want to work on relationships, you could find news stories about
            novel gifts
            - If the horoscope says that they may want to work on their career,
            find news stories about training courses.
            """.trimIndent()
                )

    /**
     * Creates a personalized writeup combining the horoscope and relevant news stories.
     *
     * This method is the final step in the agent's workflow, marked with @AchievesGoal
     * to indicate that it fulfills the agent's primary purpose. It uses the LLM with
     * increased temperature (0.9) to generate creative content that combines the
     * horoscope interpretation with the found news stories in an amusing way.
     *
     * @param person The person with their star sign
     * @param relevantNewsStories The collection of news stories found
     * @param horoscope The person's daily horoscope
     * @return A Writeup containing the formatted text combining horoscope and news
     */
    // The @AchievesGoal annotation indicates that completing this action
    // achieves the given goal, so the agent flow can be complete
    @AchievesGoal(
        description = "Create an amusing writeup for the target person based on their horoscope and current news stories",
    )
    @Action
    fun starNewsWriteup(
        person: StarPerson,
        relevantNewsStories: RelevantNewsStories,
        horoscope: Horoscope,
        context: OperationContext,
    ): Writeup = context.ai().withLlm(
        LlmOptions(Auto).withTemperature(.9)
    ).createObject<Writeup>(
        """
        Take the following news stories and write up something
        amusing for the target person in $wordCount words.

        Begin by summarizing their horoscope in a concise, amusing way, then
        talk about the news. End with a surprising signoff.

        ${person.name} is an astrology believer with the sign ${person.sign}.
        Their horoscope for today is:
            <horoscope>${horoscope.summary}</horoscope>
        Relevant news stories are:
        ${relevantNewsStories.items.joinToString("\n") { "- ${it.url}: ${it.summary}" }}

        Format it as Markdown with links.
        """.trimIndent()
    )

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/example/simple/movie/InMemoryCrudRepository.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.example.simple.movie



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/plan/PlanTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.plan

import com.embabel.common.core.types.ZeroToOne
import com.embabel.common.util.indent
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Test

/**
 * Tests for the [Plan] class.
 *
 * The Plan class represents a sequence of actions to achieve a goal, with
 * associated metrics like cost and value. These tests verify:
 *
 * - Plan completion status detection
 * - Cost calculation as the sum of action costs
 * - Action value calculation as the sum of action values
 * - Net value calculation (goal value + action values - cost)
 * - Handling of negative costs and values
 * - String representation formatting in verbose and compact modes
 *
 * These tests ensure that plans correctly calculate their metrics
 * and provide appropriate string representations for logging and debugging.
 */
class PlanTest {

    // Simple implementation of Goal for testing
    private class TestGoal(
        override val name: String,
        override val value: Double = 0.0,
    ) : Goal {
        override fun infoString(
            verbose: Boolean?,
            indent: Int,
        ): String = "Goal($name, value=$value)".indent(indent)
    }

    // Simple implementation of Action for testing
    private class TestAction(
        override val name: String,
        override val cost: ZeroToOne = 0.0,
        override val value: ZeroToOne = 0.0,
    ) : Action {
        override fun infoString(
            verbose: Boolean?,
            indent: Int,
        ): String = name.indent(indent)
    }

    @Test
    fun `test plan isComplete detects empty action list`() {
        // Create plan with no actions
        val goal = TestGoal("TestGoal", 5.0)
        val emptyPlan = Plan(emptyList(), goal)

        // Complete when no actions
        assertTrue(emptyPlan.isComplete())

        // Not complete when there are actions
        val actionPlan = Plan(listOf(TestAction("Action1")), goal)
        assertFalse(actionPlan.isComplete())
    }

    @Test
    fun `test plan cost calculation`() {
        val goal = TestGoal("TestGoal")
        val actions = listOf(
            TestAction("Action1", cost = 2.5),
            TestAction("Action2", cost = 1.5),
            TestAction("Action3", cost = 3.0)
        )

        val plan = Plan(actions, goal)

        // Total cost should be sum of action costs
        assertEquals(7.0, plan.cost)
    }

    @Test
    fun `test plan actionsValue calculation`() {
        val goal = TestGoal("TestGoal")
        val actions = listOf(
            TestAction("Action1", value = 2.0),
            TestAction("Action2", value = 3.0),
            TestAction("Action3", value = 1.0)
        )

        val plan = Plan(actions, goal)

        // Total action value should be sum of action values
        assertEquals(6.0, plan.actionsValue)
    }

    @Test
    fun `test plan netValue calculation`() {
        val goal = TestGoal("TestGoal", value = 10.0)
        val actions = listOf(
            TestAction("Action1", cost = 2.0, value = 1.0),
            TestAction("Action2", cost = 3.0, value = 2.0)
        )

        val plan = Plan(actions, goal)

        // Net value = goal value + action values - cost
        // 10 + (1 + 2) - (2 + 3) = 8
        assertEquals(8.0, plan.netValue)
    }

    @Test
    fun `test plan handles negative values and costs`() {
        val goal = TestGoal("TestGoal", value = -5.0)
        val actions = listOf(
            TestAction("Action1", cost = -1.0, value = -2.0),
            TestAction("Action2", cost = 3.0, value = 1.0)
        )

        val plan = Plan(actions, goal)

        // Net value = goal value + action values - cost
        // -5 + (-2 + 1) - (-1 + 3) = -8
        assertEquals(-8.0, plan.netValue)
    }

    @Test
    fun `test plan verbose infoString formatting`() {
        val goal = TestGoal("TestGoal")
        val actions = listOf(
            TestAction("Action1"),
            TestAction("Action2"),
            TestAction("Action3")
        )

        val plan = Plan(actions, goal)

        val verboseInfo = plan.infoString(verbose = true, indent = 1)

        // Check format with indentation
        assertTrue(verboseInfo.contains("  ".repeat(1) + "Action1"))
        assertTrue(verboseInfo.contains("  ".repeat(2) + "Action2"))
        assertTrue(verboseInfo.contains("  ".repeat(3) + "Action3"))

        // Should contain cost and netValue
        assertTrue(verboseInfo.contains("cost:"))
        assertTrue(verboseInfo.contains("netValue:"))
    }

    @Test
    fun `test plan non-verbose infoString formatting`() {
        val goal = TestGoal("TestGoal")
        val actions = listOf(
            TestAction("Action1"),
            TestAction("Action2"),
            TestAction("Action3")
        )

        val plan = Plan(actions, goal)

        val info = plan.infoString(verbose = false)

        // Should contain action names with arrows
        assertTrue(info.contains("Action1 -> Action2 -> Action3"))

        // Should contain netValue but be more compact
        assertTrue(info.contains("netValue="))
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/plan/goap/AStarGoapPlannerTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.plan.goap

import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test

/**
 * Tests specifically for AStarGoapPlanner, focusing on action selection logic
 * when multiple valid actions are available.
 */
class AStarGoapPlannerTest {

    @Nested
    inner class `Action selection priority tests` {

        @Test
        fun `should prefer action with more preconditions when costs are equal`() {
            // Action with fewer preconditions
            val simpleAction = GoapAction(
                name = "simpleAction",
                preconditions = mapOf("start" to ConditionDetermination.TRUE),
                effects = mapOf("goal" to ConditionDetermination.TRUE),
                cost = 1.0
            )

            // Action with more preconditions (more specific)
            val specificAction = GoapAction(
                name = "specificAction",
                preconditions = mapOf(
                    "start" to ConditionDetermination.TRUE,
                    "condition1" to ConditionDetermination.TRUE,
                    "condition2" to ConditionDetermination.TRUE
                ),
                effects = mapOf("goal" to ConditionDetermination.TRUE),
                cost = 1.0 // Same cost as simpleAction
            )

            val goal = GoapGoal(
                name = "testGoal",
                preconditions = mapOf("goal" to ConditionDetermination.TRUE)
            )

            val planner = AStarGoapPlanner(
                WorldStateDeterminer.fromMap(
                    mapOf(
                        "start" to ConditionDetermination.TRUE,
                        "condition1" to ConditionDetermination.TRUE,
                        "condition2" to ConditionDetermination.TRUE,
                        "goal" to ConditionDetermination.FALSE
                    )
                )
            )

            val actions = listOf(simpleAction, specificAction)
            val plan = planner.planToGoal(actions, goal)

            assertNotNull(plan, "Should find a plan")
            assertEquals(1, plan!!.actions.size, "Should have exactly one action")
            assertEquals("specificAction", plan.actions[0].name,
                "Should prefer the action with more preconditions")
        }

        @Test
        fun `should prefer action with more preconditions even when it appears later in the list`() {
            // Create several actions with different numbers of preconditions but same cost/effect
            val action1 = GoapAction(
                name = "action1",
                preconditions = mapOf("start" to ConditionDetermination.TRUE),
                effects = mapOf("goal" to ConditionDetermination.TRUE),
                cost = 1.0
            )

            val action2 = GoapAction(
                name = "action2",
                preconditions = mapOf(
                    "start" to ConditionDetermination.TRUE,
                    "extra1" to ConditionDetermination.TRUE
                ),
                effects = mapOf("goal" to ConditionDetermination.TRUE),
                cost = 1.0
            )

            val action3 = GoapAction(
                name = "action3",
                preconditions = mapOf(
                    "start" to ConditionDetermination.TRUE,
                    "extra1" to ConditionDetermination.TRUE,
                    "extra2" to ConditionDetermination.TRUE,
                    "extra3" to ConditionDetermination.TRUE
                ),
                effects = mapOf("goal" to ConditionDetermination.TRUE),
                cost = 1.0
            )

            val goal = GoapGoal(
                name = "testGoal",
                preconditions = mapOf("goal" to ConditionDetermination.TRUE)
            )

            val planner = AStarGoapPlanner(
                WorldStateDeterminer.fromMap(
                    mapOf(
                        "start" to ConditionDetermination.TRUE,
                        "extra1" to ConditionDetermination.TRUE,
                        "extra2" to ConditionDetermination.TRUE,
                        "extra3" to ConditionDetermination.TRUE,
                        "goal" to ConditionDetermination.FALSE
                    )
                )
            )

            // Test with actions in different orders
            val actions1 = listOf(action1, action2, action3)
            val plan1 = planner.planToGoal(actions1, goal)

            val actions2 = listOf(action3, action1, action2)
            val plan2 = planner.planToGoal(actions2, goal)

            assertNotNull(plan1, "Should find a plan with first ordering")
            assertNotNull(plan2, "Should find a plan with second ordering")

            assertEquals("action3", plan1!!.actions[0].name,
                "Should prefer action3 with most preconditions (first ordering)")
            assertEquals("action3", plan2!!.actions[0].name,
                "Should prefer action3 with most preconditions (second ordering)")
        }

        @Test
        fun `should still choose lower cost action over higher cost action with more preconditions`() {
            // High cost action with many preconditions
            val expensiveSpecificAction = GoapAction(
                name = "expensiveSpecificAction",
                preconditions = mapOf(
                    "start" to ConditionDetermination.TRUE,
                    "condition1" to ConditionDetermination.TRUE,
                    "condition2" to ConditionDetermination.TRUE,
                    "condition3" to ConditionDetermination.TRUE
                ),
                effects = mapOf("goal" to ConditionDetermination.TRUE),
                cost = 5.0
            )

            // Low cost action with fewer preconditions
            val cheapSimpleAction = GoapAction(
                name = "cheapSimpleAction",
                preconditions = mapOf("start" to ConditionDetermination.TRUE),
                effects = mapOf("goal" to ConditionDetermination.TRUE),
                cost = 1.0
            )

            val goal = GoapGoal(
                name = "testGoal",
                preconditions = mapOf("goal" to ConditionDetermination.TRUE)
            )

            val planner = AStarGoapPlanner(
                WorldStateDeterminer.fromMap(
                    mapOf(
                        "start" to ConditionDetermination.TRUE,
                        "condition1" to ConditionDetermination.TRUE,
                        "condition2" to ConditionDetermination.TRUE,
                        "condition3" to ConditionDetermination.TRUE,
                        "goal" to ConditionDetermination.FALSE
                    )
                )
            )

            val actions = listOf(expensiveSpecificAction, cheapSimpleAction)
            val plan = planner.planToGoal(actions, goal)

            assertNotNull(plan, "Should find a plan")
            assertEquals(1, plan!!.actions.size, "Should have exactly one action")
            assertEquals("cheapSimpleAction", plan.actions[0].name,
                "Should prefer the lower cost action despite fewer preconditions")
        }

        @Test
        fun `should use precondition count as tie-breaker in multi-step plans`() {
            // First step: multiple ways to get to intermediate state
            val simpleStep1 = GoapAction(
                name = "simpleStep1",
                preconditions = mapOf("start" to ConditionDetermination.TRUE),
                effects = mapOf("intermediate" to ConditionDetermination.TRUE),
                cost = 1.0
            )

            val specificStep1 = GoapAction(
                name = "specificStep1",
                preconditions = mapOf(
                    "start" to ConditionDetermination.TRUE,
                    "extra" to ConditionDetermination.TRUE
                ),
                effects = mapOf("intermediate" to ConditionDetermination.TRUE),
                cost = 1.0
            )

            // Second step: same for both paths
            val step2 = GoapAction(
                name = "step2",
                preconditions = mapOf("intermediate" to ConditionDetermination.TRUE),
                effects = mapOf("goal" to ConditionDetermination.TRUE),
                cost = 1.0
            )

            val goal = GoapGoal(
                name = "testGoal",
                preconditions = mapOf("goal" to ConditionDetermination.TRUE)
            )

            val planner = AStarGoapPlanner(
                WorldStateDeterminer.fromMap(
                    mapOf(
                        "start" to ConditionDetermination.TRUE,
                        "extra" to ConditionDetermination.TRUE,
                        "intermediate" to ConditionDetermination.FALSE,
                        "goal" to ConditionDetermination.FALSE
                    )
                )
            )

            val actions = listOf(simpleStep1, specificStep1, step2)
            val plan = planner.planToGoal(actions, goal)

            assertNotNull(plan, "Should find a plan")
            assertEquals(2, plan!!.actions.size, "Should have exactly two actions")
            assertEquals("specificStep1", plan.actions[0].name,
                "Should prefer the more specific first step")
            assertEquals("step2", plan.actions[1].name,
                "Should include the second step")
        }
    }

    @Nested
    inner class `Action selection edge cases` {

        @Test
        fun `should handle actions with zero preconditions`() {
            val actionWithNoPreconditions = GoapAction(
                name = "noPreconditions",
                preconditions = emptyMap(),
                effects = mapOf("goal" to ConditionDetermination.TRUE),
                cost = 1.0
            )

            val actionWithOnePrecondition = GoapAction(
                name = "onePrecondition",
                preconditions = mapOf("start" to ConditionDetermination.TRUE),
                effects = mapOf("goal" to ConditionDetermination.TRUE),
                cost = 1.0
            )

            val goal = GoapGoal(
                name = "testGoal",
                preconditions = mapOf("goal" to ConditionDetermination.TRUE)
            )

            val planner = AStarGoapPlanner(
                WorldStateDeterminer.fromMap(
                    mapOf(
                        "start" to ConditionDetermination.TRUE,
                        "goal" to ConditionDetermination.FALSE
                    )
                )
            )

            val actions = listOf(actionWithNoPreconditions, actionWithOnePrecondition)
            val plan = planner.planToGoal(actions, goal)

            assertNotNull(plan, "Should find a plan")
            assertEquals(1, plan!!.actions.size, "Should have exactly one action")
            assertEquals("onePrecondition", plan.actions[0].name,
                "Should prefer action with preconditions over action with none")
        }

        @Test
        fun `should handle identical actions with same precondition count`() {
            val action1 = GoapAction(
                name = "action1",
                preconditions = mapOf(
                    "start" to ConditionDetermination.TRUE,
                    "condition1" to ConditionDetermination.TRUE
                ),
                effects = mapOf("goal" to ConditionDetermination.TRUE),
                cost = 1.0
            )

            val action2 = GoapAction(
                name = "action2",
                preconditions = mapOf(
                    "start" to ConditionDetermination.TRUE,
                    "condition2" to ConditionDetermination.TRUE
                ),
                effects = mapOf("goal" to ConditionDetermination.TRUE),
                cost = 1.0
            )

            val goal = GoapGoal(
                name = "testGoal",
                preconditions = mapOf("goal" to ConditionDetermination.TRUE)
            )

            val planner = AStarGoapPlanner(
                WorldStateDeterminer.fromMap(
                    mapOf(
                        "start" to ConditionDetermination.TRUE,
                        "condition1" to ConditionDetermination.TRUE,
                        "condition2" to ConditionDetermination.TRUE,
                        "goal" to ConditionDetermination.FALSE
                    )
                )
            )

            val actions = listOf(action1, action2)
            val plan = planner.planToGoal(actions, goal)

            assertNotNull(plan, "Should find a plan")
            assertEquals(1, plan!!.actions.size, "Should have exactly one action")
            // Either action is acceptable since they have the same precondition count
            assertTrue(plan.actions[0].name in listOf("action1", "action2"),
                "Should choose one of the actions with equal precondition counts")
        }
    }

    @Nested
    inner class `Unreachable goal optimization` {

        @Test
        fun `should quickly return null for unreachable goal with no action producing required effect`() {
            val action = GoapAction(
                name = "irrelevantAction",
                preconditions = mapOf("start" to ConditionDetermination.TRUE),
                effects = mapOf("irrelevant" to ConditionDetermination.TRUE),
                cost = 1.0
            )

            val goal = GoapGoal(
                name = "unreachableGoal",
                preconditions = mapOf("impossibleCondition" to ConditionDetermination.TRUE)
            )

            val planner = AStarGoapPlanner(
                WorldStateDeterminer.fromMap(
                    mapOf(
                        "start" to ConditionDetermination.TRUE,
                        "impossibleCondition" to ConditionDetermination.FALSE
                    )
                )
            )

            val startTime = System.currentTimeMillis()
            val plan = planner.planToGoal(listOf(action), goal)
            val elapsedTime = System.currentTimeMillis() - startTime

            assertNull(plan, "Should return null for unreachable goal")
            assertTrue(elapsedTime < 100, "Should detect unreachability quickly (took ${elapsedTime}ms)")
        }

        @Test
        fun `should quickly return null for goal requiring unavailable precondition chain`() {
            // Actions that don't create the chain needed for the goal
            val action1 = GoapAction(
                name = "action1",
                preconditions = mapOf("start" to ConditionDetermination.TRUE),
                effects = mapOf("conditionA" to ConditionDetermination.TRUE),
                cost = 1.0
            )

            val action2 = GoapAction(
                name = "action2",
                preconditions = mapOf("conditionB" to ConditionDetermination.TRUE),
                effects = mapOf("conditionC" to ConditionDetermination.TRUE),
                cost = 1.0
            )

            // Goal requires conditionC, but there's no way to get conditionB
            val goal = GoapGoal(
                name = "unreachableGoal",
                preconditions = mapOf("conditionC" to ConditionDetermination.TRUE)
            )

            val planner = AStarGoapPlanner(
                WorldStateDeterminer.fromMap(
                    mapOf(
                        "start" to ConditionDetermination.TRUE,
                        "conditionA" to ConditionDetermination.FALSE,
                        "conditionB" to ConditionDetermination.FALSE,
                        "conditionC" to ConditionDetermination.FALSE
                    )
                )
            )

            val startTime = System.currentTimeMillis()
            val plan = planner.planToGoal(listOf(action1, action2), goal)
            val elapsedTime = System.currentTimeMillis() - startTime

            assertNull(plan, "Should return null for unreachable goal")
            assertTrue(elapsedTime < 100, "Should detect unreachability quickly (took ${elapsedTime}ms)")
        }

        @Test
        fun `should still find plans for reachable goals`() {
            val action1 = GoapAction(
                name = "action1",
                preconditions = mapOf("start" to ConditionDetermination.TRUE),
                effects = mapOf("intermediate" to ConditionDetermination.TRUE),
                cost = 1.0
            )

            val action2 = GoapAction(
                name = "action2",
                preconditions = mapOf("intermediate" to ConditionDetermination.TRUE),
                effects = mapOf("goal" to ConditionDetermination.TRUE),
                cost = 1.0
            )

            val goal = GoapGoal(
                name = "reachableGoal",
                preconditions = mapOf("goal" to ConditionDetermination.TRUE)
            )

            val planner = AStarGoapPlanner(
                WorldStateDeterminer.fromMap(
                    mapOf(
                        "start" to ConditionDetermination.TRUE,
                        "intermediate" to ConditionDetermination.FALSE,
                        "goal" to ConditionDetermination.FALSE
                    )
                )
            )

            val plan = planner.planToGoal(listOf(action1, action2), goal)

            assertNotNull(plan, "Should find a plan for reachable goal")
            assertEquals(2, plan!!.actions.size)
        }

        @Test
        fun `should return empty plan when goal already satisfied`() {
            val action = GoapAction(
                name = "unnecessaryAction",
                preconditions = mapOf("start" to ConditionDetermination.TRUE),
                effects = mapOf("goal" to ConditionDetermination.TRUE),
                cost = 1.0
            )

            val goal = GoapGoal(
                name = "alreadySatisfied",
                preconditions = mapOf("goal" to ConditionDetermination.TRUE)
            )

            val planner = AStarGoapPlanner(
                WorldStateDeterminer.fromMap(
                    mapOf(
                        "start" to ConditionDetermination.TRUE,
                        "goal" to ConditionDetermination.TRUE
                    )
                )
            )

            val plan = planner.planToGoal(listOf(action), goal)

            assertNotNull(plan, "Should return a plan when goal is already satisfied")
            assertEquals(0, plan!!.actions.size, "Plan should be empty when goal already satisfied")
        }
    }

    @Nested
    inner class `Integration with existing optimization` {

        @Test
        fun `should maintain optimization behavior while preferring more conditions`() {
            // Setup a scenario where optimization and condition preference both matter
            val unnecessaryAction = GoapAction(
                name = "unnecessary",
                preconditions = mapOf("start" to ConditionDetermination.TRUE),
                effects = mapOf("irrelevant" to ConditionDetermination.TRUE),
                cost = 1.0
            )

            val simpleGoalAction = GoapAction(
                name = "simpleGoal",
                preconditions = mapOf("start" to ConditionDetermination.TRUE),
                effects = mapOf("goal" to ConditionDetermination.TRUE),
                cost = 1.0
            )

            val specificGoalAction = GoapAction(
                name = "specificGoal",
                preconditions = mapOf(
                    "start" to ConditionDetermination.TRUE,
                    "specific" to ConditionDetermination.TRUE
                ),
                effects = mapOf("goal" to ConditionDetermination.TRUE),
                cost = 1.0
            )

            val goal = GoapGoal(
                name = "testGoal",
                preconditions = mapOf("goal" to ConditionDetermination.TRUE)
            )

            val planner = AStarGoapPlanner(
                WorldStateDeterminer.fromMap(
                    mapOf(
                        "start" to ConditionDetermination.TRUE,
                        "specific" to ConditionDetermination.TRUE,
                        "goal" to ConditionDetermination.FALSE,
                        "irrelevant" to ConditionDetermination.FALSE
                    )
                )
            )

            val actions = listOf(unnecessaryAction, simpleGoalAction, specificGoalAction)
            val plan = planner.planToGoal(actions, goal)

            assertNotNull(plan, "Should find a plan")
            assertEquals(1, plan!!.actions.size, "Should optimize away unnecessary actions")
            assertEquals("specificGoal", plan.actions[0].name,
                "Should prefer specific action that achieves goal")
            assertFalse(plan.actions.any { it.name == "unnecessary" },
                "Should not include unnecessary action")
        }
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/plan/goap/GoapPlannerTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.plan.goap

import com.embabel.common.util.time
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import java.util.*

object EmptyWorldStateDeterminer : WorldStateDeterminer {
    override fun determineWorldState(): GoapWorldState {
        return GoapWorldState()
    }

    override fun determineCondition(condition: String): ConditionDetermination =
        ConditionDetermination.UNKNOWN
}

class GoapPlannerTest {

    @Nested
    inner class Crime {

        val cookDrugs = GoapAction(
            name = "Cook drugs",
            preconditions = emptyMap(),
            effects = mapOf("hasDrugs" to ConditionDetermination(true), "legalPeril" to ConditionDetermination(true)),
            cost = 1.20
        )

        val sellDrugs = GoapAction(
            name = "Sell drugs",
            preconditions = mapOf("hasDrugs" to ConditionDetermination(true)),
            effects = mapOf(
                "hasDrugs" to ConditionDetermination(false),
                "hasMoney" to ConditionDetermination(true),
                "legalPeril" to ConditionDetermination(true)
            ),
            cost = 1.20,
        )

        val buyGun = GoapAction(
            name = "Buy gun",
            preconditions = mapOf("hasMoney" to ConditionDetermination(true)),
            effects = mapOf("hasGun" to ConditionDetermination(true), "hasMoney" to ConditionDetermination(false)),
            cost = 1.0,
        )

        val bribeCop = GoapAction(
            name = "Bribe cop",
            preconditions = mapOf("hasMoney" to ConditionDetermination(true)),
            effects = mapOf("legalPeril" to ConditionDetermination(false), "hasMoney" to ConditionDetermination(false)),
            cost = 2.0,
        )

        val shootEnemy = GoapAction(
            name = "Shoot enemy",
            preconditions = mapOf("hasGun" to ConditionDetermination(true)),
            effects = mapOf("enemyDead" to ConditionDetermination(true), "legalPeril" to ConditionDetermination(true)),
            cost = 1.0,
        )

        val buyPoison = GoapAction(
            name = "Buy poison",
            preconditions = mapOf("hasMoney" to ConditionDetermination(true)),
            effects = mapOf("hasPoison" to ConditionDetermination(true), "hasMoney" to ConditionDetermination(false)),
            cost = 3.0,
        )

        val poisonEnemy = GoapAction(
            name = "Poison enemy",
            preconditions = mapOf("hasPoison" to ConditionDetermination(true)),
            effects = mapOf("enemyDead" to ConditionDetermination(true), "legalPeril" to ConditionDetermination(true)),
            cost = 1.0
        )

        val getAwayWithMurderGoal =
            GoapGoal(
                name = "getAwayWithMurder",
                preconditions = mapOf(
                    "enemyDead" to ConditionDetermination(true),
                    "legalPeril" to ConditionDetermination(false)
                ),
                value = 10.0,
            )

        val actions = setOf(
            cookDrugs,
            buyGun,
            shootEnemy,
            bribeCop,
            sellDrugs,
            buyPoison,
            poisonEnemy,
        )

        val bestPlanActions =
            listOf("Cook drugs", "Sell drugs", "Buy gun", "Cook drugs", "Shoot enemy", "Sell drugs", "Bribe cop")


        @Test
        fun `single plan`() {
            val planner = AStarGoapPlanner(EmptyWorldStateDeterminer)
            val plan = planner.planToGoal(actions, getAwayWithMurderGoal)
            assertTrue(plan != null)
            assertEquals(
                bestPlanActions,
                plan!!.actions.map { it.name })
        }

        @Test
        fun `should find 2 plans`() {
            val planner = AStarGoapPlanner(EmptyWorldStateDeterminer)
            val hasGunGoal = GoapGoal("hasGun", value = 1.0)
            val goapSystem = GoapPlanningSystem(actions, setOf(getAwayWithMurderGoal, hasGunGoal))
            val plans = planner.plansToGoals(goapSystem)
            assertEquals(plans.size, 2)
            val best = plans.first()
            assertEquals(
                bestPlanActions,
                best.actions.map { it.name })
            assertTrue(best.netValue > 0.0)
            assertTrue(best.cost > 0.0)
        }

        @Test
        fun `best plan to any goal`() {
            val planner = AStarGoapPlanner(EmptyWorldStateDeterminer)
            val hasGunGoal = GoapGoal(name = "hasGun", value = 1.0)
            val goapSystem = GoapPlanningSystem(actions, setOf(getAwayWithMurderGoal, hasGunGoal))
            val plan = planner.bestValuePlanToAnyGoal(goapSystem)
            assertNotNull(plan)
            assertEquals(
                bestPlanActions,
                plan!!.actions.map { it.name })
        }

        @Test
        fun `find path from unknown`() {
            val touchyWorldStateDeterminer = object : WorldStateDeterminer {
                override fun determineWorldState(): GoapWorldState {
                    return GoapWorldState(
                        state = mapOf(
                            "hasMoney" to ConditionDetermination(true),
                            "enemyDead" to ConditionDetermination.UNKNOWN,
                        )
                    )
                }

                override fun determineCondition(condition: String): ConditionDetermination =
                    ConditionDetermination.UNKNOWN
            }
            val planner = AStarGoapPlanner(touchyWorldStateDeterminer)
            val plan = planner.planToGoal(actions, getAwayWithMurderGoal)
            assertTrue(
                plan!!.actions.map { it.name }.containsAll(bestPlanActions.drop(2))
            )
        }

        @Test
        fun `find path, force evaluating unknown`() {
            // We are going to have to ask for enemyDead to be evaluated
            // Will find that the goal has been achieved if we force evaluate that condition
            val forceEvaluated = mutableListOf<String>()
            val touchyWorldStateDeterminer = object : WorldStateDeterminer {

                override fun determineWorldState(): GoapWorldState {
                    return GoapWorldState(
                        state = mapOf(
                            "legalPeril" to ConditionDetermination.FALSE,
                            "enemyDead" to ConditionDetermination.UNKNOWN,
                        )
                    )
                }

                override fun determineCondition(condition: String): ConditionDetermination {
                    assertEquals(condition, "enemyDead")
                    forceEvaluated += condition
                    return ConditionDetermination.TRUE
                }
            }
            val planner = AStarGoapPlanner(touchyWorldStateDeterminer)
            val plan = planner.planToGoal(
                actions,
                getAwayWithMurderGoal
            )
            assertNotNull(plan)
            assertEquals(0, plan!!.actions.size)
            assertTrue(forceEvaluated.contains("enemyDead"), "Should have force evaluated enemy dead")
        }

        private fun generateRandomActions(num: Int): List<GoapAction> {
            val random = Random()
            return List(num) {
                GoapAction(
                    name = random.nextInt().toString(),
                    preconditions = mapOf(
                        "hasGun" to ConditionDetermination(true),
                        "hasPoison" to ConditionDetermination(false),
                        UUID.randomUUID().toString() to ConditionDetermination(true)
                    ),
                    effects = mapOf(
                        "hasPoison" to ConditionDetermination(true),
                        UUID.randomUUID().toString() to ConditionDetermination(true),
                        UUID.randomUUID().toString() to ConditionDetermination(false)
                    ),
                    cost = 3.0,
                )
            }
        }

        @Test
        fun `scalability testing`() {
            val planner = AStarGoapPlanner(EmptyWorldStateDeterminer)
            val paddedActions = actions + generateRandomActions(300)
            val (plan, ms) = time {
                planner.planToGoal(paddedActions, getAwayWithMurderGoal)
            }
            assertTrue(plan != null)
        }
    }

}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/plan/goap/GoapPlanningSystemTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.plan.goap

import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Test

/**
 * Tests for the [GoapPlanningSystem] class.
 *
 * The GoapPlanningSystem collects and manages a set of actions and goals for
 * goal-oriented action planning. These tests verify:
 *
 * - Collection of unique preconditions from all actions
 * - Collection of unique effects from all actions
 * - Determination of all conditions (union of preconditions and effects)
 * - System construction with multiple goals or a single goal
 * - Formatting of system information for display
 *
 * These tests ensure the planning system correctly tracks and manages
 * the conditions needed for planning with GOAP algorithms.
 */
class GoapPlanningSystemTest {

    @Test
    fun `test knownPreconditions returns all unique preconditions`() {
        // Create actions with various preconditions
        val action1 = GoapAction("Action1",
            preconditions = mapOf("cond1" to ConditionDetermination.TRUE, "cond2" to ConditionDetermination.FALSE))

        val action2 = GoapAction("Action2",
            preconditions = mapOf("cond2" to ConditionDetermination.TRUE, "cond3" to ConditionDetermination.UNKNOWN))

        val system = GoapPlanningSystem(setOf(action1, action2), GoapGoal("Goal1"))

        // Verify
        val preconditions = system.knownPreconditions()
        assertEquals(3, preconditions.size)
        assertTrue(preconditions.containsAll(listOf("cond1", "cond2", "cond3")))
    }

    @Test
    fun `test knownEffects returns all unique effects`() {
        // Create actions with various effects
        val action1 = GoapAction("Action1",
            effects = mapOf("effect1" to ConditionDetermination.TRUE, "effect2" to ConditionDetermination.FALSE))

        val action2 = GoapAction("Action2",
            effects = mapOf("effect2" to ConditionDetermination.TRUE, "effect3" to ConditionDetermination.UNKNOWN))

        val system = GoapPlanningSystem(setOf(action1, action2), GoapGoal("Goal1"))

        // Verify
        val effects = system.knownEffects()
        assertEquals(3, effects.size)
        assertTrue(effects.containsAll(listOf("effect1", "effect2", "effect3")))
    }

    @Test
    fun `test knownConditions returns union of preconditions and effects`() {
        // Create actions with preconditions and effects
        val action1 = GoapAction("Action1",
            preconditions = mapOf("cond1" to ConditionDetermination.TRUE),
            effects = mapOf("effect1" to ConditionDetermination.TRUE))

        val action2 = GoapAction("Action2",
            preconditions = mapOf("cond2" to ConditionDetermination.TRUE),
            effects = mapOf("effect2" to ConditionDetermination.TRUE))

        val system = GoapPlanningSystem(setOf(action1, action2), GoapGoal("Goal1"))

        // Verify
        val conditions = system.knownConditions()
        assertEquals(4, conditions.size)
        assertTrue(conditions.containsAll(listOf("cond1", "cond2", "effect1", "effect2")))
    }

    @Test
    fun `test GoapPlanningSystem construction with multiple goals`() {
        val goal1 = GoapGoal("Goal1")
        val goal2 = GoapGoal("Goal2")

        val system = GoapPlanningSystem(emptySet(), setOf(goal1, goal2))

        assertEquals(2, system.goals.size)
        assertTrue(system.goals.containsAll(listOf(goal1, goal2)))
    }

    @Test
    fun `test GoapPlanningSystem infoString contains all key information`() {
        val action = GoapAction("Action1",
            preconditions = mapOf("cond1" to ConditionDetermination.TRUE),
            effects = mapOf("effect1" to ConditionDetermination.TRUE))

        val goal = GoapGoal("Goal1")

        val system = GoapPlanningSystem(setOf(action), setOf(goal))

        val info = system.infoString()
        assertTrue(info.contains("Action1"))
        assertTrue(info.contains("Goal1"))
        assertTrue(info.contains("knownPreconditions"))
        assertTrue(info.contains("knownEffects"))
    }

    @Test
    fun `test GoapPlanningSystem constructor from collection of actions and single goal`() {
        val action1 = GoapAction("Action1")
        val action2 = GoapAction("Action2")
        val goal = GoapGoal("Goal1")

        val system = GoapPlanningSystem(
            actions = listOf(action1, action2),
            goal = goal
        )

        assertEquals(2, system.actions.size)
        assertEquals(1, system.goals.size)
        assertTrue(system.actions.containsAll(listOf(action1, action2)))
        assertTrue(system.goals.contains(goal))
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/plan/goap/IrrelevantActionsTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.plan.goap

import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*

class IrrelevantActionsTest {
    @Nested
    inner class `Planner confusion and distraction tests` {
        @Test
        fun `should fail if planner gets distracted by chain of irrelevant actions`() {
            val chainLength = 5
            val realChain = (1..chainLength).map { i ->
                val prev = if (i == 1) "start" else "step${i-1}"
                val next = "step$i"
                GoapAction(
                    name = "realAction$i",
                    preconditions = mapOf(prev to ConditionDetermination.TRUE),
                    effects = mapOf(next to ConditionDetermination.TRUE)
                )
            }
            val goal = GoapGoal(
                name = "testGoal",
                pre = listOf("step$chainLength")
            )
            val irrelevantChain = (1..10).map { i ->
                GoapAction(
                    name = "irrelevantChain$i",
                    preconditions = mapOf("noise${i-1}" to ConditionDetermination.TRUE),
                    effects = mapOf("noise$i" to ConditionDetermination.TRUE)
                )
            }
            val worldStateMap = mutableMapOf<String, ConditionDetermination>()
            worldStateMap["start"] = ConditionDetermination.TRUE
            (1..chainLength).forEach { i -> worldStateMap["step$i"] = ConditionDetermination.FALSE }
            (0..10).forEach { i -> worldStateMap["noise$i"] = ConditionDetermination.TRUE }
            val planner = AStarGoapPlanner(WorldStateDeterminer.fromMap(worldStateMap))
            val allActions = realChain + irrelevantChain
            val plan = planner.planToGoal(allActions, goal)
            assertNotNull(plan, "Should find a plan despite irrelevant chains")
            assertEquals(chainLength, plan!!.actions.size, "Should only use the real chain actions")
            (1..chainLength).forEach { i ->
                assertEquals("realAction$i", plan.actions[i-1].name)
            }
        }

        @Test
        fun `should fail if planner includes actions that undo progress`() {
            val actionA = GoapAction(
                name = "setA",
                preconditions = mapOf("start" to ConditionDetermination.TRUE),
                effects = mapOf("A" to ConditionDetermination.TRUE)
            )
            val actionB = GoapAction(
                name = "unsetA",
                preconditions = mapOf("A" to ConditionDetermination.TRUE),
                effects = mapOf("A" to ConditionDetermination.FALSE)
            )
            val actionGoal = GoapAction(
                name = "reachGoal",
                preconditions = mapOf("A" to ConditionDetermination.TRUE),
                effects = mapOf("goal" to ConditionDetermination.TRUE)
            )
            val goal = GoapGoal(
                name = "goal",
                pre = listOf("goal")
            )
            val worldState = WorldStateDeterminer.fromMap(mapOf("start" to ConditionDetermination.TRUE, "A" to ConditionDetermination.FALSE, "goal" to ConditionDetermination.FALSE))
            val planner = AStarGoapPlanner(worldState)
            val plan = planner.planToGoal(listOf(actionA, actionB, actionGoal), goal)
            assertNotNull(plan, "Should find a plan")
            // Should not undo progress by including unsetA
            assertFalse(plan!!.actions.any { it.name == "unsetA" }, "Plan should not include actions that undo required conditions")
        }

        @Test
        fun `should fail if planner takes a detour through irrelevant misleading actions`() {
            val actionA = GoapAction(
                name = "setA",
                preconditions = mapOf("start" to ConditionDetermination.TRUE),
                effects = mapOf("A" to ConditionDetermination.TRUE)
            )
            val misleading = GoapAction(
                name = "misleadA",
                preconditions = mapOf("start" to ConditionDetermination.TRUE),
                effects = mapOf("A" to ConditionDetermination.TRUE, "foo" to ConditionDetermination.TRUE)
            )
            val actionGoal = GoapAction(
                name = "reachGoal",
                preconditions = mapOf("A" to ConditionDetermination.TRUE),
                effects = mapOf("goal" to ConditionDetermination.TRUE)
            )
            val goal = GoapGoal(
                name = "goal",
                pre = listOf("goal")
            )
            val worldState = WorldStateDeterminer.fromMap(mapOf("start" to ConditionDetermination.TRUE, "A" to ConditionDetermination.FALSE, "goal" to ConditionDetermination.FALSE, "foo" to ConditionDetermination.FALSE))
            val planner = AStarGoapPlanner(worldState)
            val plan = planner.planToGoal(listOf(actionA, misleading, actionGoal), goal)
            assertNotNull(plan)
            // Accept either minimal plan (setA, reachGoal) or (misleadA, reachGoal), but not both
            assertTrue(
                plan!!.actions.map { it.name } == listOf("setA", "reachGoal") ||
                plan.actions.map { it.name } == listOf("misleadA", "reachGoal")
            )
        }
    }
    // --- EXTENDED TESTS TO BREAK THE PLANNER FURTHER ---
    @Nested
    inner class `Additional confusion-breaking tests` {
        @Test
        fun `should fail if planner is tricked by actions with irrelevant side effects`() {
            val actionA = GoapAction(
                name = "setA",
                preconditions = mapOf("start" to ConditionDetermination.TRUE),
                effects = mapOf("A" to ConditionDetermination.TRUE, "sideNoise" to ConditionDetermination.TRUE)
            )
            val actionGoal = GoapAction(
                name = "reachGoal",
                preconditions = mapOf("A" to ConditionDetermination.TRUE),
                effects = mapOf("goal" to ConditionDetermination.TRUE)
            )
            val irrelevant = GoapAction(
                name = "irrelevantNoise",
                preconditions = mapOf("sideNoise" to ConditionDetermination.TRUE),
                effects = mapOf("moreNoise" to ConditionDetermination.TRUE)
            )
            val goal = GoapGoal(
                name = "goal",
                pre = listOf("goal")
            )
            val worldState = WorldStateDeterminer.fromMap(mapOf("start" to ConditionDetermination.TRUE, "A" to ConditionDetermination.FALSE, "goal" to ConditionDetermination.FALSE, "sideNoise" to ConditionDetermination.FALSE, "moreNoise" to ConditionDetermination.FALSE))
            val planner = AStarGoapPlanner(worldState)
            val plan = planner.planToGoal(listOf(actionA, actionGoal, irrelevant), goal)
            assertNotNull(plan)
            assertFalse(plan!!.actions.any { it.name == "irrelevantNoise" }, "Plan should not include irrelevant side-effect actions")
        }
        @Test
        fun `should fail if planner is confused by multiple irrelevant chains`() {
            val chainLength = 3
            val realChain = (1..chainLength).map { i ->
                val prev = if (i == 1) "start" else "step${i-1}"
                val next = "step$i"
                GoapAction(
                    name = "realAction$i",
                    preconditions = mapOf(prev to ConditionDetermination.TRUE),
                    effects = mapOf(next to ConditionDetermination.TRUE)
                )
            }
            val goal = GoapGoal(
                name = "goal",
                pre = listOf("step$chainLength")
            )
            val irrelevantChains = (1..3).flatMap { chainNum ->
                (1..5).map { i ->
                    GoapAction(
                        name = "irrelevantChain${chainNum}_$i",
                        preconditions = mapOf("noise${chainNum}_${i-1}" to ConditionDetermination.TRUE),
                        effects = mapOf("noise${chainNum}_$i" to ConditionDetermination.TRUE)
                    )
                }
            }
            val worldStateMap = mutableMapOf<String, ConditionDetermination>()
            worldStateMap["start"] = ConditionDetermination.TRUE
            (1..chainLength).forEach { i -> worldStateMap["step$i"] = ConditionDetermination.FALSE }
            (1..3).forEach { chainNum ->
                (0..5).forEach { i -> worldStateMap["noise${chainNum}_$i"] = ConditionDetermination.TRUE }
            }
            val planner = AStarGoapPlanner(WorldStateDeterminer.fromMap(worldStateMap))
            val allActions = realChain + irrelevantChains
            val plan = planner.planToGoal(allActions, goal)
            assertNotNull(plan, "Should find a plan despite multiple irrelevant chains")
            assertEquals(chainLength, plan!!.actions.size, "Should only use the real chain actions")
            (1..chainLength).forEach { i ->
                assertEquals("realAction$i", plan.actions[i-1].name)
            }
        }
    }

    @Nested
    inner class `More devious planner-breaking tests` {
        @Test
        fun `should fail if planner loops between undo and redo actions`() {
            val setA = GoapAction(
                name = "setA",
                preconditions = mapOf("start" to ConditionDetermination.TRUE),
                effects = mapOf("A" to ConditionDetermination.TRUE)
            )
            val unsetA = GoapAction(
                name = "unsetA",
                preconditions = mapOf("A" to ConditionDetermination.TRUE),
                effects = mapOf("A" to ConditionDetermination.FALSE)
            )
            val setAagain = GoapAction(
                name = "setAagain",
                preconditions = mapOf("A" to ConditionDetermination.FALSE),
                effects = mapOf("A" to ConditionDetermination.TRUE)
            )
            val reachGoal = GoapAction(
                name = "reachGoal",
                preconditions = mapOf("A" to ConditionDetermination.TRUE),
                effects = mapOf("goal" to ConditionDetermination.TRUE)
            )
            val goal = GoapGoal(
                name = "goal",
                pre = listOf("goal")
            )
            val worldState = WorldStateDeterminer.fromMap(
                mapOf(
                    "start" to ConditionDetermination.TRUE,
                    "A" to ConditionDetermination.FALSE,
                    "goal" to ConditionDetermination.FALSE
                )
            )
            val planner = AStarGoapPlanner(worldState)
            val plan = planner.planToGoal(listOf(setA, unsetA, setAagain, reachGoal), goal)
            assertNotNull(plan, "Should find a plan")
            // Should not loop between setA/unsetA/setAagain unnecessarily
            val actionNames = plan!!.actions.map { it.name }
            assertFalse(actionNames.windowed(2).any { it == listOf("setA", "unsetA") || it == listOf("unsetA", "setAagain") },
                "Plan should not bounce between undo and redo actions")
            assertTrue(
                actionNames == listOf("setA", "reachGoal") ||
                actionNames == listOf("setAagain", "reachGoal"),
                "Plan should be minimal and direct"
            )
        }

        @Test
        fun `should fail if planner is distracted by actions with only irrelevant net effect`() {
            val setA = GoapAction(
                name = "setA",
                preconditions = mapOf("start" to ConditionDetermination.TRUE),
                effects = mapOf("A" to ConditionDetermination.TRUE)
            )
            val distract = GoapAction(
                name = "distract",
                preconditions = mapOf("start" to ConditionDetermination.TRUE),
                effects = mapOf("noise" to ConditionDetermination.TRUE)
            )
            val undoNoise = GoapAction(
                name = "undoNoise",
                preconditions = mapOf("noise" to ConditionDetermination.TRUE),
                effects = mapOf("noise" to ConditionDetermination.FALSE)
            )
            val reachGoal = GoapAction(
                name = "reachGoal",
                preconditions = mapOf("A" to ConditionDetermination.TRUE),
                effects = mapOf("goal" to ConditionDetermination.TRUE)
            )
            val goal = GoapGoal(
                name = "goal",
                pre = listOf("goal")
            )
            val worldState = WorldStateDeterminer.fromMap(
                mapOf(
                    "start" to ConditionDetermination.TRUE,
                    "A" to ConditionDetermination.FALSE,
                    "goal" to ConditionDetermination.FALSE,
                    "noise" to ConditionDetermination.FALSE
                )
            )
            val planner = AStarGoapPlanner(worldState)
            val plan = planner.planToGoal(listOf(setA, distract, undoNoise, reachGoal), goal)
            assertNotNull(plan, "Should find a plan")
            val names = plan!!.actions.map { it.name }
            assertFalse(names.contains("distract"), "Plan should not include irrelevant distract action")
            assertFalse(names.contains("undoNoise"), "Plan should not include undoNoise action")
            assertTrue(names == listOf("setA", "reachGoal"), "Plan should be minimal and direct")
        }
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/plan/goap/OptimizingGoapPlannerTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.plan.goap

import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test

/**
 * Tests specifically designed to challenge the OptimizingGoapPlanner with complex scenarios
 * that might break its planning capabilities.
 */
class OptimizingGoapPlannerTest {

    @Nested
    inner class `Cyclic dependency tests` {

        @Test
        fun `should detect and avoid cyclic dependencies in actions`() {
            // Create actions with a potential cycle
            val action1 = GoapAction(
                name = "action1",
                preconditions = mapOf("conditionA" to ConditionDetermination.FALSE),
                effects = mapOf("conditionB" to ConditionDetermination.TRUE)
            )

            val action2 = GoapAction(
                name = "action2",
                preconditions = mapOf("conditionB" to ConditionDetermination.TRUE),
                effects = mapOf("conditionC" to ConditionDetermination.TRUE)
            )

            val action3 = GoapAction(
                name = "action3",
                preconditions = mapOf("conditionC" to ConditionDetermination.TRUE),
                effects = mapOf("conditionA" to ConditionDetermination.TRUE)
            )

            // This action creates a potential infinite loop because it undoes what action1 does
            val cycleAction = GoapAction(
                name = "cycleAction",
                preconditions = mapOf("conditionB" to ConditionDetermination.TRUE),
                effects = mapOf("conditionB" to ConditionDetermination.FALSE)
            )

            val goal = GoapGoal(
                name = "testGoal",
                pre = listOf("conditionC")
            )

            val planner = AStarGoapPlanner(
                WorldStateDeterminer.fromMap(
                    mapOf(
                        "conditionA" to ConditionDetermination.FALSE,
                        "conditionB" to ConditionDetermination.FALSE,
                        "conditionC" to ConditionDetermination.FALSE
                    )
                )
            )

            val actions: List<GoapAction> = listOf(action1, action2, action3, cycleAction)
            val plan = planner.planToGoal(actions, goal)

            assertNotNull(plan, "Should find a plan despite potential cycles")
            assertFalse(plan!!.actions.contains(cycleAction), "Plan should not include the cycle-creating action")
            assertEquals(listOf("action1", "action2"), plan.actions.map { it.name })
        }
    }

    @Nested
    inner class `Action cost optimization tests` {

        @Test
        fun `should choose lower cost path when multiple paths exist`() {
            // Path 1: A -> B -> C (total cost 3)
            val actionA1 = GoapAction(
                name = "actionA1",
                preconditions = mapOf("start" to ConditionDetermination.TRUE),
                effects = mapOf("stepB" to ConditionDetermination.TRUE),
                cost = 1.0
            )

            val actionB1 = GoapAction(
                name = "actionB1",
                preconditions = mapOf("stepB" to ConditionDetermination.TRUE),
                effects = mapOf("goal" to ConditionDetermination.TRUE),
                cost = 2.0
            )

            // Path 2: X -> Y -> Z (total cost 5)
            val actionX2 = GoapAction(
                name = "actionX2",
                preconditions = mapOf("start" to ConditionDetermination.TRUE),
                effects = mapOf("stepY" to ConditionDetermination.TRUE),
                cost = 2.0
            )

            val actionY2 = GoapAction(
                name = "actionY2",
                preconditions = mapOf("stepY" to ConditionDetermination.TRUE),
                effects = mapOf("goal" to ConditionDetermination.TRUE),
                cost = 3.0
            )

            val goal = GoapGoal(
                name = "testGoal",
                pre = listOf("goal")
            )

            val planner = AStarGoapPlanner(
                WorldStateDeterminer.fromMap(
                    mapOf(
                        "start" to ConditionDetermination.TRUE,
                        "stepB" to ConditionDetermination.FALSE,
                        "stepY" to ConditionDetermination.FALSE,
                        "goal" to ConditionDetermination.FALSE
                    )
                )
            )

            val actions: List<GoapAction> = listOf(actionA1, actionB1, actionX2, actionY2)
            val plan = planner.planToGoal(actions, goal)

            assertNotNull(plan, "Should find a plan")
            assertEquals(
                listOf("actionA1", "actionB1"), plan!!.actions.map { it.name },
                "Should choose the lower cost path"
            )
        }
    }

    @Nested
    inner class `Irrelevant action pruning tests` {

        @Test
        fun `should ignore irrelevant actions with misleading effects`() {
            // The actions we actually need
            val actionA = GoapAction(
                name = "actionA",
                preconditions = mapOf("start" to ConditionDetermination.TRUE),
                effects = mapOf("stepB" to ConditionDetermination.TRUE)
            )

            val actionB = GoapAction(
                name = "actionB",
                preconditions = mapOf("stepB" to ConditionDetermination.TRUE),
                effects = mapOf("goal" to ConditionDetermination.TRUE)
            )

            // Irrelevant action that has an effect that matches a goal precondition name
            // but is actually for a different context
            val misleadingAction = GoapAction(
                name = "misleadingAction",
                preconditions = mapOf("start" to ConditionDetermination.TRUE),
                effects = mapOf(
                    "goal" to ConditionDetermination.TRUE,
                    "wrongContext" to ConditionDetermination.TRUE
                )
            )

            // Another misleading action that seems to be part of a valid path
            val misleadingAction2 = GoapAction(
                name = "misleadingAction2",
                preconditions = mapOf("wrongContext" to ConditionDetermination.TRUE),
                effects = mapOf("goal" to ConditionDetermination.TRUE)
            )

            val goal = GoapGoal(
                name = "testGoal",
                pre = listOf("goal")
            )

            val planner = AStarGoapPlanner(
                WorldStateDeterminer.fromMap(
                    mapOf(
                        "start" to ConditionDetermination.TRUE,
                        "stepB" to ConditionDetermination.FALSE,
                        "goal" to ConditionDetermination.FALSE,
                        "wrongContext" to ConditionDetermination.FALSE
                    )
                )
            )

            val actions: List<GoapAction> = listOf(actionA, actionB, misleadingAction, misleadingAction2)
            val plan = planner.planToGoal(actions, goal)

            assertNotNull(plan, "Should find a plan")

            // The planner could choose either path, but the important thing is that it finds a valid plan
            // Let's check if the plan actually achieves the goal
            val finalState = simulatePlan(planner.worldState(), plan!!.actions.filterIsInstance<GoapAction>())
            assertTrue(goal.isAchievable(finalState), "The plan should achieve the goal")
        }

        private fun simulatePlan(startState: GoapWorldState, actions: List<GoapAction>): GoapWorldState {
            var currentState = startState
            for (action in actions) {
                if (action.isAchievable(currentState)) {
                    currentState = applyAction(currentState, action)
                }
            }
            return currentState
        }

        private fun applyAction(currentState: GoapWorldState, action: GoapAction): GoapWorldState {
            val newState = currentState.state.toMutableMap()
            action.effects.forEach { (key, value) ->
                newState[key] = value
            }
            return GoapWorldState(HashMap(newState))
        }
    }

    @Nested
    inner class `Complex dependency chain tests` {

        @Test
        fun `should handle long dependency chains with many irrelevant actions`() {
            // Create a long chain of necessary actions
            val actionChain = (1..10).map { i ->
                val prev = if (i == 1) "start" else "step${i - 1}"
                val next = "step$i"
                GoapAction(
                    name = "action$i",
                    preconditions = mapOf(prev to ConditionDetermination.TRUE),
                    effects = mapOf(next to ConditionDetermination.TRUE)
                )
            }

            // Create a large number of irrelevant actions
            val irrelevantActions = (1..50).map { i ->
                GoapAction(
                    name = "irrelevant$i",
                    preconditions = mapOf("irrelevantPre$i" to ConditionDetermination.TRUE),
                    effects = mapOf("irrelevantEffect$i" to ConditionDetermination.TRUE)
                )
            }

            // Create some misleading actions that have similar names but don't help
            val misleadingActions = (1..10).map { i ->
                GoapAction(
                    name = "misleading$i",
                    preconditions = mapOf("start" to ConditionDetermination.TRUE),
                    effects = mapOf("badStep$i" to ConditionDetermination.TRUE)
                )
            }

            val goal = GoapGoal(
                name = "testGoal",
                pre = listOf("step10")
            )

            // Create a world state with all the conditions
            val worldStateMap = mutableMapOf<String, ConditionDetermination>()
            worldStateMap["start"] = ConditionDetermination.TRUE
            (1..10).forEach { i -> worldStateMap["step$i"] = ConditionDetermination.FALSE }
            (1..50).forEach { i ->
                worldStateMap["irrelevantPre$i"] = ConditionDetermination.TRUE
                worldStateMap["irrelevantEffect$i"] = ConditionDetermination.FALSE
            }
            (1..10).forEach { i -> worldStateMap["badStep$i"] = ConditionDetermination.FALSE }

            val planner = AStarGoapPlanner(
                WorldStateDeterminer.fromMap(worldStateMap)
            )

            val allActions = actionChain + irrelevantActions + misleadingActions
            val actions: List<GoapAction> = allActions
            val plan = planner.planToGoal(actions, goal)

            assertNotNull(plan, "Should find a plan despite many irrelevant actions")
            assertEquals(10, plan!!.actions.size, "Should include exactly the 10 actions in the chain")

            // Verify the correct sequence
            (1..10).forEach { i ->
                assertEquals("action$i", plan.actions[i - 1].name, "Action at position ${i - 1} should be action$i")
            }
        }
    }

    @Nested
    inner class `Condition conflicts tests` {

        @Test
        fun `should handle actions with conflicting effects`() {
            // Action that sets condition A to TRUE
            val actionSetA = GoapAction(
                name = "actionSetA",
                preconditions = mapOf("start" to ConditionDetermination.TRUE),
                effects = mapOf("conditionA" to ConditionDetermination.TRUE)
            )

            // Action that requires A but sets it to FALSE
            val actionUnsetA = GoapAction(
                name = "actionUnsetA",
                preconditions = mapOf("conditionA" to ConditionDetermination.TRUE),
                effects = mapOf(
                    "conditionA" to ConditionDetermination.FALSE,
                    "conditionB" to ConditionDetermination.TRUE
                )
            )

            // Action that requires both A and B
            val actionNeedsAandB = GoapAction(
                name = "actionNeedsAandB",
                preconditions = mapOf(
                    "conditionA" to ConditionDetermination.TRUE,
                    "conditionB" to ConditionDetermination.TRUE
                ),
                effects = mapOf("goal" to ConditionDetermination.TRUE)
            )

            // Action that only needs B
            val actionNeedsOnlyB = GoapAction(
                name = "actionNeedsOnlyB",
                preconditions = mapOf("conditionB" to ConditionDetermination.TRUE),
                effects = mapOf("goal" to ConditionDetermination.TRUE)
            )

            val goal = GoapGoal(
                name = "testGoal",
                pre = listOf("goal")
            )

            val planner = AStarGoapPlanner(
                WorldStateDeterminer.fromMap(
                    mapOf(
                        "start" to ConditionDetermination.TRUE,
                        "conditionA" to ConditionDetermination.FALSE,
                        "conditionB" to ConditionDetermination.FALSE,
                        "goal" to ConditionDetermination.FALSE
                    )
                )
            )

            val actions: List<GoapAction> = listOf(actionSetA, actionUnsetA, actionNeedsAandB, actionNeedsOnlyB)
            val plan = planner.planToGoal(actions, goal)


            assertNotNull(plan, "Should find a plan despite conflicting effects")
            assertEquals(
                listOf("actionSetA", "actionUnsetA", "actionNeedsOnlyB"),
                plan!!.actions.map { it.name },
                "Should choose the path that resolves the conflict"
            )
        }
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/plan/goap/WorldStateTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.plan.goap

import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test

class WorldStateTest {

    @Nested
    inner class Constructor {
        @Test
        fun `test constructor with empty map`() {
            val worldState = GoapWorldState()
            assertTrue(worldState.state.isEmpty())
        }

        @Test
        fun `test constructor with populated map`() {
            val state = mapOf(
                "condition1" to ConditionDetermination.TRUE,
                "condition2" to ConditionDetermination.FALSE
            )
            val worldState = GoapWorldState(state)
            assertEquals(state, worldState.state)
        }
    }

    @Nested
    inner class UnknownConditions {

        @Test
        fun `test unknownConditions with empty state`() {
            val worldState = GoapWorldState()
            assertTrue(worldState.unknownConditions().isEmpty())
        }

        @Test
        fun `test unknownConditions with no unknowns`() {
            val state = mapOf(
                "condition1" to ConditionDetermination.TRUE,
                "condition2" to ConditionDetermination.FALSE
            )
            val worldState = GoapWorldState(state)
            assertTrue(worldState.unknownConditions().isEmpty())
        }

        @Test
        fun `test unknownConditions with unknowns`() {
            val state = mapOf(
                "condition1" to ConditionDetermination.TRUE,
                "condition2" to ConditionDetermination.UNKNOWN,
                "condition3" to ConditionDetermination.FALSE,
                "condition4" to ConditionDetermination.UNKNOWN
            )
            val worldState = GoapWorldState(state)
            val unknowns = worldState.unknownConditions()
            assertEquals(2, unknowns.size)
            assertTrue(unknowns.contains("condition2"))
            assertTrue(unknowns.contains("condition4"))
        }
    }

    @Nested
    inner class Variants {

        @Test
        fun `test variants with an unknown condition`() {
            val state = mapOf(
                "condition1" to ConditionDetermination.TRUE,
                "condition2" to ConditionDetermination.UNKNOWN
            )
            val worldState = GoapWorldState(state)
            val variants = worldState.variants("condition2")

            assertEquals(2, variants.size)

            val trueVariant = variants.find { it.state["condition2"] == ConditionDetermination.TRUE }
            val falseVariant = variants.find { it.state["condition2"] == ConditionDetermination.FALSE }

            assertNotNull(trueVariant)
            assertNotNull(falseVariant)
            assertEquals(ConditionDetermination.TRUE, trueVariant!!.state["condition1"])
            assertEquals(ConditionDetermination.TRUE, falseVariant!!.state["condition1"])
        }
    }

    @Nested
    inner class Plus {

        @Test
        fun `test plus operator`() {
            val state = mapOf(
                "condition1" to ConditionDetermination.TRUE,
                "condition2" to ConditionDetermination.FALSE
            )
            val worldState = GoapWorldState(state)
            val newWorldState = worldState + ("condition3" to ConditionDetermination.UNKNOWN)

            assertEquals(3, newWorldState.state.size)
            assertEquals(ConditionDetermination.TRUE, newWorldState.state["condition1"])
            assertEquals(ConditionDetermination.FALSE, newWorldState.state["condition2"])
            assertEquals(ConditionDetermination.UNKNOWN, newWorldState.state["condition3"])
        }

        @Test
        fun `test plus operator overwriting existing condition`() {
            val state = mapOf(
                "condition1" to ConditionDetermination.TRUE,
                "condition2" to ConditionDetermination.FALSE
            )
            val worldState = GoapWorldState(state)
            val newWorldState = worldState + ("condition1" to ConditionDetermination.UNKNOWN)

            assertEquals(2, newWorldState.state.size)
            assertEquals(ConditionDetermination.UNKNOWN, newWorldState.state["condition1"])
            assertEquals(ConditionDetermination.FALSE, newWorldState.state["condition2"])
        }
    }

    @Nested
    inner class WithOneChange {

        @Test
        fun `test withOneChange with empty state`() {
            val worldState = GoapWorldState()
            val changes = worldState.withOneChange()
            assertTrue(changes.isEmpty())
        }

        @Test
        fun `test withOneChange with single TRUE condition`() {
            val state = mapOf("condition1" to ConditionDetermination.TRUE)
            val worldState = GoapWorldState(state)
            val changes = worldState.withOneChange()

            assertEquals(2, changes.size)

            val falseVariant = changes.find { it.state["condition1"] == ConditionDetermination.FALSE }
            val unknownVariant = changes.find { it.state["condition1"] == ConditionDetermination.UNKNOWN }

            assertNotNull(falseVariant)
            assertNotNull(unknownVariant)
        }

        @Test
        fun `test withOneChange with single FALSE condition`() {
            val state = mapOf("condition1" to ConditionDetermination.FALSE)
            val worldState = GoapWorldState(state)
            val changes = worldState.withOneChange()

            assertEquals(2, changes.size)

            val trueVariant = changes.find { it.state["condition1"] == ConditionDetermination.TRUE }
            val unknownVariant = changes.find { it.state["condition1"] == ConditionDetermination.UNKNOWN }

            assertNotNull(trueVariant)
            assertNotNull(unknownVariant)
        }

        @Test
        fun `test withOneChange with single UNKNOWN condition`() {
            val state = mapOf("condition1" to ConditionDetermination.UNKNOWN)
            val worldState = GoapWorldState(state)
            val changes = worldState.withOneChange()

            assertEquals(2, changes.size)

            val trueVariant = changes.find { it.state["condition1"] == ConditionDetermination.TRUE }
            val falseVariant = changes.find { it.state["condition1"] == ConditionDetermination.FALSE }

            assertNotNull(trueVariant)
            assertNotNull(falseVariant)
        }


        @Test
        fun `test withOneChange with 10 conditions`() {
            val states = oneChangeWithNConditions(10)
            assertEquals(20, states.size) // 10 conditions, each with 2 alternate values

        }

        @Test
        fun `test withOneChange with 40 conditions`() {
            val states = oneChangeWithNConditions(40)
            assertEquals(80, states.size) // 10 conditions, each with 2 alternate values

        }

        private fun oneChangeWithNConditions(n: Int): Collection<GoapWorldState> {
            val state = mutableMapOf<String, ConditionDetermination>()
            for (i in 1..n) {
                state["condition$i"] = ConditionDetermination.entries.toTypedArray().random()
            }
            val worldState = GoapWorldState(state)
            val changes = worldState.withOneChange()

            return changes
        }

        @Test
        fun `test withOneChange with multiple conditions`() {
            val state = mapOf(
                "condition1" to ConditionDetermination.TRUE,
                "condition2" to ConditionDetermination.FALSE,
                "condition3" to ConditionDetermination.UNKNOWN
            )
            val worldState = GoapWorldState(state)
            val changes = worldState.withOneChange()

            assertEquals(6, changes.size)  // 3 conditions, each with 2 alternate values

            // Verify condition1 variants (TRUE can be changed to FALSE or UNKNOWN)
            val condition1ToFalse = changes.find {
                it.state["condition1"] == ConditionDetermination.FALSE &&
                        it.state["condition2"] == ConditionDetermination.FALSE &&
                        it.state["condition3"] == ConditionDetermination.UNKNOWN
            }
            val condition1ToUnknown = changes.find {
                it.state["condition1"] == ConditionDetermination.UNKNOWN &&
                        it.state["condition2"] == ConditionDetermination.FALSE &&
                        it.state["condition3"] == ConditionDetermination.UNKNOWN
            }

            // Verify condition2 variants (FALSE can be changed to TRUE or UNKNOWN)
            val condition2ToTrue = changes.find {
                it.state["condition1"] == ConditionDetermination.TRUE &&
                        it.state["condition2"] == ConditionDetermination.TRUE &&
                        it.state["condition3"] == ConditionDetermination.UNKNOWN
            }
            val condition2ToUnknown = changes.find {
                it.state["condition1"] == ConditionDetermination.TRUE &&
                        it.state["condition2"] == ConditionDetermination.UNKNOWN &&
                        it.state["condition3"] == ConditionDetermination.UNKNOWN
            }

            // Verify condition3 variants (UNKNOWN can be changed to TRUE or FALSE)
            val condition3ToTrue = changes.find {
                it.state["condition1"] == ConditionDetermination.TRUE &&
                        it.state["condition2"] == ConditionDetermination.FALSE &&
                        it.state["condition3"] == ConditionDetermination.TRUE
            }
            val condition3ToFalse = changes.find {
                it.state["condition1"] == ConditionDetermination.TRUE &&
                        it.state["condition2"] == ConditionDetermination.FALSE &&
                        it.state["condition3"] == ConditionDetermination.FALSE
            }

            assertNotNull(condition1ToFalse)
            assertNotNull(condition1ToUnknown)
            assertNotNull(condition2ToTrue)
            assertNotNull(condition2ToUnknown)
            assertNotNull(condition3ToTrue)
            assertNotNull(condition3ToFalse)
        }
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/ux/form/DefaultFormProcessorTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.ux.form

import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Disabled
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import java.time.LocalDate
import java.time.LocalTime

class DefaultFormProcessorTest {

    private lateinit var formProcessor: DefaultFormProcessor

    @BeforeEach
    fun setUp() {
        formProcessor = DefaultFormProcessor()
    }

    @Test
    fun `test process submission with text field`() {
        // Given
        val textField = TextField(
            label = "Name",
            required = true,
            id = "name-field"
        )

        val form = Form(
            title = "Test Form",
            controls = listOf(textField)
        )

        val submission = FormSubmission(
            formId = form.id,
            values = mapOf("name-field" to "John Doe")
        )

        // When
        val result = formProcessor.processSubmission(form, submission)

        // Then
        assertTrue(result.valid)
        assertTrue(result.validationErrors.isEmpty())
        assertEquals(1, result.values.size)
        assertTrue(result.values["name-field"] is ControlValue.TextValue)
        assertEquals("John Doe", (result.values["name-field"] as ControlValue.TextValue).value)
    }

    @Test
    fun `test process submission with missing required field`() {
        // Given
        val textField = TextField(
            label = "Name",
            required = true,
            id = "name-field"
        )

        val form = Form(
            title = "Test Form",
            controls = listOf(textField)
        )

        val submission = FormSubmission(
            formId = form.id,
            values = mapOf("name-field" to "")
        )

        // When
        val result = formProcessor.processSubmission(form, submission)

        assertFalse(result.valid)
        assertEquals(1, result.validationErrors.size)
        assertTrue(result.validationErrors.containsKey("name-field"))
        assertTrue(
            result.validationErrors["name-field"]!!.contains("is required"),
            "Validation error message should relate to field being required': ${result.validationErrors["name-field"]}",
        )
    }

    @Test
    fun `test process submission with invalid pattern for text field`() {
        // Given
        val emailField = TextField(
            label = "Email",
            validationPattern = "^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}\$",
            validationMessage = "Invalid email format",
            id = "email-field"
        )

        val form = Form(
            title = "Test Form",
            controls = listOf(emailField)
        )

        val submission = FormSubmission(
            formId = form.id,
            values = mapOf("email-field" to "invalid-email")
        )

        // When
        val result = formProcessor.processSubmission(form, submission)

        // Then
        assertFalse(result.valid)
        assertEquals(1, result.validationErrors.size)
        assertTrue(result.validationErrors.containsKey("email-field"))
        assertEquals("Invalid email format", result.validationErrors["email-field"])
    }

    @Test
    fun `test process submission with text area`() {
        // Given
        val textArea = TextArea(
            label = "Description",
            rows = 5,
            id = "description-field"
        )

        val form = Form(
            title = "Test Form",
            controls = listOf(textArea)
        )

        val submission = FormSubmission(
            formId = form.id,
            values = mapOf("description-field" to "This is a long description\nWith multiple lines\nFor testing purposes")
        )

        // When
        val result = formProcessor.processSubmission(form, submission)

        // Then
        assertTrue(result.valid)
        assertEquals(1, result.values.size)
        assertTrue(result.values["description-field"] is ControlValue.TextValue)
        assertEquals(
            "This is a long description\nWith multiple lines\nFor testing purposes",
            (result.values["description-field"] as ControlValue.TextValue).value
        )
    }

    @Test
    fun `test process submission with checkbox`() {
        // Given
        val checkbox = Checkbox(
            label = "Accept Terms",
            required = true,
            id = "terms-field"
        )

        val form = Form(
            title = "Test Form",
            controls = listOf(checkbox)
        )

        val submission = FormSubmission(
            formId = form.id,
            values = mapOf("terms-field" to true)
        )

        // When
        val result = formProcessor.processSubmission(form, submission)

        // Then
        assertTrue(result.valid)
        assertEquals(1, result.values.size)
        assertTrue(result.values["terms-field"] is ControlValue.BooleanValue)
        assertTrue((result.values["terms-field"] as ControlValue.BooleanValue).value)
    }

    @Test
    fun `test process submission with unchecked required checkbox`() {
        // Given
        val checkbox = Checkbox(
            label = "Accept Terms",
            required = true,
            id = "terms-field"
        )

        val form = Form(
            title = "Test Form",
            controls = listOf(checkbox)
        )

        val submission = FormSubmission(
            formId = form.id,
            values = mapOf("terms-field" to false)
        )

        // When
        val result = formProcessor.processSubmission(form, submission)

        // Then
        assertFalse(result.valid)
        assertEquals(1, result.validationErrors.size)
        assertTrue(result.validationErrors.containsKey("terms-field"))
    }

    @Test
    fun `test process submission with radio group`() {
        // Given
        val radioGroup = RadioGroup(
            label = "Gender",
            options = listOf(
                RadioOption("Male", "male"),
                RadioOption("Female", "female"),
                RadioOption("Other", "other")
            ),
            id = "gender-field"
        )

        val form = Form(
            title = "Test Form",
            controls = listOf(radioGroup)
        )

        val submission = FormSubmission(
            formId = form.id,
            values = mapOf("gender-field" to "female")
        )

        // When
        val result = formProcessor.processSubmission(form, submission)

        // Then
        assertTrue(result.valid)
        assertEquals(1, result.values.size)
        assertTrue(result.values["gender-field"] is ControlValue.OptionValue)
        assertEquals("female", (result.values["gender-field"] as ControlValue.OptionValue).value)
    }

    @Test
    fun `test process submission with dropdown`() {
        // Given
        val dropdown = Dropdown(
            label = "Country",
            options = listOf(
                DropdownOption("United States", "us"),
                DropdownOption("Canada", "ca"),
                DropdownOption("United Kingdom", "uk")
            ),
            id = "country-field"
        )

        val form = Form(
            title = "Test Form",
            controls = listOf(dropdown)
        )

        val submission = FormSubmission(
            formId = form.id,
            values = mapOf("country-field" to "ca")
        )

        // When
        val result = formProcessor.processSubmission(form, submission)

        // Then
        assertTrue(result.valid)
        assertEquals(1, result.values.size)
        assertTrue(result.values["country-field"] is ControlValue.OptionValue)
        assertEquals("ca", (result.values["country-field"] as ControlValue.OptionValue).value)
    }

    @Test
    fun `test process submission with date picker`() {
        // Given
        val datePicker = DatePicker(
            label = "Birth Date",
            id = "birth-date-field"
        )

        val form = Form(
            title = "Test Form",
            controls = listOf(datePicker)
        )

        val birthDate = "2000-01-15"
        val submission = FormSubmission(
            formId = form.id,
            values = mapOf("birth-date-field" to birthDate)
        )

        // When
        val result = formProcessor.processSubmission(form, submission)

        // Then
        assertTrue(result.valid)
        assertEquals(1, result.values.size)
        assertTrue(result.values["birth-date-field"] is ControlValue.DateValue)
        assertEquals(
            LocalDate.parse(birthDate),
            (result.values["birth-date-field"] as ControlValue.DateValue).value
        )
    }

    @Test
    fun `test process submission with time picker`() {
        // Given
        val timePicker = TimePicker(
            label = "Meeting Time",
            is24Hour = true,
            id = "meeting-time-field"
        )

        val form = Form(
            title = "Test Form",
            controls = listOf(timePicker)
        )

        val meetingTime = "14:30"
        val submission = FormSubmission(
            formId = form.id,
            values = mapOf("meeting-time-field" to meetingTime)
        )

        // When
        val result = formProcessor.processSubmission(form, submission)

        // Then
        assertTrue(result.valid)
        assertEquals(1, result.values.size)
        assertTrue(result.values["meeting-time-field"] is ControlValue.TimeValue)
        assertEquals(
            LocalTime.parse(meetingTime),
            (result.values["meeting-time-field"] as ControlValue.TimeValue).value
        )
    }

    @Test
    fun `test process submission with slider`() {
        // Given
        val slider = Slider(
            label = "Rating",
            min = 1.0,
            max = 5.0,
            step = 0.5,
            id = "rating-field"
        )

        val form = Form(
            title = "Test Form",
            controls = listOf(slider)
        )

        val submission = FormSubmission(
            formId = form.id,
            values = mapOf("rating-field" to 4.5)
        )

        // When
        val result = formProcessor.processSubmission(form, submission)

        // Then
        assertTrue(result.valid)
        assertEquals(1, result.values.size)
        assertTrue(result.values["rating-field"] is ControlValue.NumberValue)
        assertEquals(4.5, (result.values["rating-field"] as ControlValue.NumberValue).value)
    }

    @Nested
    inner class InvalidSubmissions {

        @Test
        fun `test process submission with invalid dropdown option`() {
            // Given
            val dropdown = Dropdown(
                label = "Country",
                options = listOf(
                    DropdownOption("United States", "us"),
                    DropdownOption("Canada", "ca"),
                    DropdownOption("United Kingdom", "uk")
                ),
                id = "country-field"
            )

            val form = Form(
                title = "Test Form",
                controls = listOf(dropdown)
            )

            val submission = FormSubmission(
                formId = form.id,
                values = mapOf("country-field" to "fr") // Not in options
            )

            val result = formProcessor.processSubmission(form, submission)

            assertFalse(result.valid, "Submission should be invalid: ${result.infoString(true)}")
            assertEquals(1, result.validationErrors.size, "Should have 1 validation error: ${result.infoString(true)}")
            assertTrue(result.validationErrors.containsKey("country-field"))
        }

        @Test
        fun `test process submission with slider outside range`() {
            // Given
            val slider = Slider(
                label = "Rating",
                min = 1.0,
                max = 5.0,
                step = 0.5,
                id = "rating-field"
            )

            val form = Form(
                title = "Test Form",
                controls = listOf(slider)
            )

            val submission = FormSubmission(
                formId = form.id,
                values = mapOf("rating-field" to 7.5) // Outside max
            )

            // When
            val result = formProcessor.processSubmission(form, submission)

            // Then
            assertFalse(result.valid, "Result should be invalid: ${result.infoString(true)}")
            assertEquals(1, result.validationErrors.size)
            assertTrue(result.validationErrors.containsKey("rating-field"))
        }

        @Test
        fun `test process submission with too many files`() {
            // Given
            val fileUpload = FileUpload(
                label = "Documents",
                maxFiles = 2,
                id = "documents-field"
            )

            val form = Form(
                title = "Test Form",
                controls = listOf(fileUpload)
            )

            val fileIds = listOf("file-1", "file-2", "file-3") // 3 files but max is 2
            val fileNames = listOf("document1.pdf", "document2.pdf", "document3.pdf")
            val fileData = mapOf(
                "fileIds" to fileIds,
                "fileNames" to fileNames
            )

            val submission = FormSubmission(
                formId = form.id,
                values = mapOf("documents-field" to fileData)
            )

            // When
            val result = formProcessor.processSubmission(form, submission)

            // Then
            assertFalse(result.valid)
            assertTrue(result.validationErrors.containsKey("documents-field"))
        }

        @Test
        @Disabled("decide whether validation should be required here")
        fun `test process submission with date picker and min date validation`() {
            // Given
            val datePicker = DatePicker(
                label = "Future Appointment",
                minDate = "2025-01-01",
                id = "appointment-field"
            )

            val form = Form(
                title = "Test Form",
                controls = listOf(datePicker)
            )

            val pastDate = "2023-01-15"
            val submission = FormSubmission(
                formId = form.id,
                values = mapOf("appointment-field" to pastDate)
            )

            // When
            val result = formProcessor.processSubmission(form, submission)

            // Then
            assertFalse(result.valid, "Submission should be invalid due to past date")
            assertEquals(1, result.validationErrors.size)
            assertTrue(result.validationErrors.containsKey("appointment-field"))
        }
    }

    @Test
    fun `test process submission with toggle`() {
        // Given
        val toggle = Toggle(
            label = "Notifications",
            id = "notifications-field"
        )

        val form = Form(
            title = "Test Form",
            controls = listOf(toggle)
        )

        val submission = FormSubmission(
            formId = form.id,
            values = mapOf("notifications-field" to true)
        )

        // When
        val result = formProcessor.processSubmission(form, submission)

        // Then
        assertTrue(result.valid)
        assertEquals(1, result.values.size)
        assertTrue(result.values["notifications-field"] is ControlValue.BooleanValue)
        assertTrue((result.values["notifications-field"] as ControlValue.BooleanValue).value)
    }

    @Test
    @Disabled("not yet working")
    fun `test process submission with file upload`() {
        // Given
        val fileUpload = FileUpload(
            label = "Documents",
            maxFiles = 2,
            id = "documents-field"
        )

        val form = Form(
            title = "Test Form",
            controls = listOf(fileUpload)
        )

        val fileIds = listOf("file-1", "file-2")
        val fileNames = listOf("document1.pdf", "document2.pdf")
        val fileData = mapOf(
            "fileIds" to fileIds,
            "fileNames" to fileNames
        )

        val submission = FormSubmission(
            formId = form.id,
            values = mapOf("documents-field" to fileData)
        )

        // When
        val result = formProcessor.processSubmission(form, submission)

        // Then
        assertTrue(result.valid)
        assertEquals(1, result.values.size)
        assertTrue(result.values["documents-field"] is ControlValue.FileValue)
        assertEquals(fileIds, (result.values["documents-field"] as ControlValue.FileValue).fileIds)
        assertEquals(fileNames, (result.values["documents-field"] as ControlValue.FileValue).fileNames)
    }

    @Test
    fun `test process submission with multiple controls`() {
        // Given
        val nameField = TextField(label = "Name", required = true, id = "name-field")
        val emailField = TextField(
            label = "Email",
            validationPattern = "^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}\$",
            id = "email-field"
        )
        val countryDropdown = Dropdown(
            label = "Country",
            options = listOf(
                DropdownOption("United States", "us"),
                DropdownOption("Canada", "ca")
            ),
            id = "country-field"
        )
        val termsCheckbox = Checkbox(label = "Accept Terms", required = true, id = "terms-field")

        val form = Form(
            title = "Registration Form",
            controls = listOf(nameField, emailField, countryDropdown, termsCheckbox)
        )

        val submission = FormSubmission(
            formId = form.id,
            values = mapOf(
                "name-field" to "John Doe",
                "email-field" to "john.doe@example.com",
                "country-field" to "us",
                "terms-field" to true
            )
        )

        // When
        val result = formProcessor.processSubmission(form, submission)

        // Then
        assertTrue(result.valid)
        assertTrue(result.validationErrors.isEmpty())
        assertEquals(4, result.values.size)
    }

    @Test
    fun `test process submission with partially valid controls`() {
        // Given
        val nameField = TextField(label = "Name", required = true, id = "name-field")
        val emailField = TextField(
            label = "Email",
            validationPattern = "^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}\$",
            validationMessage = "Invalid email format",
            id = "email-field"
        )
        val countryDropdown = Dropdown(
            label = "Country",
            options = listOf(
                DropdownOption("United States", "us"),
                DropdownOption("Canada", "ca")
            ),
            id = "country-field"
        )
        val termsCheckbox = Checkbox(label = "Accept Terms", required = true, id = "terms-field")

        val form = Form(
            title = "Registration Form",
            controls = listOf(nameField, emailField, countryDropdown, termsCheckbox)
        )

        val submission = FormSubmission(
            formId = form.id,
            values = mapOf(
                "name-field" to "John Doe",
                "email-field" to "invalid-email", // Invalid email
                "country-field" to "us",
                "terms-field" to false // Required but false
            )
        )

        // When
        val result = formProcessor.processSubmission(form, submission)

        // Then
        assertFalse(result.valid)
        assertEquals(2, result.validationErrors.size)
        assertTrue(result.validationErrors.containsKey("email-field"))
        assertEquals("Invalid email format", result.validationErrors["email-field"])
        assertTrue(result.validationErrors.containsKey("terms-field"))
    }

    @Test
    fun `test process submission with missing control`() {
        // Given
        val nameField = TextField(label = "Name", required = true, id = "name-field")
        val emailField = TextField(label = "Email", id = "email-field", required = false)

        val form = Form(
            title = "Simple Form",
            controls = listOf(nameField, emailField)
        )

        val submission = FormSubmission(
            formId = form.id,
            values = mapOf(
                "name-field" to "John Doe"
                // email-field is missing
            )
        )

        // When
        val result = formProcessor.processSubmission(form, submission)

        // Then
        assertTrue(
            result.valid,
            "Form should be valid because email is not required: ${result.infoString(true)}",
        ) // Valid because email is not required
        assertEquals(2, result.values.size)
        assertTrue(result.values["email-field"] is ControlValue.EmptyValue)
    }

    @Test
    fun `test process submission with button control`() {
        // Given
        val nameField = TextField(label = "Name", id = "name-field")
        val submitButton = Button(label = "Submit", id = "submit-button")

        val form = Form(
            title = "Button Test Form",
            controls = listOf(nameField, submitButton)
        )

        val submission = FormSubmission(
            formId = form.id,
            values = mapOf(
                "name-field" to "John Doe",
                "submit-button" to true
            )
        )

        // When
        val result = formProcessor.processSubmission(form, submission)

        // Then
        assertTrue(result.valid)
        assertEquals(
            2,
            result.values.size,
            "Should have 2 result values: " + result.infoString(true)
        )
        assertTrue(result.values.containsKey("submit-button"))
    }

    @Test
    fun `test process submission with disabled control`() {
        // Given
        val nameField = TextField(label = "Name", id = "name-field")
        val emailField = TextField(
            label = "Email",
            disabled = true,
            id = "email-field"
        )

        val form = Form(
            title = "Disabled Control Form",
            controls = listOf(nameField, emailField)
        )

        val submission = FormSubmission(
            formId = form.id,
            values = mapOf(
                "name-field" to "John Doe",
                "email-field" to "john.doe@example.com" // This should be ignored since the field is disabled
            )
        )

        val result = formProcessor.processSubmission(form, submission)

        assertTrue(result.valid)
        assertEquals(1, result.values.size)
        assertNull(
            result.values["email-field"],
            "Disabled field should not be returned, has ${result.infoString(true)}",
        )
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/ux/form/FormBinderTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.ux.form

import com.embabel.example.simple.horoscope.java.StarPerson
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import java.time.Instant
import java.time.LocalDate
import java.time.LocalTime

data class TypeTestUser(
    // Now form field on this one
    val stringValue: String,

    @property:FormField("int-id")
    val intValue: Int,

    @property:FormField("long-id")
    val longValue: Long,

    @property:FormField("double-id")
    val doubleValue: Double,

    @property:FormField("float-id")
    val floatValue: Float,

    @property:FormField("boolean-id")
    val booleanValue: Boolean,

    @property:FormField("date-id")
    val dateValue: LocalDate,

    @property:FormField("time-id")
    val timeValue: LocalTime,
)

data class OptionalFieldsUser(
    @property:FormField("name-id")
    val name: String,

    @property:FormField("age-id")
    val age: Int?,

    @property:FormField("email-id")
    val email: String?,
)

class FormBinderTest {

    // Test data classes
    data class SimpleUser(
        @property:FormField("name-id")
        val name: String,

        @property:FormField("age-id")
        val age: Int,
    )

    data class UserWithOptional(
        @property:FormField("name-id")
        val name: String,

        @property:FormField("age-id")
        val age: Int,

        @property:FormField("bio-id")
        val bio: String? = null,
    )

    data class ComplexUser(
        @property:FormField("name-id")
        val name: String,

        @property:FormField("email-id")
        val email: String,

        @property:FormField("age-id")
        val age: Int,

        @property:FormField("birth-date-id")
        val birthDate: LocalDate,

        @property:FormField("wake-time-id")
        val wakeTime: LocalTime,

        @property:FormField("active-id")
        val isActive: Boolean,

        @property:FormField("country-id")
        val country: String,

        @property:FormField("hobbies-id")
        val hobbies: List<String>,
    )

    data class UnmappedFieldUser(
        @property:FormField("name-id")
        val name: String,

        @property:NoFormField
        val unmappedField: String, // No annotation
    )

    // Setup helper functions
    private fun createSimpleSubmission(valid: Boolean = true): FormSubmissionResult {
        return FormSubmissionResult(
            submission = FormSubmission(
                formId = "test-form",
                values = mapOf(
                    "name-id" to "John Doe",
                    "age-id" to 30
                )
            ),
            values = mapOf(
                "name-id" to ControlValue.TextValue("John Doe"),
                "age-id" to ControlValue.NumberValue(30.0)
            ),
            valid = valid,
            validationErrors = if (valid) emptyMap() else mapOf("age-id" to "Age must be positive")
        )
    }

    private fun createComplexSubmission(): FormSubmissionResult {
        // Raw submission with primitive values as would come from a form
        val rawSubmission = FormSubmission(
            formId = "complex-form",
            values = mapOf(
                "name-id" to "Jane Smith",
                "email-id" to "jane@example.com",
                "age-id" to 28,
                "birth-date-id" to "1995-03-15", // Note: Date as string from form
                "wake-time-id" to "07:30",       // Note: Time as string from form
                "active-id" to true,
                "country-id" to "Canada",
                "hobbies-id" to listOf("Reading", "Hiking")
            )
        )

        // The processed submission with typed values
        return FormSubmissionResult(
            submission = rawSubmission,
            values = mapOf(
                "name-id" to ControlValue.TextValue("Jane Smith"),
                "email-id" to ControlValue.TextValue("jane@example.com"),
                "age-id" to ControlValue.NumberValue(28.0),
                "birth-date-id" to ControlValue.DateValue(LocalDate.of(1995, 3, 15)),
                "wake-time-id" to ControlValue.TimeValue(LocalTime.of(7, 30)),
                "active-id" to ControlValue.BooleanValue(true),
                "country-id" to ControlValue.OptionValue("Canada"),
                "hobbies-id" to ControlValue.MultiOptionValue(listOf("Reading", "Hiking"))
            ),
            valid = true
        )
    }

    @Nested
    @DisplayName("Basic Binding Tests")
    inner class BasicBindingTests {

        @Test
        @DisplayName("Should bind a simple form submission to a data class")
        fun bindSimpleFormSubmission() {
            val submission = createSimpleSubmission()
            val user: SimpleUser = submission.bindTo()
            assertEquals("John Doe", user.name)
            assertEquals(30, user.age)
        }

        @Test
        @DisplayName("Should bind a complex form submission with various types")
        fun bindComplexFormSubmission() {
            // Given
            val submission = createComplexSubmission()

            // When
            val user: ComplexUser = submission.bindTo()

            // Then
            assertEquals("Jane Smith", user.name)
            assertEquals("jane@example.com", user.email)
            assertEquals(28, user.age)
            assertEquals(LocalDate.of(1995, 3, 15), user.birthDate)
            assertEquals(LocalTime.of(7, 30), user.wakeTime)
            assertTrue(user.isActive)
            assertEquals("Canada", user.country)
            assertEquals(listOf("Reading", "Hiking"), user.hobbies)
        }

        @Test
        @DisplayName("Should handle optional fields when present")
        fun handleOptionalFieldsWhenPresent() {
            // Given
            val rawSubmission = FormSubmission(
                formId = "test-form",
                values = mapOf(
                    "name-id" to "Alice",
                    "age-id" to 25,
                    "bio-id" to "Software engineer"
                )
            )

            val submission = FormSubmissionResult(
                submission = rawSubmission,
                values = mapOf(
                    "name-id" to ControlValue.TextValue("Alice"),
                    "age-id" to ControlValue.NumberValue(25.0),
                    "bio-id" to ControlValue.TextValue("Software engineer")
                ),
                valid = true
            )

            // When
            val user: UserWithOptional = submission.bindTo()

            // Then
            assertEquals("Alice", user.name)
            assertEquals(25, user.age)
            assertEquals("Software engineer", user.bio)
        }

        @Test
        @DisplayName("Should handle optional fields when missing")
        fun handleOptionalFieldsWhenMissing() {
            // Given
            val rawSubmission = FormSubmission(
                formId = "test-form",
                values = mapOf(
                    "name-id" to "Bob",
                    "age-id" to 40
                    // bio-id is missing
                )
            )

            val submission = FormSubmissionResult(
                submission = rawSubmission,
                values = mapOf(
                    "name-id" to ControlValue.TextValue("Bob"),
                    "age-id" to ControlValue.NumberValue(40.0)
                    // bio-id is missing
                ),
                valid = true
            )

            assertThrows<FormBinder.FormBindingException> {
                submission.bindTo<UserWithOptional>()
            }
        }
    }

    @Nested
    @DisplayName("Java Binding Tests")
    inner class JavaBindingTests {

        @Test
        fun `bind record`() {
            val submission = FormSubmissionResult(
                submission = FormSubmission(
                    formId = "test-form",
                    values = mapOf(
                        "name" to "John Doe",
                        "age" to 30
                    )
                ),
                values = mapOf(
                    "name" to ControlValue.TextValue("John Doe"),
                    "age" to ControlValue.NumberValue(30.0)
                ),
                valid = true,
                validationErrors = emptyMap()
            )
            val user: JavaPersonRecord = submission.bindTo()
            assertEquals("John Doe", user.name)
            assertEquals(30, user.age)
        }

        @Test
        fun `bind StarPerson record`() {
            val submission = FormSubmissionResult(
                submission = FormSubmission(
                    formId = "test-form",
                    values = mapOf(
                        "name" to "John Doe",
                        "sign" to "virgo"
                    )
                ),
                values = mapOf(
                    "name" to ControlValue.TextValue("John Doe"),
                    "sign" to ControlValue.TextValue("virgo")
                ),
                valid = true,
                validationErrors = emptyMap()
            )
            val user: StarPerson = submission.bindTo()
            assertEquals("John Doe", user.name)
            assertEquals("virgo", user.sign)
        }

        @Test
        fun `bind record with control id`() {
            val submission = createSimpleSubmission()
            val user: JavaPersonRecordWithControlId = submission.bindTo()
            assertEquals("John Doe", user.name)
            assertEquals(30, user.age)
        }

        @Test
        fun `bind immutable class`() {
            val submission = createSimpleSubmission()
            val user: JavaPersonImmutable = submission.bindTo()
            assertEquals("John Doe", user.getName())
            assertEquals(30, user.getAge())
        }
    }

    @Nested
    @DisplayName("Error Handling Tests")
    inner class ErrorHandlingTests {

        @Test
        @DisplayName("Should throw ValidationException when form is invalid")
        fun throwValidationExceptionForInvalidForm() {
            // Given
            val invalidSubmission = createSimpleSubmission(valid = false)

            // When/Then
            val exception = assertThrows(FormBinder.ValidationException::class.java) {
                invalidSubmission.bindTo<SimpleUser>()
            }

            assertEquals("Form validation failed", exception.message)
            assertEquals("Age must be positive", exception.errors["age-id"])
        }

        @Test
        @DisplayName("Should throw FormBindingException when control ID is missing")
        fun throwExceptionWhenControlIdIsMissing() {
            // Given
            val rawSubmission = FormSubmission(
                formId = "test-form",
                values = mapOf(
                    "name-id" to "Charlie"
                    // age-id is missing
                )
            )

            val incompleteSubmission = FormSubmissionResult(
                submission = rawSubmission,
                values = mapOf(
                    "name-id" to ControlValue.TextValue("Charlie")
                    // age-id is missing
                ),
                valid = true
            )

            // When/Then
            val exception = assertThrows(FormBinder.FormBindingException::class.java) {
                incompleteSubmission.bindTo<SimpleUser>()
            }

            assertTrue(
                exception.message?.contains("No value found for control id 'age-id'") == true,
                "Expected error message about missing control id, got ${exception.message}",
            )
        }

        @Test
        @DisplayName("Should throw FormBindingException for type mismatch")
        fun throwExceptionForTypeMismatch() {
            // Given
            val rawSubmission = FormSubmission(
                formId = "test-form",
                values = mapOf(
                    "name-id" to "Dave",
                    "age-id" to "not-a-number" // String instead of number
                )
            )

            val submissionWithTypeMismatch = FormSubmissionResult(
                submission = rawSubmission,
                values = mapOf(
                    "name-id" to ControlValue.TextValue("Dave"),
                    "age-id" to ControlValue.TextValue("not-a-number") // String instead of number
                ),
                valid = true
            )

            // When/Then
            assertThrows(FormBinder.FormBindingException::class.java) {
                submissionWithTypeMismatch.bindTo<SimpleUser>()
            }
        }

        @Test
        @DisplayName("Should throw FormBindingException for transient required fields")
        fun throwExceptionForUnmappedRequiredFields() {
            // Given
            val submission = createSimpleSubmission()

            // When/Then
            val exception = assertThrows(FormBinder.FormBindingException::class.java) {
                submission.bindTo<UnmappedFieldUser>()
            }

            assertTrue(
                exception.message?.contains("Missing required parameter") ?: false,
                "Expected error message about missing required parameter, got ${exception.message}",
            )
        }
    }

    @Nested
    @DisplayName("Type Conversion Tests")
    inner class TypeConversionTests {


        @Test
        @DisplayName("Should convert different control value types correctly")
        fun convertDifferentValueTypesCorrectly() {
            val rawSubmission = FormSubmission(
                formId = "type-test",
                values = mapOf(
                    "stringValue" to "test string",
                    "int-id" to 42,
                    "long-id" to 9999999999L,
                    "double-id" to 3.14159,
                    "float-id" to 2.71828f,
                    "boolean-id" to true,
                    "date-id" to "2023-05-15",
                    "time-id" to "14:30:45"
                )
            )

            val submission = FormSubmissionResult(
                submission = rawSubmission,
                values = mapOf(
                    "stringValue" to ControlValue.TextValue("test string"),
                    "int-id" to ControlValue.NumberValue(42.0),
                    "long-id" to ControlValue.NumberValue(9999999999.0),
                    "double-id" to ControlValue.NumberValue(3.14159),
                    "float-id" to ControlValue.NumberValue(2.71828),
                    "boolean-id" to ControlValue.BooleanValue(true),
                    "date-id" to ControlValue.DateValue(LocalDate.of(2023, 5, 15)),
                    "time-id" to ControlValue.TimeValue(LocalTime.of(14, 30, 45))
                ),
                valid = true
            )

            // When
            val user: TypeTestUser = submission.bindTo()

            // Then
            assertEquals("test string", user.stringValue)
            assertEquals(42, user.intValue)
            assertEquals(9999999999L, user.longValue)
            assertEquals(3.14159, user.doubleValue)
            assertEquals(2.71828f, user.floatValue)
            assertTrue(user.booleanValue)
            assertEquals(LocalDate.of(2023, 5, 15), user.dateValue)
            assertEquals(LocalTime.of(14, 30, 45), user.timeValue)
        }

        @Test
        @DisplayName("Should convert string to appropriate types")
        fun convertStringToAppropriateTypes() {
            // Given - all values represented as strings in the raw submission
            val rawSubmission = FormSubmission(
                formId = "string-conversion-test",
                values = mapOf(
                    "stringValue" to "test string",
                    "int-id" to "42",
                    "long-id" to "9999999999",
                    "double-id" to "3.14159",
                    "float-id" to "2.71828",
                    "boolean-id" to "true",
                    "date-id" to "2023-05-15",
                    "time-id" to "14:30:45"
                )
            )

            // But in the processed result, they're properly typed
            val submission = FormSubmissionResult(
                submission = rawSubmission,
                values = mapOf(
                    "stringValue" to ControlValue.TextValue("test string"),
                    "int-id" to ControlValue.TextValue("42"),
                    "long-id" to ControlValue.TextValue("9999999999"),
                    "double-id" to ControlValue.TextValue("3.14159"),
                    "float-id" to ControlValue.TextValue("2.71828"),
                    "boolean-id" to ControlValue.TextValue("true"),
                    "date-id" to ControlValue.TextValue("2023-05-15"),
                    "time-id" to ControlValue.TextValue("14:30:45")
                ),
                valid = true
            )

            // When
            val user: TypeTestUser = submission.bindTo()

            // Then
            assertEquals("test string", user.stringValue)
            assertEquals(42, user.intValue)
            assertEquals(9999999999L, user.longValue)
            assertEquals(3.14159, user.doubleValue)
            assertEquals(2.71828f, user.floatValue)
            assertTrue(user.booleanValue)
            assertEquals(LocalDate.of(2023, 5, 15), user.dateValue)
            assertEquals(LocalTime.of(14, 30, 45), user.timeValue)
        }
    }

    @Nested
    @DisplayName("Empty Value Tests")
    inner class EmptyValueTests {

        @Test
        @DisplayName("Should handle empty values for optional fields")
        fun handleEmptyValuesForOptionalFields() {
            // Given
            val rawSubmission = FormSubmission(
                formId = "empty-test",
                values = mapOf(
                    "name-id" to "Eve"
                    // age-id and email-id are missing
                )
            )

            val submission = FormSubmissionResult(
                submission = rawSubmission,
                values = mapOf(
                    "name-id" to ControlValue.TextValue("Eve"),
                    "age-id" to ControlValue.EmptyValue,
                    "email-id" to ControlValue.EmptyValue
                ),
                valid = true
            )

            // When
            val user: OptionalFieldsUser = submission.bindTo()

            // Then
            assertEquals("Eve", user.name)
            assertNull(user.age)
            assertNull(user.email)
        }
    }

    @Nested
    @DisplayName("FormSubmission Timestamp Tests")
    inner class FormSubmissionTimestampTests {

        @Test
        @DisplayName("Should preserve timestamp from form submission")
        fun preserveTimestampFromFormSubmission() {
            // Given
            val fixedTime = Instant.parse("2023-05-15T14:30:45Z")
            val rawSubmission = FormSubmission(
                formId = "timestamp-test",
                values = mapOf("name-id" to "Frank"),
                timestamp = fixedTime
            )

            val submission = FormSubmissionResult(
                submission = rawSubmission,
                values = mapOf("name-id" to ControlValue.TextValue("Frank")),
                valid = true
            )

            // When/Then
            assertEquals(fixedTime, submission.submission.timestamp)
        }
    }
}



================================================
FILE: embabel-agent-api/src/test/kotlin/com/embabel/ux/form/SimpleFormGeneratorTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.ux.form

import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Disabled
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import java.time.LocalDate
import java.time.LocalTime

data class AllTypesClass(

    @property:FormField("string-id")
    @Text(label = "custom label")
    val stringField: String,

    @property:FormField("int-id")
    val intField: Int,

    @property:FormField("long-id")
    val longField: Long,

    @property:FormField("double-id")
    val doubleField: Double,

    @property:FormField("float-id")
    val floatField: Float,

    @property:FormField("boolean-id")
    val booleanField: Boolean,

    @property:FormField("date-id")
    val dateField: LocalDate,

    @property:FormField("time-id")
    val timeField: LocalTime,

    @property:FormField("list-id")
    val listField: List<String>
)


class SimpleFormGeneratorTest {

    private val formGenerator = SimpleFormGenerator

    @Nested
    @DisplayName("Basic Form Generation Tests")
    inner class BasicFormGenerationTests {

        @Test
        @DisplayName("Single field data class")
        fun singleField() {
            data class Starry(
                @Text(label = "Enter your star sign")
                val sign: String,
            )

            // When
            val form = formGenerator.generateForm<Starry>("Test Form")

            // Then
            assertEquals("Test Form", form.title)
            assertEquals(2, form.controls.size)
            assertTrue(form.controls[0] is TextField, "Expected TextField, got ${form.controls}")
            assertEquals("Enter your star sign", (form.controls[0] as TextField).label)
        }

        @Test
        @DisplayName("Should generate form with correct title")
        fun shouldGenerateFormWithCorrectTitle() {
            // Given
            data class SimpleClass(
                @FormField("test-id")
                val testField: String
            )

            // When
            val form = formGenerator.generateForm<SimpleClass>("Test Form")

            // Then
            assertEquals("Test Form", form.title)
        }

        @Test
        @DisplayName("Should include a submit button")
        fun shouldIncludeSubmitButton() {
            // Given
            data class SimpleClass(
                @FormField("test-id")
                val testField: String
            )

            // When
            val form = formGenerator.generateForm<SimpleClass>("Test Form")

            // Then
            val lastControl = form.controls.last()
            assertTrue(lastControl is Button)
            assertEquals("Submit", (lastControl as Button).label)
        }

        @Test
        @DisplayName("Should skip properties with NotFormField annotation")
        fun shouldSkipPropertiesWithoutAnnotation() {
            // Given
            data class MixedClass(
                @property:FormField("annotated-id")
                val annotatedField: String,

                // Negative annotation, should be skipped
                @property:NoFormField
                val unannotatedField: String
            )

            // When
            val form = formGenerator.generateForm<MixedClass>("Mixed Form")

            // Then
            // Should have annotated field + submit button = 2 controls
            assertEquals(2, form.controls.size)

            val firstControl = form.controls.first()
            assertTrue(firstControl is TextField)
            assertEquals("annotated-id", (firstControl as TextField).id)
            assertEquals("Annotated Field", firstControl.label)
        }
    }

    @Nested
    @DisplayName("Control Type Tests")
    inner class ControlTypeTests {


        @Test
        @DisplayName("Should create correct control types for different property types")
        fun shouldCreateCorrectControlTypes() {
            // When
            val form = formGenerator.generateForm<AllTypesClass>("All Types Form")

            // Then - excluding the submit button
            val controls = form.controls.dropLast(1)
            assertEquals(9, controls.size)

            // Check each control type
            assertTrue(controls[0] is TextField, "First control should be text field, it is ${controls[0]}")
            assertEquals("string-id", (controls[0] as TextField).id)
            assertEquals("custom label", (controls[0] as TextField).label)

            assertTrue(controls[1] is TextField)
            assertEquals("int-id", (controls[1] as TextField).id)
            assertNotNull((controls[1] as TextField).validationPattern)

            assertTrue(controls[2] is TextField)
            assertEquals("long-id", (controls[2] as TextField).id)
            assertNotNull((controls[2] as TextField).validationPattern)

            assertTrue(controls[3] is TextField)
            assertEquals("double-id", (controls[3] as TextField).id)
            assertNotNull((controls[3] as TextField).validationPattern)

            assertTrue(controls[4] is TextField)
            assertEquals("float-id", (controls[4] as TextField).id)
            assertNotNull((controls[4] as TextField).validationPattern)

            assertTrue(controls[5] is Checkbox)
            assertEquals("boolean-id", (controls[5] as Checkbox).id)

            assertTrue(controls[6] is DatePicker)
            assertEquals("date-id", (controls[6] as DatePicker).id)

            assertTrue(controls[7] is TimePicker)
            assertEquals("time-id", (controls[7] as TimePicker).id)

            assertTrue(controls[8] is TextArea)
            assertEquals("list-id", (controls[8] as TextArea).id)
        }
    }

    @Nested
    @DisplayName("Label Formatting Tests")
    inner class LabelFormattingTests {

        @Test
        @DisplayName("Should format camelCase property names to proper labels")
        fun shouldFormatCamelCasePropertyNames() {
            // Given
            data class FormattingClass(
                @FormField("simple-id")
                val simpleField: String,

                @FormField("camel-case-id")
                val camelCaseField: String,

                @FormField("multiple-words-id")
                val multipleWordsInThisField: String
            )

            // When
            val form = formGenerator.generateForm<FormattingClass>("Formatting Form")

            // Then - excluding the submit button
            val controls = form.controls.dropLast(1)
            assertEquals(3, controls.size)

            // Check label formatting
            assertEquals("Simple Field", (controls[0] as TextField).label)
            assertEquals("Camel Case Field", (controls[1] as TextField).label)
            assertEquals("Multiple Words In This Field", (controls[2] as TextField).label)
        }
    }

    @Nested
    @DisplayName("Nullability Tests")
    inner class NullabilityTests {

        @Test
        @DisplayName("Should mark non-nullable fields as required")
        fun shouldMarkNonNullableFieldsAsRequired() {
            // Given
            data class NullabilityClass(
                @FormField("required-id")
                val requiredField: String,

                @FormField("optional-id")
                val optionalField: String?
            )

            // When
            val form = formGenerator.generateForm<NullabilityClass>("Nullability Form")

            // Then - excluding the submit button
            val controls = form.controls.dropLast(1)
            assertEquals(2, controls.size)

            // Check required state
            assertTrue((controls[0] as TextField).required, "First control should be required: ${controls[0]}")
            assertFalse((controls[1] as TextField).required)
        }
    }

    @Nested
    @DisplayName("Complex Class Tests")
    inner class ComplexClassTests {

        @Test
        @DisplayName("Should handle complex classes with inheritance")
        @Disabled("not yet working")
        fun shouldHandleInheritance() {
            // Given
            open class BaseClass(
                @FormField("base-id")
                open val baseField: String
            )

            data class DerivedClass(
                override val baseField: String,
                @FormField("derived-id")
                val derivedField: Int
            ) : BaseClass(baseField)

            // When
            val form = formGenerator.generateForm<DerivedClass>("Inheritance Form")

            // Then - excluding the submit button
            val controls = form.controls.dropLast(1)
            assertEquals(2, controls.size)

            // Check fields from both base and derived classes
            val controlIds = controls.map {
                when (it) {
                    is TextField -> it.id
                    else -> ""
                }
            }

            assertTrue(controlIds.contains("base-id"))
            assertTrue(controlIds.contains("derived-id"))
        }

        @Test
        @DisplayName("Should handle nested data classes")
        fun shouldHandleNestedDataClasses() {
            // Given
            data class NestedClass(
                @property:FormField("nested-id")
                val nestedField: String
            )

            data class OuterClass(
                @property:FormField("outer-id")
                val outerField: String,

                // No annotation on the nested object itself
                val nested: NestedClass
            )

            // When
            val form = formGenerator.generateForm<OuterClass>("Nested Form")

            // Then - excluding the submit button
            val controls = form.controls.dropLast(1)
            assertEquals(2, controls.size)

            // Should only include the annotated field from the outer class
            assertEquals("outer-id", (controls[0] as TextField).id)
        }
    }

    @Nested
    @DisplayName("Real-World Example Tests")
    inner class RealWorldExampleTests {

        @Test
        @DisplayName("Should generate a complete user registration form")
        fun shouldGenerateUserRegistrationForm() {
            // Given
            data class UserRegistration(
                @property:FormField("name-field")
                val fullName: String,

                @property:FormField("email-field")
                val emailAddress: String,

                @property:FormField("password-field")
                val password: String,

                @property:FormField("age-field")
                val age: Int,

                @property:FormField("terms-field")
                val acceptTerms: Boolean,

                @property:FormField("birth-date-field")
                val dateOfBirth: LocalDate,

                @property:FormField("bio-field")
                val biography: String? = null
            )

            // When
            val form = formGenerator.generateForm<UserRegistration>("User Registration")

            // Then - excluding the submit button
            val controls = form.controls.dropLast(1)
            assertEquals(7, controls.size)

            // Check specific fields
            val nameField = controls.find { it is TextField && it.id == "name-field" } as TextField?
            assertNotNull(nameField)
            assertEquals("Full Name", nameField?.label)
            assertTrue(nameField?.required ?: false)

            val emailField = controls.find { it is TextField && it.id == "email-field" } as TextField?
            assertNotNull(emailField)
            assertEquals("Email Address", emailField?.label)

            val termsField = controls.find { it is Checkbox && it.id == "terms-field" } as Checkbox?
            assertNotNull(termsField)
            assertEquals("Accept Terms", termsField?.label)

            val bioField = controls.find { it is TextField && it.id == "bio-field" } as TextField?
            assertNotNull(bioField)
            assertEquals("Biography", bioField?.label)
            assertFalse(bioField?.required ?: true)
        }
    }
}



================================================
FILE: embabel-agent-api/src/test/resources/application-shell.yml
================================================
spring:
  main:
    web-application-type: none
  shell:
    command:
      exit:
        enabled: false
      quit:
        enabled: false
    history:
      enabled: true
    interactive:
      enabled: true

logging:
  level:
    org.springframework.shell: WARN


================================================
FILE: embabel-agent-api/src/test/resources/application-test.properties
================================================
[Empty file]


================================================
FILE: embabel-agent-api/src/test/resources/application.properties
================================================
# Spring Boot Application Properties
spring.application.name=agent-api
spring.threads.virtual.enabled=true
spring.output.ansi.enabled=ALWAYS

# AI Configuration
spring.ai.ollama.base-url=http://localhost:11434
spring.ai.openai.api-key=${OPENAI_API_KEY}

# Management
management.tracing.enabled=false

# Embabel Agent Platform
embabel.agent-platform.name=embabel-default
embabel.agent-platform.description=Embabel Default Agent Platform
embabel.agent-platform.scanning.annotation=true
embabel.agent-platform.scanning.bean=true
embabel.agent-platform.ranking.max-attempts=5

# Embabel Autonomy
embabel.autonomy.agent-confidence-cut-off=0.6
embabel.autonomy.goal-confidence-cut-off=0.6

# Process ID Generation
embabel.process-id-generation.include-agent-name=false
embabel.process-id-generation.include-version=false

# LLM Operations
embabel.llm-operations.prompts.generate-examples-by-default=true

# Models
embabel.models.default-llm=gpt-4.1-mini
embabel.models.default-embedding-model=text-embedding-3-small

# Logging
logging.pattern.console=%clr(%d{HH:mm:ss.SSS}){faint} %clr([%t]){magenta} %clr(%-5level) %clr(%logger{0}){cyan} %clr(-){faint} %msg%n

# Logging Levels
logging.level.org.springframework.ai.converter.BeanOutputConverter=OFF
logging.level.com.embabel.agent.core.support.BlackboardWorldStateDeterminer=INFO
logging.level.com.embabel.agent.api.annotation.support.AgentMetadataReader=INFO
logging.level.com.embabel.agent.spi.support.LlmRanker=INFO
logging.level.com.embabel.agent.spi.support.com.embabel.agent.spi.support.springai.ChatClientLlmOperations=INFO


================================================
FILE: embabel-agent-api/src/test/resources/examples/movie/rod_ratings.tsv
================================================
The Godfather 10
The Godfather Part II 10
The Big Lebowski 10
No Country for Old Men 8
Fargo 10
Top Gun: Maverick 8
Requiem for a Dream 8
Birds of Passage 9
Wake in Fright 8
The Killers 8
# Babylon --year 2022 7
2001: A Space Odyssey 10
8½ 10
2001: A Space Odyssey 10
Love Is My Profession 10
Sunset Boulevard 10
Casablanca 8
The Seventh Seal 9
To Have and Have Not 8
The Big Sleep 8
Dune 8
Elevator to the Gallows 8
Reservoir Dogs 9
Pulp Fiction 8
Come and See 8
The Terminator 9
The Terminator 2 7
Stagecoach 8
Unforgiven 8
Rear Window 9
Blade Runner 10
Blade Runner 2049 9
Barry Lyndon 10
Whiplash 10
Eternal Sunshine of the Spotless Mind 9
Interstellar 10
Inception 9
All the President's Men 8
Oppenheimer 8
Apocalypse Now 10
Parasite 9
Andrei Rublev 8
Chinatown 8
City of God 8
Downfall 8
Full Metal Jacket 9
Dr. Strangelove or: How I Learned to Stop Worrying and Love the Bomb 9
Paths of Glory 9
The Cruel Sea 8
Taxi Driver 9
Goodfellas 9
The Wolf Of Wall Street 8
Star Wars: Episode IV - 9
Star Wars: Episode VI - 8
Blue Jasmine 8
Baby Doll 8
The Artist 8
On The Waterfront 8
Mad Max 8
The Road Warrior 8
Mad Max: Fury Road 9
The Bridge on the River Kwai 9
Get Out 9
Performance 8
Arrival 7
Walkabout 9
Patton 8
The Bridges at Toko-Ri 7
Bonnie and Clyde 9
12 Angry Men 8
Rififi 9
Everything Everywhere All at Once 9
Le samouraï 9
Enter the Dragon 6
Goldeneye 7
Rosemary's Baby 8
Once Upon a Time... in Hollywood 8
Suspiria 8
Get Carter 8
The Wicker Man 8
Scarface 8
The Power of the Dog 10
Miller's Crossing 9
Das Boot 10
A Complete Unknown 10
Pan's Labyrinth 9
Rebel Without a Cause 9
Donnie Darko 8
Mulholland Drive 9
Magnolia 9
The Darjeeling Limited 8
The Life Aquatic with Steve Zissou 9
Boogie Nights 9
Night of the Hunter 8
On the Waterfront 8
The Master 8
Licorice Pizza 8
Anora 9
The Long Good Friday 8
Pain and Glory 8
The Little Mermaid	0
Commando 2
Immortal Beloved 2
Predator 5
Leprechaun 0
Transformers 3
John Wick 7
Twilight 2
Avatar 6
Avengers Endgame 5
Titanic 3
Gettysburg 7
Bram Stoker's Dracula 2
True Romance 7
Ex Machina 8
Civil War 6
Hot Tub Time Machine 6
#Hot Tub Time Machine 2 2
Atonement 7
My Old Ass 6
Knives Out 7
Back to the Future	8

Pearl Harbor 2
Idiocracy 7
Babygirl 4
Heat 6
Saving Private Ryan 7
Zoolander 7
Oldboy 6
Paul Blart: Mall Cop 0
The Royal Tenenbaums 7
The Nice Guys 7
The Grand Budapest Hotel 6
The Ballad of Buster Scruggs 8
Inside Llewyn Davis 7
Brazil 7
Inherent Vice 8
The French Connection 6
The Big Short 7
The Usual Suspects 8
The Great Beauty 9
Birdman 8
The Thin Red Line 6
The Favourite 7


================================================
FILE: embabel-agent-api/.embabel/coding-style.md
================================================
# Coding style

## General

The project uses Maven, Kotlin and Spring Boot.

Follow the style of the code you read. Favor clarity.

Do not include blank lines within methods without good reason.
GOOD REASON: two groups of 5 lines each, with a blank line between them to indicate that they are distinct processes.
BAD REASON: one line/blank line/another line for no particular reason.

Don't bother putting in licence headers, as build will do that.

Don't comment obvious things, inline or in type headers.
Comment only things that may be non-obvious. LLMs offer comment
more than humans; don't do that.

Use consistent naming in the Spring idiom.

Use the Spring idiom where possible.

Favor immutability.

Use the `Schema` and related annotations to add information to types passed over the wire in the REST application.
This will improve Swagger/OpenAPI documentation.

Unless there is a specific reason not to, use the latest GA version of all dependencies.

Use @Nested classes in tests. Use `test complicated thing` instead of @DisplayName for test cases.
Do not couple tests too tightly to implementation.

In log statements, use placeholders for efficiency at all logging levels.
E.g. logger.info("{} {}", a, b) instead of logger.info("computed string").

Write new code in Kotlin rather than Java by default.
If a file is in Java, it should stay in Java.

If in any doubt, add Java tests and test fixtures to ensure that use from Java is idiomatic.

## Kotlin

- Use Kotlin coding conventions and consistent formatting.
- Ensure that use from Java is idiomatic. For example, use @JvmOverloads
  to generate overloads for functions with default parameters if appropriate.
  Use @JvmStatic on companion object functions if appropriate.
- Use mockk for tests.

## Java

- Use modern Java features like var, records, and switch expressions.
- Use multiline strings rather than concatenation.
- Use Mockito for tests.

WRONG: String s = "a";
RIGHT: var s = "a";





================================================
FILE: embabel-agent-api/.github/workflows/maven.yml
================================================
# This workflow will build a Java / Kotlin project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-java-with-maven

# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

name: Build

on:
  push:
  pull_request:
    types: [ opened, synchronize, reopened ]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: maven
      - name: Configure Testcontainers
        run: |
          mkdir -p /home/runner
          echo "testcontainers.reuse.enable=true" > /home/runner/.testcontainers.properties
      - name: Configure Maven Settings
        uses: s4u/maven-settings-action@v2.8.0
        with:
          servers: ${{secrets.GITREPO_SERVER}}
      - name: Build and analyze
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Needed to get PR information, if any
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: mvn -B test verify



================================================
FILE: embabel-agent-api/.mvn/wrapper/maven-wrapper.properties
================================================
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.9.6
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.6/apache-maven-3.9.6-bin.zip



================================================
FILE: embabel-agent-autoconfigure/README.md
================================================
# Embabel Agent Auto-Configuration

## Objective
Bootstrap beans defined in @**Configuration** artifacts for Spring Boot Application through annotation-driven profile activation.

## How It Works

The auto-configuration uses Spring profiles to conditionally load different agent configurations. The `EmbabelEnvironmentPostProcessor` runs early in the Spring Boot startup sequence to activate profiles based on annotations found on your application class.

## Auto-Configuration Types

1. **AgentPlatformAutoConfiguration** - bootstraps Agent Platform Configuration, Tools Group Configuration, and RAG Service Configuration

## Direct Usage of Auto-Configuration

Required dependency:
```xml
<dependency>
    <groupId>com.embabel.agent</groupId>
    <artifactId>embabel-agent-starter-platform</artifactId>
</dependency>
```

Example:
```java
@SpringBootApplication
@ImportAutoConfiguration(AgentPlatformAutoConfiguration.class)
public class AgentExampleApplication {
    // ...
}
```

## Annotation-Driven Auto-Configuration (Recommended)

The preferred approach uses annotations that automatically activate the necessary Spring profiles:

### Available Annotations

1. **@EnableAgentShell** - Activates "shell" profile for command-line agent applications
2. **@EnableAgentMCP** - Activates "mcp-server" profile for MCP server applications
3. **@EnableAgentBedrock** - Activates "bedrock" profile for AWS Bedrock agent applications
4. **@EnableAgents** - Generic annotation for fine-grained control over profiles

### Basic Examples

```java
@SpringBootApplication
@EnableAgentShell
public class ShellAgentApplication {
    public static void main(String[] args) {
        SpringApplication.run(ShellAgentApplication.class, args);
    }
}
```

### Advanced Configuration with @EnableAgents

The `@EnableAgents` annotation provides additional configuration options:

```java
import com.embabel.agent.config.annotation.LocalModels;
import com.embabel.agent.config.annotation.LoggingThemes;
import com.embabel.agent.config.annotation.McpServers;

@SpringBootApplication
@EnableAgents(
        loggingTheme = LoggingThemes.STAR_WARS,         // Activates "starwars" profile
        localModels =  {LocalModels.OLLAMA},            // Activates "ollama" profile
        mcpServers =   {McpServers.DOCKER_DESKTOP}      // Activates "filesystem" profile
)
public class CustomAgentApplication {
    public static void main(String[] args) {
        SpringApplication.run(CustomAgentApplication.class, args);
    }
}
```

### Combining Platform and Agent Annotations

```java
import com.embabel.agent.config.annotation.LocalModels;
import com.embabel.agent.config.annotation.LoggingThemes;
import com.embabel.agent.config.annotation.McpServers;

@SpringBootApplication
@EnableAgentShell                    // Activates "shell" profile
@EnableAgents(
        loggingTheme = LoggingThemes.STAR_WARS,         // Activates "starwars" profile
        localModels = {LocalModels.OLLAMA},             // Activates "ollama" and "llamacpp" profiles
        mcpServers = {McpServers.DOCKER_DESKTOP}        // Activates "docker" and "github" profiles
)
public class AdvancedAgentApplication { 
    public static void main(String[] args) {
        SpringApplication.run(AdvancedAgentApplication.class, args);
    }
}
```

## Profile Activation Order

The `EmbabelEnvironmentPostProcessor` activates profiles in the following order:

1. **Platform Profiles** - From `@AgentPlatform` or meta-annotations like `@EnableAgentShell`
2. **Logging Theme** - From `@EnableAgents(loggingTheme="...")`
3. **Local Models** - From `@EnableAgents(localModels={...})`
4. **MCP Servers** - From `@EnableAgents(mcpServers={...})`

## Available Logging Themes

When using `@EnableAgents`, you can specify a logging theme that changes the appearance of log output:

- `starwars` - Star Wars themed logging
- `severance` - Severance TV show themed logging
- Custom themes can be added by creating corresponding profile configurations

## Implementation Details

- The `EmbabelEnvironmentPostProcessor` runs with `HIGHEST_PRECEDENCE` to ensure profiles are activated before any beans are created
- Profiles are activated through both system properties (`spring.profiles.active`) and the Spring Environment API
- Existing profiles are preserved when new profiles are added
- The processor handles multiple application sources, though typically there's only one main class

## Notes

1. **Multiple platform annotations** - You can use multiple platform annotations (`@EnableAgentShell`, `@EnableAgentMCP`, etc.) on the same application class
2. **Annotation-driven approach is preferred** - We favor annotation-driven auto-configuration over direct `@ImportAutoConfiguration` usage for better flexibility and cleaner code
3. **Profile-based configuration** - All configurations are profile-based, allowing easy switching between different agent modes
4. **Empty annotations** - Using `@EnableAgents` with empty attributes (e.g., `loggingTheme = ""`) will not activate any profiles for those attributes


================================================
FILE: embabel-agent-autoconfigure/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-parent</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-autoconfigure</artifactId>
    <packaging>pom</packaging>
    <name>Embabel Agent Autoconfigurations</name>
    <description>Spring Boot Auto-Configurations for Embabel Agent API</description>
    
    <modules>
        <module>embabel-agent-platform-autoconfigure</module>
        <module>models/embabel-agent-bedrock-autoconfigure</module>
        <module>models/embabel-agent-openai-autoconfigure</module>
        <module>models/embabel-agent-anthropic-autoconfigure</module>
        <module>models/embabel-agent-ollama-autoconfigure</module>
        <module>models/embabel-agent-dockermodels-autoconfigure</module>
        <module>models/embabel-agent-deepseek-autoconfigure</module>
    </modules>

    <build>
        <plugins>
            <!-- Production Build Plugins -->
            <plugin>
                <groupId>org.jetbrains.kotlin</groupId>
                <artifactId>kotlin-maven-plugin</artifactId>
                <executions>
                    <execution>
                        <id>compile</id>
                        <phase>compile</phase>
                        <goals>
                            <goal>compile</goal>
                        </goals>
                        <configuration>
                            <sourceDirs>
                                <source>src/main/java</source>
                                <source>src/main/kotlin</source>
                                <source>target/generated-sources/annotations</source>
                            </sourceDirs>
                        </configuration>
                    </execution>
                    <execution>
                        <id>test-compile</id>
                        <phase>test-compile</phase>
                        <goals>
                            <goal>test-compile</goal>
                        </goals>
                        <configuration>
                            <sourceDirs>
                                <source>src/test/java</source>
                                <source>src/test/kotlin</source>
                                <source>target/generated-test-sources/test-annotations</source>
                            </sourceDirs>
                        </configuration>
                    </execution>
                    <execution>
                        <id>kapt</id>
                        <goals>
                            <goal>kapt</goal>
                        </goals>
                        <configuration>
                            <annotationProcessorPaths>
                                <path>
                                    <groupId>org.springframework.boot</groupId>
                                    <artifactId>spring-boot-configuration-processor</artifactId>
                                    <version>${spring-boot.version}</version>
                                </path>
                            </annotationProcessorPaths>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>

</project>



================================================
FILE: embabel-agent-autoconfigure/embabel-agent-platform-autoconfigure/README.md
================================================
# Embabel Agent Auto-Configuration

## Objective
Bootstrap beans defined in @**Configuration** artifacts for Spring Boot Application through annotation-driven profile activation.

## How It Works

The auto-configuration uses Spring profiles to conditionally load different agent configurations. The `EmbabelEnvironmentPostProcessor` runs early in the Spring Boot startup sequence to activate profiles based on annotations found on your application class.

## Auto-Configuration Types

1. **AgentPlatformAutoConfiguration** - bootstraps Agent Platform Configuration, Tools Group Configuration, and RAG Service Configuration

## Direct Usage of Auto-Configuration

Required dependency:
```xml
<dependency>
    <groupId>com.embabel.agent</groupId>
    <artifactId>embabel-agent-starter-platform</artifactId>
</dependency>
```

Example:
```java
@SpringBootApplication
@ImportAutoConfiguration(AgentPlatformAutoConfiguration.class)
public class AgentExampleApplication {
    // ...
}
```

## Annotation-Driven Auto-Configuration (Recommended)

The preferred approach uses annotations that automatically activate the necessary Spring profiles:

### Available Annotations

1. **@EnableAgentShell** - Activates "shell" profile for command-line agent applications
2. **@EnableAgentMCP** - Activates "mcp-server" profile for MCP server applications
3. **@EnableAgentBedrock** - Activates "bedrock" profile for AWS Bedrock agent applications
4. **@EnableAgents** - Generic annotation for fine-grained control over profiles

### Basic Examples

```java
@SpringBootApplication
@EnableAgentShell
public class ShellAgentApplication {
    public static void main(String[] args) {
        SpringApplication.run(ShellAgentApplication.class, args);
    }
}
```

### Advanced Configuration with @EnableAgents

The `@EnableAgents` annotation provides additional configuration options:

```java
import com.embabel.agent.config.annotation.LocalModels;
import com.embabel.agent.config.annotation.LoggingThemes;
import com.embabel.agent.config.annotation.McpServers;

@SpringBootApplication
@EnableAgents(
        loggingTheme = LoggingThemes.STAR_WARS,         // Activates "starwars" profile
        localModels =  {LocalModels.OLLAMA},            // Activates "ollama" profile
        mcpServers =   {McpServers.DOCKER_DESKTOP}      // Activates "filesystem" profile
)
public class CustomAgentApplication {
    public static void main(String[] args) {
        SpringApplication.run(CustomAgentApplication.class, args);
    }
}
```

### Combining Platform and Agent Annotations

```java
import com.embabel.agent.config.annotation.LocalModels;
import com.embabel.agent.config.annotation.LoggingThemes;
import com.embabel.agent.config.annotation.McpServers;

@SpringBootApplication
@EnableAgentShell                    // Activates "shell" profile
@EnableAgents(
        loggingTheme = LoggingThemes.STAR_WARS,         // Activates "starwars" profile
        localModels = {LocalModels.OLLAMA},             // Activates "ollama" and "llamacpp" profiles
        mcpServers = {McpServers.DOCKER_DESKTOP}        // Activates "docker" and "github" profiles
)
public class AdvancedAgentApplication { 
    public static void main(String[] args) {
        SpringApplication.run(AdvancedAgentApplication.class, args);
    }
}
```

## Profile Activation Order

The `EmbabelEnvironmentPostProcessor` activates profiles in the following order:

1. **Platform Profiles** - From `@AgentPlatform` or meta-annotations like `@EnableAgentShell`
2. **Logging Theme** - From `@EnableAgents(loggingTheme="...")`
3. **Local Models** - From `@EnableAgents(localModels={...})`
4. **MCP Servers** - From `@EnableAgents(mcpServers={...})`

## Available Logging Themes

When using `@EnableAgents`, you can specify a logging theme that changes the appearance of log output:

- `starwars` - Star Wars themed logging
- `severance` - Severance TV show themed logging
- Custom themes can be added by creating corresponding profile configurations

## Implementation Details

- The `EmbabelEnvironmentPostProcessor` runs with `HIGHEST_PRECEDENCE` to ensure profiles are activated before any beans are created
- Profiles are activated through both system properties (`spring.profiles.active`) and the Spring Environment API
- Existing profiles are preserved when new profiles are added
- The processor handles multiple application sources, though typically there's only one main class

## Notes

1. **Multiple platform annotations** - You can use multiple platform annotations (`@EnableAgentShell`, `@EnableAgentMCP`, etc.) on the same application class
2. **Annotation-driven approach is preferred** - We favor annotation-driven auto-configuration over direct `@ImportAutoConfiguration` usage for better flexibility and cleaner code
3. **Profile-based configuration** - All configurations are profile-based, allowing easy switching between different agent modes
4. **Empty annotations** - Using `@EnableAgents` with empty attributes (e.g., `loggingTheme = ""`) will not activate any profiles for those attributes


================================================
FILE: embabel-agent-autoconfigure/embabel-agent-platform-autoconfigure/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-autoconfigure</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-platform-autoconfigure</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent Autoconfiguration Platform</name>
    <description>Spring Boot Auto-Configuration platform for Embabel Agent API</description>

    <dependencies>
        <!-- Core API -->
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-api</artifactId>
        </dependency>

        <!-- Spring AI Auto Configurations required for all models -->
        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-autoconfigure-model-chat-observation</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-autoconfigure-model-chat-client</artifactId>
        </dependency>

        <!-- Move this one to a dedicated starter once ready-->
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-a2a</artifactId>
        </dependency>
    </dependencies>

</project>



================================================
FILE: embabel-agent-autoconfigure/embabel-agent-platform-autoconfigure/src/main/java/com/embabel/agent/autoconfigure/platform/AgentPlatformAutoConfiguration.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.autoconfigure.platform;


import com.embabel.agent.spi.config.spring.AgentPlatformConfiguration;
import com.embabel.agent.spi.config.spring.ToolGroupsConfiguration;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.autoconfigure.AutoConfiguration;
import org.springframework.context.annotation.Import;
import com.embabel.common.core.config.CommonPlatformPropertiesLoader;


/**
 * Bootstraps Agent Platform Configuration, Tools Configuration, and Rag Service Configuration
 */
@AutoConfiguration
@Import({CommonPlatformPropertiesLoader.class, ScanConfiguration.class, AgentPlatformConfiguration.class, ToolGroupsConfiguration.class,})
public class AgentPlatformAutoConfiguration {
    final private static Logger logger = LoggerFactory.getLogger(AgentPlatformAutoConfiguration.class);

    static {
        logger.info("AgentPlatformAutoConfiguration has been initialized.");
    }

    @PostConstruct
    public void logEvent() {
        logger.info("AgentPlatformAutoConfiguration about to be processed...");
    }
}



================================================
FILE: embabel-agent-autoconfigure/embabel-agent-platform-autoconfigure/src/main/java/com/embabel/agent/autoconfigure/platform/ScanConfiguration.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.autoconfigure.platform;

import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.context.properties.ConfigurationPropertiesScan;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;


/**
 * Spring Boot configuration class for component and configuration properties scanning.
 * <p>
 * Scans the following base packages for Spring components and configuration properties:
 * <ul>
 *   <li>com.embabel.agent</li>
 *   <li>com.embabel.example</li>
 * </ul>
 * This enables automatic bean registration and property binding for classes in these packages.
 */
@ConfigurationPropertiesScan(
        basePackages = {
                "com.embabel.agent"
        }
)
@ComponentScan(
        basePackages = {
                "com.embabel.agent"
        }
)
@Configuration
public class ScanConfiguration {

    final private Logger logger = LoggerFactory.getLogger(ScanConfiguration.class);

    @PostConstruct
    public void logEvent() {
        logger.info("ComponentConfiguration initialized: Scanning com.embabel.agent and com.embabel.example packages.");
    }

}



================================================
FILE: embabel-agent-autoconfigure/embabel-agent-platform-autoconfigure/src/main/java/com/embabel/agent/config/annotation/AgentPlatform.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.annotation;

import com.embabel.agent.autoconfigure.platform.AgentPlatformAutoConfiguration;
import com.embabel.agent.config.annotation.spi.EnvironmentPostProcessor;
import org.springframework.boot.autoconfigure.ImportAutoConfiguration;
import org.springframework.boot.context.properties.ConfigurationPropertiesScan;
import org.springframework.context.annotation.ComponentScan;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Core meta-annotation that enables the Embabel Agent platform infrastructure.
 *
 * <p>This annotation serves as the foundation for all agent-specific annotations
 * in the Embabel framework. It bootstraps the agent platform by importing necessary
 * auto-configuration, scanning for components, and activating platform-specific
 * Spring profiles.
 *
 * <h3>Primary Purpose:</h3>
 * <p>This is a <b>meta-annotation</b> designed to be used on other annotations rather
 * than directly on application classes. It provides the common configuration needed
 * by all agent platform variants (Shell, MCP Server, Bedrock, etc.).
 *
 * <h3>What This Annotation Does:</h3>
 * <ul>
 *   <li><b>Imports Auto-Configuration</b>: Loads {@link AgentPlatformAutoConfiguration}
 *       which sets up core agent infrastructure</li>
 *   <li><b>Scans Configuration Properties</b>: Discovers all {@code @ConfigurationProperties}
 *       classes in the {@code com.embabel.agent} package</li>
 *   <li><b>Component Scanning</b>: Registers all Spring components in the
 *       {@code com.embabel.agent.autoconfigure} package</li>
 *   <li><b>Profile Activation</b>: Activates Spring profiles based on the {@code value}
 *       attribute (e.g., "shell", "mcp-server", "bedrock")</li>
 * </ul>
 *
 * <h3>Usage as Meta-Annotation:</h3>
 * <pre>{@code
 * // Creating a custom agent annotation
 * @Retention(RetentionPolicy.RUNTIME)
 * @Target(ElementType.TYPE)
 * @AgentPlatform("my-platform")
 * public @interface EnableMyAgentPlatform {
 * }
 * }</pre>
 *
 * <h3>Direct Usage (Rare):</h3>
 * <pre>{@code
 * // Only for advanced customization
 * @SpringBootApplication
 * @AgentPlatform({"custom-profile-1", "custom-profile-2"})
 * public class CustomAgentApplication {
 * }
 * }</pre>
 *
 * <h3>Platform Profiles:</h3>
 * <p>The {@code value} attribute specifies which Spring profiles to activate:
 * <ul>
 *   <li>{@code "default"} - Basic agent platform without specific features</li>
 *   <li>{@code "shell"} - Interactive command-line interface mode</li>
 *   <li>{@code "mcp-server"} - Model Context Protocol server mode</li>
 *   <li>{@code "bedrock"} - AWS Bedrock integration mode</li>
 *   <li>{@code "a2a-server"} - Agent-to-Agent communication server</li>
 * </ul>
 *
 * <h3>Component Discovery:</h3>
 * <p>This annotation ensures the following are discovered and registered:
 * <ul>
 *   <li>All {@code @Agent} annotated classes</li>
 *   <li>Custom {@code @Tool} implementations</li>
 *   <li>Agent {@code @Repository} interfaces</li>
 *   <li>Configuration properties for agent behavior</li>
 *   <li>Auto-configuration classes for platform features</li>
 * </ul>
 *
 * <h3>Relationship to Other Annotations:</h3>
 * <p>This annotation is used as a building block by:
 * <ul>
 *   <li>{@link EnableAgentShell} - Adds {@code @AgentPlatform("shell")}</li>
 *   <li>{@link EnableAgentMcpServer} - Adds {@code @AgentPlatform("mcp-server")}</li>
 *   <li>{@link EnableAgentBedrock} - Adds {@code @AgentPlatform("shell, bedrock")}</li>
 *   <li>{@link EnableAgents} - Adds {@code @AgentPlatform} with default value</li>
 * </ul>
 *
 * <h3>Advanced Configuration:</h3>
 * <p>When multiple {@code @AgentPlatform} annotations are present (through meta-annotations),
 * their profiles are merged. For example:
 * <pre>{@code
 * @EnableAgentShell        // Contributes "shell"
 * @EnableAgentBedrock      // Contributes "shell, bedrock"
 * // Result: Profiles "shell" and "bedrock" are both active
 * }</pre>
 *
 * <h3>Implementation Note:</h3>
 * <p>The actual profile activation is handled by {@link EnvironmentPostProcessor}
 * which processes this annotation during the Spring Boot startup sequence.
 *
 * @see EnableAgentShell
 * @see EnableAgentMcpServer
 * @see EnableAgentBedrock
 * @see EnableAgents
 * @see AgentPlatformAutoConfiguration
 * @since 1.0
 * @author Embabel Team
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Deprecated(since = "0.1.3", forRemoval = true)
public @interface AgentPlatform {
    /**
     * Specifies the platform profiles to activate.
     *
     * <p>Each value in this array will be registered as an active Spring profile,
     * enabling platform-specific configurations and beans.
     *
     * <h4>Common Values:</h4>
     * <ul>
     *   <li>{@code "shell"} - Interactive CLI mode</li>
     *   <li>{@code "mcp-server"} - MCP protocol server</li>
     *   <li>{@code "bedrock"} - AWS Bedrock integration</li>
     * </ul>
     *
     * <h4>Multiple Profiles:</h4>
     * <p>Multiple profiles can be specified to combine features:
     * <pre>{@code
     * @AgentPlatform({"shell", "metrics", "observability"})
     * }</pre>
     *
     * @return array of profile names to activate
     */
    String[] value() default {};
}



================================================
FILE: embabel-agent-autoconfigure/embabel-agent-platform-autoconfigure/src/main/java/com/embabel/agent/config/annotation/EnableAgentMcpServer.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * @deprecated This annotation is deprecated in favor of embabel-agent-starter-mcpserver dependency.
 * <p>
 * <b>Migration paths:</b>
 * <br>If using embabel-agent-starter: Replace with embabel-agent-starter-mcpserver
 * <br>Remove this @EnableAgentMcpServer annotation from your application class
 * <p>
 * Agent Mcp Server capabilities will be auto-discovered through convention.
 * <p>
 * This annotation will be removed in version 0.2.0.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Deprecated(since = "0.1.2", forRemoval = true)
public @interface EnableAgentMcpServer {}



================================================
FILE: embabel-agent-autoconfigure/embabel-agent-platform-autoconfigure/src/main/java/com/embabel/agent/config/annotation/EnableAgents.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Enables the Embabel Agent framework with auto-configuration support.
 *
 * <p>This annotation triggers the import of agent-related configuration classes
 * and activates appropriate Spring profiles based on the specified attributes.
 * It serves as the foundation for more specialized annotations like
 * {@code @EnableAgentShell} and {@code @EnableAgentMcp}.
 *
 * <h3>Example Usage:</h3>
 * <pre>{@code
 * @SpringBootApplication
 * @EnableAgents(
 *     loggingTheme = "starwars",
 *     localModels = {"ollama", "docker"},
 *     mcpClients = {"filesystem", "github"}
 * )
 * public class MyAgentApplication {
 *     public static void main(String[] args) {
 *         SpringApplication.run(MyAgentApplication.class, args);
 *     }
 * }
 * }</pre>
 *
 * <h3>Profile Activation:</h3>
 * <p>This annotation activates Spring profiles based on the provided attributes:
 * <ul>
 *   <li>{@code loggingTheme} - Activates a theme-specific profile (e.g., "starwars", "severance")</li>
 *   <li>{@code localModels} - Activates profiles for local AI model providers</li>
 *   <li>{@code mcpClients} - Activates profiles for Model Context Protocol clients</li>
 * </ul>
 *
 * @author Embabel Team
 * @see AgentPlatform
 * @see EnableAgentShell
 * @see EnableAgentMcpServer
 * @since 0.1.0
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@AgentPlatform
public @interface EnableAgents {

    /**
     * Specifies the logging theme to use for agent operations.
     *
     * <p>If set, this activates a corresponding Spring profile that
     * customizes logging output with themed messages and formatting.
     *
     * <h4>Supported themes:</h4>
     * <ul>
     *   <li>{@code "starwars"} - Star Wars themed logging messages</li>
     *   <li>{@code "severance"} - Corporate/Severance themed logging</li>
     *   <li>{@code ""} (default) - Standard logging without theming</li>
     * </ul>
     *
     * <h4>Example:</h4>
     * <pre>{@code
     * @EnableAgents(loggingTheme = LoggingThemes.STAR_WARS)
     * // Outputs: "May the Force be with your agents!"
     * }</pre>
     *
     * @return the logging theme name, or empty string for default logging
     */
    String loggingTheme() default "";

    /**
     * Specifies local AI model providers to enable.
     *
     * <p>This attribute configures which local model providers should be
     * initialized and made available to agents. Each value activates a
     * corresponding Spring profile and loads provider-specific configuration.
     *
     * <h4>Common providers:</h4>
     * <ul>
     *   <li>{@code "ollama"} - Ollama local model server</li>
     *   <li>{@code "docker"} - Docker-based model containers</li>
     *   <li>{@code "llamacpp"} - LLaMA C++ implementation</li>
     * </ul>
     *
     * <h4>Example:</h4>
     * <pre>{@code
     * @EnableAgents(localModels = {LocalModels.OLLAMA, LocalModels.DOCKER"})
     * // Enables both Ollama and Docker-based models
     * }</pre>
     *
     * @return array of local model provider identifiers
     */
    @Deprecated(since = "0.1.3", forRemoval = true)
    String[] localModels() default {};

    /**
     * Specifies Model Context Protocol (MCP) clients to enable.
     *
     * <p>MCP clients allow agents to interact with external tools and
     * data sources through the standardized Model Context Protocol.
     * Each value activates a corresponding integration module.
     *
     * <h4>Example:</h4>
     * <pre>{@code
     * @EnableAgents(mcpClients = {"filesystem", "github", "postgres"})
     * // Enables file system, GitHub, and PostgresSQL MCP clients
     * }</pre>
     *
     * <h4>Security Note:</h4>
     * <p>Each MCP server specified may require additional configuration and
     * authentication. Ensure proper credentials are configured before
     * enabling clients.
     *
     * @return array of MCP server identifiers to enable and connect to
     */
    String[] mcpServers() default {};
}


================================================
FILE: embabel-agent-autoconfigure/embabel-agent-platform-autoconfigure/src/main/java/com/embabel/agent/config/annotation/EnableAgentShell.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * @deprecated This annotation is deprecated in favor of embabel-agent-starter-shell dependency.
 * <p>
 * <b>Migration paths:</b>
 * <br>If using embabel-agent-starter: Replace with embabel-agent-starter-shell
 * <br>Remove this @EnableAgentShell annotation from your application class
 * <p>
 * Agent shell capabilities will be auto-discovered through convention.
 * <p>
 * This annotation will be removed in version 0.2.0.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Deprecated(since = "0.1.2", forRemoval = true)
public @interface EnableAgentShell {}



================================================
FILE: embabel-agent-autoconfigure/embabel-agent-platform-autoconfigure/src/main/java/com/embabel/agent/config/annotation/LocalModels.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.annotation;

/**
 * Well-known local AI model providers for Embabel Agent applications.
 */
public class LocalModels {

    public static final String OLLAMA = "ollama";

    public static final String DOCKER = "docker";
}



================================================
FILE: embabel-agent-autoconfigure/embabel-agent-platform-autoconfigure/src/main/java/com/embabel/agent/config/annotation/LoggingThemes.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.annotation;

/**
 * Well-known logging themes for Embabel Agent applications.
 */
public class LoggingThemes {

    /**
     * loggingTheme value for Star Wars themed logging messages.
     */
    public static final String STAR_WARS = "starwars";

    /**
     * loggingTheme value for Severance themed logging messages.
     * Praise Kier
     * <a href="https://www.imdb.com/title/tt11280740/">Severance on IMDB</a>
     */
    public static final String SEVERANCE = "severance";

    /**
     * loggingTheme value for logging messages inspired by "Colossus: The Forbin Project"
     * Action will be taken!
     * <a href="https://www.imdb.com/title/tt0064177/">Colossus on IMDB</a>
     */
    public static final String COLOSSUS = "colossus";

}



================================================
FILE: embabel-agent-autoconfigure/embabel-agent-platform-autoconfigure/src/main/java/com/embabel/agent/config/annotation/McpServers.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.annotation;

/**
 * Well-known provides of MCP tools
 */
public class McpServers {

    public static final String DOCKER = "docker-ce";

    public static final String DOCKER_DESKTOP = "docker-desktop";
}



================================================
FILE: embabel-agent-autoconfigure/embabel-agent-platform-autoconfigure/src/main/java/com/embabel/agent/config/annotation/StartupMode.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.annotation;

public class StartupMode {

    public static final String SHELL = "shell";

    public static final String MCP_SERVER = "mcp-server";
}




================================================
FILE: embabel-agent-autoconfigure/embabel-agent-platform-autoconfigure/src/main/java/com/embabel/agent/config/annotation/spi/EnvironmentPostProcessor.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.annotation.spi;

import com.embabel.agent.config.annotation.AgentPlatform;
import com.embabel.agent.config.annotation.EnableAgents;
import com.embabel.common.util.WinUtils;
import org.apache.commons.lang3.ArrayUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.core.annotation.MergedAnnotations;
import org.springframework.core.env.ConfigurableEnvironment;

import java.util.Arrays;
import java.util.LinkedHashSet;
import java.util.Set;

/**
 * Environment post-processor that activates Spring profiles based on Embabel Agent annotations.
 *
 * <p>This processor runs very early in the Spring Boot startup sequence and examines
 * the application's main class for agent-related annotations. It then activates
 * corresponding Spring profiles to enable platform-specific configurations.
 *
 * <h3>Processing Order:</h3>
 * <ol>
 *   <li><b>Platform Profiles</b> - From {@code @AgentPlatform} or meta-annotations like {@code @EnableAgentShell}</li>
 *   <li><b>Logging Theme</b> - From {@code @EnableAgents(loggingTheme="...")}</li>
 *   <li><b>Local Models</b> - From {@code @EnableAgents(localModels={...})}</li>
 *   <li><b>MCP Servers</b> - From {@code @EnableAgents(mcpServers={...})}</li>
 * </ol>
 *
 * <h3>Profile Activation:</h3>
 * <p>Profiles are activated through two mechanisms:
 * <ul>
 *   <li>System property: {@code spring.profiles.active} - for compatibility</li>
 *   <li>Environment API: {@code environment.addActiveProfile()} - for direct activation</li>
 * </ul>
 *
 * <h3>Example:</h3>
 * <pre>{@code
 * @SpringBootApplication
 * @EnableAgentShell  // Activates "shell" profile
 * @EnableAgents(
 *     loggingTheme = LoggingThemes.START_WARS
 *     localModels = {LocalModels.OLAMA},
 *     mcpServer = {McpServers.DOCKER_DESKTOP}
 * )
 * public class MyApp {
 *     // Result: Application comes up with Start Wars Theme, Local Models for Ollama
 *     // and will try to connect to Docker Desktop MCP server.
 * }
 * }</pre>
 *
 * <h3>Implementation Notes:</h3>
 * <ul>
 *   <li>Runs with {@link Ordered#HIGHEST_PRECEDENCE} to ensure early execution</li>
 *   <li>Preserves existing profiles if already set</li>
 *   <li>Handles multiple application sources (though typically there's only one)</li>
 *   <li>Uses both annotation utils for proper meta-annotation support</li>
 * </ul>
 *
 * @author Embabel Team
 * @see EnableAgents
 * @see AgentPlatform
 * @see org.springframework.boot.env.EnvironmentPostProcessor
 * @since 1.0
 */
public class EnvironmentPostProcessor implements org.springframework.boot.env.EnvironmentPostProcessor, Ordered {

    private final Logger logger = LoggerFactory.getLogger(EnvironmentPostProcessor.class);

    private static final String SPRING_PROFILES_ACTIVE = "spring.profiles.active";

    static {
        if (WinUtils.IS_OS_WINDOWS()) {
            // Set console to UTF-8 on Windows and optimize font for Unicode display
            // This is necessary to display non-ASCII characters correctly
            WinUtils.CHCP_TO_UTF8();
            WinUtils.SETUP_OPTIMAL_CONSOLE();
        }
    }

    /**
     * Post-processes the environment to activate profiles based on agent annotations.
     *
     * @param environment the environment to post-process
     * @param application the Spring application
     */
    @Override
    public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
        // Use LinkedHashSet to maintain order and avoid duplicates
        var allProfiles = new LinkedHashSet<String>();

        // 1. Get platform profiles from @AgentPlatform
        var agentProfiles = findPlatformProfiles(application);
        if (agentProfiles.length > 0) {
            allProfiles.addAll(Arrays.asList(agentProfiles));
            logger.debug("Found platform profiles: {}", Arrays.toString(agentProfiles));
        }

        // 2. Get profile from loggingTheme
        var themeProfile = findLoggingTheme(application);
        if (themeProfile != null && !themeProfile.isEmpty()) {
            allProfiles.add(themeProfile);
            logger.info("Found loggingTheme '{}' - adding profile: {}", themeProfile, themeProfile);
        }

        // 3. Get profiles from localModels
        var localModelsProfiles = findLocalModels(application);
        if (ArrayUtils.isNotEmpty(localModelsProfiles)) {
            allProfiles.addAll(Arrays.asList(localModelsProfiles));
            logger.info("Found localModels - adding profiles: {}", Arrays.toString(localModelsProfiles));
        }

        // 4. Get profiles from mcpServers
        var mcpServerProfiles = findMcpServers(application);
        if (ArrayUtils.isNotEmpty(mcpServerProfiles)) {
            allProfiles.addAll(Arrays.asList(mcpServerProfiles));
            logger.info("Found mcpServers - adding profiles: {}", Arrays.toString(mcpServerProfiles));
        }

        // Apply all collected profiles
        if (!allProfiles.isEmpty()) {
            activateProfiles(environment, allProfiles);
        }
    }

    /**
     * Finds platform profiles from {@code @AgentPlatform} annotations.
     *
     * <p>This method handles both direct usage and meta-annotations
     * (e.g., {@code @EnableAgentShell} which has {@code @AgentPlatform("shell")}).
     *
     * @param application the Spring application
     * @return array of platform profile names, empty if none found
     */
    private String[] findPlatformProfiles(SpringApplication application) {
        var allPlatformProfiles = new LinkedHashSet<String>();

        for (Object source : application.getAllSources()) {
            if (source instanceof Class<?> clazz) {
                // Use MergedAnnotations to find ALL occurrences of @AgentPlatform
                MergedAnnotations annotations = MergedAnnotations.from(clazz);

                // Stream through all @AgentPlatform annotations (direct and meta)
                annotations.stream(AgentPlatform.class)
                        .forEach(mergedAnnotation -> {
                            String[] values = mergedAnnotation.getStringArray("value");
                            allPlatformProfiles.addAll(Arrays.asList(values));
                        });
            }
        }

        logger.debug("Collected all platform profiles: {}", allPlatformProfiles);
        return allPlatformProfiles.toArray(new String[0]);
    }

    /**
     * Finds the logging theme from {@code @EnableAgents} annotation.
     *
     * @param application the Spring application
     * @return logging theme name, or empty string if not specified
     */
    private String findLoggingTheme(SpringApplication application) {
        EnableAgents enableAgents = findEnableAgentsAnnotation(application);
        // Return theme or empty string to avoid null handling
        return enableAgents != null ? enableAgents.loggingTheme() : "";
    }

    /**
     * Finds local model profiles from {@code @EnableAgents} annotation.
     *
     * @param application the Spring application
     * @return array of local model names, empty if none specified
     */
    private String[] findLocalModels(SpringApplication application) {
        EnableAgents enableAgents = findEnableAgentsAnnotation(application);
        // Return array or empty array to avoid null
        return enableAgents != null ? enableAgents.localModels() : new String[0];
    }

    /**
     * Finds MCP server profile from {@code @EnableAgents} annotation.
     *
     * @param application the Spring application
     * @return array of MCP server names, empty if none specified
     */
    private String[] findMcpServers(SpringApplication application) {
        EnableAgents enableAgents = findEnableAgentsAnnotation(application);
        // Return array or empty array to avoid null
        return enableAgents != null ? enableAgents.mcpServers() : new String[0];
    }

    /**
     * Finds the {@code @EnableAgents} annotation on the application class.
     *
     * @param application the Spring application
     * @return the annotation instance, or null if not found
     */
    private EnableAgents findEnableAgentsAnnotation(SpringApplication application) {
        // Search through all sources for @EnableAgents
        for (Object source : application.getAllSources()) {
            if (source instanceof Class<?> clazz) {
                // Use AnnotationUtils to handle inheritance and interfaces
                EnableAgents enableAgents = AnnotationUtils.findAnnotation(clazz, EnableAgents.class);
                if (enableAgents != null) {
                    return enableAgents;
                }
            }
        }
        return null;
    }

    /**
     * Activates the collected profiles in both system properties and the environment.
     *
     * @param environment the Spring environment
     * @param profiles    the profiles to activate
     */
    private void activateProfiles(ConfigurableEnvironment environment, Set<String> profiles) {
        // Get existing profiles from system property
        String existingProfiles = System.getProperty(SPRING_PROFILES_ACTIVE);
        
        if (existingProfiles != null && !existingProfiles.isEmpty()) {
            // Merge with existing profiles, maintaining uniqueness
            var mergedProfiles = new LinkedHashSet<String>();
            // Add existing profiles first to maintain order
            mergedProfiles.addAll(Arrays.asList(existingProfiles.split(",")));
            // Add new profiles
            mergedProfiles.addAll(profiles);
            // Update environment
            mergedProfiles.forEach(environment::addActiveProfile);
        } else {
            profiles.forEach(environment::addActiveProfile);
        }


        // Log the final state for debugging
        logger.info("Activated Spring profiles: {}", (Object[]) environment.getActiveProfiles());
    }

    /**
     * Returns the order of this post-processor.
     *
     * @return {@link Ordered#HIGHEST_PRECEDENCE} to ensure early execution
     */
    @Override
    public int getOrder() {
        // Run as early as possible to ensure profiles are set before beans are created
        return Ordered.HIGHEST_PRECEDENCE;
    }
}


================================================
FILE: embabel-agent-autoconfigure/embabel-agent-platform-autoconfigure/src/main/resources/META-INF/spring.factories
================================================
org.springframework.boot.env.EnvironmentPostProcessor=com.embabel.agent.config.annotation.spi.EnvironmentPostProcessor



================================================
FILE: embabel-agent-autoconfigure/embabel-agent-platform-autoconfigure/src/main/resources/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports
================================================
com.embabel.agent.autoconfigure.platform.AgentPlatformAutoConfiguration


================================================
FILE: embabel-agent-autoconfigure/embabel-agent-platform-autoconfigure/src/test/java/com/embabel/agent/autoconfigure/platform/AgentPlatformAutoConfigurationIT.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.autoconfigure.platform;

import com.embabel.agent.config.annotation.AgentPlatform;
import com.embabel.agent.event.AgenticEventListener;
import com.embabel.agent.rag.RagService;
import com.embabel.agent.spi.Ranker;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.ImportAutoConfiguration;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.test.annotation.DirtiesContext;

/**
 * Java INTEGRATION test for AgentPlatformAutoConfiguration.
 * Test employs OPEN API KEY.
 *
 */
@SpringBootTest(classes= AgentPlatformAutoConfigurationIT.class)
@ComponentScan(basePackages = "com.embabel.agent.autoconfigure")
@ImportAutoConfiguration(classes = {AgentPlatformAutoConfiguration.class})
@AgentPlatform("my-domain")
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS)
class AgentPlatformAutoConfigurationIT {


    @Autowired
    private AgenticEventListener eventListener;

    @Autowired
    private Ranker ranker;

    @Autowired
    private RagService defaultSpringVectorStore;

    @BeforeEach
    void setUp() {
    }


    @AfterEach
    void tearDown() {
    }


    @Test
    public void testAutoConfiguredBeanPresence() {
        Assertions.assertNotNull(eventListener, "Event Listener should be Auto-Configured");
        Assertions.assertNotNull(ranker, "Ranker should be Auto-Configured");
        Assertions.assertNotNull(defaultSpringVectorStore, "RagService should be Auto-Configured");

    }


}


================================================
FILE: embabel-agent-autoconfigure/embabel-agent-platform-autoconfigure/src/test/java/com/embabel/agent/config/annotation/EnableAgentsAnnotationIT.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.annotation;

import com.embabel.agent.event.AgenticEventListener;
import com.embabel.agent.rag.RagService;
import com.embabel.agent.spi.Ranker;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.condition.EnabledIfEnvironmentVariable;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.ApplicationContext;
import org.springframework.core.env.Environment;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.context.TestPropertySource;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Integration test for AgentPlatformAutoConfiguration via @EnableAgents annotation.
 *
 * <p>This test verifies that the @EnableAgents annotation properly:
 * <ul>
 *   <li>Activates the agent platform auto-configuration</li>
 *   <li>Registers required beans in the application context</li>
 *   <li>Sets up appropriate Spring profiles</li>
 * </ul>
 *
 * <p>Note: This test requires OPENAI_API_KEY to be set as an environment variable.
 */
@SpringBootTest
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS)
@EnabledIfEnvironmentVariable(named = "OPENAI_API_KEY", matches = ".+",
        disabledReason = "Integration test requires OPENAI_API_KEY")
@TestPropertySource(properties = {
        "spring.main.lazy-initialization=true",
        "logging.level.com.embabel=DEBUG"
})
@DisplayName("EnableAgents Annotation Integration Test")
class EnableAgentsAnnotationIT {

    @Autowired
    private ApplicationContext context;

    @Autowired
    private Environment environment;

    @Autowired
    private AgenticEventListener eventListener;

    @Autowired
    private Ranker ranker;

    @Autowired
    private RagService defaultSpringVectorStore;

    @Test
    @DisplayName("Should auto-configure all required agent platform beans")
    void testAutoConfiguredBeanPresence() {
        // Verify core beans are present
        assertThat(eventListener)
                .as("AgenticEventListener should be auto-configured")
                .isNotNull();

        assertThat(ranker)
                .as("Ranker should be auto-configured")
                .isNotNull();

        assertThat(defaultSpringVectorStore)
                .as("RagService should be auto-configured")
                .isNotNull();
    }

    @Test
    @DisplayName("Should register agent platform configuration beans")
    void testAgentPlatformConfigurationBeans() {
        // Verify that agent platform specific beans are registered
        assertThat(context.containsBean("agentPlatformAutoConfiguration"))
                .as("AgentPlatformAutoConfiguration should be registered")
                .isTrue();

        // Verify component scanning worked
        String[] beanNames = context.getBeanDefinitionNames();
        assertThat(beanNames)
                .as("Should contain agent-related beans")
                .anyMatch(name -> name.contains("agent") || name.contains("Agent"));
    }

    @Test
    @DisplayName("Should configure agent platform with additional attributes")
    void testEnableAgentsWithAttributes() {
        // This would test a configuration with attributes
        // Currently @EnableAgents has default values, but this shows how to test them

        // For example, if @EnableAgents had attributes:
        // - loggingTheme: verify theme profile is active
        // - localModels: verify model profiles are active

        // Since the test class uses @EnableAgents with defaults,
        // we just verify the base configuration works
        assertThat(context).isNotNull();
    }

    /**
     * Test configuration class that simulates a Spring Boot application.
     * This is nested to avoid conflicts with other test configurations.
     */
    @SpringBootApplication
    @EnableAgents
    static class TestApplication {
        // Empty - just provides application context for testing
    }
}

/**
 * Additional test class to verify @EnableAgents with custom attributes.
 */
@SpringBootTest
@DirtiesContext
@EnabledIfEnvironmentVariable(named = "OPENAI_API_KEY", matches = ".+")
@DisplayName("EnableAgents with Custom Attributes Test")
class EnableAgentsWithAttributesIT {

    @Autowired
    private Environment environment;

    @Test
    @DisplayName("Should activate profiles from annotation attributes")
    void testCustomAttributeProfiles() {
        String[] activeProfiles = environment.getActiveProfiles();

        // Verify all expected profiles are active
        assertThat(activeProfiles)
                .as("Should contain all configured profiles")
                .contains(
                        LoggingThemes.STAR_WARS,       // From loggingTheme
                        LocalModels.OLLAMA,            // From localModels
                        McpServers.DOCKER_DESKTOP      // From mcpClients
                );
    }

    @SpringBootApplication
    @EnableAgents(
            loggingTheme = LoggingThemes.STAR_WARS,
            localModels = {LocalModels.OLLAMA},
            mcpServers = {McpServers.DOCKER_DESKTOP}
    )
    static class CustomAttributesTestApplication {
        // Configuration with custom attributes
    }
}


================================================
FILE: embabel-agent-autoconfigure/embabel-agent-platform-autoconfigure/src/test/java/com/embabel/agent/config/annotation/spi/EnvironmentPostProcessorTest.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.annotation.spi;

import com.embabel.agent.config.annotation.*;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.boot.SpringApplication;
import org.springframework.mock.env.MockEnvironment;

import java.util.Arrays;
import java.util.Set;
import java.util.stream.Collectors;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

class EnvironmentPostProcessorTest {

    private EnvironmentPostProcessor processor;
    private MockEnvironment environment;
    private SpringApplication application;
    private String originalProfilesProperty;

    @BeforeEach
    void setUp() {
        processor = new EnvironmentPostProcessor();
        environment = new MockEnvironment();
        application = mock(SpringApplication.class);

        // Save and clear system property
        originalProfilesProperty = System.getProperty("spring.profiles.active");
        System.clearProperty("spring.profiles.active");
    }

    @AfterEach
    void tearDown() {
        // Restore system property
        if (originalProfilesProperty != null) {
            System.setProperty("spring.profiles.active", originalProfilesProperty);
        } else {
            System.clearProperty("spring.profiles.active");
        }
    }

    @Test
    void testNoAnnotations() {
        // Given
        class TestApp {
        }
        when(application.getAllSources()).thenReturn(Set.of(TestApp.class));

        // When
        processor.postProcessEnvironment(environment, application);

        // Then
        assertThat(getAddedProfiles()).isEmpty();
        assertThat(System.getProperty("spring.profiles.active")).isNull();
    }

    @Test
    void testEnableAgentsWithLoggingTheme() {
        // Given
        @EnableAgents(loggingTheme = "starwars")
        class TestApp {
        }
        when(application.getAllSources()).thenReturn(Set.of(TestApp.class));

        // When
        processor.postProcessEnvironment(environment, application);

        // Then
        assertThat(getAddedProfiles()).containsExactly(LoggingThemes.STAR_WARS);
    }

    @Test
    void testEnableAgentsWithLocalModels() {
        // Given
        @EnableAgents(localModels = {LocalModels.OLLAMA, LocalModels.DOCKER})
        class TestApp {
        }
        when(application.getAllSources()).thenReturn(Set.of(TestApp.class));

        // When
        processor.postProcessEnvironment(environment, application);

        // Then
        assertThat(getAddedProfiles()).containsExactlyInAnyOrder(LocalModels.OLLAMA, LocalModels.DOCKER);
    }

    @Test
    void testEnableAgentsWithMcpServers() {
        // Given
        @EnableAgents(mcpServers = {McpServers.DOCKER_DESKTOP})
        class TestApp {
        }
        when(application.getAllSources()).thenReturn(Set.of(TestApp.class));

        // When
        processor.postProcessEnvironment(environment, application);

        // Then
        assertThat(getAddedProfiles()).containsExactlyInAnyOrder(McpServers.DOCKER_DESKTOP);
    }

    @Test
    void testCombinedAnnotations() {
        // Given
        @EnableAgents(
                loggingTheme = LoggingThemes.STAR_WARS,
                localModels = {LocalModels.OLLAMA},
                mcpServers = {McpServers.DOCKER_DESKTOP}
        )
        class TestApp {
        }
        when(application.getAllSources()).thenReturn(Set.of(TestApp.class));

        // When
        processor.postProcessEnvironment(environment, application);

        // Then
        assertThat(getAddedProfiles())
                .containsExactlyInAnyOrder(LoggingThemes.STAR_WARS, LocalModels.OLLAMA, McpServers.DOCKER_DESKTOP);
    }

    @Test
    void testPreservesExistingProfiles() {
        // Given
        System.setProperty("spring.profiles.active", "existing,profiles");

        @EnableAgents(loggingTheme = LoggingThemes.STAR_WARS)
        class TestApp {
        }
        when(application.getAllSources()).thenReturn(Set.of(TestApp.class));

        // When
        processor.postProcessEnvironment(environment, application);

        // Then
        assertThat(getAddedProfiles()).containsExactlyInAnyOrder("existing", "profiles", LoggingThemes.STAR_WARS);

    }

    @Test
    void testEmptyEnableAgents() {
        // Given
        @EnableAgents(loggingTheme = "", localModels = {}, mcpServers = {})
        class TestApp {
        }
        when(application.getAllSources()).thenReturn(Set.of(TestApp.class));

        // When
        processor.postProcessEnvironment(environment, application);

        // Then
        assertThat(getAddedProfiles()).isEmpty();
        assertThat(System.getProperty("spring.profiles.active")).isNull();
    }

    @Test
    void testEmptyProfiles() {
        class TestApp {
        }
        when(application.getAllSources()).thenReturn(Set.of(TestApp.class));

        // When
        processor.postProcessEnvironment(environment, application);

        // Then
        assertThat(getAddedProfiles()).isEmpty();
        assertThat(System.getProperty("spring.profiles.active")).isNull();
    }

    @Test
    void testHighestPrecedenceOrder() {
        assertThat(processor.getOrder()).isEqualTo(Integer.MIN_VALUE);
    }

    /**
     * Helper method to get only the profiles added by our processor,
     */
    private Set<String> getAddedProfiles() {
        return Arrays.stream(environment.getActiveProfiles())
                .collect(Collectors.toSet());
    }
}


================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-anthropic-autoconfigure/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-autoconfigure</artifactId>
        <version>0.2.0-SNAPSHOT</version>
        <relativePath>../../pom.xml</relativePath>
    </parent>
    <artifactId>embabel-agent-anthropic-autoconfigure</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent Autoconfiguration Models Anthropic</name>
    <description>Anthropic Models for Embabel Agent API</description>

    <dependencies>
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-api</artifactId>
        </dependency>

        <dependency>
           <groupId>org.springframework.ai</groupId>
           <artifactId>spring-ai-anthropic</artifactId>
        </dependency>

        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-test-internal</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

</project>



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-anthropic-autoconfigure/src/main/java/com/embabel/agent/autoconfigure/models/anthropic/AgentAnthropicAutoConfiguration.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.autoconfigure.models.anthropic;

import com.embabel.agent.config.models.anthropic.AnthropicModelsConfig;
import org.springframework.boot.autoconfigure.AutoConfiguration;
import org.springframework.boot.autoconfigure.AutoConfigureBefore;
import org.springframework.context.annotation.Import;

/**
 * Autoconfiguration for Anthropic AI models in the Embabel Agent system.
 * <p>
 * This class serves as a Spring Boot autoconfiguration entry point that:
 * - Scans for configuration properties in the "com.embabel.agent" package
 * - Imports the [AnthropicModels] configuration to register Anthropic model beans
 * <p>
 * The configuration is automatically activated when the Anthropic models
 * dependencies are present on the classpath.
 */
@AutoConfiguration
@AutoConfigureBefore(name = {"com.embabel.agent.autoconfigure.platform.AgentPlatformAutoConfiguration"})
@Import(AnthropicModelsConfig.class)
public class AgentAnthropicAutoConfiguration {
}



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-anthropic-autoconfigure/src/main/kotlin/com/embabel/agent/config/models/anthropic/AnthropicModelLoader.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.models.anthropic

import com.embabel.common.ai.autoconfig.AbstractYamlModelLoader
import com.embabel.common.ai.autoconfig.LlmAutoConfigMetadata
import com.embabel.common.ai.autoconfig.LlmAutoConfigProvider
import com.embabel.common.ai.model.PerTokenPricingModel
import org.springframework.core.io.DefaultResourceLoader
import org.springframework.core.io.ResourceLoader
import java.time.LocalDate

/**
 * Container for Anthropic model definitions loaded from YAML.
 *
 * Implements [LlmAutoConfigProvider] to supply Anthropic-specific model metadata
 * for auto-configuration purposes.
 *
 * @property models list of Anthropic model definitions
 */
data class AnthropicModelDefinitions(
    override val models: List<AnthropicModelDefinition> = emptyList()
) : LlmAutoConfigProvider<AnthropicModelDefinition>

/**
 * Anthropic-specific model definition.
 *
 * Implements [LlmAutoConfigMetadata] with Anthropic-specific features
 * like thinking mode and custom parameter defaults.
 *
 * @property name the unique name of the model
 * @property modelId the Anthropic API model identifier
 * @property displayName optional human-readable name
 * @property knowledgeCutoffDate optional knowledge cutoff date
 * @property pricingModel optional per-token pricing information
 * @property maxTokens maximum tokens for completion (default 8192)
 * @property temperature sampling temperature (default 1.0)
 * @property topP nucleus sampling parameter
 * @property topK top-k sampling parameter
 * @property thinking optional thinking mode configuration
 */
data class AnthropicModelDefinition(
    override val name: String,
    override val modelId: String,
    override val displayName: String? = null,
    override val knowledgeCutoffDate: LocalDate? = null,
    override val pricingModel: PerTokenPricingModel? = null,
    val maxTokens: Int = 8192,
    val temperature: Double = 1.0,
    val topP: Double? = null,
    val topK: Int? = null,
    val thinking: ThinkingConfiguration? = null,
) : LlmAutoConfigMetadata

/**
 * Configuration for Anthropic's extended thinking mode.
 *
 * @property tokenBudget maximum tokens allocated for thinking
 */
data class ThinkingConfiguration(
    val tokenBudget: Int? = null
)

/**
 * Loader for Anthropic model definitions from YAML configuration.
 *
 * Reads model metadata from the configured resource path (default: `classpath:models/anthropic-models.yml`)
 * and deserializes it into [AnthropicModelDefinitions]. Validates loaded models to ensure data integrity.
 *
 * @property resourceLoader Spring resource loader for accessing classpath resources
 * @property configPath path to the YAML configuration file
 */
class AnthropicModelLoader(
    resourceLoader: ResourceLoader = DefaultResourceLoader(),
    configPath: String = DEFAULT_CONFIG_PATH
) : AbstractYamlModelLoader<AnthropicModelDefinitions>(resourceLoader, configPath) {

    override fun getProviderClass() = AnthropicModelDefinitions::class

    override fun createEmptyProvider() = AnthropicModelDefinitions()

    override fun getProviderName() = "Anthropic"

    override fun validateModels(provider: AnthropicModelDefinitions) {
        provider.models.forEach { model ->
            validateCommonFields(model)
            require(model.maxTokens > 0) { "Max tokens must be positive for model ${model.name}" }
            require(model.temperature in 0.0..2.0) {
                "Temperature must be between 0 and 2 for model ${model.name}"
            }
            model.topP?.let {
                require(it in 0.0..1.0) { "Top P must be between 0 and 1 for model ${model.name}" }
            }
            model.topK?.let {
                require(it > 0) { "Top K must be positive for model ${model.name}" }
            }
            model.thinking?.tokenBudget?.let {
                require(it > 0) { "Thinking token budget must be positive for model ${model.name}" }
            }
        }
    }

    companion object {
        /**
         * Default path to the Anthropic models YAML configuration file.
         */
        private const val DEFAULT_CONFIG_PATH = "classpath:models/anthropic-models.yml"
    }
}



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-anthropic-autoconfigure/src/main/kotlin/com/embabel/agent/config/models/anthropic/AnthropicModelsConfig.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.models.anthropic

import com.embabel.agent.common.RetryProperties
import com.embabel.agent.api.models.AnthropicModels
import com.embabel.common.ai.autoconfig.LlmAutoConfigMetadataLoader
import com.embabel.common.ai.model.Llm
import com.embabel.common.ai.model.LlmOptions
import com.embabel.common.ai.model.OptionsConverter
import com.embabel.common.ai.model.PerTokenPricingModel
import com.embabel.common.util.ExcludeFromJacocoGeneratedReport
import io.micrometer.observation.ObservationRegistry
import jakarta.annotation.PostConstruct
import org.slf4j.LoggerFactory
import org.springframework.ai.anthropic.AnthropicChatModel
import org.springframework.ai.anthropic.AnthropicChatOptions
import org.springframework.ai.anthropic.api.AnthropicApi
import org.springframework.ai.model.tool.ToolCallingManager
import org.springframework.beans.factory.ObjectProvider
import org.springframework.beans.factory.annotation.Value
import org.springframework.beans.factory.config.ConfigurableBeanFactory
import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.context.annotation.Configuration
import org.springframework.web.client.RestClient
import org.springframework.web.reactive.function.client.WebClient
import java.time.LocalDate


/**
 * Configuration properties for Anthropic models.
 * These properties are bound from the Spring configuration with the prefix
 * "embabel.agent.platform.models.anthropic" and control retry behavior
 * when calling Anthropic APIs.
 */
@ConfigurationProperties(prefix = "embabel.agent.platform.models.anthropic")
class AnthropicProperties : RetryProperties {
    /**
     *  Maximum number of attempts.
     */
    override var maxAttempts: Int = 10

    /**
     * Initial backoff interval (in milliseconds).
     */
    override var backoffMillis: Long = 5000L

    /**
     * Backoff interval multiplier.
     */
    override var backoffMultiplier: Double = 5.0

    /**
     * Maximum backoff interval (in milliseconds).
     */
    override var backoffMaxInterval: Long = 180000L
}


/**
 * Configuration class for Anthropic models.
 * This class provides beans for various Claude models (Opus, Sonnet, Haiku)
 * and handles the creation of Anthropic API clients with proper authentication.
 */
@Configuration(proxyBeanMethods = false)
@ExcludeFromJacocoGeneratedReport(reason = "Anthropic configuration can't be unit tested")
class AnthropicModelsConfig(
    @param:Value("\${ANTHROPIC_BASE_URL:}")
    private val baseUrl: String,
    @param:Value("\${ANTHROPIC_API_KEY}")
    private val apiKey: String,
    private val properties: AnthropicProperties,
    private val observationRegistry: ObjectProvider<ObservationRegistry>,
    private val configurableBeanFactory: ConfigurableBeanFactory,
    private val modelLoader: LlmAutoConfigMetadataLoader<AnthropicModelDefinitions> = AnthropicModelLoader(),
) {
    private val logger = LoggerFactory.getLogger(AnthropicModelsConfig::class.java)

    init {
        logger.info("Anthropic models are available: {}", properties)
    }

    @PostConstruct
    fun registerModelBeans() {
        modelLoader
            .loadAutoConfigMetadata().models.forEach { modelDef ->
                try {
                    val llm = createAnthropicLlm(modelDef)

                    // Register as singleton bean with the configured bean name
                    configurableBeanFactory.registerSingleton(modelDef.name, llm)

                    logger.info(
                        "Registered Anthropic model bean: {} -> {}",
                        modelDef.name, modelDef.modelId
                    )

                } catch (e: Exception) {
                    logger.error(
                        "Failed to create model: {} ({})",
                        modelDef.name, modelDef.modelId, e
                    )
                    throw e
                }
            }
    }

    /**
     * Creates an individual Anthropic model from configuration.
     */
    private fun createAnthropicLlm(modelDef: AnthropicModelDefinition): Llm {
        val chatModel = AnthropicChatModel
            .builder()
            .defaultOptions(createDefaultOptions(modelDef))
            .anthropicApi(createAnthropicApi())
            .toolCallingManager(
                ToolCallingManager.builder()
                    .observationRegistry(observationRegistry.getIfUnique { ObservationRegistry.NOOP })
                    .build()
            )
            .retryTemplate(properties.retryTemplate("anthropic-${modelDef.modelId}"))
            .observationRegistry(observationRegistry.getIfUnique { ObservationRegistry.NOOP })
            .build()

        return Llm(
            name = modelDef.modelId,
            model = chatModel,
            provider = AnthropicModels.PROVIDER,
            optionsConverter = AnthropicOptionsConverter,
            knowledgeCutoffDate = modelDef.knowledgeCutoffDate,
            pricingModel = modelDef.pricingModel?.let {
                PerTokenPricingModel(
                    usdPer1mInputTokens = it.usdPer1mInputTokens,
                    usdPer1mOutputTokens = it.usdPer1mOutputTokens,
                )
            }
        )
    }

    /**
     * Creates default options for a model based on YAML configuration.
     */
    private fun createDefaultOptions(modelDef: AnthropicModelDefinition): AnthropicChatOptions {
        return AnthropicChatOptions.builder()
            .model(modelDef.modelId)
            .maxTokens(modelDef.maxTokens)
            .temperature(modelDef.temperature)
            .apply {
                modelDef.topP?.let { topP(it) }
                modelDef.topK?.let { topK(it) }

                // Configure thinking mode if specified
                modelDef.thinking?.let { thinkingConfig ->
                    thinking(
                        AnthropicApi.ChatCompletionRequest.ThinkingConfig(
                            AnthropicApi.ThinkingType.ENABLED,
                            thinkingConfig.tokenBudget
                        )
                    )
                } ?: thinking(
                    AnthropicApi.ChatCompletionRequest.ThinkingConfig(
                        AnthropicApi.ThinkingType.DISABLED,
                        null
                    )
                )
            }
            .build()
    }

    private fun anthropicLlmOf(
        name: String,
        knowledgeCutoffDate: LocalDate?,
    ): Llm {
        val chatModel = AnthropicChatModel
            .builder()
            .defaultOptions(
                AnthropicChatOptions.builder()
                    .model(name)
                    .build()
            )
            .anthropicApi(createAnthropicApi())
            .toolCallingManager(
                ToolCallingManager.builder()
                    .observationRegistry(observationRegistry.getIfUnique { ObservationRegistry.NOOP })
                    .build()
            )
            .retryTemplate(properties.retryTemplate("anthropic-$name"))
            .observationRegistry(observationRegistry.getIfUnique { ObservationRegistry.NOOP })
            .build()

        return Llm(
            name = name,
            model = chatModel,
            provider = AnthropicModels.PROVIDER,
            optionsConverter = AnthropicOptionsConverter,
            knowledgeCutoffDate = knowledgeCutoffDate,
        )
    }

    private fun createAnthropicApi(): AnthropicApi {
        val builder = AnthropicApi.builder().apiKey(apiKey)
        if (baseUrl.isNotBlank()) {
            logger.info("Using custom Anthropic base URL: {}", baseUrl)
            builder.baseUrl(baseUrl)
        }
        // add observation registry to rest and web client builders
        builder
            .restClientBuilder(
                RestClient.builder()
                    .observationRegistry(observationRegistry.getIfUnique { ObservationRegistry.NOOP })
            )
        builder
            .webClientBuilder(
                WebClient.builder()
                    .observationRegistry(observationRegistry.getIfUnique { ObservationRegistry.NOOP })
            )

        return builder.build()
    }

}

object AnthropicOptionsConverter : OptionsConverter<AnthropicChatOptions> {

    /**
     * Anthropic's default is too low and results in truncated responses.
     */
    const val DEFAULT_MAX_TOKENS = 8192

    override fun convertOptions(options: LlmOptions): AnthropicChatOptions =
        AnthropicChatOptions.builder()
            .temperature(options.temperature)
            .topP(options.topP)
            .maxTokens(options.maxTokens ?: DEFAULT_MAX_TOKENS)
            .thinking(
                if (options.thinking?.enabled == true) AnthropicApi.ChatCompletionRequest.ThinkingConfig(
                    AnthropicApi.ThinkingType.ENABLED,
                    options.thinking!!.tokenBudget,
                ) else AnthropicApi.ChatCompletionRequest.ThinkingConfig(
                    AnthropicApi.ThinkingType.DISABLED,
                    null,
                )
            )
            .topK(options.topK)
            .build()
}



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-anthropic-autoconfigure/src/main/resources/models/anthropic-models.yml
================================================
# ============================================
# anthropic-models.yml
# ============================================
# Updated with latest Anthropic models as of October 2025
# Using official Anthropic API aliases

models:
  # ========================================
  # CLAUDE 4.5 FAMILY (Latest Generation)
  # ========================================

  # Claude Sonnet 4.5 - Best coding model, flagship for general use
  - name: "claude_sonnet_45"
    model_id: "claude-sonnet-4-5"
    display_name: "Claude Sonnet 4.5"
    knowledge_cutoff_date: "2025-01-01"
    max_tokens: 8192
    pricing_model:
      usd_per1m_input_tokens: 3.0
      usd_per1m_output_tokens: 15.0

  # Claude Haiku 4.5 - Fast, cost-efficient with near-frontier performance
  - name: "claude_haiku_45"
    model_id: "claude-haiku-4-5"
    display_name: "Claude Haiku 4.5"
    knowledge_cutoff_date: "2025-02-01"
    max_tokens: 8192
    pricing_model:
      usd_per1m_input_tokens: 1.0
      usd_per1m_output_tokens: 5.0

  # ========================================
  # CLAUDE 4 FAMILY (Current Generation)
  # ========================================

  # Claude Opus 4.1 - Most powerful for complex reasoning tasks
  - name: "claude_opus_41"
    model_id: "claude-opus-4-1"
    display_name: "Claude Opus 4.1"
    knowledge_cutoff_date: "2025-01-01"
    max_tokens: 8192
    pricing_model:
      usd_per1m_input_tokens: 15.0
      usd_per1m_output_tokens: 75.0

  # Claude Sonnet 4 - General purpose, large context window
  - name: "claude_sonnet_4"
    model_id: "claude-sonnet-4-0"
    display_name: "Claude Sonnet 4"
    knowledge_cutoff_date: "2025-01-01"
    max_tokens: 8192
    pricing_model:
      usd_per1m_input_tokens: 3.0
      usd_per1m_output_tokens: 15.0

  # ========================================
  # LEGACY MODELS (For Backward Compatibility)
  # ========================================

  # Claude Opus 4.0 - Legacy flagship model
  - name: "claude_opus_40"
    model_id: "claude-opus-4-0"
    display_name: "Claude Opus 4.0"
    knowledge_cutoff_date: "2025-03-31"
    max_tokens: 8192
    pricing_model:
      usd_per1m_input_tokens: 15.0
      usd_per1m_output_tokens: 75.0

  # Claude 3.7 Sonnet - Hybrid reasoning model (being phased out)
  - name: "claude_sonnet_37"
    model_id: "claude-3-7-sonnet-latest"
    display_name: "Claude 3.7 Sonnet"
    knowledge_cutoff_date: "2024-10-31"
    max_tokens: 8192
    pricing_model:
      usd_per1m_input_tokens: 3.0
      usd_per1m_output_tokens: 15.0

  # Claude 3.5 Haiku - Legacy fast model (replaced by Haiku 4.5)
  - name: "claude_haiku_35"
    model_id: "claude-3-5-haiku-latest"
    display_name: "Claude 3.5 Haiku"
    knowledge_cutoff_date: "2024-10-22"
    max_tokens: 8192
    pricing_model:
      usd_per1m_input_tokens: 0.80
      usd_per1m_output_tokens: 4.0


================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-anthropic-autoconfigure/src/test/kotlin/com/embabel/agent/config/models/anthropic/AnthropicModelLoaderTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.models.anthropic

import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Test
import org.springframework.core.io.DefaultResourceLoader
import java.io.File
import java.nio.file.Files

class AnthropicModelLoaderTest {

    @Test
    fun `should load valid model definitions from default YAML file`() {
        // Arrange
        val loader = AnthropicModelLoader()

        // Act
        val result = loader.loadAutoConfigMetadata()

        // Assert
        assertNotNull(result)
        assertTrue(result.models.isNotEmpty(), "Should load at least one model")

        // Verify first model has required fields
        val firstModel = result.models.first()
        assertNotNull(firstModel.name)
        assertNotNull(firstModel.modelId)
        assertTrue(firstModel.name.isNotBlank(), "Model name should not be blank")
        assertTrue(firstModel.modelId.isNotBlank(), "Model ID should not be blank")
    }

    @Test
    fun `should validate all loaded models have correct default values`() {
        // Arrange
        val loader = AnthropicModelLoader()

        // Act
        val result = loader.loadAutoConfigMetadata()

        // Assert
        result.models.forEach { model ->
            // Verify defaults
            assertTrue(model.maxTokens > 0, "Max tokens should be positive for ${model.name}")
            assertTrue(model.temperature in 0.0..2.0, "Temperature should be in valid range for ${model.name}")

            // Verify optional fields when present
            model.topP?.let {
                assertTrue(it in 0.0..1.0, "Top P should be between 0 and 1 for ${model.name}")
            }
            model.topK?.let {
                assertTrue(it > 0, "Top K should be positive for ${model.name}")
            }
            model.thinking?.tokenBudget?.let {
                assertTrue(it > 0, "Thinking token budget should be positive for ${model.name}")
            }
        }
    }

    @Test
    fun `should verify specific known models are loaded`() {
        // Arrange
        val loader = AnthropicModelLoader()

        // Act
        val result = loader.loadAutoConfigMetadata()

        // Assert - verify some known Anthropic models are present
        val modelNames = result.models.map { it.name }
        assertTrue(modelNames.isNotEmpty(), "Should have loaded model names")

        // Verify at least one model has pricing info
        assertTrue(result.models.any { it.pricingModel != null },
            "At least one model should have pricing information")
    }

    @Test
    fun `should return empty definitions when file does not exist`() {
        // Arrange
        val loader = AnthropicModelLoader(
            resourceLoader = DefaultResourceLoader(),
            configPath = "classpath:nonexistent-file.yml"
        )

        // Act
        val result = loader.loadAutoConfigMetadata()

        // Assert
        assertNotNull(result)
        assertTrue(result.models.isEmpty(), "Should return empty list when file not found")
    }

    @Test
    fun `should handle invalid YAML gracefully`() {
        // Arrange
        val tempFile = Files.createTempFile("invalid", ".yml").toFile()
        tempFile.writeText("invalid: yaml: content: ][")
        tempFile.deleteOnExit()

        val loader = AnthropicModelLoader(
            resourceLoader = DefaultResourceLoader(),
            configPath = "file:${tempFile.absolutePath}"
        )

        // Act
        val result = loader.loadAutoConfigMetadata()

        // Assert
        assertNotNull(result)
        assertTrue(result.models.isEmpty(), "Should return empty list on parse error")
    }

    @Test
    fun `should validate model with invalid maxTokens`() {
        // Arrange
        val tempFile = createTempYamlFile("""
            models:
              - name: test-model
                model_id: test-id
                max_tokens: -100
        """.trimIndent())

        val loader = AnthropicModelLoader(
            resourceLoader = DefaultResourceLoader(),
            configPath = "file:${tempFile.absolutePath}"
        )

        // Act & Assert
        val result = loader.loadAutoConfigMetadata()
        assertTrue(result.models.isEmpty(), "Should fail validation for negative maxTokens")
    }

    @Test
    fun `should validate model with invalid temperature`() {
        // Arrange
        val tempFile = createTempYamlFile("""
            models:
              - name: test-model
                model_id: test-id
                temperature: 3.0
        """.trimIndent())

        val loader = AnthropicModelLoader(
            resourceLoader = DefaultResourceLoader(),
            configPath = "file:${tempFile.absolutePath}"
        )

        // Act & Assert
        val result = loader.loadAutoConfigMetadata()
        assertTrue(result.models.isEmpty(), "Should fail validation for temperature out of range")
    }

    @Test
    fun `should validate model with invalid topP`() {
        // Arrange
        val tempFile = createTempYamlFile("""
            models:
              - name: test-model
                model_id: test-id
                top_p: 1.5
        """.trimIndent())

        val loader = AnthropicModelLoader(
            resourceLoader = DefaultResourceLoader(),
            configPath = "file:${tempFile.absolutePath}"
        )

        // Act & Assert
        val result = loader.loadAutoConfigMetadata()
        assertTrue(result.models.isEmpty(), "Should fail validation for topP out of range")
    }

    @Test
    fun `should validate model with blank name`() {
        // Arrange
        val tempFile = createTempYamlFile("""
            models:
              - name: ""
                model_id: test-id
        """.trimIndent())

        val loader = AnthropicModelLoader(
            resourceLoader = DefaultResourceLoader(),
            configPath = "file:${tempFile.absolutePath}"
        )

        // Act & Assert
        val result = loader.loadAutoConfigMetadata()
        assertTrue(result.models.isEmpty(), "Should fail validation for blank name")
    }

    @Test
    fun `should load valid model with all optional fields`() {
        // Arrange
        val tempFile = createTempYamlFile("""
            models:
              - name: test-model
                model_id: claude-test
                display_name: Test Model
                max_tokens: 4096
                temperature: 0.7
                top_p: 0.9
                top_k: 50
                thinking:
                  token_budget: 1000
                pricing_model:
                  usd_per1m_input_tokens: 10.0
                  usd_per1m_output_tokens: 20.0
        """.trimIndent())

        val loader = AnthropicModelLoader(
            resourceLoader = DefaultResourceLoader(),
            configPath = "file:${tempFile.absolutePath}"
        )

        // Act
        val result = loader.loadAutoConfigMetadata()

        // Assert
        assertEquals(1, result.models.size)
        val model = result.models.first()
        assertEquals("test-model", model.name)
        assertEquals("claude-test", model.modelId)
        assertEquals("Test Model", model.displayName)
        assertEquals(4096, model.maxTokens)
        assertEquals(0.7, model.temperature)
        assertEquals(0.9, model.topP)
        assertEquals(50, model.topK)
        assertNotNull(model.thinking)
        assertEquals(1000, model.thinking?.tokenBudget)
        assertNotNull(model.pricingModel)
        assertEquals(10.0, model.pricingModel?.usdPer1mInputTokens)
        assertEquals(20.0, model.pricingModel?.usdPer1mOutputTokens)
    }

    @Test
    fun `should load multiple models correctly`() {
        // Arrange
        val tempFile = createTempYamlFile("""
            models:
              - name: model-1
                model_id: claude-1
                max_tokens: 2000
              - name: model-2
                model_id: claude-2
                max_tokens: 4000
        """.trimIndent())

        val loader = AnthropicModelLoader(
            resourceLoader = DefaultResourceLoader(),
            configPath = "file:${tempFile.absolutePath}"
        )

        // Act
        val result = loader.loadAutoConfigMetadata()

        // Assert
        assertEquals(2, result.models.size)
        assertEquals("model-1", result.models[0].name)
        assertEquals("model-2", result.models[1].name)
        assertEquals(2000, result.models[0].maxTokens)
        assertEquals(4000, result.models[1].maxTokens)
    }

    @Test
    fun `should validate model with invalid topK`() {
        // Arrange
        val tempFile = createTempYamlFile("""
            models:
              - name: test-model
                model_id: test-id
                top_k: -5
        """.trimIndent())

        val loader = AnthropicModelLoader(
            resourceLoader = DefaultResourceLoader(),
            configPath = "file:${tempFile.absolutePath}"
        )

        // Act & Assert
        val result = loader.loadAutoConfigMetadata()
        assertTrue(result.models.isEmpty(), "Should fail validation for negative topK")
    }

    @Test
    fun `should validate model with invalid thinking token budget`() {
        // Arrange
        val tempFile = createTempYamlFile("""
            models:
              - name: test-model
                model_id: test-id
                thinking:
                  token_budget: -1000
        """.trimIndent())

        val loader = AnthropicModelLoader(
            resourceLoader = DefaultResourceLoader(),
            configPath = "file:${tempFile.absolutePath}"
        )

        // Act & Assert
        val result = loader.loadAutoConfigMetadata()
        assertTrue(result.models.isEmpty(), "Should fail validation for negative thinking token budget")
    }

    @Test
    fun `should load model with minimal fields`() {
        // Arrange
        val tempFile = createTempYamlFile("""
            models:
              - name: minimal-model
                model_id: claude-minimal
        """.trimIndent())

        val loader = AnthropicModelLoader(
            resourceLoader = DefaultResourceLoader(),
            configPath = "file:${tempFile.absolutePath}"
        )

        // Act
        val result = loader.loadAutoConfigMetadata()

        // Assert
        assertEquals(1, result.models.size)
        val model = result.models.first()
        assertEquals("minimal-model", model.name)
        assertEquals("claude-minimal", model.modelId)
        assertNull(model.displayName)
        assertEquals(8192, model.maxTokens) // Default value
        assertEquals(1.0, model.temperature) // Default value
        assertNull(model.topP)
        assertNull(model.topK)
        assertNull(model.thinking)
        assertNull(model.pricingModel)
    }

    private fun createTempYamlFile(content: String): File {
        val tempFile = Files.createTempFile("test-anthropic", ".yml").toFile()
        tempFile.writeText(content)
        tempFile.deleteOnExit()
        return tempFile
    }
}



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-anthropic-autoconfigure/src/test/kotlin/com/embabel/agent/config/models/anthropic/AnthropicOptionsConverterTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.models.anthropic

import com.embabel.agent.test.models.OptionsConverterTestSupport
import com.embabel.common.ai.model.LlmOptions
import com.embabel.common.ai.model.Thinking
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test
import org.springframework.ai.anthropic.AnthropicChatOptions
import org.springframework.ai.anthropic.api.AnthropicApi

class AnthropicOptionsConverterTest : OptionsConverterTestSupport<AnthropicChatOptions>(
    optionsConverter = AnthropicOptionsConverter
) {

    @Test
    fun `should default to no thinking`() {
        val options = optionsConverter.convertOptions(LlmOptions())
        assertEquals(AnthropicApi.ThinkingType.DISABLED, options.thinking.type)
    }

    @Test
    fun `should set thinking`() {
        val options = optionsConverter.convertOptions(LlmOptions().withThinking(Thinking.withTokenBudget(2000)))
        assertEquals(AnthropicApi.ThinkingType.ENABLED, options.thinking.type)
        assertEquals(2000, options.thinking.budgetTokens())
    }

    @Test
    fun `should set high maxTokens default`() {
        val options = optionsConverter.convertOptions(LlmOptions())
        assertEquals(AnthropicOptionsConverter.DEFAULT_MAX_TOKENS, options.maxTokens)
    }

    @Test
    fun `should set override maxTokens default`() {
        val options = optionsConverter.convertOptions(LlmOptions().withMaxTokens(200))
        assertEquals(200, options.maxTokens)
    }

}



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-bedrock-autoconfigure/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-autoconfigure</artifactId>
        <version>0.2.0-SNAPSHOT</version>
        <relativePath>../../pom.xml</relativePath>
    </parent>
    <artifactId>embabel-agent-bedrock-autoconfigure</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent Autoconfiguration Models Bedrock AI</name>
    <description>Bedrock models Auto-Configuration for Embabel Agent API</description>

    <dependencies>
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-api</artifactId>
        </dependency>

        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-platform-autoconfigure</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-starter-model-bedrock</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-starter-model-bedrock-converse</artifactId>
        </dependency>

        <dependency>
            <groupId>com.embabel.common</groupId>
            <artifactId>embabel-common-test-ai</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-test-internal</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

</project>



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-bedrock-autoconfigure/src/main/java/com/embabel/agent/autoconfigure/models/bedrock/AgentBedrockAutoConfiguration.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.autoconfigure.models.bedrock;

import com.embabel.agent.config.models.bedrock.BedrockModels;
import org.springframework.ai.bedrock.cohere.api.CohereEmbeddingBedrockApi;
import org.springframework.ai.bedrock.converse.BedrockProxyChatModel;
import org.springframework.ai.bedrock.titan.api.TitanEmbeddingBedrockApi;
import org.springframework.boot.autoconfigure.AutoConfiguration;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.context.properties.ConfigurationPropertiesScan;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Import;
import software.amazon.awssdk.services.bedrockruntime.BedrockRuntimeAsyncClient;
import software.amazon.awssdk.services.bedrockruntime.BedrockRuntimeClient;

@AutoConfiguration
@ConfigurationPropertiesScan(
        basePackages = {
                "com.embabel.agent"
        }
)
@ComponentScan(
        basePackages = {
                "com.embabel.agent"
        }
)
@ConditionalOnClass({
        BedrockProxyChatModel.class,
        BedrockRuntimeClient.class,
        BedrockRuntimeAsyncClient.class,
        TitanEmbeddingBedrockApi.class,
        CohereEmbeddingBedrockApi.class,
        BedrockModels.class})
@Import(BedrockModels.class)
public class AgentBedrockAutoConfiguration {
}



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-bedrock-autoconfigure/src/main/java/com/embabel/agent/config/annotation/bedrock/EnableAgentBedrock.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.annotation.bedrock;

import com.embabel.agent.config.annotation.AgentPlatform;
import com.embabel.agent.config.models.bedrock.BedrockModels;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Enables Embabel Agent integration with AWS Bedrock for enterprise-grade AI model access.
 *
 * <p>This annotation configures your Spring Boot application to use AWS Bedrock as
 * AI model provider, enabling access to foundation models like Claude, Titan,
 * and other AWS-hosted models through a unified interface.
 *
 * <h3>What This Provides:</h3>
 * <ul>
 *   <li>Activates "bedrock" Spring profile</li>
 *   <li>Configures AWS Bedrock client with proper authentication (using AwsCredentialsProvider through org.springframework.ai:spring-ai-bedrock library)</li>
 *   <li>Sets up model routing to use Bedrock-hosted models</li>
 * </ul>
 *
 * <h3>Example Usage:</h3>
 * <pre>{@code
 * @SpringBootApplication
 * @EnableAgentBedrock
 * public class BedrockAgentApplication {
 *     public static void main(String[] args) {
 *         SpringApplication.run(BedrockAgentApplication.class, args);
 *     }
 * }
 * }</pre>
 *
 * <h3>Required AWS Configuration:</h3>
 * <p>Ensure AWS credentials are configured via one of these methods:
 * <ul>
 *   <li>AWS credentials file: {@code ~/.aws/credentials}</li>
 *   <li>Environment variables: {@code AWS_REGION}, {@code AWS_ACCESS_KEY_ID} and {@code AWS_SECRET_ACCESS_KEY}</li>
 *   <li>IAM role (when running on EC2/ECS/Lambda)</li>
 *   <li>AWS SSO configuration</li>
 * </ul>
 *
 * <h3>Configuration Properties:</h3>
 * <pre>{@code
 * # application.yml
 * embabel:
 *   models:
 *     default-llm: eu.anthropic.claude-sonnet-4-20250514-v1:0
 *     default-embedding-model: cohere.embed-multilingual-v3
 * }</pre>
 *
 * See BedrockModels for other available Bedrock Models.
 * <p>If a more convenient model is needed, you may also override the provided application-bedrock.yml model list.
 *
 * @see com.embabel.agent.config.annotation.EnableAgents
 * @see AgentPlatform
 * @see BedrockModels
 * @since 1.0
 * @author Embabel Team
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@AgentPlatform(BedrockModels.BEDROCK_PROFILE)
@Deprecated(since = "0.1.3", forRemoval = true)
public @interface EnableAgentBedrock {
}



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-bedrock-autoconfigure/src/main/kotlin/com/embabel/agent/config/models/bedrock/BedrockModels.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.models.bedrock

import com.embabel.agent.spi.config.spring.AgentPlatformConfiguration
import com.embabel.common.ai.model.*
import io.micrometer.observation.ObservationRegistry
import org.springframework.ai.bedrock.cohere.BedrockCohereEmbeddingModel
import org.springframework.ai.bedrock.cohere.api.CohereEmbeddingBedrockApi
import org.springframework.ai.bedrock.cohere.api.CohereEmbeddingBedrockApi.CohereEmbeddingModel
import org.springframework.ai.bedrock.converse.BedrockProxyChatModel
import org.springframework.ai.bedrock.titan.BedrockTitanEmbeddingModel
import org.springframework.ai.bedrock.titan.api.TitanEmbeddingBedrockApi
import org.springframework.ai.bedrock.titan.api.TitanEmbeddingBedrockApi.TitanEmbeddingModel
import org.springframework.ai.chat.model.ChatModel
import org.springframework.ai.chat.observation.ChatModelObservationConvention
import org.springframework.ai.model.ModelOptionsUtils
import org.springframework.ai.model.bedrock.autoconfigure.BedrockAwsConnectionConfiguration
import org.springframework.ai.model.bedrock.autoconfigure.BedrockAwsConnectionProperties
import org.springframework.ai.model.bedrock.cohere.autoconfigure.BedrockCohereEmbeddingProperties
import org.springframework.ai.model.bedrock.titan.autoconfigure.BedrockTitanEmbeddingProperties
import org.springframework.ai.model.tool.DefaultToolExecutionEligibilityPredicate
import org.springframework.ai.model.tool.ToolCallingChatOptions
import org.springframework.ai.model.tool.ToolCallingManager
import org.springframework.ai.model.tool.ToolExecutionEligibilityPredicate
import org.springframework.beans.factory.ObjectProvider
import org.springframework.boot.autoconfigure.AutoConfigureBefore
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass
import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.boot.context.properties.EnableConfigurationProperties
import org.springframework.boot.context.properties.NestedConfigurationProperty
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.context.annotation.Import
import software.amazon.awssdk.auth.credentials.AwsCredentialsProvider
import software.amazon.awssdk.http.nio.netty.NettyNioAsyncHttpClient
import software.amazon.awssdk.regions.Region
import software.amazon.awssdk.regions.providers.AwsRegionProvider
import software.amazon.awssdk.services.bedrockruntime.BedrockRuntimeAsyncClient
import software.amazon.awssdk.services.bedrockruntime.BedrockRuntimeClient

@ConfigurationProperties(prefix = "embabel.agent.models.bedrock")
class BedrockProperties {
    /**
     * List of Bedrock models to configure
     */
    @NestedConfigurationProperty
    var models: List<BedrockModelProperties> = emptyList()
}

@ConfigurationProperties(prefix = "embabel.agent.models.bedrock.models")
class BedrockModelProperties {
    /**
     * Name of the LLM, such as "gpt-3.5-turbo"
     */
    var name: String = ""

    /**
     * Model's knowledge cutoff date
     */
    var knowledgeCutoff: String = ""

    /**
     * Input token price
     */
    var inputPrice: Double = 0.0

    /**
     * Output token price
     */
    var outputPrice: Double = 0.0
}

@ConditionalOnClass(
    BedrockProxyChatModel::class,
    BedrockRuntimeClient::class,
    BedrockRuntimeAsyncClient::class,
    TitanEmbeddingBedrockApi::class,
    CohereEmbeddingBedrockApi::class
)

@Configuration(proxyBeanMethods = false)
@Import(BedrockAwsConnectionConfiguration::class)
@EnableConfigurationProperties(
    BedrockProperties::class,
    BedrockCohereEmbeddingProperties::class,
    BedrockTitanEmbeddingProperties::class
)
@AutoConfigureBefore(AgentPlatformConfiguration::class)
class BedrockModels(

    private val bedrockProperties: BedrockProperties,
    private val credentialsProvider: AwsCredentialsProvider,
    private val regionProvider: AwsRegionProvider,
    private val connectionProperties: BedrockAwsConnectionProperties,
    private val observationRegistry: ObjectProvider<ObservationRegistry>,
    private val observationConvention: ObjectProvider<ChatModelObservationConvention>,
    private val bedrockRuntimeClient: ObjectProvider<BedrockRuntimeClient>,
    private val bedrockRuntimeAsyncClient: ObjectProvider<BedrockRuntimeAsyncClient>,
    private val bedrockCohereEmbeddingProperties: BedrockCohereEmbeddingProperties,
    private val bedrockTitanEmbeddingProperties: BedrockTitanEmbeddingProperties,
) {

    @Bean("bedrockModel-$EU_ANTHROPIC_CLAUDE_3_5_SONNET")
    fun euAnthropicClaude35Sonnet(): Llm = llmOf(EU_ANTHROPIC_CLAUDE_3_5_SONNET)

    @Bean("bedrockModel-$EU_ANTHROPIC_CLAUDE_3_5_SONNET_V2")
    fun euAnthropicClaude35SonnetV2(): Llm = llmOf(EU_ANTHROPIC_CLAUDE_3_5_SONNET_V2)

    @Bean("bedrockModel-$EU_ANTHROPIC_CLAUDE_3_5_HAIKU")
    fun euAnthropicClaude35Haiku(): Llm = llmOf(EU_ANTHROPIC_CLAUDE_3_5_HAIKU)

    @Bean("bedrockModel-$EU_ANTHROPIC_CLAUDE_3_7_SONNET")
    fun euAnthropicClaude37Sonnet(): Llm = llmOf(EU_ANTHROPIC_CLAUDE_3_7_SONNET)

    @Bean("bedrockModel-$EU_ANTHROPIC_CLAUDE_SONNET_4")
    fun euAnthropicClaudeSonnet4(): Llm = llmOf(EU_ANTHROPIC_CLAUDE_SONNET_4)

    @Bean("bedrockModel-$EU_ANTHROPIC_CLAUDE_OPUS_4")
    fun euAnthropicClaudeOpus4(): Llm = llmOf(EU_ANTHROPIC_CLAUDE_OPUS_4)

    @Bean("bedrockModel-$US_ANTHROPIC_CLAUDE_3_5_SONNET")
    fun usAnthropicClaude35Sonnet(): Llm = llmOf(US_ANTHROPIC_CLAUDE_3_5_SONNET)

    @Bean("bedrockModel-$US_ANTHROPIC_CLAUDE_3_5_SONNET_V2")
    fun usAnthropicClaude35SonnetV2(): Llm = llmOf(US_ANTHROPIC_CLAUDE_3_5_SONNET_V2)

    @Bean("bedrockModel-$US_ANTHROPIC_CLAUDE_3_5_HAIKU")
    fun usAnthropicClaude35Haiku(): Llm = llmOf(US_ANTHROPIC_CLAUDE_3_5_HAIKU)

    @Bean("bedrockModel-$US_ANTHROPIC_CLAUDE_3_7_SONNET")
    fun usAnthropicClaude37Sonnet(): Llm = llmOf(US_ANTHROPIC_CLAUDE_3_7_SONNET)

    @Bean("bedrockModel-$US_ANTHROPIC_CLAUDE_SONNET_4")
    fun usAnthropicClaudeSonnet4(): Llm = llmOf(US_ANTHROPIC_CLAUDE_SONNET_4)

    @Bean("bedrockModel-$US_ANTHROPIC_CLAUDE_OPUS_4")
    fun usAnthropicClaudeOpus4(): Llm = llmOf(US_ANTHROPIC_CLAUDE_OPUS_4)

    @Bean("bedrockModel-$APAC_ANTHROPIC_CLAUDE_3_5_SONNET")
    fun apacAnthropicClaude35Sonnet(): Llm = llmOf(APAC_ANTHROPIC_CLAUDE_3_5_SONNET)

    @Bean("bedrockModel-$APAC_ANTHROPIC_CLAUDE_3_5_SONNET_V2")
    fun apacAnthropicClaude35SonnetV2(): Llm = llmOf(APAC_ANTHROPIC_CLAUDE_3_5_SONNET_V2)

    @Bean("bedrockModel-$APAC_ANTHROPIC_CLAUDE_3_5_HAIKU")
    fun apacAnthropicClaude35Haiku(): Llm = llmOf(APAC_ANTHROPIC_CLAUDE_3_5_HAIKU)

    @Bean("bedrockModel-$APAC_ANTHROPIC_CLAUDE_3_7_SONNET")
    fun apacAnthropicClaude37Sonnet(): Llm = llmOf(APAC_ANTHROPIC_CLAUDE_3_7_SONNET)

    @Bean("bedrockModel-$APAC_ANTHROPIC_CLAUDE_SONNET_4")
    fun apacAnthropicClaudeSonnet4(): Llm = llmOf(APAC_ANTHROPIC_CLAUDE_SONNET_4)

    @Bean("bedrockModel-$APAC_ANTHROPIC_CLAUDE_OPUS_4")
    fun apacAnthropicClaudeOpus4(): Llm = llmOf(APAC_ANTHROPIC_CLAUDE_OPUS_4)

    @Bean("bedrockModel-amazon.titan-embed-image-v1")
    fun titanEmbedImageV1(): EmbeddingService = embeddingServiceOf(TitanEmbeddingModel.TITAN_EMBED_IMAGE_V1)

    @Bean("bedrockModel-amazon.titan-embed-text-v1")
    fun titanEmbedTextV1(): EmbeddingService = embeddingServiceOf(TitanEmbeddingModel.TITAN_EMBED_TEXT_V1)

    @Bean("bedrockModel-amazon.titan-embed-text-v2:0")
    fun titanEmbedTextV2(): EmbeddingService = embeddingServiceOf(TitanEmbeddingModel.TITAN_EMBED_TEXT_V2)

    @Bean("bedrockModel-cohere.embed-multilingual-v3")
    fun cohereEmbedMultilingualV3(): EmbeddingService =
        embeddingServiceOf(CohereEmbeddingModel.COHERE_EMBED_MULTILINGUAL_V3)

    @Bean("bedrockModel-cohere.embed-english-v3")
    fun cohereEmbedEnglishV3(): EmbeddingService = embeddingServiceOf(CohereEmbeddingModel.COHERE_EMBED_ENGLISH_V3)

    private fun bedrockModelProperties(string: String): BedrockModelProperties =
        bedrockProperties.models.find { it.name == string }
            ?: throw IllegalArgumentException(
                "No bedrock model named $string: Known bedrock models: ${
                    bedrockProperties.models.map { it.name }.sorted()
                }"
            )

    private fun llmOf(model: String): Llm = llmOf(bedrockModelProperties(model))

    private fun llmOf(model: BedrockModelProperties): Llm = Llm(
        name = model.name,
        model = chatModelOf(model.name),
        optionsConverter = BedrockOptionsConverter,
        provider = PROVIDER,
        knowledgeCutoffDate = java.time.LocalDate.parse(model.knowledgeCutoff),
        pricingModel = PerTokenPricingModel(
            usdPer1mInputTokens = model.inputPrice,
            usdPer1mOutputTokens = model.outputPrice,
        )
    )

    private fun chatModelOf(model: String): ChatModel = EmbabelBedrockProxyChatModelBuilder()
        .credentialsProvider(credentialsProvider)
        .region(regionProvider.region)
        .timeout(connectionProperties.timeout)
        .defaultOptions(ToolCallingChatOptions.builder().model(model).build())
        .observationRegistry(observationRegistry.getIfUnique { ObservationRegistry.NOOP })
        .toolCallingManager(
            ToolCallingManager.builder()
            .observationRegistry(observationRegistry.getIfUnique { ObservationRegistry.NOOP }).build()
        )
        .bedrockRuntimeClient(bedrockRuntimeClient.getIfAvailable())
        .bedrockRuntimeAsyncClient(bedrockRuntimeAsyncClient.getIfAvailable())
        .build()
        .apply<BedrockProxyChatModel> {
            observationConvention.ifAvailable(::setObservationConvention)
        }

    private fun embeddingServiceOf(model: TitanEmbeddingModel): EmbeddingService = EmbeddingService(
        name = model.id(),
        model = BedrockTitanEmbeddingModel(
            TitanEmbeddingBedrockApi(
                model.id(),
                credentialsProvider,
                regionProvider.region,
                ModelOptionsUtils.OBJECT_MAPPER,
                connectionProperties.timeout,
            ), observationRegistry.getIfUnique { ObservationRegistry.NOOP }
        ).withInputType(bedrockTitanEmbeddingProperties.inputType),
        provider = PROVIDER,
    )

    private fun embeddingServiceOf(model: CohereEmbeddingModel): EmbeddingService = EmbeddingService(
        name = model.id(),
        model = BedrockCohereEmbeddingModel(
            CohereEmbeddingBedrockApi(
                model.id(),
                credentialsProvider,
                regionProvider.region,
                ModelOptionsUtils.OBJECT_MAPPER,
                connectionProperties.timeout
            ),
            bedrockCohereEmbeddingProperties.options
        ),
        provider = PROVIDER,
    )

    companion object {

        const val BEDROCK_PROFILE = "bedrock"

        // https://docs.aws.amazon.com/bedrock/latest/userguide/models-supported.html
        const val EU_ANTHROPIC_CLAUDE_3_5_SONNET = "eu.anthropic.claude-3-5-sonnet-20240620-v1:0"
        const val EU_ANTHROPIC_CLAUDE_3_5_SONNET_V2 = "eu.anthropic.claude-3-5-sonnet-20241022-v2:0"
        const val EU_ANTHROPIC_CLAUDE_3_5_HAIKU = "eu.anthropic.claude-3-5-haiku-20241022-v1:0"
        const val EU_ANTHROPIC_CLAUDE_3_7_SONNET = "eu.anthropic.claude-3-7-sonnet-20250219-v1:0"
        const val EU_ANTHROPIC_CLAUDE_SONNET_4 = "eu.anthropic.claude-sonnet-4-20250514-v1:0"
        const val EU_ANTHROPIC_CLAUDE_OPUS_4 = "eu.anthropic.claude-opus-4-20250514-v1:0"

        const val US_ANTHROPIC_CLAUDE_3_5_SONNET = "us.anthropic.claude-3-5-sonnet-20240620-v1:0"
        const val US_ANTHROPIC_CLAUDE_3_5_SONNET_V2 = "us.anthropic.claude-3-5-sonnet-20241022-v2:0"
        const val US_ANTHROPIC_CLAUDE_3_5_HAIKU = "us.anthropic.claude-3-5-haiku-20241022-v1:0"
        const val US_ANTHROPIC_CLAUDE_3_7_SONNET = "us.anthropic.claude-3-7-sonnet-20250219-v1:0"
        const val US_ANTHROPIC_CLAUDE_SONNET_4 = "us.anthropic.claude-sonnet-4-20250514-v1:0"
        const val US_ANTHROPIC_CLAUDE_OPUS_4 = "us.anthropic.claude-opus-4-20250514-v1:0"

        const val APAC_ANTHROPIC_CLAUDE_3_5_SONNET = "apac.anthropic.claude-3-5-sonnet-20240620-v1:0"
        const val APAC_ANTHROPIC_CLAUDE_3_5_SONNET_V2 = "apac.anthropic.claude-3-5-sonnet-20241022-v2:0"
        const val APAC_ANTHROPIC_CLAUDE_3_5_HAIKU = "apac.anthropic.claude-3-5-haiku-20241022-v1:0"
        const val APAC_ANTHROPIC_CLAUDE_3_7_SONNET = "apac.anthropic.claude-3-7-sonnet-20250219-v1:0"
        const val APAC_ANTHROPIC_CLAUDE_SONNET_4 = "apac.anthropic.claude-sonnet-4-20250514-v1:0"
        const val APAC_ANTHROPIC_CLAUDE_OPUS_4 = "apac.anthropic.claude-opus-4-20250514-v1:0"

        const val PROVIDER = "Bedrock"
    }
}


object BedrockOptionsConverter : OptionsConverter<ToolCallingChatOptions> {

    override fun convertOptions(options: LlmOptions) =
        ToolCallingChatOptions.builder()
            .temperature(options.temperature)
            .topP(options.topP)
            .maxTokens(options.maxTokens)
            .presencePenalty(options.presencePenalty)
            .frequencyPenalty(options.frequencyPenalty)
            .topK(options.topK)
            .build()
}

/**
 * Inspired from final org.springframework.ai.bedrock.converse.BedrockProxyChatModel.Builder class to avoid annoying
 * warn log message during builder initialization relative to how AWS configuration values are provided.
 */
class EmbabelBedrockProxyChatModelBuilder internal constructor() {
    private var credentialsProvider: AwsCredentialsProvider? = null
    private var region: Region? = Region.US_EAST_1
    private var timeout: java.time.Duration? = java.time.Duration.ofMinutes(10)
    private var toolCallingManager: ToolCallingManager? = null
    private var toolExecutionEligibilityPredicate: ToolExecutionEligibilityPredicate =
        DefaultToolExecutionEligibilityPredicate()
    private var defaultOptions = ToolCallingChatOptions.builder().build()
    private var observationRegistry = ObservationRegistry.NOOP
    private var customObservationConvention: ChatModelObservationConvention? = null
    private var bedrockRuntimeClient: BedrockRuntimeClient? = null
    private var bedrockRuntimeAsyncClient: BedrockRuntimeAsyncClient? = null
    private val defaultToolCallingManager: ToolCallingManager = ToolCallingManager.builder().build()

    fun toolCallingManager(toolCallingManager: ToolCallingManager?): EmbabelBedrockProxyChatModelBuilder {
        this.toolCallingManager = toolCallingManager
        return this
    }

    fun toolExecutionEligibilityPredicate(toolExecutionEligibilityPredicate: ToolExecutionEligibilityPredicate):
            EmbabelBedrockProxyChatModelBuilder {
        this.toolExecutionEligibilityPredicate = toolExecutionEligibilityPredicate
        return this
    }

    fun credentialsProvider(credentialsProvider: AwsCredentialsProvider): EmbabelBedrockProxyChatModelBuilder {
        this.credentialsProvider = credentialsProvider
        return this
    }

    fun region(region: Region): EmbabelBedrockProxyChatModelBuilder {
        this.region = region
        return this
    }

    fun timeout(timeout: java.time.Duration): EmbabelBedrockProxyChatModelBuilder {
        this.timeout = timeout
        return this
    }

    fun defaultOptions(defaultOptions: ToolCallingChatOptions): EmbabelBedrockProxyChatModelBuilder {
        this.defaultOptions = defaultOptions
        return this
    }

    fun observationRegistry(observationRegistry: ObservationRegistry): EmbabelBedrockProxyChatModelBuilder {
        this.observationRegistry = observationRegistry
        return this
    }

    fun customObservationConvention(observationConvention: ChatModelObservationConvention): EmbabelBedrockProxyChatModelBuilder {
        this.customObservationConvention = observationConvention
        return this
    }

    fun bedrockRuntimeClient(bedrockRuntimeClient: BedrockRuntimeClient?): EmbabelBedrockProxyChatModelBuilder {
        this.bedrockRuntimeClient = bedrockRuntimeClient
        return this
    }

    fun bedrockRuntimeAsyncClient(bedrockRuntimeAsyncClient: BedrockRuntimeAsyncClient?): EmbabelBedrockProxyChatModelBuilder {
        this.bedrockRuntimeAsyncClient = bedrockRuntimeAsyncClient
        return this
    }

    fun build(): BedrockProxyChatModel {
        if (this.bedrockRuntimeClient == null) {
            this.bedrockRuntimeClient = BedrockRuntimeClient.builder()
                .region(this.region)
                .httpClientBuilder(null)
                .credentialsProvider(this.credentialsProvider)
                .overrideConfiguration { c -> c.apiCallTimeout(this.timeout) }
                .build()
        }

        if (this.bedrockRuntimeAsyncClient == null) {
            this.bedrockRuntimeAsyncClient = BedrockRuntimeAsyncClient.builder()
                .region(this.region)
                .httpClientBuilder(
                    NettyNioAsyncHttpClient.builder()
                        .tcpKeepAlive(true)
                        .connectionAcquisitionTimeout(java.time.Duration.ofSeconds(30))
                        .maxConcurrency(200)
                )
                .credentialsProvider(this.credentialsProvider)
                .overrideConfiguration { c -> c.apiCallTimeout(this.timeout) }
                .build()
        }

        return BedrockProxyChatModel(
            bedrockRuntimeClient,
            bedrockRuntimeAsyncClient,
            defaultOptions,
            observationRegistry,
            toolCallingManager ?: defaultToolCallingManager,
            toolExecutionEligibilityPredicate
        ).apply {
            if (customObservationConvention != null) {
                setObservationConvention(customObservationConvention)
            }
        }
    }
}



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-bedrock-autoconfigure/src/main/resources/application-bedrock.yml
================================================
spring:
  autoconfigure:
    exclude:
      - org.springframework.ai.model.bedrock.converse.autoconfigure.BedrockConverseProxyChatAutoConfiguration
      - org.springframework.ai.model.bedrock.cohere.autoconfigure.BedrockCohereEmbeddingAutoConfiguration
      - org.springframework.ai.model.bedrock.titan.autoconfigure.BedrockTitanEmbeddingAutoConfiguration
  ai:
    bedrock:
      aws:
        region: ${AWS_REGION:}
        access-key: ${AWS_ACCESS_KEY_ID:}
        secret-key: ${AWS_SECRET_ACCESS_KEY:}
        session-token: ${AWS_SESSION_TOKEN:}

embabel:
  agent:
    models:
      bedrock:
        models:
        # US region
          - name: us.anthropic.claude-3-5-sonnet-20240620-v1:0
            knowledge-cutoff: 2024-04-01
            input-price: 3.0
            output-price: 15.0
          - name: us.anthropic.claude-3-5-sonnet-20241022-v2:0
            knowledge-cutoff: 2024-07-01
            input-price: 3.0
            output-price: 15.0
          - name: us.anthropic.claude-3-5-haiku-20241022-v1:0
            knowledge-cutoff: 2024-07-01
            input-price: 0.8
            output-price: 4.0
          - name: us.anthropic.claude-3-7-sonnet-20250219-v1:0
            knowledge-cutoff: 2024-10-31
            input-price: 3.0
            output-price: 15.0
          - name: us.anthropic.claude-sonnet-4-20250514-v1:0
            knowledge-cutoff: 2025-03-01
            input-price: 3.0
            output-price: 15.0
          - name: us.anthropic.claude-opus-4-20250514-v1:0
            knowledge-cutoff: 2025-03-01
            input-price: 15.0
            output-price: 75.0
          # EU region
          - name: eu.anthropic.claude-3-5-sonnet-20240620-v1:0
            knowledge-cutoff: 2024-04-01
            input-price: 3.0
            output-price: 15.0
          - name: eu.anthropic.claude-3-5-sonnet-20241022-v2:0
            knowledge-cutoff: 2024-07-01
            input-price: 3.0
            output-price: 15.0
          - name: eu.anthropic.claude-3-5-haiku-20241022-v1:0
            knowledge-cutoff: 2024-07-01
            input-price: 0.8
            output-price: 4.0
          - name: eu.anthropic.claude-3-7-sonnet-20250219-v1:0
            knowledge-cutoff: 2024-10-31
            input-price: 3.0
            output-price: 15.0
          - name: eu.anthropic.claude-sonnet-4-20250514-v1:0
            knowledge-cutoff: 2025-03-01
            input-price: 3.0
            output-price: 15.0
          - name: eu.anthropic.claude-opus-4-20250514-v1:0
            knowledge-cutoff: 2025-03-01
            input-price: 15.0
            output-price: 75.0
          # APAC region
          - name: apac.anthropic.claude-3-5-sonnet-20240620-v1:0
            knowledge-cutoff: 2024-04-01
            input-price: 3.0
            output-price: 15.0
          - name: apac.anthropic.claude-3-5-sonnet-20241022-v2:0
            knowledge-cutoff: 2024-07-01
            input-price: 3.0
            output-price: 15.0
          - name: apac.anthropic.claude-3-5-haiku-20241022-v1:0
            knowledge-cutoff: 2024-07-01
            input-price: 0.8
            output-price: 4.0
          - name: apac.anthropic.claude-3-7-sonnet-20250219-v1:0
            knowledge-cutoff: 2024-10-31
            input-price: 3.0
            output-price: 15.0
          - name: apac.anthropic.claude-sonnet-4-20250514-v1:0
            knowledge-cutoff: 2025-03-01
            input-price: 3.0
            output-price: 15.0
          - name: apac.anthropic.claude-opus-4-20250514-v1:0
            knowledge-cutoff: 2025-03-01
            input-price: 15.0
            output-price: 75.0



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-bedrock-autoconfigure/src/main/resources/META-INF/spring.factories
================================================
[Empty file]


================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-bedrock-autoconfigure/src/main/resources/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports
================================================
com.embabel.agent.autoconfigure.models.bedrock.AgentBedrockAutoConfiguration


================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-bedrock-autoconfigure/src/test/java/com/embabel/agent/autoconfigure/models/bedrock/AgentBedrockAutoConfigurationIT.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.autoconfigure.models.bedrock;

//import com.embabel.agent.config.annotation.EnableAgentShell;
import com.embabel.agent.config.annotation.bedrock.EnableAgentBedrock;
import com.embabel.common.ai.model.Llm;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.ImportAutoConfiguration;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.test.annotation.DirtiesContext;

import java.util.Arrays;
import java.util.List;

import static com.embabel.agent.config.models.bedrock.BedrockModels.*;

@SpringBootTest(
        classes = AgentBedrockAutoConfigurationIT.class,
        properties = {
                "embabel.models.default-llm=" + EU_ANTHROPIC_CLAUDE_SONNET_4,
                "embabel.models.llms.cheapest=" + EU_ANTHROPIC_CLAUDE_SONNET_4,
                "embabel.models.llms.best=" + EU_ANTHROPIC_CLAUDE_OPUS_4,
                "spring.ai.bedrock.aws.region=eu-west-3",
                "spring.ai.bedrock.aws.access-key=AWSACCESSKEYID",
                "spring.ai.bedrock.aws.secret-key=AWSSECRETACCESSKEY"
        })
@EnableAgentBedrock
//@EnableAgentShell can be added as well
@ComponentScan(basePackages = "com.embabel.agent.autoconfigure")
@ImportAutoConfiguration(classes = {AgentBedrockAutoConfiguration.class})
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS)
class AgentBedrockAutoConfigurationIT {

    @Autowired
    private ApplicationContext applicationContext;

    @Test
    public void testAutoConfiguredBedrockModelsBeanPresence() {
        List<String> bedrockLlmsNames = Arrays.stream(applicationContext.getBeanNamesForType(Llm.class))
                .filter(it -> it.startsWith("bedrockModel-"))
                .map(it -> applicationContext.getBean(it, Llm.class))
                .map(Llm::getName)
                .toList();

        Assertions.assertFalse(bedrockLlmsNames.isEmpty());
    }

}


================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-bedrock-autoconfigure/src/test/kotlin/com/embabel/agent/config/models/bedrock/BedrockModelsIntegrationTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.models.bedrock

import com.embabel.agent.config.models.bedrock.BedrockModels.Companion.APAC_ANTHROPIC_CLAUDE_3_5_HAIKU
import com.embabel.agent.config.models.bedrock.BedrockModels.Companion.APAC_ANTHROPIC_CLAUDE_3_5_SONNET
import com.embabel.agent.config.models.bedrock.BedrockModels.Companion.APAC_ANTHROPIC_CLAUDE_3_5_SONNET_V2
import com.embabel.agent.config.models.bedrock.BedrockModels.Companion.APAC_ANTHROPIC_CLAUDE_3_7_SONNET
import com.embabel.agent.config.models.bedrock.BedrockModels.Companion.APAC_ANTHROPIC_CLAUDE_OPUS_4
import com.embabel.agent.config.models.bedrock.BedrockModels.Companion.APAC_ANTHROPIC_CLAUDE_SONNET_4
import com.embabel.agent.config.models.bedrock.BedrockModels.Companion.EU_ANTHROPIC_CLAUDE_3_5_HAIKU
import com.embabel.agent.config.models.bedrock.BedrockModels.Companion.EU_ANTHROPIC_CLAUDE_3_5_SONNET
import com.embabel.agent.config.models.bedrock.BedrockModels.Companion.EU_ANTHROPIC_CLAUDE_3_5_SONNET_V2
import com.embabel.agent.config.models.bedrock.BedrockModels.Companion.EU_ANTHROPIC_CLAUDE_3_7_SONNET
import com.embabel.agent.config.models.bedrock.BedrockModels.Companion.EU_ANTHROPIC_CLAUDE_OPUS_4
import com.embabel.agent.config.models.bedrock.BedrockModels.Companion.EU_ANTHROPIC_CLAUDE_SONNET_4
import com.embabel.agent.config.models.bedrock.BedrockModels.Companion.US_ANTHROPIC_CLAUDE_3_5_HAIKU
import com.embabel.agent.config.models.bedrock.BedrockModels.Companion.US_ANTHROPIC_CLAUDE_3_5_SONNET
import com.embabel.agent.config.models.bedrock.BedrockModels.Companion.US_ANTHROPIC_CLAUDE_3_5_SONNET_V2
import com.embabel.agent.config.models.bedrock.BedrockModels.Companion.US_ANTHROPIC_CLAUDE_3_7_SONNET
import com.embabel.agent.config.models.bedrock.BedrockModels.Companion.US_ANTHROPIC_CLAUDE_OPUS_4
import com.embabel.agent.config.models.bedrock.BedrockModels.Companion.US_ANTHROPIC_CLAUDE_SONNET_4
import com.embabel.common.ai.model.EmbeddingService
import com.embabel.common.ai.model.Llm
import org.junit.jupiter.api.Test
import org.springframework.ai.bedrock.cohere.api.CohereEmbeddingBedrockApi.CohereEmbeddingModel.COHERE_EMBED_ENGLISH_V3
import org.springframework.ai.bedrock.cohere.api.CohereEmbeddingBedrockApi.CohereEmbeddingModel.COHERE_EMBED_MULTILINGUAL_V3
import org.springframework.ai.bedrock.titan.api.TitanEmbeddingBedrockApi.TitanEmbeddingModel.*
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.context.ApplicationContext
import org.springframework.test.context.ActiveProfiles
import kotlin.test.assertTrue

@SpringBootTest(
    properties = [
        "embabel.models.default-llm=${EU_ANTHROPIC_CLAUDE_SONNET_4}",
        "embabel.models.llms.cheapest=${EU_ANTHROPIC_CLAUDE_SONNET_4}",
        "embabel.models.llms.best=${EU_ANTHROPIC_CLAUDE_OPUS_4}",
        "embabel.models.default-embedding-model=cohere.embed-multilingual-v3",
        "spring.ai.bedrock.aws.region=eu-west-3",
        "spring.ai.bedrock.aws.access-key=AWSACCESSKEYID",
        "spring.ai.bedrock.aws.secret-key=AWSSECRETACCESSKEY",
    ]
)
@ActiveProfiles(value = ["bedrock"])
class BedrockModelsIntegrationTest {

    @Autowired
    private lateinit var applicationContext: ApplicationContext

    @Test
    fun `should register Bedrock Llms`() {
        val bedrockLlmsNames = applicationContext.getBeanNamesForType(Llm::class.java)
            .filter { it.startsWith("bedrockModel-") }
            .map { applicationContext.getBean(it, Llm::class.java) }
            .map { it.name }

        assertTrue(
            bedrockLlmsNames.containsAll(
                listOf(
                    EU_ANTHROPIC_CLAUDE_3_5_SONNET,
                    EU_ANTHROPIC_CLAUDE_3_5_SONNET_V2,
                    EU_ANTHROPIC_CLAUDE_3_5_HAIKU,
                    EU_ANTHROPIC_CLAUDE_3_7_SONNET,
                    EU_ANTHROPIC_CLAUDE_SONNET_4,
                    EU_ANTHROPIC_CLAUDE_OPUS_4,
                    US_ANTHROPIC_CLAUDE_3_5_SONNET,
                    US_ANTHROPIC_CLAUDE_3_5_SONNET_V2,
                    US_ANTHROPIC_CLAUDE_3_5_HAIKU,
                    US_ANTHROPIC_CLAUDE_3_7_SONNET,
                    US_ANTHROPIC_CLAUDE_SONNET_4,
                    US_ANTHROPIC_CLAUDE_OPUS_4,
                    APAC_ANTHROPIC_CLAUDE_3_5_SONNET,
                    APAC_ANTHROPIC_CLAUDE_3_5_SONNET_V2,
                    APAC_ANTHROPIC_CLAUDE_3_5_HAIKU,
                    APAC_ANTHROPIC_CLAUDE_3_7_SONNET,
                    APAC_ANTHROPIC_CLAUDE_SONNET_4,
                    APAC_ANTHROPIC_CLAUDE_OPUS_4
                )
            )
        )
    }

    @Test
    fun `should register Titan and Cohere embedding services`() {
        val embeddingServices = applicationContext.getBeanNamesForType(EmbeddingService::class.java)
            .filter { it.startsWith("bedrockModel-") }
            .map<String, EmbeddingService> {
                applicationContext.getBean(it, EmbeddingService::class.java)
            }
        assertTrue(
            embeddingServices.map { it.name }.containsAll(
                listOf(
                    TITAN_EMBED_IMAGE_V1.id(),
                    TITAN_EMBED_TEXT_V1.id(),
                    TITAN_EMBED_TEXT_V2.id(),
                    COHERE_EMBED_MULTILINGUAL_V3.id(),
                    COHERE_EMBED_ENGLISH_V3.id(),
                )
            )
        )
    }
}



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-bedrock-autoconfigure/src/test/kotlin/com/embabel/agent/config/models/bedrock/BedrockOptionsConverterTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.models.bedrock

//import com.embabel.agent.config.models.OptionsConverterTestSupport
//import org.springframework.ai.model.tool.ToolCallingChatOptions
//// TODO: need a place to access OptionsConverterTestSupport from api and autoconfiguration
//class BedrockOptionsConverterTest : OptionsConverterTestSupport<ToolCallingChatOptions>(
//    optionsConverter = BedrockOptionsConverter
//) {
//
//
//}



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-bedrock-autoconfigure/src/test/kotlin/com/embabel/agent/config/models/bedrock/EmbabelBedrockProxyChatModelBuilderTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.models.bedrock

import io.micrometer.observation.ObservationRegistry
import io.mockk.mockk
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.extension.ExtendWith
import org.springframework.ai.bedrock.converse.BedrockProxyChatModel
import org.springframework.ai.chat.observation.DefaultChatModelObservationConvention
import org.springframework.ai.model.tool.DefaultToolExecutionEligibilityPredicate
import org.springframework.ai.model.tool.ToolCallingChatOptions
import org.springframework.ai.model.tool.ToolCallingManager
import org.springframework.boot.test.system.CapturedOutput
import org.springframework.boot.test.system.OutputCaptureExtension
import software.amazon.awssdk.auth.credentials.DefaultCredentialsProvider
import software.amazon.awssdk.http.nio.netty.NettyNioAsyncHttpClient
import software.amazon.awssdk.regions.Region.EU_WEST_3
import software.amazon.awssdk.services.bedrockruntime.BedrockRuntimeAsyncClient
import software.amazon.awssdk.services.bedrockruntime.BedrockRuntimeClient
import java.time.Duration

@ExtendWith(OutputCaptureExtension::class)
class EmbabelBedrockProxyChatModelBuilderTest {

    @Test
    fun `Custom BedrockProxyChatModel builder should not log warn message on init`(output: CapturedOutput) {
        EmbabelBedrockProxyChatModelBuilder()
        assertTrue({ output.isEmpty() }, "Output should be empty, had [$output]")
    }

    @Test
    fun `build should return a default chat model`() {
        val builder = EmbabelBedrockProxyChatModelBuilder()
        val chatModel = builder.build()
        assertNotNull(chatModel)
    }

    @Test
    fun `build should return a fully customized chat model`() {
        val region = EU_WEST_3
        val credentialsProvider = DefaultCredentialsProvider.create()
        val timeout = Duration.ofSeconds(1)
        val defaultOptions = ToolCallingChatOptions.builder().model("model").build()
        val toolCallingManager: ToolCallingManager = mockk()
        val observationRegistry = ObservationRegistry.NOOP
        val observationConvention = DefaultChatModelObservationConvention()

        val chatModel = EmbabelBedrockProxyChatModelBuilder()
            .toolCallingManager(toolCallingManager)
            .toolExecutionEligibilityPredicate(DefaultToolExecutionEligibilityPredicate())
            .customObservationConvention(observationConvention)
            .credentialsProvider(credentialsProvider)
            .region(region)
            .timeout(timeout)
            .defaultOptions(defaultOptions)
            .observationRegistry(observationRegistry)
            .bedrockRuntimeClient(
                BedrockRuntimeClient.builder()
                    .region(region)
                    .httpClientBuilder(null)
                    .credentialsProvider(credentialsProvider)
                    .overrideConfiguration { c -> c.apiCallTimeout(timeout) }
                    .build()
            )
            .bedrockRuntimeAsyncClient(
                BedrockRuntimeAsyncClient.builder()
                    .region(region)
                    .httpClientBuilder(
                        NettyNioAsyncHttpClient.builder()
                            .tcpKeepAlive(true)
                            .connectionAcquisitionTimeout(Duration.ofSeconds(30))
                            .maxConcurrency(200)
                    )
                    .credentialsProvider(credentialsProvider)
                    .overrideConfiguration { c -> c.apiCallTimeout(timeout) }
                    .build()
            )
            .build()

        assertNotNull(chatModel)
    }
}



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-deepseek-autoconfigure/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-autoconfigure</artifactId>
        <version>0.2.0-SNAPSHOT</version>
        <relativePath>../../pom.xml</relativePath>
    </parent>

    <artifactId>embabel-agent-deepseek-autoconfigure</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent Autoconfiguration Models Deepseek</name>
    <description>Deepseek Models for Embabel Agent API</description>

    <dependencies>
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-api</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-deepseek</artifactId>
        </dependency>

        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-test-internal</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

</project>



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-deepseek-autoconfigure/src/main/java/com/embabel/agent/autoconfigure/models/deepseek/AgentDeepSeekAutoConfiguration.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.autoconfigure.models.deepseek;

import com.embabel.agent.config.models.deepseek.DeepSeekModelsConfig;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.autoconfigure.AutoConfiguration;
import org.springframework.boot.autoconfigure.AutoConfigureBefore;
import org.springframework.context.annotation.Import;

/**
 * Autoconfiguration for DeepSeek AI models in the Embabel Agent system.
 * <p>
 * This class serves as a Spring Boot autoconfiguration entry point that:
 * - Scans for configuration properties in the "com.embabel.agent" package
 * - Imports the [DeepSeekModels] configuration to register DeepSeek model beans
 * <p>
 * The configuration is automatically activated when the DeepSeek models
 * dependencies are present on the classpath.
 */
@AutoConfiguration
@AutoConfigureBefore(name = {"com.embabel.agent.autoconfigure.platform.AgentPlatformAutoConfiguration"})
@Import(DeepSeekModelsConfig.class)
public class AgentDeepSeekAutoConfiguration {
    private static final Logger logger = LoggerFactory.getLogger(AgentDeepSeekAutoConfiguration.class);

    @PostConstruct
    public void logEvent() {
        logger.info("AgentDeepseekAutoConfiguration about to proceed...");
    }
}



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-deepseek-autoconfigure/src/main/kotlin/com/embabel/agent/config/models/deepseek/DeepSeekModelsConfig.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.models.deepseek

import com.embabel.agent.common.RetryProperties
import com.embabel.agent.api.models.DeepSeekModels
import com.embabel.common.ai.model.Llm
import com.embabel.common.ai.model.OptionsConverter
import com.embabel.common.ai.model.PerTokenPricingModel
import com.embabel.common.util.ExcludeFromJacocoGeneratedReport
import io.micrometer.observation.ObservationRegistry
import org.slf4j.LoggerFactory
import org.springframework.ai.deepseek.DeepSeekChatModel
import org.springframework.ai.deepseek.DeepSeekChatOptions
import org.springframework.ai.deepseek.api.DeepSeekApi
import org.springframework.ai.model.tool.ToolCallingManager
import org.springframework.beans.factory.ObjectProvider
import org.springframework.beans.factory.annotation.Value
import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.web.client.RestClient
import org.springframework.web.reactive.function.client.WebClient
import java.time.LocalDate

/**
 * Configuration properties for Deepseek models.
 * These properties are bound from the Spring configuration with the prefix
 * "embabel.agent.platform.models.deepseek" and control retry behavior
 * when calling Deepseek APIs.
 */
@ConfigurationProperties(prefix = "embabel.agent.platform.models.deepseek")
class DeepSeekProperties : RetryProperties {
    /**
     *  Maximum number of attempts.
     */
    override var maxAttempts: Int = 4

    /**
     * Initial backoff interval (in milliseconds).
     */
    override var backoffMillis: Long = 1500L

    /**
     * Backoff interval multiplier.
     */
    override var backoffMultiplier: Double = 2.0

    /**
     * Maximum backoff interval (in milliseconds).
     */
    override var backoffMaxInterval: Long = 60000L
}

/**
 * Configuration class for DeepSeek models.
 * This class provides beans for various DeepSeek models (chat, reasoner)
 * and handles the creation of DeepSeek API clients with proper authentication.
 */
@Configuration(proxyBeanMethods = false)
@ExcludeFromJacocoGeneratedReport(reason = "DeepSeek configuration can't be unit tested")
class DeepSeekModelsConfig(
    @param:Value("\${DEEPSEEK_BASE_URL:}")
    private val baseUrl: String,
    @param:Value("\${DEEPSEEK_API_KEY}")
    private val apiKey: String,
    private val properties: DeepSeekProperties,
    private val observationRegistry: ObjectProvider<ObservationRegistry>,
) {
    private val logger = LoggerFactory.getLogger(DeepSeekModelsConfig::class.java)

    init {
        logger.info("DeepSeek models are available: {}", properties)
    }

    @Bean
    fun deepSeekChat(): Llm {
        return deepSeekLlmOf(
            DeepSeekModels.DEEPSEEK_CHAT,
            knowledgeCutoffDate = LocalDate.of(2025, 8, 21),
        )
            // https://api-docs.deepseek.com/quick_start/pricing
            // 1M Input tokens Cache hit $0.07
            // 1M Input tokens Cache miss $0.56
            .copy(
                pricingModel = PerTokenPricingModel(
                    usdPer1mInputTokens = 0.56,
                    usdPer1mOutputTokens = 1.68,
                )
            )
    }

    @Bean
    fun deepSeekReasoner(): Llm = deepSeekLlmOf(
        DeepSeekModels.DEEPSEEK_REASONER,
        knowledgeCutoffDate = LocalDate.of(2025, 5, 28),
    )
        // https://api-docs.deepseek.com/quick_start/pricing
        // 1M Input tokens Cache hit $0.07
        // 1M Input tokens Cache miss $0.56
        .copy(
            pricingModel = PerTokenPricingModel(
                usdPer1mInputTokens = 0.56,
                usdPer1mOutputTokens = 1.68,
            )
        )

    private fun deepSeekLlmOf(
        name: String,
        knowledgeCutoffDate: LocalDate?,
    ): Llm {
        val chatModel = DeepSeekChatModel
            .builder()
            .observationRegistry(observationRegistry.getIfUnique { ObservationRegistry.NOOP })
            .toolCallingManager(
                ToolCallingManager.builder()
                    .observationRegistry(observationRegistry.getIfUnique { ObservationRegistry.NOOP })
                    .build()
            )
            .defaultOptions(
                DeepSeekChatOptions.builder()
                    .model(name)
                    .build()
            )
            .deepSeekApi(createDeepSeekApi())
            .retryTemplate(properties.retryTemplate(name))
            .build()
        return Llm(
            name = name,
            model = chatModel,
            provider = DeepSeekModels.PROVIDER,
            optionsConverter = DeepSeekOptionsConverter,
            knowledgeCutoffDate = knowledgeCutoffDate,
        )
    }

    private fun createDeepSeekApi(): DeepSeekApi {
        val builder = DeepSeekApi.builder().apiKey(apiKey)
        // If baseUrl is blank, use default baseUrl https://api.deepseek.com
        if (baseUrl.isNotBlank()) {
            logger.info("Using custom DeepSeek base URL: {}", baseUrl)
            builder.baseUrl(baseUrl)
        }
        return builder
            .restClientBuilder(
                RestClient.builder()
                .observationRegistry(observationRegistry.getIfUnique { ObservationRegistry.NOOP })
            )
            .webClientBuilder(
                WebClient.builder()
                .observationRegistry(observationRegistry.getIfUnique { ObservationRegistry.NOOP })
            )
            .build()
    }
}

val DeepSeekOptionsConverter: OptionsConverter<DeepSeekChatOptions> =
    OptionsConverter { options ->
        DeepSeekChatOptions.builder()
            .frequencyPenalty(options.frequencyPenalty)
            .maxTokens(options.maxTokens)
            .presencePenalty(options.presencePenalty)
            .temperature(options.temperature)
            .topP(options.topP)
            .build()

        // logprobs/topLogprobs/responseFormat
    }



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-deepseek-autoconfigure/src/test/kotlin/com/embabel/agent/config/models/deepseek/DeepSeekOptionsConverterTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.models.deepseek

import com.embabel.agent.test.models.OptionsConverterTestSupport
import com.embabel.common.ai.model.LlmOptions
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test
import org.springframework.ai.deepseek.DeepSeekChatOptions

class DeepSeekOptionsConverterTest : OptionsConverterTestSupport<DeepSeekChatOptions>(
    optionsConverter = DeepSeekOptionsConverter
) {
    @Test
    fun `should set override maxTokens default`() {
        val options = optionsConverter.convertOptions(LlmOptions().withMaxTokens(200))
        assertEquals(200, options.maxTokens)
    }
}



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-dockermodels-autoconfigure/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-autoconfigure</artifactId>
        <version>0.2.0-SNAPSHOT</version>
        <relativePath>../../pom.xml</relativePath>
    </parent>
    <artifactId>embabel-agent-dockermodels-autoconfigure</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent Autoconfiguration Models Docker</name>
    <description>Docker Local Models for Embabel Agent API</description>

    <dependencies>
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-api</artifactId>
        </dependency>

        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-test-internal</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

</project>



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-dockermodels-autoconfigure/src/main/java/com/embabel/agent/autoconfigure/models/docker/AgentDockerModelsAutoConfiguration.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.autoconfigure.models.docker;

import com.embabel.agent.config.models.docker.DockerLocalModelsConfig;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.autoconfigure.AutoConfiguration;
import org.springframework.boot.autoconfigure.AutoConfigureBefore;
import org.springframework.context.annotation.Import;

/**
 * Autoconfiguration for Docker AI models in the Embabel Agent system.
 * <p>
 * This class serves as a Spring Boot autoconfiguration entry point that:
 * - Scans for configuration properties in the "com.embabel.agent" package
 * - Imports the [Docker] configuration to register model beans
 * <p>
 * The configuration is activated by starter dependencies that include Docker model support.
 */
@AutoConfiguration
@AutoConfigureBefore(name = {"com.embabel.agent.autoconfigure.platform.AgentPlatformAutoConfiguration"})
@Import(DockerLocalModelsConfig.class)
public class AgentDockerModelsAutoConfiguration {
    private static final Logger logger = LoggerFactory.getLogger(AgentDockerModelsAutoConfiguration.class);

    @PostConstruct
    public void logEvent() {
        logger.info("AgentOllamaAutoConfiguration about to proceed...");
    }
}



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-dockermodels-autoconfigure/src/main/kotlin/com/embabel/agent/config/models/docker/DockerLocalModelsConfig.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.models.docker

import com.embabel.agent.common.RetryProperties
import com.embabel.agent.api.models.DockerLocalModels.Companion.PROVIDER
import com.embabel.agent.api.models.OpenAiChatOptionsConverter
import com.embabel.common.ai.model.*
import com.embabel.common.util.ExcludeFromJacocoGeneratedReport
import io.micrometer.observation.ObservationRegistry
import jakarta.annotation.PostConstruct
import org.slf4j.LoggerFactory
import org.springframework.ai.document.MetadataMode
import org.springframework.ai.model.NoopApiKey
import org.springframework.ai.model.tool.ToolCallingManager
import org.springframework.ai.openai.OpenAiChatModel
import org.springframework.ai.openai.OpenAiChatOptions
import org.springframework.ai.openai.OpenAiEmbeddingModel
import org.springframework.ai.openai.OpenAiEmbeddingOptions
import org.springframework.ai.openai.api.OpenAiApi
import org.springframework.beans.factory.ObjectProvider
import org.springframework.beans.factory.config.ConfigurableBeanFactory
import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.boot.context.properties.EnableConfigurationProperties
import org.springframework.context.annotation.Configuration
import org.springframework.http.MediaType
import org.springframework.web.client.RestClient
import org.springframework.web.client.body
import org.springframework.web.reactive.function.client.WebClient


@ConfigurationProperties(prefix = "embabel.agent.platform.models.docker")
class DockerRetryProperties : RetryProperties {

    /**
     *  Maximum number of attempts.
     */
    override var maxAttempts: Int = 10

    /**
     * Initial backoff interval (in milliseconds).
     */
    override var backoffMillis: Long = 5000L

    /**
     * Backoff interval multiplier.
     */
    override var backoffMultiplier: Double = 5.0

    /**
     * Maximum backoff interval (in milliseconds).
     */
    override var backoffMaxInterval: Long = 180000L
}

@ConfigurationProperties(prefix = "embabel.agent.models.docker")
class DockerConnectionProperties {
    /**
     * Base URL for Docker model endpoint
     */
    var baseUrl: String = "http://localhost:12434/engines"
}

/**
 * Docker local models
 * This class will always be loaded, but models won't be loaded
 * from the Docker endpoint unless the "docker" profile is set.
 * Model names will be precisely as reported from
 * http://localhost:12434/engines/v1/models (assuming default port).
 */
@ExcludeFromJacocoGeneratedReport(reason = "Docker model configuration can't be unit tested")
@Configuration(proxyBeanMethods = false)
@EnableConfigurationProperties(
    DockerRetryProperties::class,
    DockerConnectionProperties::class,
    ConfigurableModelProviderProperties::class
)
class DockerLocalModelsConfig(
    private val dockerRetryProperties: DockerRetryProperties,
    private val dockerConnectionProperties: DockerConnectionProperties,
    private val configurableBeanFactory: ConfigurableBeanFactory,
    private val properties: ConfigurableModelProviderProperties,
    private val observationRegistry: ObjectProvider<ObservationRegistry>,
) {
    private val logger = LoggerFactory.getLogger(DockerLocalModelsConfig::class.java)

    private data class ModelResponse(
        val `object`: String,
        val data: List<ModelDetails>,
    )

    private data class ModelDetails(
        val id: String,
    )

    private data class Model(
        val id: String,
    )

    private fun loadModels(): List<Model> =
        try {
            val restClient = RestClient.create()
            val response = restClient.get()
                .uri("${dockerConnectionProperties.baseUrl}/v1/models")
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .body<ModelResponse>()

            response?.data?.map { modelDetails ->
                Model(
                    id = modelDetails.id,
                )
            } ?: emptyList()
        } catch (e: Exception) {
            logger.warn("Failed to load models from {}: {}", dockerConnectionProperties.baseUrl, e.message)
            emptyList()
        }


    @PostConstruct
    fun registerModels() {
        logger.info("Docker local models will be discovered at {}", dockerConnectionProperties.baseUrl)

        val models = loadModels()
        logger.info(
            "Discovered the following Docker models:\n{}",
            models.joinToString("\n") { it.id })
        if (models.isEmpty()) {
            logger.warn("No Docker local models discovered. Check Docker server configuration.")
            return
        }

        models.forEach { model ->
            try {
                val beanName = "dockerModel-${model.id}"
                val dockerModel = dockerModelOf(model)

                // Use registerSingleton with a more descriptive bean name
                configurableBeanFactory.registerSingleton(beanName, dockerModel)
                logger.debug(
                    "Successfully registered Docker {} {} as bean {}",
                    dockerModel.model.javaClass.simpleName,
                    model.id,
                    beanName,
                )
            } catch (e: Exception) {
                logger.error("Failed to register Docker model {}", model.id, e)
            }
        }
    }

    /**
     * Docker models are open AI compatible
     */
    private fun dockerModelOf(model: Model): AiModel<*> {
        return if (properties.allWellKnownEmbeddingServiceNames().contains(model.id)) {
            dockerEmbeddingServiceOf(model)
        } else {
            return dockerLlmOf(model)
        }
    }

    private fun dockerEmbeddingServiceOf(model: Model): EmbeddingService {
        val springEmbeddingModel = OpenAiEmbeddingModel(
            OpenAiApi.Builder()
                .baseUrl(dockerConnectionProperties.baseUrl)
                .apiKey(NoopApiKey())
                .build(),
            MetadataMode.EMBED,
            OpenAiEmbeddingOptions.builder()
                .model(model.id)
                .build(),
        )

        return EmbeddingService(
            name = model.id,
            model = springEmbeddingModel,
            provider = PROVIDER,
        )
    }

    private fun dockerLlmOf(model: Model): Llm {
        val chatModel = OpenAiChatModel.builder()
            .openAiApi(
                OpenAiApi.Builder()
                    .baseUrl(dockerConnectionProperties.baseUrl)
                    .apiKey(NoopApiKey())
                    .restClientBuilder(
                        RestClient.builder()
                        .observationRegistry(observationRegistry.getIfUnique { ObservationRegistry.NOOP })
                    )
                    .webClientBuilder(
                        WebClient.builder()
                        .observationRegistry(observationRegistry.getIfUnique { ObservationRegistry.NOOP })
                    )
                    .build()
            )
            .observationRegistry(observationRegistry.getIfUnique { ObservationRegistry.NOOP })
            .toolCallingManager(
                ToolCallingManager.builder()
                    .observationRegistry(observationRegistry.getIfUnique { ObservationRegistry.NOOP })
                    .build()
            )
            .defaultOptions(
                OpenAiChatOptions.builder()
                    .model(model.id)
                    .build()
            )
            .retryTemplate(dockerRetryProperties.retryTemplate("docker-${model.id}"))
            .build()
        return Llm(
            name = model.id,
            model = chatModel,
            provider = PROVIDER,
            optionsConverter = OpenAiChatOptionsConverter,
            knowledgeCutoffDate = null,
            pricingModel = PricingModel.ALL_YOU_CAN_EAT,
        )
    }

}



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-dockermodels-autoconfigure/src/main/resources/META-INF/spring.factories
================================================
[Empty file]


================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-dockermodels-autoconfigure/src/main/resources/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports
================================================
com.embabel.agent.autoconfigure.models.docker.AgentDockerModelsAutoConfiguration


================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-ollama-autoconfigure/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-autoconfigure</artifactId>
        <version>0.2.0-SNAPSHOT</version>
        <relativePath>../../pom.xml</relativePath>
    </parent>
    <artifactId>embabel-agent-ollama-autoconfigure</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent Autoconfiguration Models Ollama</name>
    <description>Ollama Models for Embabel Agent API</description>

    <dependencies>
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-api</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-ollama</artifactId>
        </dependency>

        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-test-internal</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

</project>



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-ollama-autoconfigure/src/main/java/com/embabel/agent/autoconfigure/models/ollama/AgentOllamaAutoConfiguration.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.autoconfigure.models.ollama;

import com.embabel.agent.config.models.ollama.OllamaModelsConfig;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.autoconfigure.AutoConfiguration;
import org.springframework.boot.autoconfigure.AutoConfigureBefore;
import org.springframework.context.annotation.Import;

/**
 * Autoconfiguration for Ollama AI models in the Embabel Agent system.
 * <p>
 * This class serves as a Spring Boot autoconfiguration entry point that:
 * - Scans for configuration properties in the "com.embabel.agent" package
 * - Imports the [Ollama] configuration to register  model beans
 * <p>
 * The configuration is automatically activated
 */
@AutoConfiguration
@AutoConfigureBefore(name = {"com.embabel.agent.autoconfigure.platform.AgentPlatformAutoConfiguration"})
@Import(OllamaModelsConfig.class)
public class AgentOllamaAutoConfiguration {
    private static final Logger logger = LoggerFactory.getLogger(AgentOllamaAutoConfiguration.class);

    @PostConstruct
    public void logEvent() {
        logger.info("AgentOllamaAutoConfiguration about to proceed...");
    }
}



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-ollama-autoconfigure/src/main/kotlin/com/embabel/agent/config/models/ollama/OllamaModelsConfig.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.models.ollama

import com.embabel.agent.api.models.OllamaModels
import com.embabel.common.ai.model.*
import com.embabel.common.util.ExcludeFromJacocoGeneratedReport
import com.fasterxml.jackson.annotation.JsonProperty
import io.micrometer.observation.ObservationRegistry
import jakarta.annotation.PostConstruct
import org.slf4j.LoggerFactory
import org.springframework.ai.model.tool.ToolCallingManager
import org.springframework.ai.ollama.OllamaChatModel
import org.springframework.ai.ollama.OllamaEmbeddingModel
import org.springframework.ai.ollama.api.OllamaApi
import org.springframework.ai.ollama.api.OllamaOptions
import org.springframework.beans.factory.ObjectProvider
import org.springframework.beans.factory.annotation.Value
import org.springframework.beans.factory.config.ConfigurableBeanFactory
import org.springframework.context.annotation.Configuration
import org.springframework.http.MediaType
import org.springframework.web.client.RestClient
import org.springframework.web.client.body
import org.springframework.web.reactive.function.client.WebClient

/**
 * Load Ollama local models, both LLMs and embedding models.
 * This class will always be loaded, but models won't be loaded
 * from Ollama unless the "ollama" profile is set.
 */
@ExcludeFromJacocoGeneratedReport(reason = "Ollama configuration can't be unit tested")
@Configuration(proxyBeanMethods = false)
class OllamaModelsConfig(
    @param:Value("\${spring.ai.ollama.base-url}")
    private val baseUrl: String,
    private val configurableBeanFactory: ConfigurableBeanFactory,
    private val properties: ConfigurableModelProviderProperties,
    private val observationRegistry: ObjectProvider<ObservationRegistry>,
) {
    private val logger = LoggerFactory.getLogger(OllamaModelsConfig::class.java)

    private data class ModelResponse(
        @param:JsonProperty("models") val models: List<ModelDetails>,
    )

    private data class ModelDetails(
        @param:JsonProperty("name") val name: String,
        @param:JsonProperty("size") val size: Long,
        @param:JsonProperty("modified_at") val modifiedAt: String,
    )

    private data class Model(
        val name: String,
        val model: String,
        val size: Long,
    )

    private fun loadModels(): List<Model> =
        try {
            val restClient = RestClient.create()
            val response = restClient.get()
                .uri("$baseUrl/api/tags")
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .body<ModelResponse>()

            response?.models?.mapNotNull { modelDetails ->
                // Additional validation to ensure model names are valid
                if (modelDetails.name.isNotBlank()) {
                    Model(
                        name = modelDetails.name.replace(":", "-").lowercase(),
                        model = modelDetails.name,
                        size = modelDetails.size
                    )
                } else null
            } ?: emptyList()
        } catch (e: Exception) {
            logger.warn("Failed to load models from {}: {}", baseUrl, e.message)
            emptyList()
        }


    @PostConstruct
    fun registerModels() {
        logger.info("Ollama models will be discovered at {}", baseUrl)

        val models = loadModels()
        if (models.isEmpty()) {
            logger.warn("No Ollama models discovered. Check Ollama server configuration.")
        } else {
            logger.info("Discovered Ollama models: {}", models.map { it.name })
        }

        models.forEach { model ->
            try {
                val beanName = "ollamaModel-${model.name}"
                if (properties.allWellKnownEmbeddingServiceNames().contains(model.model)) {
                    val embeddingService = ollamaEmbeddingServiceOf(model.model)
                    val embeddingBeanName = "ollamaEmbeddingModel-${model.name}"
                    configurableBeanFactory.registerSingleton(embeddingBeanName, embeddingService)
                    logger.debug(
                        "Successfully registered Ollama embedding service {} as bean {}",
                        model.name,
                        embeddingBeanName,
                    )
                } else {
                    val llm = ollamaLlmOf(model.model)

                    // Use registerSingleton with a more descriptive bean name
                    configurableBeanFactory.registerSingleton(beanName, llm)
                    logger.debug(
                        "Successfully registered Ollama LLM {} as bean {}",
                        model.name,
                        beanName,
                    )
                }
            } catch (e: Exception) {
                logger.error("Failed to register Ollama model {}: {}", model.name, e.message)
            }
        }
    }

    private fun ollamaLlmOf(name: String): Llm {
        val springChatModel = OllamaChatModel.builder()
            .ollamaApi(
                OllamaApi.builder()
                    .baseUrl(baseUrl)
                    .restClientBuilder(
                        RestClient.builder()
                        .observationRegistry(observationRegistry.getIfUnique { ObservationRegistry.NOOP })
                    )
                    .webClientBuilder(
                        WebClient.builder()
                        .observationRegistry(observationRegistry.getIfUnique { ObservationRegistry.NOOP })
                    )
                    .build()
            )
            .defaultOptions(
                OllamaOptions.builder()
                    .model(name)
                    .build()
            )
            .observationRegistry(observationRegistry.getIfUnique { ObservationRegistry.NOOP })
            .toolCallingManager(
                ToolCallingManager.builder()
                    .observationRegistry(observationRegistry.getIfUnique { ObservationRegistry.NOOP })
                    .build()
            )
            .build()

        return Llm(
            name = name,
            model = springChatModel,
            provider = OllamaModels.PROVIDER,
            pricingModel = PricingModel.ALL_YOU_CAN_EAT,
            optionsConverter = OllamaOptionsConverter,
        )
    }


    private fun ollamaEmbeddingServiceOf(name: String): EmbeddingService {
        val springEmbeddingModel = OllamaEmbeddingModel.builder()
            .ollamaApi(
                OllamaApi.builder()
                    .baseUrl(baseUrl)
                    .restClientBuilder(
                        RestClient.builder()
                        .observationRegistry(observationRegistry.getIfUnique { ObservationRegistry.NOOP })
                    )
                    .webClientBuilder(
                        WebClient.builder()
                        .observationRegistry(observationRegistry.getIfUnique { ObservationRegistry.NOOP })
                    )
                    .build()
            )
            .defaultOptions(
                OllamaOptions.builder()
                    .model(name)
                    .build()
            )
            .build()

        return EmbeddingService(
            name = name,
            model = springEmbeddingModel,
            provider = OllamaModels.PROVIDER,
        )
    }
}

object OllamaOptionsConverter : OptionsConverter<OllamaOptions> {
    override fun convertOptions(options: LlmOptions): OllamaOptions =
        OllamaOptions.builder()
            .temperature(options.temperature)
            .topP(options.topP)
            .presencePenalty(options.presencePenalty)
            .frequencyPenalty(options.frequencyPenalty)
            .topK(options.topK)
            .build()
}



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-ollama-autoconfigure/src/main/resources/META-INF/spring.factories
================================================
[Empty file]


================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-ollama-autoconfigure/src/main/resources/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports
================================================
com.embabel.agent.autoconfigure.models.ollama.AgentOllamaAutoConfiguration


================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-ollama-autoconfigure/src/test/kotlin/com/embabel/agent/config/models/ollama/OllamaOptionsConverterTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.models.ollama

import com.embabel.agent.test.models.OptionsConverterTestSupport
import org.springframework.ai.ollama.api.OllamaOptions

class OllamaOptionsConverterTest : OptionsConverterTestSupport<OllamaOptions>(
    optionsConverter = OllamaOptionsConverter
)



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-openai-autoconfigure/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-autoconfigure</artifactId>
        <version>0.2.0-SNAPSHOT</version>
        <relativePath>../../pom.xml</relativePath>
    </parent>
    <artifactId>embabel-agent-openai-autoconfigure</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent Autoconfiguration Models OpenAI</name>
    <description>OpenAI models Auto-Configuration for Embabel Agent API</description>

    <dependencies>
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-api</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-openai</artifactId>
        </dependency>

        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-test-internal</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

</project>



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-openai-autoconfigure/src/main/java/com/embabel/agent/autoconfigure/models/openai/AgentOpenAiAutoConfiguration.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.autoconfigure.models.openai;

import com.embabel.agent.config.models.openai.OpenAiModelsConfig;
import org.springframework.boot.autoconfigure.AutoConfiguration;
import org.springframework.boot.autoconfigure.AutoConfigureBefore;
import org.springframework.context.annotation.Import;

/**
 * Autoconfiguration for OpenAI models in the Embabel Agent system.
 * <p>
 * This class serves as a Spring Boot autoconfiguration entry point that:
 * - Scans for configuration properties in the "com.embabel.agent" package
 * - Imports the {@link OpenAiModelsConfig} configuration to register OpenAI model beans
 * <p>
 * The configuration is automatically activated when the OpenAI models
 * dependencies are present on the classpath.
 */
@AutoConfiguration
@AutoConfigureBefore(name = {"com.embabel.agent.autoconfigure.platform.AgentPlatformAutoConfiguration"})
@Import(OpenAiModelsConfig.class)
public class AgentOpenAiAutoConfiguration {
}



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-openai-autoconfigure/src/main/kotlin/com/embabel/agent/config/models/openai/OpenAiModelsConfig.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.models.openai

import com.embabel.agent.common.RetryProperties
import com.embabel.agent.api.models.OpenAiCompatibleModelFactory
import com.embabel.agent.api.models.OpenAiModels
import com.embabel.common.ai.model.*
import com.embabel.common.util.ExcludeFromJacocoGeneratedReport
import com.embabel.common.util.loggerFor
import io.micrometer.observation.ObservationRegistry
import org.springframework.ai.openai.OpenAiChatOptions
import org.springframework.beans.factory.ObjectProvider
import org.springframework.beans.factory.annotation.Value
import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import java.time.LocalDate


/**
 * Configuration properties for OpenAI model settings.
 * These properties can be set in application.properties/yaml using the
 * prefix embabel.agent.platform.models.openai.
 */
@ConfigurationProperties(prefix = "embabel.agent.platform.models.openai")
class OpenAiProperties : RetryProperties {
    /**
     *  Maximum number of attempts.
     */
    override var maxAttempts: Int = 10

    /**
     * Initial backoff interval (in milliseconds).
     */
    override var backoffMillis: Long = 5000L

    /**
     * Backoff interval multiplier.
     */
    override var backoffMultiplier: Double = 5.0

    /**
     * Maximum backoff interval (in milliseconds).
     */
    override var backoffMaxInterval: Long = 180000L
}

/**
 * Configuration for well-known OpenAI language and embedding models.
 * Provides bean definitions for various GPT models with their corresponding
 * capabilities, knowledge cutoff dates, and pricing models.
 */
@Configuration(proxyBeanMethods = false)
@ExcludeFromJacocoGeneratedReport(reason = "OpenAi configuration can't be unit tested")
class OpenAiModelsConfig(
    @Value("\${OPENAI_BASE_URL:#{null}}")
    baseUrl: String?,
    @Value("\${OPENAI_API_KEY}")
    apiKey: String,
    @Value("\${OPENAI_COMPLETIONS_PATH:#{null}}")
    completionsPath: String?,
    @Value("\${OPENAI_EMBEDDINGS_PATH:#{null}}")
    embeddingsPath: String?,
    observationRegistry: ObjectProvider<ObservationRegistry>,
    private val properties: OpenAiProperties,
) : OpenAiCompatibleModelFactory(
    baseUrl = baseUrl,
    apiKey = apiKey,
    completionsPath = completionsPath,
    embeddingsPath = embeddingsPath,
    observationRegistry = observationRegistry.getIfUnique { ObservationRegistry.NOOP }
) {

    init {
        logger.info("Open AI models are available: {}", properties)
    }

    @Bean
    fun gpt5(): Llm {
        return openAiCompatibleLlm(
            model = OpenAiModels.GPT_5,
            provider = OpenAiModels.PROVIDER,
            knowledgeCutoffDate = LocalDate.of(2024, 10, 1),
            pricingModel = PerTokenPricingModel(
                usdPer1mInputTokens = 1.25,
                usdPer1mOutputTokens = 10.0,
            ),
            retryTemplate = properties.retryTemplate(OpenAiModels.GPT_5),
            optionsConverter = Gpt5ChatOptionsConverter,
        )
    }

    @Bean
    fun gpt5mini(): Llm {
        return openAiCompatibleLlm(
            model = OpenAiModels.GPT_5_MINI,
            provider = OpenAiModels.PROVIDER,
            knowledgeCutoffDate = LocalDate.of(2024, 5, 31),
            pricingModel = PerTokenPricingModel(
                usdPer1mInputTokens = .25,
                usdPer1mOutputTokens = 2.0,
            ),
            retryTemplate = properties.retryTemplate(OpenAiModels.GPT_5_MINI),
            optionsConverter = Gpt5ChatOptionsConverter,
        )
    }

    @Bean
    fun gpt5nano(): Llm {
        return openAiCompatibleLlm(
            model = OpenAiModels.GPT_5_NANO,
            provider = OpenAiModels.PROVIDER,
            knowledgeCutoffDate = LocalDate.of(2024, 5, 31),
            pricingModel = PerTokenPricingModel(
                usdPer1mInputTokens = .05,
                usdPer1mOutputTokens = .40,
            ),
            optionsConverter = Gpt5ChatOptionsConverter,
            retryTemplate = properties.retryTemplate(OpenAiModels.GPT_5_NANO),
        )
    }

    @Bean
    fun gpt41mini(): Llm {
        return openAiCompatibleLlm(
            model = OpenAiModels.GPT_41_MINI,
            provider = OpenAiModels.PROVIDER,
            knowledgeCutoffDate = LocalDate.of(2024, 7, 18),
            pricingModel = PerTokenPricingModel(
                usdPer1mInputTokens = .40,
                usdPer1mOutputTokens = 1.6,
            ),
            retryTemplate = properties.retryTemplate(OpenAiModels.GPT_41_MINI),
        )
    }

    @Bean
    fun gpt41(): Llm {
        return openAiCompatibleLlm(
            model = OpenAiModels.GPT_41,
            provider = OpenAiModels.PROVIDER,
            knowledgeCutoffDate = LocalDate.of(2024, 8, 6),
            pricingModel = PerTokenPricingModel(
                usdPer1mInputTokens = 2.0,
                usdPer1mOutputTokens = 8.0,
            ),
            retryTemplate = properties.retryTemplate(OpenAiModels.GPT_41),
        )
    }

    @Bean
    fun gpt41nano(): Llm {
        return openAiCompatibleLlm(
            model = OpenAiModels.GPT_41_NANO,
            provider = OpenAiModels.PROVIDER,
            knowledgeCutoffDate = LocalDate.of(2024, 8, 6),
            pricingModel = PerTokenPricingModel(
                usdPer1mInputTokens = .1,
                usdPer1mOutputTokens = .4,
            ),
            retryTemplate = properties.retryTemplate(OpenAiModels.GPT_41_NANO),
        )
    }

    @Bean
    fun defaultOpenAiEmbeddingService(): EmbeddingService {
        return openAiCompatibleEmbeddingService(
            model = OpenAiModels.DEFAULT_TEXT_EMBEDDING_MODEL,
            provider = OpenAiModels.PROVIDER,
        )
    }
}

internal object Gpt5ChatOptionsConverter : OptionsConverter<OpenAiChatOptions> {

    override fun convertOptions(options: LlmOptions): OpenAiChatOptions {
        if (options.temperature != null && options.temperature != 1.0) {
            loggerFor<Gpt5ChatOptionsConverter>().warn(
                "GPT-5 models do not support temperature settings other than default 1.0. You set {} but it will be ignored.",
                options.temperature,
            )
        }
        return OpenAiChatOptions.builder()
            .topP(options.topP)
            .maxTokens(options.maxTokens)
            .presencePenalty(options.presencePenalty)
            .frequencyPenalty(options.frequencyPenalty)
//            .topP(options.topP)
            .build()
    }
}



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-openai-autoconfigure/src/test/kotlin/com/embabel/agent/config/models/openai/Gpt5ChatOptionsConverterTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.models.openai

import com.embabel.agent.api.models.OpenAiModels
import com.embabel.common.ai.model.LlmOptions
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertNull
import org.junit.jupiter.api.Disabled
import org.junit.jupiter.api.Test

class Gpt5ChatOptionsConverterTest(
) {

    @Test
    fun `ignores temperature`() {
        val llmo = LlmOptions().withTemperature(temperature = 0.5)
        val options = Gpt5ChatOptionsConverter.convertOptions(llmo)
        assertEquals(null, options.temperature, "Custom temperature should be ignored for GPT-5")
    }

    @Test
    fun `respects non-temperature options`() {
        val llmo = LlmOptions.withModel(OpenAiModels.GPT_5).withTopK(10).withTopP(.2)
        val options = Gpt5ChatOptionsConverter.convertOptions(llmo)
        assertEquals(llmo.topP, options.topP, "Top P should be preserved for GPT-5")
        assertNull(options.temperature, "Temperature should not be set for GPT-5")
    }

    @Disabled("We not support thinking effort yet")
    @Test
    fun `supports thinking effort`() {

    }

}



================================================
FILE: embabel-agent-autoconfigure/models/embabel-agent-openai-autoconfigure/src/test/kotlin/com/embabel/agent/config/models/openai/OpenAiOptionsConverterTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.config.models.openai

import com.embabel.agent.api.models.OpenAiChatOptionsConverter
import com.embabel.agent.test.models.OptionsConverterTestSupport
import org.springframework.ai.openai.OpenAiChatOptions

class OpenAiOptionsConverterTest : OptionsConverterTestSupport<OpenAiChatOptions>(
    optionsConverter = OpenAiChatOptionsConverter
)



================================================
FILE: embabel-agent-code/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-parent</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-code</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent Coding Domain Library</name>
    <description>Embabel Coding Domain Library</description>

    <dependencies>
        <!-- Main Dependencies -->
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-api</artifactId>
        </dependency>

        <!-- https://mvnrepository.com/artifact/io.github.classgraph/classgraph -->
        <dependency>
            <groupId>io.github.classgraph</groupId>
            <artifactId>classgraph</artifactId>
            <version>4.8.181</version>
        </dependency>

        <!-- JGit for git operations -->
        <dependency>
            <groupId>org.eclipse.jgit</groupId>
            <artifactId>org.eclipse.jgit</artifactId>
            <version>7.0.1.202505221510-r</version>
        </dependency>

        <!-- JavaParser for source code analysis -->
        <dependency>
            <groupId>com.github.javaparser</groupId>
            <artifactId>javaparser-core</artifactId>
            <version>3.26.2</version>
        </dependency>

        <dependency>
            <groupId>com.github.javaparser</groupId>
            <artifactId>javaparser-symbol-solver-core</artifactId>
            <version>3.26.2</version>
        </dependency>

        <!-- Test Dependencies -->
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-test-internal</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.jetbrains.kotlin</groupId>
                <artifactId>kotlin-maven-plugin</artifactId>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
            </plugin>

        </plugins>
    </build>

</project>


================================================
FILE: embabel-agent-code/src/main/kotlin/com/embabel/agent/domain/library/code/SoftwareProject.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.domain.library.code

import com.embabel.agent.api.common.LlmReference
import com.embabel.agent.tools.file.*
import com.embabel.coding.tools.ci.BuildOptions
import com.embabel.coding.tools.ci.BuildResult
import com.embabel.coding.tools.ci.Ci
import com.embabel.coding.tools.git.GitOperations
import com.embabel.common.util.StringTransformer
import com.embabel.common.util.loggerFor
import com.fasterxml.jackson.annotation.JsonClassDescription
import com.fasterxml.jackson.annotation.JsonPropertyDescription
import org.springframework.ai.tool.annotation.Tool
import org.springframework.ai.tool.annotation.ToolParam

/**
 * Represents a software project that supports CI
 * and git
 *
 * Open to allow extension
 */
@JsonClassDescription("Analysis of a technology project")
open class SoftwareProject @JvmOverloads constructor(
    override val root: String,
    val url: String? = null,
    @get:JsonPropertyDescription("The technologies used in the project. List, comma separated. Include 10")
    val tech: String = "Java,Embabel,Spring Boot,Maven",
    val defaultCodingStyle: String = """
            No coding style guide found at ${DEFAULT_CODING_STYLE_GUIDE}.
            Try to follow the conventions of files you read in the project.
        """.trimIndent(),
    @get:JsonPropertyDescription("Build command, such as 'mvn clean test'")
    val buildCommand: String = "mvn clean test",
    val streamOutput: Boolean = false,
    val wasCreated: Boolean = false,
) : LlmReference, FileTools, SymbolSearch, GitOperations, FileChangeLog by DefaultFileChangeLog(), FileReadLog by DefaultFileReadLog() {

    init {
        if (!exists()) {
            error("Directory '$root' does not exist")
        }
        loggerFor<SoftwareProject>().info(
            "Software project tools: ${
                toolCallbacks.map { it.toolDefinition.name() }.sorted()
            }"
        )
    }

    override val name
        get() = root.substringAfterLast('/')

    override val description get() = "Software project at $root${if (url != null) " from $url" else ""} using $tech"

    val codingStyle: String
        get() {
            val location = DEFAULT_CODING_STYLE_GUIDE
            loggerFor<SoftwareProject>().info("Looking for coding style guide at '$location'")
            val content = safeReadFile(location)
            loggerFor<SoftwareProject>().info("Found coding style guide at $location")
            return content
                ?: defaultCodingStyle
        }

    override val fileContentTransformers: List<StringTransformer>
        get() = listOf(WellKnownFileContentTransformers.removeApacheLicenseHeader)

    val ci = Ci(root)

    @Tool(description = "Find all Java files under src/main/java. Good for quickly getting to grips with a project")
    fun findJavaFiles(): List<String> {
        val files = findFiles("src/main/java/**.java", findHighest = false)
        return if (files.size > 100) {
            listOf("More than 100 Java files found, please narrow your search")
        } else {
            files
        }
    }

    @Tool(description = "Returns the file containing a class with the given name")
    fun findClass(@ToolParam(description = "class name") name: String): String {
        val matches = findClassInProject(name, globPattern = "**/*.{java,kt}")
        return if (matches.isNotEmpty()) {
            matches.joinToString("\n") { it.relativePath }
        } else {
            "No class found with name $name"
        }
    }

    @Tool(description = "Returns the file containing a class with the given name")
    fun findPattern(
        @ToolParam(description = "regex pattern") regex: String,
        @ToolParam(description = "glob pattern for file to search") globPattern: String,
    ): String {
        val matches = findPatternInProject(pattern = Regex(regex), globPattern = globPattern)
        return if (matches.isNotEmpty()) {
            matches.joinToString("\n") { it.relativePath }
        } else {
            "No matches for pattern '$regex' in $globPattern"
        }
    }

    @Tool(description = "Build the project using the given command in the root")
    fun build(command: String): String {
        val br = ci.buildAndParse(BuildOptions(command, streamOutput = streamOutput))
        return br.relevantOutput()
    }

    fun build(): BuildResult {
        return ci.buildAndParse(BuildOptions(buildCommand, streamOutput = streamOutput))
    }

    override fun toString(): String {
        return "SoftwareProject($root)"
    }

    override fun notes() =
        """
            |Project:
            |${url ?: "No URL"}
            |$tech
            |
            |Coding style:
            |$codingStyle
        """.trimMargin()

    companion object {
        const val DEFAULT_CODING_STYLE_GUIDE = ".embabel/coding-style.md"
    }

}



================================================
FILE: embabel-agent-code/src/main/kotlin/com/embabel/agent/domain/library/code/SymbolSearch.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.domain.library.code

import com.embabel.agent.tools.file.PatternSearch

/**
 * Extends PatternSearch to provide specific methods for searching for symbols in code.
 */
interface SymbolSearch : PatternSearch {

    fun classPattern(className: String): Regex {
        return Regex(
            "(^|\\s)(class|interface|object|enum\\s+class|data\\s+class|sealed\\s+class|abstract\\s+class)\\s+" +
                    className +  // The exact class name
                    "\\b" +         // Word boundary to ensure it doesn't match partial names
                    "([<(]|\\s|$)"  // Followed by generic parameters, constructor params, whitespace or line end
        )
    }

    fun findClassInProject(
        className: String,
        globPattern: String = "**/*.{kt,java}",
        useParallelSearch: Boolean = true,
    ): List<PatternSearch.PatternMatch> {
        return findPatternInProject(
            pattern = classPattern(className),
            globPattern = globPattern,
            useParallelSearch = useParallelSearch
        )
    }
}



================================================
FILE: embabel-agent-code/src/main/kotlin/com/embabel/coding/tools/api/Api.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.coding.tools.api

import com.embabel.common.core.types.Named

data class ApiMethod(
    val name: String,
    val parameters: List<String>,
    val returnType: String,
    val annotations: List<String> = emptyList(),
    val comment: String? = null,
)

data class ApiClass(
    val name: String,
    val packageName: String,
    val type: String, // class, interface, enum, annotation
    val methods: List<ApiMethod> = emptyList(),
    val annotations: List<String> = emptyList(),
    val superTypes: List<String> = emptyList(),
    val comment: String? = null,
) {

    fun fqn() = "$packageName.$name"
}

/**
 * Representation of an API with its classes and methods.
 */
data class Api(
    override val name: String,
    val classes: List<ApiClass>,
    val totalClasses: Int,
    val totalMethods: Int,
) : Named



================================================
FILE: embabel-agent-code/src/main/kotlin/com/embabel/coding/tools/api/ApiExtractor.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.coding.tools.api

import com.embabel.coding.tools.jvm.ClassGraphApiReferenceExtractor
import com.embabel.coding.tools.jvm.JavaParserApiExtractor
import java.nio.file.Path

/**
 * Unified API extractor that can work with both source code and compiled bytecode.
 */
class ApiExtractor {

    private val javaParserExtractor = JavaParserApiExtractor()
    private val classGraphExtractor = ClassGraphApiReferenceExtractor()

    /**
     * Extract API information from source code directory
     */
    fun fromSourceCode(
        name: String,
        sourceDir: Path,
        acceptedPackages: Set<String> = emptySet(),
        rejectedPackages: Set<String> = JavaParserApiExtractor.DEFAULT_EXCLUDED_PACKAGES,
    ): Api {
        return javaParserExtractor.fromSourceDirectory(name, sourceDir, acceptedPackages, rejectedPackages)
    }

    /**
     * Extract API information from project classpath (compiled bytecode)
     */
    fun fromClasspath(
        name: String,
        acceptedPackages: Set<String>,
        rejectedPackages: Set<String> = ClassGraphApiReferenceExtractor.DEFAULT_EXCLUDED_PACKAGES,
    ): Api {
        return classGraphExtractor.fromProjectClasspath(name, acceptedPackages, rejectedPackages)
    }

    /**
     * Combine API information from multiple sources
     */
    fun combine(name: String, apis: List<Api>): Api {
        val allClasses = apis.flatMap { it.classes }
            .distinctBy { "${it.packageName}.${it.name}" } // Remove duplicates

        val totalMethods = allClasses.sumOf { it.methods.size }

        return Api(name, allClasses, allClasses.size, totalMethods)
    }

    /**
     * Extract API from both source code and classpath, combining results
     */
    fun fromSourceAndClasspath(
        name: String,
        sourceDir: Path?,
        acceptedPackages: Set<String>,
        rejectedPackages: Set<String> = JavaParserApiExtractor.DEFAULT_EXCLUDED_PACKAGES,
    ): Api {
        val apis = mutableListOf<Api>()

        // Extract from source if available
        sourceDir?.let { dir ->
            val sourceApi = fromSourceCode(name + "-source", dir, acceptedPackages, rejectedPackages)
            if (sourceApi.classes.isNotEmpty()) {
                apis.add(sourceApi)
            }
        }

        // Extract from classpath
        val classpathApi = fromClasspath(name + "-classpath", acceptedPackages, rejectedPackages)
        if (classpathApi.classes.isNotEmpty()) {
            apis.add(classpathApi)
        }

        return if (apis.isNotEmpty()) {
            combine(name, apis)
        } else {
            Api(name, emptyList(), 0, 0)
        }
    }
}



================================================
FILE: embabel-agent-code/src/main/kotlin/com/embabel/coding/tools/api/ApiReference.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.coding.tools.api

import com.embabel.agent.api.common.LlmReference
import org.springframework.ai.tool.annotation.Tool

/**
 * API reference that can be exposed to LLMs as a prompt contribution and tools.
 */
class ApiReference(
    override val description: String,
    private val api: Api,
    private val classLimit: Int = 100,
) : LlmReference {

    override val name = api.name

    override fun notes(): String {
        if (api.classes.size > classLimit) {
            return """
                API reference is too large to include here (contains ${api.totalClasses} classes and ${api.totalMethods} methods).
                Use tools to look up specific classes or packages by their fully qualified names (FQN).
            """.trimIndent()
        }
        return """
            API reference for ${api.totalClasses} classes and ${api.totalMethods} methods.
            Use this reference to answer questions about the API, find class or package signatures, and understand how to use the classes and methods.
            You can also use tools to look up specific classes or packages by their fully qualified names (FQN).

            ${formatAsText()}
        """.trimIndent()
    }

    fun formatAsText(): String {
        val sb = StringBuilder()
        sb.appendLine("API Reference - ${api.totalClasses} classes, ${api.totalMethods} methods")
        sb.appendLine()

        for (clazz in api.classes.sortedBy { "${it.packageName}.${it.name}" }) {
            sb.appendLine()
            sb.append(formatClass(clazz))
            sb.appendLine()
        }
        return sb.toString()
    }

    @Tool(description = "find the signature of a class by FQN")
    fun findClassSignatureByFqn(fqn: String): String {
        val classes = api.classes.filter { it.fqn().equals(fqn, ignoreCase = true) }
        return if (classes.isEmpty()) {
            "Class not found: $fqn"
        } else if (classes.size > 1) {
            """
                Multiple classes found with FQN '$fqn'!!
                ${classes.joinToString { formatClass(it) }}
            """.trimIndent()
        } else {
            formatClass(classes.first())
        }
    }

    @Tool(description = "find the signature of a class by simple name")
    fun findClassSignatureBySimpleName(simpleName: String): String {
        val matchingClasses = api.classes.filter { it.name.equals(simpleName, ignoreCase = true) }

        return when (matchingClasses.size) {
            0 -> "Class not found: $simpleName"
            1 -> formatClass(matchingClasses.first())
            else -> {
                val sb = StringBuilder()
                sb.appendLine("Multiple classes found with name '$simpleName':")
                matchingClasses.forEach { clazz ->
                    sb.appendLine("${clazz.packageName}.${clazz.name}")
                }
                sb.toString().trimEnd()
            }
        }
    }

    @Tool(description = "find the signature of a package by FQN")
    fun findPackageSignature(packageName: String): String {
        val classesInPackage = api.classes.filter { it.packageName == packageName }
        if (classesInPackage.isEmpty()) {
            return "Package not found: $packageName"
        }

        val sb = StringBuilder()
        sb.appendLine("Package: $packageName")
        sb.appendLine("Classes:")
        for (clazz in classesInPackage.sortedBy { it.name }) {
            sb.appendLine("  - ${clazz.name} (${clazz.type})")
        }
        return sb.toString()
    }

    fun formatClass(clazz: ApiClass): String {
        val sb = StringBuilder()

        // Class header
        sb.append("${clazz.packageName}.${clazz.name}")
        if (clazz.type != "class") sb.append(" (${clazz.type})")
        sb.appendLine()

        // Class comment
        clazz.comment?.let { comment ->
            sb.appendLine("  // $comment")
        }

        // Annotations
//        if (clazz.annotations.isNotEmpty()) {
//            sb.appendLine("  @${clazz.annotations.joinToString(" @") { it.substringAfterLast('.') }}")
//        }

        // Super types
        if (clazz.superTypes.isNotEmpty()) {
            sb.appendLine("  extends/implements: ${clazz.superTypes.joinToString(", ")}")
        }

        // Methods
        clazz.methods.forEach { method ->
            val params = method.parameters.joinToString(", ")
            val annotations = if (method.annotations.isNotEmpty()) {
                " @${method.annotations.joinToString(" @") { it.substringAfterLast('.') }}"
            } else ""

            // Method with comment
            method.comment?.let { comment ->
                sb.appendLine("    // $comment")
            }
            sb.appendLine("  ${method.name}($params): ${method.returnType}$annotations")
        }
        return sb.toString()
    }
}



================================================
FILE: embabel-agent-code/src/main/kotlin/com/embabel/coding/tools/bash/BashTools.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.coding.tools.bash

import org.springframework.ai.tool.annotation.Tool
import java.io.File

class BashTools(private val workingDirectory: String) {

    @Tool(description = "Generic bash tool")
    fun runBashCommand(command: String): String {
        val process = ProcessBuilder("/bin/bash", "-c", command)
            .directory(File(workingDirectory))
            .redirectErrorStream(true)
            .start()
        return process.inputStream.bufferedReader().readText()
    }
}



================================================
FILE: embabel-agent-code/src/main/kotlin/com/embabel/coding/tools/ci/Ci.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.coding.tools.ci

import com.embabel.agent.tools.DirectoryBased
import com.embabel.coding.tools.jvm.MavenBuildSystemIntegration
import com.embabel.common.ai.prompt.PromptContributor
import com.embabel.common.core.types.Timed
import com.embabel.common.core.types.Timestamped
import com.embabel.common.util.loggerFor
import com.embabel.common.util.time
import org.slf4j.LoggerFactory
import java.nio.file.Paths
import java.time.Duration
import java.time.Instant

/**
 * Options for build
 * @param buildCommand command to run such as "mvn test"
 * @param streamOutput if true, the output will be streamed to the console
 * @param interactive if true, gives full terminal control for interactive commands (Spring Boot, etc.)
 */
data class BuildOptions(
    val buildCommand: String,
    val streamOutput: Boolean = false,
    val interactive: Boolean = false,
)

data class BuildStatus(
    val success: Boolean,
    val relevantOutput: String,
)

/**
 * Result of a build command
 * @param status status of the build if we could parse it
 */
data class BuildResult(
    val status: BuildStatus?,
    val rawOutput: String,
    override val timestamp: Instant = Instant.now(),
    override val runningTime: Duration,
) : Timestamped, Timed, PromptContributor {

    override fun contribution(): String =
        """
            |Build result: success=${status?.success ?: "unknown"}
            |Relevant output:
            |${relevantOutput()}
        """.trimIndent()

    fun relevantOutput(): String {
        return status?.relevantOutput ?: rawOutput
    }
}


/**
 * CI support with pluggable build systems
 */
class Ci(
    override val root: String,
    val buildSystemIntegrations: List<BuildSystemIntegration> = listOf(
        MavenBuildSystemIntegration()
    ),
) : DirectoryBased {

    private val logger = LoggerFactory.getLogger(Ci::class.java)

    /**
     * Detect if running in a CI environment by checking common CI environment variables
     */
    private fun detectCIEnvironment(): Boolean {
        val ciEnvVars = listOf(
            "CI", "CONTINUOUS_INTEGRATION", "BUILD_NUMBER", "RUN_ID",
            "GITHUB_ACTIONS", "GITLAB_CI", "JENKINS_URL", "TRAVIS",
            "CIRCLECI", "BAMBOO_BUILD_NUMBER", "TF_BUILD", "BUILDKITE"
        )

        return ciEnvVars.any { envVar ->
            System.getenv(envVar)?.isNotEmpty() == true
        } || System.console() == null
    }

    /**
     * Build the project with the given command and parse the output
     * Parse status if known
     */
    fun buildAndParse(buildOptions: BuildOptions): BuildResult {
        val (rawOutput, ms) = time {
            build(buildOptions)
        }
        val buildResult = BuildResult(
            status = null,
            rawOutput = rawOutput,
            runningTime = Duration.ofMillis(ms),
        )
        val buildStatus = parseOutput(buildResult.rawOutput)
        return buildResult.copy(status = buildStatus)
    }

    fun parseBuildOutput(
        rawOutput: String,
        runningTime: Duration,
    ): BuildResult {
        val buildResult = BuildResult(
            status = null,
            rawOutput = rawOutput,
            runningTime = runningTime,
        )
        val buildStatus = parseOutput(buildResult.rawOutput)
        return buildResult.copy(status = buildStatus)
    }

    private fun parseOutput(rawOutput: String): BuildStatus {
        for (b in buildSystemIntegrations) {
            val status = b.parseBuildOutput(root, rawOutput)
            if (status != null) {
                return status
            }
        }
        return BuildStatus(
            success = false,
            relevantOutput = "No build system understands this output: Are you sure the build command is correct?\n$rawOutput",
        )
    }

    /**
     * Build the project using the given command
     */
    fun build(buildOptions: BuildOptions): String {
        logger.info("Running build command <{}> in root directory {}", buildOptions.buildCommand, root)

        val processBuilder = ProcessBuilder()

        // Set the working directory to the root
        processBuilder.directory(Paths.get(root).toFile())

        // Configure the command
        val commandParts = buildOptions.buildCommand.split("\\s+".toRegex())
        processBuilder.command(commandParts)

        try {
            val process: Process
            val outputBuilder = StringBuilder()

            if (buildOptions.interactive) {
                // Check if running in CI environment
                val isCI = detectCIEnvironment()

                if (isCI) {
                    // In CI: Use non-interactive mode with output capture
                    logger.info("CI environment detected, falling back to non-interactive mode")
                    processBuilder.redirectErrorStream(true)
                    process = processBuilder.start()

                    // Capture output for CI logs
                    val output = process.inputStream.bufferedReader().use { it.readText() }
                    outputBuilder.append(output)

                    val exitCode = process.waitFor()

                    return if (exitCode == 0) {
                        "Command executed successfully in CI mode:\n$output"
                    } else {
                        "Command failed with exit code $exitCode in CI mode:\n$output"
                    }
                } else {
                    // Interactive mode: give full terminal control
                    processBuilder.inheritIO()
                    process = processBuilder.start()

                    val exitCode = process.waitFor()

                    return if (exitCode == 0) {
                        "Interactive command executed successfully"
                    } else {
                        "Interactive command failed with exit code $exitCode"
                    }
                }
            } else {
                // Non-interactive mode: capture output
                processBuilder.redirectErrorStream(true)
                process = processBuilder.start()

                // Handle the output differently based on streamOutput flag
                if (buildOptions.streamOutput) {
                    // Stream the output to the console while also capturing it
                    process.inputStream.bufferedReader().use { reader ->
                        var line: String?
                        while (reader.readLine().also { line = it } != null) {
                            println(line)
                            outputBuilder.append(line).append("\n")
                        }
                    }
                } else {
                    val output = process.inputStream.bufferedReader().use { it.readText() }
                    outputBuilder.append(output)
                }

                val exitCode = process.waitFor()
                val output = outputBuilder.toString()

                return if (exitCode == 0) {
                    logger.info("✅ Build command <{}> in root directory {}", buildOptions.buildCommand, root)
                    "Command executed successfully:\n$output"
                } else {
                    logger.info("❌ Build command <{}> in root directory {}", buildOptions.buildCommand, root)
                    "Command failed with exit code $exitCode:\n$output"
                }
            }
        } catch (e: Exception) {
            loggerFor<CiTools>().error("Error executing command: ${buildOptions.buildCommand}", e)
            return "Error executing command: ${e.message}"
        }
    }

}

interface BuildSystemIntegration {

    /**
     * If possible, parse the build result
     */
    fun parseBuildOutput(
        root: String,
        rawOutput: String,
    ): BuildStatus?
}



================================================
FILE: embabel-agent-code/src/main/kotlin/com/embabel/coding/tools/ci/CiTools.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.coding.tools.ci

import com.embabel.agent.api.common.support.SelfToolCallbackPublisher
import com.embabel.agent.tools.DirectoryBased
import org.springframework.ai.tool.annotation.Tool

/**
 * Interface for Continuous Integration tools that enable building and testing projects.
 *
 * The CiTools interface provides functionality for executing build commands within a project's
 * root directory. It serves as a bridge between the agent and the underlying build system,
 * allowing for seamless integration with various build tools like Maven, Gradle, npm, etc.
 *
 * This interface extends:
 * - [SelfToolCallbackPublisher]: Automatically publishes methods annotated with @Tool to be
 *   available as callable tools by the agent system. This enables the methods to be discovered
 *   and invoked through the tool callback mechanism.
 * - [DirectoryBased]: Provides access to the root directory on the host machine where the
 *   project is located. This allows build commands to be executed in the correct context.
 *
 * Implementations of this interface are expected to handle the execution of build commands
 * and process their output appropriately.
 *
 * @see SelfToolCallbackPublisher
 * @see DirectoryBased
 * @see Ci
 * @see BuildOptions
 */
interface CiTools : SelfToolCallbackPublisher, DirectoryBased {

    /**
     * Builds the project using the specified command.
     *
     * This method executes the provided build command in the project's root directory.
     * It leverages the [Ci] implementation to handle the actual command execution and
     * returns the output (stdout/stderr) from the build process.
     *
     * The method is annotated with @Tool to make it available as a callable tool
     * within the agent system.
     *
     * @param command The build command to execute in the project root (e.g., "mvn clean install",
     *                "gradle build", "npm run build", etc.)
     * @return The output of the build process as a string, containing both stdout and stderr
     * @throws RuntimeException if the build process fails or cannot be executed
     */
    @Tool(description = "build the project using the given command in the root")
    fun buildProject(command: String): String {
        return Ci(root).build(BuildOptions(command, true))
    }

    /**
     * Builds the project using the specified command with full terminal control.
     *
     * This method is intended for interactive applications like Spring Boot that require
     * user input during execution. It gives complete terminal control to the child process,
     * allowing for interactive shells, prompts, and real-time user interaction.
     *
     * The method returns only when the application exits, making it suitable for
     * long-running applications that need to stay active until manually terminated.
     *
     * @param command The build command to execute in the project root (e.g., "mvn spring-boot:run")
     * @return A simple status message indicating success or failure
     * @throws RuntimeException if the build process fails or cannot be executed
     */
    @Tool(description = "build the project with full terminal control for interactive applications like Spring Boot")
    fun buildProjectInteractive(command: String): String {
        return Ci(root).build(BuildOptions(command, streamOutput = false, interactive = true))
    }

}



================================================
FILE: embabel-agent-code/src/main/kotlin/com/embabel/coding/tools/git/ClonedRepositoryReference.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.coding.tools.git

import com.embabel.agent.api.common.LlmReference
import com.embabel.agent.domain.library.code.SymbolSearch
import com.embabel.agent.tools.file.DefaultFileReadLog
import com.embabel.agent.tools.file.FileReadLog
import com.embabel.agent.tools.file.FileReadTools
import com.embabel.agent.tools.file.WellKnownFileContentTransformers
import com.embabel.common.util.StringTransformer
import java.io.IOException
import java.nio.file.FileVisitResult
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.SimpleFileVisitor
import java.nio.file.attribute.BasicFileAttributes

/**
 * Reference to a cloned Git repository with automatic cleanup capabilities.
 * Exposes LLM tools and ensures proper cleanup on application shutdown.
 *
 * @param url The URL of the Git repository we cloned
 * @param localPath The local path where the repository is cloned.
 * @param deleteOnClose If true, the repository will be deleted when closed.
 * @param fileFormatLimits Limits for file processing operations.
 */
class ClonedRepositoryReference(
    val url: String,
    override val description: String,
    val localPath: Path,
    val deleteOnClose: Boolean = true,
    val fileFormatLimits: FileFormatLimits = FileFormatLimits(),
) : AutoCloseable, FileReadTools, SymbolSearch, FileReadLog by DefaultFileReadLog(), LlmReference {

    override val name: String
        get() = url.substringAfterLast('/')

    override val fileContentTransformers: List<StringTransformer>
        get() = listOf(WellKnownFileContentTransformers.removeApacheLicenseHeader)

    override val root = localPath.toAbsolutePath().toString()

    private var isClosed = false
    private val shutdownHook: Thread?

    init {
        // Register shutdown hook for cleanup if this should delete on close
        shutdownHook = if (deleteOnClose) {
            val hook = Thread {
                if (!isClosed) {
                    cleanupRepository()
                }
            }
            Runtime.getRuntime().addShutdownHook(hook)
            hook
        } else {
            null
        }
    }

    override fun close() {
        if (!isClosed) {
            isClosed = true

            // Remove shutdown hook since we're cleaning up manually
            shutdownHook?.let { hook ->
                try {
                    Runtime.getRuntime().removeShutdownHook(hook)
                } catch (e: IllegalStateException) {
                    // JVM is already shutting down, ignore
                }
            }

            if (deleteOnClose) {
                cleanupRepository()
            }
        }
    }

    private fun cleanupRepository() {
        if (Files.exists(localPath)) {
            try {
                localPath.toFile().deleteRecursively()
            } catch (e: Exception) {
                // Log warning but don't fail
                System.err.println("Warning: Could not delete temporary git repository at $localPath: ${e.message}")
            }
        }
    }

    /**
     * Equality based on localPath only, not on cleanup behavior or limits.
     */
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is ClonedRepositoryReference) return false
        return localPath == other.localPath
    }

    override fun hashCode(): Int {
        return localPath.hashCode()
    }

    override fun toString(): String {
        return "ClonedRepositoryReference(localPath=$localPath, shouldDeleteOnClose=$deleteOnClose)"
    }

    /**
     * Write all files in the repository to a single string.
     * Only use this for small repositories as it loads everything into memory.
     * Applies file content transformers (like removing Apache license headers).
     * Uses FileVisitor for cross-platform compatibility.
     */
    fun writeAllFilesToString(): String {
        val result = StringBuilder()
        val files = mutableListOf<Path>()

        try {
            // Use FileVisitor for cross-platform .git exclusion
            Files.walkFileTree(localPath, object : SimpleFileVisitor<Path>() {
                override fun preVisitDirectory(
                    dir: Path,
                    attrs: BasicFileAttributes,
                ): FileVisitResult {
                    val dirName = dir.fileName?.toString()
                    return if (dirName == ".git") {
                        FileVisitResult.SKIP_SUBTREE
                    } else {
                        FileVisitResult.CONTINUE
                    }
                }

                override fun visitFile(
                    file: Path,
                    attrs: BasicFileAttributes,
                ): FileVisitResult {
                    if (attrs.isRegularFile) {
                        files.add(file)
                    }
                    return FileVisitResult.CONTINUE
                }

                override fun visitFileFailed(
                    file: Path,
                    exc: IOException,
                ): FileVisitResult {
                    // Log but continue processing other files
                    return FileVisitResult.CONTINUE
                }
            })

            // Sort files and process them
            files.sorted().forEach { path ->
                val relativePath = localPath.relativize(path)
                val content = try {
                    if (Files.size(path) > fileFormatLimits.fileSizeLimit) {
                        "// File too large to read: $relativePath"
                    } else {
                        val rawContent = Files.readString(path)
                        WellKnownFileContentTransformers.removeApacheLicenseHeader.transform(rawContent)
                    }
                } catch (e: Exception) {
                    "// Error reading file: ${e.message}"
                }

                result.append("=== $relativePath ===\n")
                result.append(content)
                result.append("\n\n")
            }
        } catch (e: Exception) {
            result.append("Error walking repository: ${e.message}")
        }

        return result.toString()
    }

    /**
     * Return a prompt contributor if the repo is small enough
     */
    override fun notes(): String {
        if (fileCount() > fileFormatLimits.fileCountLimit || writeAllFilesToString().length > fileFormatLimits.fileSizeLimit) {
            return """
                Use exposed tools. The repository is too large to include in the prompt.
            """.trimIndent()
        }
        return """
                |Cloned repository.
                |Use file tools to read files in the repository relative to the root.
                |Read limit is set to ${fileFormatLimits.fileSizeLimit} bytes.
                """.trimMargin()
    }

}



================================================
FILE: embabel-agent-code/src/main/kotlin/com/embabel/coding/tools/git/GitOperations.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.coding.tools.git

import com.embabel.agent.tools.DirectoryBased
import org.eclipse.jgit.api.Git
import org.eclipse.jgit.api.ListBranchCommand
import org.eclipse.jgit.lib.Repository
import org.eclipse.jgit.storage.file.FileRepositoryBuilder
import java.io.File

/**
 * Uses JGit to perform Git operations on a local repository.
 */
interface GitOperations : DirectoryBased {

    private fun openRepository(): Repository {
        return FileRepositoryBuilder()
            .setGitDir(File(root, ".git"))
            .readEnvironment()
            .findGitDir()
            .build()
    }

    private fun openGit(): Git {
        return Git(openRepository())
    }

    fun currentBranch(): String {
        openRepository().use { repo ->
            return repo.branch
        }
    }

    fun listBranches(): List<String> {
        openGit().use { git ->
            return git.branchList()
                .setListMode(ListBranchCommand.ListMode.ALL)
                .call()
                .map { ref ->
                    ref.name.removePrefix("refs/heads/").removePrefix("refs/remotes/origin/")
                }
                .distinct()
        }
    }

    fun checkoutBranch(branch: String): Boolean {
        return try {
            openGit().use { git ->
                git.checkout()
                    .setName(branch)
                    .call()
                true
            }
        } catch (e: Exception) {
            false
        }
    }

    fun createAndCheckoutBranch(branch: String): Boolean {
        return try {
            openGit().use { git ->
                git.checkout()
                    .setCreateBranch(true)
                    .setName(branch)
                    .call()

                // Create an initial empty commit to establish the branch
                git.commit()
                    .setMessage("Initial commit for branch $branch")
                    .setAllowEmpty(true)
                    .call()
                true
            }
        } catch (e: Exception) {
            false
        }
    }

    fun pullLatestChanges(): Boolean {
        return try {
            openGit().use { git ->
                git.pull().call()
                true
            }
        } catch (e: Exception) {
            false
        }
    }

    fun deleteBranch(branch: String): Boolean {
        return try {
            openGit().use { git ->
                git.branchDelete()
                    .setBranchNames(branch)
                    .setForce(true)
                    .call()
                true
            }
        } catch (e: Exception) {
            false
        }
    }

    fun commit(message: String, addAll: Boolean = true): Boolean {
        return try {
            openGit().use { git ->
                if (addAll) {
                    git.add().addFilepattern(".").call()
                }
                git.commit()
                    .setMessage(message)
                    .call()
                true
            }
        } catch (e: Exception) {
            false
        }
    }

    fun revert(): Boolean {
        return try {
            openGit().use { git ->
                val repo = git.repository
                val headCommit = repo.resolve("HEAD")
                git.revert()
                    .include(headCommit)
                    .call()
                true
            }
        } catch (e: Exception) {
            false
        }
    }

    fun revert(commitHash: String): Boolean {
        return try {
            openGit().use { git ->
                val repo = git.repository
                val objectId = repo.resolve(commitHash)
                git.revert()
                    .include(objectId)
                    .call()
                true
            }
        } catch (e: Exception) {
            false
        }
    }
}



================================================
FILE: embabel-agent-code/src/main/kotlin/com/embabel/coding/tools/git/RepositoryReferenceProvider.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.coding.tools.git

import com.embabel.agent.core.AgentProcess
import org.eclipse.jgit.api.Git
import org.eclipse.jgit.api.errors.GitAPIException
import org.slf4j.LoggerFactory
import org.springframework.ai.tool.annotation.Tool
import org.springframework.ai.tool.annotation.ToolParam
import java.nio.file.Files
import java.nio.file.Path
import kotlin.io.path.absolutePathString

/**
 * Limits for file formats when reading files from a cloned repository.
 * @param fileCountLimit Limit of the number of files that will allow a PromptContributor to be returned.
 * @param fileSizeLimit Limit of the size of file that will be included in the prompt contribution.
 */
data class FileFormatLimits(
    val fileCountLimit: Int = 100,
    val fileSizeLimit: Long = 200_000,
)

data class RepositoryReferenceProvider(
    private val fileFormatLimits: FileFormatLimits = FileFormatLimits(),
) {

    private val logger = LoggerFactory.getLogger(javaClass)

    fun withFileCountLimit(limit: Int): RepositoryReferenceProvider {
        return copy(
            fileFormatLimits = this.fileFormatLimits.copy(fileCountLimit = limit),
        )
    }

    fun withFileSizeLimit(limit: Long): RepositoryReferenceProvider {
        return copy(
            fileFormatLimits = this.fileFormatLimits.copy(fileSizeLimit = limit),
        )
    }

    /**
     * Will add a reference to the blackboard
     */
    @Tool(description = "Clone a Git repository from the given URL to a temporary directory")
    fun clone(
        url: String,
        @ToolParam(description = "Description of the repository")
        description: String,
    ): String {
        val agentProcess = AgentProcess.get()
        if (agentProcess == null) {
            error("No agent process: Cannot add cloned repository to agent process")
        } else {
            val clonedRepositoryReference = cloneRepository(url, description = "Different description")
            agentProcess += clonedRepositoryReference
            return "Cloned repository from $url to ${clonedRepositoryReference.localPath} and added to agent process ${agentProcess.id}"
        }
    }

    /**
     * Clone a Git repository from the given URL to a temporary directory.
     * The returned object will expose tools.
     *
     * @param url The Git repository URL (supports both HTTP/HTTPS and SSH)
     * @param branch Optional specific branch to check out (defaults to repository default)
     * @param depth Optional shallow clone depth (null for full clone)
     * @return ClonedRepository with absolute path and cleanup capabilities
     * @throws GitAPIException if the clone operation fails
     */
    @JvmOverloads
    fun cloneRepository(
        url: String,
        description: String,
        branch: String? = null,
        depth: Int? = null,
    ): ClonedRepositoryReference {
        val tempDir = createTempDirectory()

        try {
            logger.debug("Cloning a Git repository from $url into temp dir ${tempDir.absolutePathString()}")
            val cloneCommand = Git.cloneRepository()
                .setURI(url)
                .setDirectory(tempDir.toFile())
                .setCloneAllBranches(branch == null)

            branch?.let { cloneCommand.setBranch(it) }
            depth?.let { cloneCommand.setDepth(it) }

            cloneCommand.call().use { git ->
                // Verify clone was successful
                if (!Files.exists(tempDir.resolve(".git"))) {
                    throw IllegalStateException("Clone operation completed but .git directory not found")
                }
            }

            logger.info("✅ Cloned Git repository from $url into temp dir ${tempDir.absolutePathString()}")
            return ClonedRepositoryReference(
                url = url,
                description = description,
                localPath = tempDir,
                deleteOnClose = true,
                fileFormatLimits = fileFormatLimits,
            )
        } catch (e: Exception) {
            // Clean up on failure
            try {
                tempDir.toFile().deleteRecursively()
            } catch (cleanupEx: Exception) {
                e.addSuppressed(cleanupEx)
            }
            throw when (e) {
                is GitAPIException -> e
                else -> e
            }
        }
    }

    /**
     * Clone a repository to a specific directory (not temporary).
     * The returned ClonedRepository will not auto-delete on close.
     */
    @JvmOverloads
    fun cloneRepositoryTo(
        url: String,
        description: String,
        targetDirectory: Path,
        branch: String? = null,
        depth: Int? = null,
    ): ClonedRepositoryReference {
        if (Files.exists(targetDirectory) && Files.list(targetDirectory).use { it.findFirst().isPresent }) {
            throw IllegalArgumentException("Target directory $targetDirectory already exists and is not empty")
        }

        Files.createDirectories(targetDirectory.parent)

        val cloneCommand = Git.cloneRepository()
            .setURI(url)
            .setDirectory(targetDirectory.toFile())
            .setCloneAllBranches(branch == null)

        branch?.let { cloneCommand.setBranch(it) }
        depth?.let { cloneCommand.setDepth(it) }

        cloneCommand.call().use { git ->
            // Verify clone was successful
            if (!Files.exists(targetDirectory.resolve(".git"))) {
                throw IllegalStateException("Clone operation completed but .git directory not found")
            }
        }

        return ClonedRepositoryReference(
            url = url,
            description = description,
            localPath = targetDirectory,
            deleteOnClose = false,
            fileFormatLimits = fileFormatLimits,
        )
    }

    private fun createTempDirectory(): Path {
        return Files.createTempDirectory("embabel-git-")
    }

    companion object {

        @JvmStatic
        fun create(): RepositoryReferenceProvider = RepositoryReferenceProvider()

    }
}



================================================
FILE: embabel-agent-code/src/main/kotlin/com/embabel/coding/tools/jvm/ClassGraphApiReferenceExtractor.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.coding.tools.jvm

import com.embabel.coding.tools.api.Api
import com.embabel.coding.tools.api.ApiClass
import com.embabel.coding.tools.api.ApiMethod
import io.github.classgraph.ClassGraph

/**
 * Extracts API reference information from the project classpath using ClassGraph.
 */
class ClassGraphApiReferenceExtractor {

    @JvmOverloads
    fun fromProjectClasspath(
        name: String,
        acceptedPackages: Set<String>,
        rejectedPackages: Set<String> = DEFAULT_EXCLUDED_PACKAGES,
    ): Api {
        val classGraph = ClassGraph()
            .enableClassInfo()
            .enableMethodInfo()
            .enableAnnotationInfo()
            .ignoreClassVisibility()
            .ignoreMethodVisibility()
            .acceptPackages(*acceptedPackages.toTypedArray())
            .rejectPackages(*rejectedPackages.toTypedArray())

        return classGraph.scan().use { scanResult ->
            val apiClasses = scanResult.allClasses
                .filter { classInfo ->
                    classInfo.isPublic &&
                            !classInfo.isAnonymousInnerClass &&
                            !classInfo.isSynthetic &&
                            !classInfo.simpleName.endsWith("Kt") &&
                            !classInfo.simpleName.contains("Companion") &&  // Filter out Kotlin companion objects
                            !classInfo.simpleName.contains("$")             // Filter out other synthetic classes
                }
                .map { classInfo ->
                    ApiClass(
                        name = classInfo.simpleName,
                        packageName = classInfo.packageName ?: "",
                        type = when {
                            classInfo.isInterface -> "interface"
                            classInfo.isEnum -> "enum"
                            classInfo.isAnnotation -> "annotation"
                            else -> "class"
                        },
                        methods = classInfo.methodInfo
                            .filter { it.isPublic && !it.isConstructor && !it.isSynthetic }
                            .map { methodInfo ->
                                ApiMethod(
                                    name = methodInfo.name,
                                    parameters = methodInfo.parameterInfo.map { param ->
                                        val typeStr = param.typeSignature?.toStringWithSimpleNames()
                                            ?: param.typeDescriptor.toStringWithSimpleNames()
                                        "${param.name ?: "param"}: $typeStr"
                                    },
                                    returnType = methodInfo.typeSignature?.resultType?.toStringWithSimpleNames()
                                        ?: methodInfo.typeDescriptor.resultType.toStringWithSimpleNames(),
                                    annotations = methodInfo.annotationInfo.map { it.name }
                                )
                            },
                        annotations = classInfo.annotationInfo.map { it.name },
                        superTypes = buildList {
                            classInfo.superclass?.let { if (it.name != "java.lang.Object") add(it.simpleName) }
                            addAll(classInfo.interfaces.map { it.simpleName })
                        }
                    )
                }

            val totalMethods = apiClasses.sumOf { it.methods.size }
            Api(name, apiClasses, apiClasses.size, totalMethods)
        }
    }

    companion object {
        val DEFAULT_EXCLUDED_PACKAGES = setOf(
            "java.",
            "javax.",
            "kotlin.",
            "kotlinx.",
            "org.jetbrains.",
            "org.springframework.",
            "org.apache.",
            "com.sun.",
            "sun.",
            "com.embabel.agent.spi",
            "com.embabel.agent.config",
            "com.embabel.agent.web",
        )
    }
}



================================================
FILE: embabel-agent-code/src/main/kotlin/com/embabel/coding/tools/jvm/JavaParserApiExtractor.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.coding.tools.jvm

import com.embabel.coding.tools.api.Api
import com.embabel.coding.tools.api.ApiClass
import com.embabel.coding.tools.api.ApiMethod
import com.github.javaparser.JavaParser
import com.github.javaparser.ParserConfiguration
import com.github.javaparser.ast.CompilationUnit
import com.github.javaparser.ast.Modifier
import com.github.javaparser.ast.body.*
import com.github.javaparser.ast.expr.AnnotationExpr
import com.github.javaparser.symbolsolver.JavaSymbolSolver
import com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver
import com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver
import org.slf4j.LoggerFactory
import java.nio.file.Files
import java.nio.file.Path
import kotlin.streams.asSequence

/**
 * Extracts API reference information from Java/Kotlin source code using JavaParser.
 */
class JavaParserApiExtractor {

    private val logger = LoggerFactory.getLogger(JavaParserApiExtractor::class.java)
    private val javaParser: JavaParser

    init {
        val typeSolver = CombinedTypeSolver().apply {
            add(ReflectionTypeSolver())
        }

        val config = ParserConfiguration().apply {
            setSymbolResolver(JavaSymbolSolver(typeSolver))
            setLanguageLevel(ParserConfiguration.LanguageLevel.JAVA_17)
        }

        javaParser = JavaParser(config)
    }

    /**
     * Extract API information from source code in the given directory
     */
    fun fromSourceDirectory(
        name: String,
        sourceDir: Path,
        acceptedPackages: Set<String> = emptySet(),
        rejectedPackages: Set<String> = DEFAULT_EXCLUDED_PACKAGES,
    ): Api {
        if (!Files.exists(sourceDir)) {
            logger.warn("Source directory does not exist: $sourceDir")
            return Api(name, emptyList(), 0, 0)
        }

        val javaFiles = findJavaFiles(sourceDir)
        val apiClasses = mutableListOf<ApiClass>()

        for (javaFile in javaFiles) {
            try {
                val parseResult = javaParser.parse(javaFile)
                if (parseResult.isSuccessful) {
                    parseResult.result.ifPresent { compilationUnit ->
                        val extractedClasses = extractClassesFromCompilationUnit(
                            compilationUnit,
                            acceptedPackages,
                            rejectedPackages
                        )
                        apiClasses.addAll(extractedClasses)
                    }
                } else {
                    logger.warn("Failed to parse: $javaFile - ${parseResult.problems}")
                }
            } catch (e: Exception) {
                logger.warn("Error parsing file $javaFile: ${e.message}")
            }
        }

        val totalMethods = apiClasses.sumOf { it.methods.size }
        return Api(name, apiClasses, apiClasses.size, totalMethods)
    }

    private fun findJavaFiles(sourceDir: Path): List<Path> {
        return try {
            Files.walk(sourceDir)
                .asSequence()
                .filter { Files.isRegularFile(it) }
                .filter { it.toString().endsWith(".java") }
                .toList()
        } catch (e: Exception) {
            logger.warn("Error walking source directory $sourceDir: ${e.message}")
            emptyList()
        }
    }

    private fun extractClassesFromCompilationUnit(
        compilationUnit: CompilationUnit,
        acceptedPackages: Set<String>,
        rejectedPackages: Set<String>,
    ): List<ApiClass> {
        val packageName = compilationUnit.packageDeclaration
            .map { it.nameAsString }
            .orElse("")

        // Filter by package acceptance/rejection rules
        if (acceptedPackages.isNotEmpty() && acceptedPackages.none { packageName.startsWith(it) }) {
            return emptyList()
        }

        if (rejectedPackages.any { packageName.startsWith(it) }) {
            return emptyList()
        }

        val apiClasses = mutableListOf<ApiClass>()

        // Extract classes, interfaces, enums, annotations
        compilationUnit.types.forEach { typeDeclaration ->
            when (typeDeclaration) {
                is ClassOrInterfaceDeclaration -> {
                    if (shouldIncludeType(typeDeclaration)) {
                        apiClasses.add(extractClassOrInterface(typeDeclaration, packageName))
                    }
                }
                is EnumDeclaration -> {
                    if (shouldIncludeType(typeDeclaration)) {
                        apiClasses.add(extractEnum(typeDeclaration, packageName))
                    }
                }
                is AnnotationDeclaration -> {
                    if (shouldIncludeType(typeDeclaration)) {
                        apiClasses.add(extractAnnotation(typeDeclaration, packageName))
                    }
                }
            }
        }

        return apiClasses
    }

    private fun shouldIncludeType(typeDeclaration: TypeDeclaration<*>): Boolean {
        return typeDeclaration.isPublic &&
               !typeDeclaration.nameAsString.contains("$") && // Skip inner/synthetic classes
               !typeDeclaration.nameAsString.endsWith("Kt")    // Skip Kotlin generated classes
    }

    private fun extractClassOrInterface(
        classDeclaration: ClassOrInterfaceDeclaration,
        packageName: String,
    ): ApiClass {
        val methods = classDeclaration.methods
            .filter { it.isPublic && !it.isStatic }
            .map { extractMethod(it) }

        val superTypes = mutableListOf<String>()

        // Add extended types
        classDeclaration.extendedTypes.forEach { extendedType ->
            superTypes.add(extendedType.nameAsString)
        }

        // Add implemented interfaces
        classDeclaration.implementedTypes.forEach { implementedType ->
            superTypes.add(implementedType.nameAsString)
        }

        return ApiClass(
            name = classDeclaration.nameAsString,
            packageName = packageName,
            type = if (classDeclaration.isInterface) "interface" else "class",
            methods = methods,
            annotations = extractAnnotations(classDeclaration.annotations),
            superTypes = superTypes,
            comment = extractComment(classDeclaration)
        )
    }

    private fun extractEnum(enumDeclaration: EnumDeclaration, packageName: String): ApiClass {
        val methods = enumDeclaration.methods
            .filter { it.isPublic && !it.isStatic }
            .map { extractMethod(it) }

        return ApiClass(
            name = enumDeclaration.nameAsString,
            packageName = packageName,
            type = "enum",
            methods = methods,
            annotations = extractAnnotations(enumDeclaration.annotations),
            superTypes = emptyList(),
            comment = extractComment(enumDeclaration)
        )
    }

    private fun extractAnnotation(annotationDeclaration: AnnotationDeclaration, packageName: String): ApiClass {
        // Annotation methods are represented as annotation members
        val methods = annotationDeclaration.members
            .filterIsInstance<AnnotationMemberDeclaration>()
            .map { member ->
                ApiMethod(
                    name = member.nameAsString,
                    parameters = emptyList(), // Annotation methods don't have parameters
                    returnType = member.type.asString(),
                    annotations = extractAnnotations(member.annotations),
                    comment = extractComment(member)
                )
            }

        return ApiClass(
            name = annotationDeclaration.nameAsString,
            packageName = packageName,
            type = "annotation",
            methods = methods,
            annotations = extractAnnotations(annotationDeclaration.annotations),
            superTypes = emptyList(),
            comment = extractComment(annotationDeclaration)
        )
    }

    private fun extractMethod(methodDeclaration: MethodDeclaration): ApiMethod {
        val parameters = methodDeclaration.parameters.map { param ->
            val paramName = param.nameAsString
            val paramType = param.type.asString()
            "$paramName: $paramType"
        }

        return ApiMethod(
            name = methodDeclaration.nameAsString,
            parameters = parameters,
            returnType = methodDeclaration.type.asString(),
            annotations = extractAnnotations(methodDeclaration.annotations),
            comment = extractComment(methodDeclaration)
        )
    }

    private fun extractAnnotations(annotations: List<AnnotationExpr>): List<String> {
        return annotations.map { annotation ->
            annotation.nameAsString
        }
    }

    private fun extractComment(node: com.github.javaparser.ast.Node): String? {
        return node.comment.map { comment ->
            when (comment) {
                is com.github.javaparser.ast.comments.JavadocComment -> {
                    // For Javadoc comments, clean up the formatting
                    cleanJavadocComment(comment.content)
                }
                is com.github.javaparser.ast.comments.BlockComment -> {
                    // For block comments, clean up the formatting
                    cleanBlockComment(comment.content)
                }
                is com.github.javaparser.ast.comments.LineComment -> {
                    // For line comments, just trim
                    comment.content.trim()
                }
                else -> comment.content.trim()
            }
        }.orElse(null)
    }

    private fun cleanJavadocComment(content: String): String {
        return content
            .lines()
            .map { line ->
                // Remove leading * and whitespace from each line
                line.trimStart().removePrefix("*").trim()
            }
            .filter { it.isNotBlank() }
            .joinToString("\n")
            .trim()
    }

    private fun cleanBlockComment(content: String): String {
        return content
            .lines()
            .map { line ->
                // Remove leading * and whitespace from each line
                line.trimStart().removePrefix("*").trim()
            }
            .filter { it.isNotBlank() }
            .joinToString("\n")
            .trim()
    }

    companion object {
        val DEFAULT_EXCLUDED_PACKAGES = setOf(
            "java.",
            "javax.",
            "kotlin.",
            "kotlinx.",
            "org.jetbrains.",
            "org.springframework.",
            "org.apache.",
            "com.sun.",
            "sun.",
            "com.embabel.agent.spi",
            "com.embabel.agent.config",
            "com.embabel.agent.web",
        )
    }
}



================================================
FILE: embabel-agent-code/src/main/kotlin/com/embabel/coding/tools/jvm/MavenBuildSystemIntegration.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.coding.tools.jvm

import com.embabel.coding.tools.ci.BuildStatus
import com.embabel.coding.tools.ci.BuildSystemIntegration

class MavenBuildSystemIntegration : BuildSystemIntegration {

    override fun parseBuildOutput(
        root: String,
        rawOutput: String,
    ): BuildStatus? {

        // TODO messy test
        if (!rawOutput.contains("[INFO]")) {
            // Not a Maven build
            return null
        }
        val success = rawOutput.contains("BUILD SUCCESS")
        val warnings = rawOutput.lines().filter { it.contains("[WARNING]") }.joinToString("\n")
        val errors = rawOutput.lines().filter { it.contains("[ERROR]") }.joinToString("\n")
        val relevantOutput = "$warnings\n$errors"
        return BuildStatus(
            success = success,
            relevantOutput = relevantOutput,
        )
    }
}



================================================
FILE: embabel-agent-code/src/main/resources/.gitkeep
================================================
ECHO is on.



================================================
FILE: embabel-agent-code/src/test/kotlin/com/embabel/agent/discord/.gitkeep
================================================
ECHO is on.



================================================
FILE: embabel-agent-code/src/test/kotlin/com/embabel/coding/tools/GitReferenceTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.coding.tools

import com.embabel.coding.tools.git.ClonedRepositoryReference
import com.embabel.coding.tools.git.RepositoryReferenceProvider
import com.embabel.common.util.loggerFor
import org.eclipse.jgit.api.Git
import org.eclipse.jgit.storage.file.WindowCacheConfig
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeAll
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.TestInstance
import org.junit.jupiter.api.condition.DisabledOnOs
import org.junit.jupiter.api.condition.OS
import org.junit.jupiter.api.io.TempDir
import java.nio.file.Files
import java.nio.file.Path

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@DisabledOnOs(OS.WINDOWS, disabledReason = "Windows file locking with Git pack files")
class GitReferenceTest {

    private val repositoryReferenceProvider = RepositoryReferenceProvider()

    @BeforeAll
    fun disableMmap() {
        WindowCacheConfig().apply {
            isPackedGitMMAP = false
        }.install()
    }


    @Test
    fun `clone public repository to temporary directory`() {
        val url = "https://github.com/octocat/Hello-World.git"

        repositoryReferenceProvider.cloneRepository(url, description = "Different description").use { clonedRepo ->
            // Verify the repository was cloned
            assertTrue(Files.exists(clonedRepo.localPath))
            assertTrue(Files.isDirectory(clonedRepo.localPath))
            assertTrue(Files.exists(clonedRepo.localPath.resolve(".git")))

            // Verify absolute path is returned
            assertTrue(clonedRepo.localPath.isAbsolute)
            assertEquals(clonedRepo.localPath.toAbsolutePath().toString(), clonedRepo.root)

            // Verify some expected files exist (Hello-World repo has README)
            assertTrue(Files.exists(clonedRepo.localPath.resolve("README")))
        }

        // After closing, temp directory should be cleaned up
        // Note: We can't easily test this without keeping a reference to the path
    }

    @Test
    fun `clone repository with specific branch`() {
        val url = "https://github.com/octocat/Hello-World.git"

        repositoryReferenceProvider.cloneRepository(url, description = "Different description", branch = "master")
            .use { clonedRepo ->
                assertTrue(Files.exists(clonedRepo.localPath))
                assertTrue(Files.exists(clonedRepo.localPath.resolve(".git")))
                assertTrue(Files.exists(clonedRepo.localPath.resolve("README")))
            }
    }

    @Test
    fun `clone repository with shallow depth`() {
        val url = "https://github.com/octocat/Hello-World.git"

        repositoryReferenceProvider.cloneRepository(url, description = "Different description", depth = 1)
            .use { clonedRepo ->
                assertTrue(Files.exists(clonedRepo.localPath))
                assertTrue(Files.exists(clonedRepo.localPath.resolve(".git")))
                assertTrue(Files.exists(clonedRepo.localPath.resolve("README")))
            }
    }

    @Test
    fun `clone repository to specific directory`(@TempDir tempDir: Path) {
        val url = "https://github.com/octocat/Hello-World.git"
        val targetDir = tempDir.resolve("hello-world")

        repositoryReferenceProvider.cloneRepositoryTo(url, description = "Different description", targetDir)
            .use { clonedRepo ->
                assertEquals(targetDir, clonedRepo.localPath)
                assertTrue(Files.exists(targetDir))
                assertTrue(Files.exists(targetDir.resolve(".git")))
                assertTrue(Files.exists(targetDir.resolve("README")))

                // This should not auto-delete on close
                assertFalse(clonedRepo.deleteOnClose)
            }
        loggerFor<GitReferenceTest>().info("Cloned repository at: ${targetDir.toAbsolutePath()}")

        // Directory should still exist after close since shouldDeleteOnClose is false
        assertTrue(Files.exists(targetDir))
    }

    @Test
    fun `clone to existing non-empty directory throws exception`(@TempDir tempDir: Path) {
        val url = "https://github.com/octocat/Hello-World.git"
        val targetDir = tempDir.resolve("existing")
        Files.createDirectories(targetDir)
        Files.write(targetDir.resolve("existing-file.txt"), "content".toByteArray())

        assertThrows(IllegalArgumentException::class.java) {
            repositoryReferenceProvider.cloneRepositoryTo(url, description = "Different description", targetDir)
        }
    }

    @Test
    fun `invalid repository URL throws GitAPIException`() {
        val invalidUrl = "https://github.com/nonexistent/nonexistent.git"

        assertThrows(Exception::class.java) {
            repositoryReferenceProvider.cloneRepository(invalidUrl, description = "Different description").use { }
        }
    }

    @Test
    fun `cloned repository implements AutoCloseable properly`() {
        val url = "https://github.com/octocat/Hello-World.git"
        var localPath: Path? = null

        repositoryReferenceProvider.cloneRepository(url, description = "Different description").use { clonedRepo ->
            localPath = clonedRepo.localPath
            assertTrue(Files.exists(localPath))
        }

        // Note: We can't reliably test cleanup in unit tests since it happens in close()
        // and temp directories might be cleaned up by the OS
    }

    @Test
    fun `fileCount returns number of files excluding git directory`() {
        val url = "https://github.com/octocat/Hello-World.git"

        repositoryReferenceProvider.cloneRepository(url, description = "Different description").use { clonedRepo ->
            val fileCount = clonedRepo.fileCount()
            assertTrue(fileCount > 0, "Repository should contain at least one file")
            // Hello-World repo typically has README file
            assertTrue(fileCount >= 1, "Should have at least README file")
        }
    }

    @Test
    fun `writeAllFilesToString returns repository content as string`() {
        val url = "https://github.com/octocat/Hello-World.git"

        repositoryReferenceProvider.cloneRepository(url, description = "Different description").use { clonedRepo ->
            val allContent = clonedRepo.writeAllFilesToString()

            assertFalse(allContent.isEmpty(), "Content should not be empty")
            assertTrue(allContent.contains("=== README ==="), "Should contain README file header")
            assertFalse(allContent.contains("/.git/"), "Should not include .git directory content")

            // Verify file content transformers are applied
            // The removeApacheLicenseHeader transformer should have been applied
            // (though the Hello-World repo may not have Apache headers to remove)
        }
    }

    @Test
    fun `writeAllFilesToString handles empty repository gracefully`(@TempDir tempDir: Path) {
        // Create a minimal git repo for testing
        val emptyRepo = tempDir.resolve("empty-repo")
        Files.createDirectories(emptyRepo)

        // Initialize empty git repo
        Git.init().setDirectory(emptyRepo.toFile()).call().use { git ->
            // Create an empty commit without signing
            git.commit()
                .setMessage("Initial commit")
                .setAllowEmpty(true)
                .setSign(false)  // Disable GPG signing for tests
                .call()
        }

        val clonedRepo = ClonedRepositoryReference(
            url = "1",
            description = "Different description",
            localPath = emptyRepo,
            deleteOnClose = false,
        )

        val content = clonedRepo.writeAllFilesToString()
        // Should handle empty repository without errors
        assertNotNull(content)
    }

    @Test
    fun `shutdown hook cleanup works properly`(@TempDir tempDir: Path) {
        val testDir = tempDir.resolve("test-shutdown-repo")
        Files.createDirectories(testDir)
        Files.writeString(testDir.resolve("test-file.txt"), "test content")

        val clonedRepo = ClonedRepositoryReference(
            url = "x",
            description = "Different description",
            localPath = testDir,
            deleteOnClose = true
        )

        // Verify directory exists initially
        assertTrue(Files.exists(testDir))
        assertTrue(Files.exists(testDir.resolve("test-file.txt")))

        // Close manually should cleanup and remove shutdown hook
        clonedRepo.close()

        // Directory should be cleaned up
        assertFalse(Files.exists(testDir))

        // Calling close again should be safe (idempotent)
        clonedRepo.close()
    }

    @Test
    fun `no cleanup for shouldDeleteOnClose false`(@TempDir tempDir: Path) {
        val testDir = tempDir.resolve("test-no-cleanup-repo")
        Files.createDirectories(testDir)
        Files.writeString(testDir.resolve("test-file.txt"), "test content")

        val clonedRepo = ClonedRepositoryReference(
            url = "y",
            description = "Different description",
            localPath = testDir,
            deleteOnClose = false,
        )

        assertTrue(Files.exists(testDir))

        clonedRepo.close()

        // Directory should still exist since shouldDeleteOnClose is false
        assertTrue(Files.exists(testDir))
        assertTrue(Files.exists(testDir.resolve("test-file.txt")))
    }

    @Test
    fun `equals and hashCode work correctly for different instances`(@TempDir tempDir: Path) {
        val testDir = tempDir.resolve("test-repo")
        Files.createDirectories(testDir)

        val repo1 = ClonedRepositoryReference(
            url = "foo1",
            description = "Different description",
            localPath = testDir,

            deleteOnClose = false,
        )
        val repo2 =
            ClonedRepositoryReference(
                url = "foo2",
                description = "Different description",
                localPath = testDir,
                deleteOnClose = true
            )  // Different cleanup behavior
        val repo3 = ClonedRepositoryReference(
            url = "foo3",
            description = "Different description",
            tempDir.resolve("other-repo"),
            deleteOnClose = false
        )

        // Same path should be equal regardless of other properties
        assertEquals(repo1, repo2)
        assertEquals(repo1.hashCode(), repo2.hashCode())

        // Different paths should not be equal
        assertNotEquals(repo1, repo3)
        assertNotEquals(repo1.hashCode(), repo3.hashCode())

        repo1.close()
        repo2.close()
        repo3.close()
    }
}



================================================
FILE: embabel-agent-code/src/test/kotlin/com/embabel/coding/tools/api/ApiExtractorTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.coding.tools.api

import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.io.TempDir
import java.nio.file.Files
import java.nio.file.Path

class ApiExtractorTest {

    @TempDir
    lateinit var tempDir: Path

    private lateinit var extractor: ApiExtractor
    private lateinit var sourceDir: Path

    @BeforeEach
    fun setUp() {
        extractor = ApiExtractor()
        sourceDir = tempDir.resolve("src")
        Files.createDirectories(sourceDir)
    }

    @Test
    fun `should extract from source code`() {
        // Create a simple Java class
        val packageDir = sourceDir.resolve("com/example")
        Files.createDirectories(packageDir)

        val javaFile = packageDir.resolve("TestService.java")
        Files.write(javaFile, """
            package com.example;

            public class TestService {
                public void doSomething() {}
                public String getName() { return "test"; }
            }
        """.trimIndent().toByteArray())

        val api = extractor.fromSourceCode("test-api", sourceDir)

        assertEquals("test-api", api.name)
        assertEquals(1, api.totalClasses)
        assertEquals(2, api.totalMethods)

        val testService = api.classes.first()
        assertEquals("TestService", testService.name)
        assertEquals("com.example", testService.packageName)
        assertEquals("class", testService.type)
    }

    @Test
    fun `should combine multiple APIs correctly`() {
        val api1 = Api("api1", listOf(
            ApiClass("ClassA", "com.example", "class", listOf(
                ApiMethod("methodA", emptyList(), "void")
            ))
        ), 1, 1)

        val api2 = Api("api2", listOf(
            ApiClass("ClassB", "com.example", "class", listOf(
                ApiMethod("methodB", emptyList(), "void")
            ))
        ), 1, 1)

        val combined = extractor.combine("combined-api", listOf(api1, api2))

        assertEquals("combined-api", combined.name)
        assertEquals(2, combined.totalClasses)
        assertEquals(2, combined.totalMethods)
        assertTrue(combined.classes.any { it.name == "ClassA" })
        assertTrue(combined.classes.any { it.name == "ClassB" })
    }

    @Test
    fun `should deduplicate classes when combining`() {
        val api1 = Api("api1", listOf(
            ApiClass("DuplicateClass", "com.example", "class", listOf(
                ApiMethod("method1", emptyList(), "void")
            ))
        ), 1, 1)

        val api2 = Api("api2", listOf(
            ApiClass("DuplicateClass", "com.example", "class", listOf(
                ApiMethod("method2", emptyList(), "void")
            ))
        ), 1, 1)

        val combined = extractor.combine("combined-api", listOf(api1, api2))

        assertEquals("combined-api", combined.name)
        assertEquals(1, combined.totalClasses) // Duplicates should be removed
        assertEquals("DuplicateClass", combined.classes.first().name)
    }

    @Test
    fun `should extract from classpath`() {
        // Test extracting from current classpath with Kotlin/Java classes
        val api = extractor.fromClasspath(
            "classpath-api",
            acceptedPackages = setOf("com.embabel.coding.tools.api")
        )

        assertTrue(api.totalClasses > 0)
        assertTrue(api.classes.any { it.name == "Api" })
        assertTrue(api.classes.any { it.name == "ApiClass" })
        assertTrue(api.classes.any { it.name == "ApiMethod" })
    }

    @Test
    fun `should handle empty source directory gracefully in combined extraction`() {
        val emptySourceDir = tempDir.resolve("empty-source")
        Files.createDirectories(emptySourceDir)

        val api = extractor.fromSourceAndClasspath(
            "combined-api",
            emptySourceDir,
            acceptedPackages = setOf("com.embabel.coding.tools.api")
        )

        // Should have classes from classpath even if source is empty
        assertTrue(api.totalClasses > 0)
        assertTrue(api.classes.any { it.name == "Api" })
    }

    @Test
    fun `should prefer source code over classpath in combined extraction`() {
        // Create source code with same package as classpath
        val packageDir = sourceDir.resolve("com/example")
        Files.createDirectories(packageDir)

        Files.write(packageDir.resolve("TestClass.java"), """
            package com.example;
            public class TestClass {
                public void sourceMethod() {}
            }
        """.trimIndent().toByteArray())

        val api = extractor.fromSourceAndClasspath(
            "combined-api",
            sourceDir,
            acceptedPackages = setOf("com.example", "com.embabel.coding.tools.api")
        )

        // Should include both source and classpath classes
        assertTrue(api.classes.any { it.name == "TestClass" }) // From source
        assertTrue(api.classes.any { it.name == "Api" }) // From classpath
    }
}



================================================
FILE: embabel-agent-code/src/test/kotlin/com/embabel/coding/tools/api/ApiReferenceTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.coding.tools.api

import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeAll
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.TestInstance

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class ApiReferenceTest {

    private lateinit var smallApi: Api
    private lateinit var largeApi: Api
    private lateinit var emptyApi: Api

    @BeforeAll
    fun setup() {
        // Create test data
        val testMethod1 = ApiMethod(
            name = "getName",
            parameters = emptyList(),
            returnType = "String",
            annotations = listOf("org.springframework.web.bind.annotation.GetMapping"),
            comment = "Gets the name of the user"
        )

        val testMethod2 = ApiMethod(
            name = "setName",
            parameters = listOf("String name"),
            returnType = "void",
            annotations = emptyList(),
            comment = null
        )

        val testMethod3 = ApiMethod(
            name = "process",
            parameters = listOf("Object input", "int timeout"),
            returnType = "Result<String>",
            annotations = listOf(
                "org.springframework.transaction.annotation.Transactional",
                "org.springframework.validation.annotation.Validated"
            ),
            comment = "Processes input with timeout"
        )

        val testClass1 = ApiClass(
            name = "UserService",
            packageName = "com.example.service",
            type = "class",
            methods = listOf(testMethod1, testMethod2),
            annotations = listOf("org.springframework.stereotype.Service"),
            superTypes = listOf("BaseService", "UserOperations"),
            comment = "Service for managing users"
        )

        val testClass2 = ApiClass(
            name = "UserController",
            packageName = "com.example.controller",
            type = "class",
            methods = listOf(testMethod3),
            annotations = listOf("org.springframework.web.bind.annotation.RestController"),
            superTypes = emptyList(),
            comment = null
        )

        val testInterface = ApiClass(
            name = "UserRepository",
            packageName = "com.example.repository",
            type = "interface",
            methods = listOf(testMethod1),
            annotations = emptyList(),
            superTypes = listOf("JpaRepository<User, Long>"),
            comment = "Repository for user data"
        )

        val testEnum = ApiClass(
            name = "UserStatus",
            packageName = "com.example.model",
            type = "enum",
            methods = emptyList(),
            annotations = emptyList(),
            superTypes = emptyList(),
            comment = "User status enumeration"
        )

        // Small API (under limit)
        smallApi = Api(
            name = "TestAPI",
            classes = listOf(testClass1, testClass2, testInterface, testEnum),
            totalClasses = 4,
            totalMethods = 4
        )

        // Large API (over default limit of 100)
        val largeClassList = (1..150).map { index ->
            ApiClass(
                name = "GeneratedClass$index",
                packageName = "com.generated.package$index",
                type = "class",
                methods = listOf(
                    ApiMethod(
                        name = "method$index",
                        parameters = listOf("String param"),
                        returnType = "void"
                    )
                )
            )
        }

        largeApi = Api(
            name = "LargeTestAPI",
            classes = largeClassList,
            totalClasses = 150,
            totalMethods = 150
        )

        // Empty API
        emptyApi = Api(
            name = "EmptyAPI",
            classes = emptyList(),
            totalClasses = 0,
            totalMethods = 0
        )
    }

    @Nested
    inner class ConstructorAndPropertiesTests {

        @Test
        fun `should initialize with default class limit`() {
            val apiRef = ApiReference("API reference for TestAPI", smallApi)
            assertEquals("TestAPI", apiRef.name)
            assertEquals("API reference for TestAPI", apiRef.description)
        }

        @Test
        fun `should initialize with custom class limit`() {
            val apiRef = ApiReference("description", smallApi, classLimit = 50)
            assertEquals("TestAPI", apiRef.name)
            assertEquals("description", apiRef.description)
        }

        @Test
        fun `should handle empty API`() {
            val apiRef = ApiReference("mt", emptyApi)
            assertEquals("EmptyAPI", apiRef.name)
            assertEquals("mt", apiRef.description)
        }
    }

    @Nested
    inner class ContributionTests {

        @Test
        fun `should return full contribution for small API`() {
            val apiRef = ApiReference("small", smallApi)
            val contribution = apiRef.contribution()

            assertTrue(contribution.contains(apiRef.name))
            assertTrue(contribution.contains("Use this reference to answer questions about the API"))
            assertTrue(contribution.contains(apiRef.toolPrefix()), "Should contain tool prefix: $contribution")
            assertTrue(contribution.contains("com.example.service.UserService"))
            assertTrue(contribution.contains("com.example.controller.UserController"))
        }

        @Test
        fun `should return limited contribution for large API`() {
            val apiRef = ApiReference("large", largeApi)
            val contribution = apiRef.contribution()
            assertTrue(contribution.contains("too large to include here"))
            assertTrue(contribution.contains("contains 150 classes and 150 methods"))
            assertFalse(contribution.contains("com.generated.package"))
        }

        @Test
        fun `should respect custom class limit`() {
            val apiRef = ApiReference("small", smallApi, classLimit = 2)
            val contribution = apiRef.contribution()

            assertTrue(contribution.contains("too large to include here"))
            assertTrue(contribution.contains("contains 4 classes and 4 methods"))
        }

        @Test
        fun `should handle empty API contribution`() {
            val apiRef = ApiReference("mt", emptyApi)
            val contribution = apiRef.contribution()

            assertTrue(contribution.contains(apiRef.name))
            assertTrue(contribution.contains("0 classes and 0 methods"))
            assertTrue(contribution.contains("API Reference - 0 classes, 0 methods"))
        }
    }

    @Nested
    inner class FormatAsTextTests {

        @Test
        fun `should format API as text with header`() {
            val apiRef = ApiReference("small", smallApi)
            val formatted = apiRef.formatAsText()

            assertTrue(formatted.startsWith("API Reference - 4 classes, 4 methods"))
            assertTrue(formatted.contains("com.example.service.UserService"))
            assertTrue(formatted.contains("com.example.controller.UserController"))
            assertTrue(formatted.contains("com.example.repository.UserRepository (interface)"))
            assertTrue(formatted.contains("com.example.model.UserStatus (enum)"))
        }

        @Test
        fun `should sort classes by fully qualified name`() {
            val apiRef = ApiReference("small", smallApi)
            val formatted = apiRef.formatAsText()

            val lines = formatted.split("\n")
            val classHeaders = lines.filter { it.matches(Regex("com\\.example\\.[a-z]+\\.[A-Z][a-zA-Z]+.*")) }

            // Should be sorted: controller, model, repository, service
            assertTrue(classHeaders[0].contains("com.example.controller.UserController"))
            assertTrue(classHeaders[1].contains("com.example.model.UserStatus"))
            assertTrue(classHeaders[2].contains("com.example.repository.UserRepository"))
            assertTrue(classHeaders[3].contains("com.example.service.UserService"))
        }

        @Test
        fun `should handle empty API formatting`() {
            val apiRef = ApiReference("mt", emptyApi)
            val formatted = apiRef.formatAsText()

            assertEquals("API Reference - 0 classes, 0 methods\n\n", formatted)
        }
    }

    @Nested
    inner class FindClassSignatureTests {

        @Test
        fun `should find existing class by FQN`() {
            val apiRef = ApiReference("small", smallApi)
            val signature = apiRef.findClassSignatureByFqn("com.example.service.UserService")

            assertTrue(signature.contains("com.example.service.UserService"))
            assertTrue(signature.contains("Service for managing users"))
            assertTrue(signature.contains("extends/implements: BaseService, UserOperations"))
            assertTrue(signature.contains("getName(): String @GetMapping"))
            assertTrue(signature.contains("setName(String name): void"))
            assertTrue(signature.contains("Gets the name of the user"))
        }

        @Test
        fun `should find existing class by FQN ignoring case`() {
            val apiRef = ApiReference("small", smallApi)
            val signature = apiRef.findClassSignatureByFqn("com.example.service.USersErvice")

            assertTrue(
                signature.contains("com.example.service.UserService"),
                "Should return correct signature: had [$signature]",
            )
            assertTrue(signature.contains("Service for managing users"))
            assertTrue(signature.contains("extends/implements: BaseService, UserOperations"))
            assertTrue(signature.contains("getName(): String @GetMapping"))
            assertTrue(signature.contains("setName(String name): void"))
            assertTrue(signature.contains("Gets the name of the user"))
        }


        @Test
        fun `should find interface class correctly`() {
            val apiRef = ApiReference("small", smallApi)
            val signature = apiRef.findClassSignatureByFqn("com.example.repository.UserRepository")
            assertTrue(signature.contains("com.example.repository.UserRepository (interface)"))
            assertTrue(signature.contains("Repository for user data"))
            assertTrue(signature.contains("extends/implements: JpaRepository<User, Long>"))
        }

        @Test
        fun `should find enum class correctly`() {
            val apiRef = ApiReference("small", smallApi)
            val signature = apiRef.findClassSignatureByFqn("com.example.model.UserStatus")
            assertTrue(signature.contains("com.example.model.UserStatus (enum)"))
            assertTrue(signature.contains("User status enumeration"))
            assertFalse(signature.contains("extends/implements"))
        }

        @Test
        fun `should return not found message for non-existent class`() {
            val apiRef = ApiReference("small", smallApi)
            val signature = apiRef.findClassSignatureByFqn("com.example.NonExistentClass")
            assertEquals("Class not found: com.example.NonExistentClass", signature)
        }

        @Test
        fun `should handle empty FQN`() {
            val apiRef = ApiReference("small", smallApi)
            val signature = apiRef.findClassSignatureByFqn("")
            assertEquals("Class not found: ", signature)
        }

        @Test
        fun `should handle null-like input`() {
            val apiRef = ApiReference("small", smallApi)
            val signature = apiRef.findClassSignatureByFqn("null")
            assertEquals("Class not found: null", signature)
        }
    }

    @Nested
    inner class FindClassSignatureBySimpleNameTests {

        @Test
        fun `should find unique class by simple name`() {
            val apiRef = ApiReference("small", smallApi)
            val signature = apiRef.findClassSignatureBySimpleName("UserService")
            assertTrue(signature.contains("com.example.service.UserService"))
            assertTrue(signature.contains("Service for managing users"))
            assertTrue(signature.contains("extends/implements: BaseService, UserOperations"))
            assertTrue(signature.contains("getName(): String @GetMapping"))
        }

        @Test
        fun `should find interface by simple name`() {
            val apiRef = ApiReference("small", smallApi)
            val signature = apiRef.findClassSignatureBySimpleName("UserRepository")
            assertTrue(signature.contains("com.example.repository.UserRepository (interface)"))
            assertTrue(signature.contains("Repository for user data"))
        }

        @Test
        fun `should find enum by simple name`() {
            val apiRef = ApiReference("small", smallApi)
            val signature = apiRef.findClassSignatureBySimpleName("UserStatus")
            assertTrue(signature.contains("com.example.model.UserStatus (enum)"))
            assertTrue(signature.contains("User status enumeration"))
        }

        @Test
        fun `should return not found for non-existent simple name`() {
            val apiRef = ApiReference("small", smallApi)
            val signature = apiRef.findClassSignatureBySimpleName("NonExistentClass")
            assertEquals("Class not found: NonExistentClass", signature)
        }

        @Test
        fun `should handle empty simple name`() {
            val apiRef = ApiReference("small", smallApi)
            val signature = apiRef.findClassSignatureBySimpleName("")
            assertEquals("Class not found: ", signature)
        }

        @Test
        fun `should handle multiple classes with same simple name`() {
            // Create two classes with same simple name but different packages
            val userModel = ApiClass(
                name = "User",
                packageName = "com.example.model",
                type = "class"
            )
            val userDto = ApiClass(
                name = "User",
                packageName = "com.example.dto",
                type = "class"
            )

            val api = Api("TestAPI", listOf(userModel, userDto), 2, 0)
            val apiRef = ApiReference("test", api)
            val signature = apiRef.findClassSignatureBySimpleName("User")

            assertTrue(signature.contains("Multiple classes found with name 'User':"))
            assertTrue(signature.contains("com.example.model.User"))
            assertTrue(signature.contains("com.example.dto.User"))
        }

        @Test
        fun `should work with large API`() {
            val apiRef = ApiReference("large", largeApi)
            val signature = apiRef.findClassSignatureBySimpleName("GeneratedClass1")
            assertTrue(signature.contains("com.generated.package1.GeneratedClass1"))
        }

        @Test
        fun `should be case insensitive`() {
            val apiRef = ApiReference("small", smallApi)
            val signature = apiRef.findClassSignatureBySimpleName("userservice")

            assertTrue(signature.contains("com.example.service.UserService"))
            assertTrue(signature.contains("Service for managing users"))
        }

        @Test
        fun `should find class with mixed case simple name`() {
            val apiRef = ApiReference("small", smallApi)
            val signature = apiRef.findClassSignatureBySimpleName("USERcontroller")

            assertTrue(signature.contains("com.example.controller.UserController"))
        }

        @Test
        fun `should find class with all caps simple name`() {
            val apiRef = ApiReference("small", smallApi)
            val signature = apiRef.findClassSignatureBySimpleName("USERREPOSITORY")

            assertTrue(signature.contains("com.example.repository.UserRepository (interface)"))
            assertTrue(signature.contains("Repository for user data"))
        }

        @Test
        fun `should find class with all lowercase simple name`() {
            val apiRef = ApiReference("small", smallApi)
            val signature = apiRef.findClassSignatureBySimpleName("userstatus")

            assertTrue(signature.contains("com.example.model.UserStatus (enum)"))
            assertTrue(signature.contains("User status enumeration"))
        }
    }

    @Nested
    inner class FindPackageSignatureTests {

        @Test
        fun `should find existing package with multiple classes`() {
            // Add another class to the same package
            val extraClass = ApiClass(
                name = "UserDto",
                packageName = "com.example.service",
                type = "class"
            )
            val apiWithExtraClass = Api(
                name = "TestAPI",
                classes = smallApi.classes + extraClass,
                totalClasses = 5,
                totalMethods = 4
            )

            val apiRef = ApiReference("extra extra extra!", apiWithExtraClass)
            val signature = apiRef.findPackageSignature("com.example.service")

            assertTrue(signature.contains("Package: com.example.service"))
            assertTrue(signature.contains("Classes:"))
            assertTrue(signature.contains("UserDto (class)"))
            assertTrue(signature.contains("UserService (class)"))

            // Check sorting
            val lines = signature.split("\n")
            val classLines = lines.filter { it.trim().startsWith("- ") }
            assertTrue(classLines[0].contains("UserDto"))
            assertTrue(classLines[1].contains("UserService"))
        }

        @Test
        fun `should find package with single class`() {
            val apiRef = ApiReference("small", smallApi)
            val signature = apiRef.findPackageSignature("com.example.controller")

            assertTrue(signature.contains("Package: com.example.controller"))
            assertTrue(signature.contains("Classes:"))
            assertTrue(signature.contains("UserController (class)"))
        }

        @Test
        fun `should return not found message for non-existent package`() {
            val apiRef = ApiReference("small", smallApi)
            val signature = apiRef.findPackageSignature("com.nonexistent.package")
            assertEquals("Package not found: com.nonexistent.package", signature)
        }

        @Test
        fun `should handle empty package name`() {
            val apiRef = ApiReference("small", smallApi)
            val signature = apiRef.findPackageSignature("")
            assertEquals("Package not found: ", signature)
        }

        @Test
        fun `should handle partial package matches correctly`() {
            val apiRef = ApiReference("small", smallApi)
            val signature = apiRef.findPackageSignature("com.example")
            assertEquals("Package not found: com.example", signature)
        }
    }

    @Nested
    inner class FormatClassTests {

        @Test
        fun `should format class with all features`() {
            val apiRef = ApiReference("small", smallApi)
            val userServiceClass = smallApi.classes.find { it.name == "UserService" }!!
            val formatted = apiRef.formatClass(userServiceClass)

            assertTrue(formatted.contains("com.example.service.UserService"))
            assertTrue(formatted.contains("// Service for managing users"))
            assertTrue(formatted.contains("extends/implements: BaseService, UserOperations"))
            assertTrue(formatted.contains("// Gets the name of the user"))
            assertTrue(formatted.contains("getName(): String @GetMapping"))
            assertTrue(formatted.contains("setName(String name): void"))
        }

        @Test
        fun `should format interface with type indicator`() {
            val apiRef = ApiReference("small", smallApi)
            val repositoryClass = smallApi.classes.find { it.name == "UserRepository" }!!
            val formatted = apiRef.formatClass(repositoryClass)

            assertTrue(formatted.contains("com.example.repository.UserRepository (interface)"))
            assertTrue(formatted.contains("// Repository for user data"))
            assertTrue(formatted.contains("extends/implements: JpaRepository<User, Long>"))
        }

        @Test
        fun `should format enum without extends implements when empty`() {
            val apiRef = ApiReference("small", smallApi)
            val enumClass = smallApi.classes.find { it.name == "UserStatus" }!!
            val formatted = apiRef.formatClass(enumClass)

            assertTrue(formatted.contains("com.example.model.UserStatus (enum)"))
            assertTrue(formatted.contains("// User status enumeration"))
            assertFalse(formatted.contains("extends/implements"))
        }

        @Test
        fun `should format class without comment`() {
            // Create a class with no comment and no method comments
            val classWithoutComments = ApiClass(
                name = "EmptyController",
                packageName = "com.example.controller",
                type = "class",
                methods = listOf(
                    ApiMethod(
                        name = "simpleMethod",
                        parameters = listOf("String input"),
                        returnType = "String",
                        annotations = emptyList(),
                        comment = null
                    )
                ),
                annotations = emptyList(),
                superTypes = emptyList(),
                comment = null
            )

            val apiRef = ApiReference("test", Api("Test", listOf(classWithoutComments), 1, 1))

            val formatted = apiRef.formatClass(classWithoutComments)

            assertTrue(formatted.contains("com.example.controller.EmptyController"))
            assertFalse(formatted.contains("//"))
        }

        @Test
        fun `should format method with multiple annotations`() {
            val method = ApiMethod(
                name = "complexMethod",
                parameters = listOf("String input", "int count"),
                returnType = "ResponseEntity<String>",
                annotations = listOf(
                    "org.springframework.web.bind.annotation.PostMapping",
                    "org.springframework.security.access.prepost.PreAuthorize",
                    "org.springframework.validation.annotation.Validated"
                ),
                comment = "A complex method with multiple annotations"
            )

            val testClass = ApiClass(
                name = "TestClass",
                packageName = "com.test",
                type = "class",
                methods = listOf(method)
            )

            val apiRef = ApiReference("test", Api("Test", listOf(testClass), 1, 1))
            val formatted = apiRef.formatClass(testClass)

            assertTrue(formatted.contains("// A complex method with multiple annotations"))
            assertTrue(formatted.contains("complexMethod(String input, int count): ResponseEntity<String> @PostMapping @PreAuthorize @Validated"))
        }

        @Test
        fun `should format method without parameters`() {
            val method = ApiMethod(
                name = "simpleMethod",
                parameters = emptyList(),
                returnType = "void"
            )

            val testClass = ApiClass(
                name = "SimpleClass",
                packageName = "com.simple",
                type = "class",
                methods = listOf(method)
            )

            val apiRef = ApiReference("test", Api("Simple", listOf(testClass), 1, 1))
            val formatted = apiRef.formatClass(testClass)

            assertTrue(formatted.contains("simpleMethod(): void"))
        }

        @Test
        fun `should handle class with no methods`() {
            val testClass = ApiClass(
                name = "EmptyClass",
                packageName = "com.empty",
                type = "class",
                methods = emptyList()
            )

            val apiRef = ApiReference("test", Api("Empty", listOf(testClass), 1, 0))
            val formatted = apiRef.formatClass(testClass)

            assertTrue(formatted.contains("com.empty.EmptyClass"))
            // Should not have method lines
            val lines = formatted.split("\n")
            assertFalse(lines.any { it.trim().contains("():") || it.trim().contains("(") && it.trim().contains("):") })
        }
    }

    @Nested
    inner class EdgeCasesAndIntegrationTests {

        @Test
        fun `should handle API with classes having same name in different packages`() {
            val class1 = ApiClass(
                name = "User",
                packageName = "com.example.model",
                type = "class"
            )

            val class2 = ApiClass(
                name = "User",
                packageName = "com.example.dto",
                type = "class"
            )

            val api = Api("DuplicateNames", listOf(class1, class2), 2, 0)
            val apiRef = ApiReference("dup", api)

            // Both should be findable by FQN
            val modelUser = apiRef.findClassSignatureByFqn("com.example.model.User")
            val dtoUser = apiRef.findClassSignatureByFqn("com.example.dto.User")

            assertTrue(modelUser.contains("com.example.model.User"))
            assertTrue(dtoUser.contains("com.example.dto.User"))
            assertNotEquals(modelUser, dtoUser)
        }

        @Test
        fun `should maintain consistent behavior with large API operations`() {
            val apiRef = ApiReference("description", largeApi)

            // Should still be able to find specific classes
            val classSignature = apiRef.findClassSignatureByFqn("com.generated.package1.GeneratedClass1")
            assertTrue(classSignature.contains("com.generated.package1.GeneratedClass1"))

            // Should still be able to find packages
            val packageSignature = apiRef.findPackageSignature("com.generated.package1")
            assertTrue(packageSignature.contains("Package: com.generated.package1"))
            assertTrue(packageSignature.contains("GeneratedClass1"))
        }

        @Test
        fun `should handle special characters in names and comments`() {
            val method = ApiMethod(
                name = "processXML",
                parameters = listOf("String xmlData", "Map<String, Object> options"),
                returnType = "Result<XML>",
                comment = "Processes XML data with special chars: <>&\"'"
            )

            val testClass = ApiClass(
                name = "XMLProcessor",
                packageName = "com.xml.util",
                type = "class",
                methods = listOf(method),
                comment = "Handles XML processing & validation"
            )

            val api = Api("XMLTest", listOf(testClass), 1, 1)
            val apiRef = ApiReference("description", api)

            val formatted = apiRef.formatClass(testClass)
            assertTrue(formatted.contains("XMLProcessor"))
            assertTrue(formatted.contains("Handles XML processing & validation"))
            assertTrue(formatted.contains("Processes XML data with special chars: <>&\"'"))
            assertTrue(formatted.contains("processXML(String xmlData, Map<String, Object> options): Result<XML>"))
        }

        @Test
        fun `should handle deeply nested generic types`() {
            val method = ApiMethod(
                name = "complexGeneric",
                parameters = listOf("Map<String, List<Optional<CompletableFuture<ResponseEntity<List<User>>>>>>"),
                returnType = "CompletableFuture<ResponseEntity<Map<String, List<Optional<Result<String>>>>>>"
            )

            val testClass = ApiClass(
                name = "GenericClass",
                packageName = "com.generic",
                type = "class",
                methods = listOf(method)
            )

            val api = Api("GenericTest", listOf(testClass), 1, 1)
            val apiRef = ApiReference("description", api)

            val formatted = apiRef.formatClass(testClass)
            assertTrue(formatted.contains("complexGeneric"))
            assertTrue(formatted.contains("Map<String, List<Optional<CompletableFuture<ResponseEntity<List<User>>>>>>"))
            assertTrue(formatted.contains("CompletableFuture<ResponseEntity<Map<String, List<Optional<Result<String>>>>>>"))
        }
    }
}



================================================
FILE: embabel-agent-code/src/test/kotlin/com/embabel/coding/tools/jvm/ClassGraphApiReferenceExtractorTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.coding.tools.jvm

import com.embabel.agent.api.common.PromptRunner
import com.embabel.coding.tools.api.ApiReference
import junit.framework.TestCase.assertFalse
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test

class ClassGraphApiReferenceExtractorTest {

    @Test
    fun `extract Embabel agent framework`() {
        val cigar = ClassGraphApiReferenceExtractor()
        val apiref = cigar.fromProjectClasspath(
            name = "test",
            acceptedPackages = setOf("com.embabel.agent"),
        )
        val tools = ApiReference("description", apiref)
        assertEquals("description", tools.description)
        val pr = tools.findClassSignatureByFqn(PromptRunner::class.java.name)
        assertFalse(pr.isEmpty())
        val agp = tools.findPackageSignature("com.embabel.agent.api.common")
        assertFalse(agp.isEmpty())
    }

}



================================================
FILE: embabel-agent-code/src/test/kotlin/com/embabel/coding/tools/jvm/JavaParserApiExtractorTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.coding.tools.jvm

import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.io.TempDir
import java.nio.file.Files
import java.nio.file.Path

class JavaParserApiExtractorTest {

    @TempDir
    lateinit var tempDir: Path

    private lateinit var extractor: JavaParserApiExtractor
    private lateinit var sourceDir: Path

    @BeforeEach
    fun setUp() {
        extractor = JavaParserApiExtractor()
        sourceDir = tempDir.resolve("src")
        Files.createDirectories(sourceDir)
    }

    @Test
    fun `should extract simple class with methods`() {
        // Create a simple Java class
        val packageDir = sourceDir.resolve("com/example")
        Files.createDirectories(packageDir)

        val javaFile = packageDir.resolve("SimpleService.java")
        Files.write(javaFile, """
            package com.example;

            import java.util.List;

            public class SimpleService {

                public String getName() {
                    return "service";
                }

                public void processData(String data, int count) {
                    // implementation
                }

                public List<String> getItems() {
                    return null;
                }

                private void privateMethod() {
                    // should not be included
                }
            }
        """.trimIndent().toByteArray())

        val api = extractor.fromSourceDirectory("test-api", sourceDir)

        assertEquals("test-api", api.name)
        assertEquals(1, api.totalClasses)
        assertEquals(3, api.totalMethods) // Only public methods

        val apiClass = api.classes.first()
        assertEquals("SimpleService", apiClass.name)
        assertEquals("com.example", apiClass.packageName)
        assertEquals("class", apiClass.type)
        assertEquals(3, apiClass.methods.size)

        // Check specific methods
        val getName = apiClass.methods.find { it.name == "getName" }
        assertNotNull(getName)
        assertEquals("String", getName?.returnType)
        assertEquals(0, getName?.parameters?.size)

        val processData = apiClass.methods.find { it.name == "processData" }
        assertNotNull(processData)
        assertEquals("void", processData?.returnType)
        assertEquals(2, processData?.parameters?.size)
        assertEquals("data: String", processData?.parameters?.get(0))
        assertEquals("count: int", processData?.parameters?.get(1))
    }

    @Test
    fun `should extract interface with methods`() {
        val packageDir = sourceDir.resolve("com/example")
        Files.createDirectories(packageDir)

        val javaFile = packageDir.resolve("UserRepository.java")
        Files.write(javaFile, """
            package com.example;

            import java.util.Optional;

            public interface UserRepository {
                Optional<User> findById(Long id);
                void save(User user);
                void deleteById(Long id);
            }
        """.trimIndent().toByteArray())

        val api = extractor.fromSourceDirectory("test-api", sourceDir)

        assertEquals(1, api.totalClasses)
        val apiClass = api.classes.first()
        assertEquals("UserRepository", apiClass.name)
        assertEquals("interface", apiClass.type)
        assertEquals(3, apiClass.methods.size)
    }

    @Test
    fun `should extract enum`() {
        val packageDir = sourceDir.resolve("com/example")
        Files.createDirectories(packageDir)

        val javaFile = packageDir.resolve("Status.java")
        Files.write(javaFile, """
            package com.example;

            public enum Status {
                ACTIVE, INACTIVE, PENDING;

                public boolean isActive() {
                    return this == ACTIVE;
                }
            }
        """.trimIndent().toByteArray())

        val api = extractor.fromSourceDirectory("test-api", sourceDir)

        assertEquals(1, api.totalClasses)
        val apiClass = api.classes.first()
        assertEquals("Status", apiClass.name)
        assertEquals("enum", apiClass.type)
        assertEquals(1, apiClass.methods.size) // Only public methods
        assertEquals("isActive", apiClass.methods.first().name)
    }

    @Test
    fun `should extract annotation`() {
        val packageDir = sourceDir.resolve("com/example")
        Files.createDirectories(packageDir)

        val javaFile = packageDir.resolve("MyAnnotation.java")
        Files.write(javaFile, """
            package com.example;

            public @interface MyAnnotation {
                String value() default "";
                int timeout() default 30;
            }
        """.trimIndent().toByteArray())

        val api = extractor.fromSourceDirectory("test-api", sourceDir)

        assertEquals(1, api.totalClasses)
        val apiClass = api.classes.first()
        assertEquals("MyAnnotation", apiClass.name)
        assertEquals("annotation", apiClass.type)
        assertEquals(2, apiClass.methods.size)

        val valueMember = apiClass.methods.find { it.name == "value" }
        assertNotNull(valueMember)
        assertEquals("String", valueMember?.returnType)
    }

    @Test
    fun `should extract class with annotations and inheritance`() {
        val packageDir = sourceDir.resolve("com/example")
        Files.createDirectories(packageDir)

        val javaFile = packageDir.resolve("UserService.java")
        Files.write(javaFile, """
            package com.example;

            import org.springframework.stereotype.Service;
            import org.springframework.transaction.annotation.Transactional;

            @Service
            public class UserService extends BaseService implements UserOperations {

                @Transactional
                public void createUser(String name) {
                    // implementation
                }

                public String getServiceName() {
                    return "UserService";
                }
            }
        """.trimIndent().toByteArray())

        val api = extractor.fromSourceDirectory("test-api", sourceDir)

        assertEquals(1, api.totalClasses)
        val apiClass = api.classes.first()
        assertEquals("UserService", apiClass.name)
        assertEquals("class", apiClass.type)

        // Check annotations
        assertEquals(1, apiClass.annotations.size)
        assertEquals("Service", apiClass.annotations.first())

        // Check inheritance
        assertEquals(2, apiClass.superTypes.size)
        assertTrue(apiClass.superTypes.contains("BaseService"))
        assertTrue(apiClass.superTypes.contains("UserOperations"))

        // Check method annotations
        val createUser = apiClass.methods.find { it.name == "createUser" }
        assertNotNull(createUser)
        assertEquals(1, createUser?.annotations?.size)
        assertEquals("Transactional", createUser?.annotations?.first())
    }

    @Test
    fun `should filter by accepted packages`() {
        // Create classes in different packages
        val packageDir1 = sourceDir.resolve("com/example/service")
        val packageDir2 = sourceDir.resolve("com/other")
        Files.createDirectories(packageDir1)
        Files.createDirectories(packageDir2)

        Files.write(packageDir1.resolve("ServiceA.java"), """
            package com.example.service;
            public class ServiceA {
                public void methodA() {}
            }
        """.trimIndent().toByteArray())

        Files.write(packageDir2.resolve("ServiceB.java"), """
            package com.other;
            public class ServiceB {
                public void methodB() {}
            }
        """.trimIndent().toByteArray())

        val api = extractor.fromSourceDirectory(
            "test-api",
            sourceDir,
            acceptedPackages = setOf("com.example")
        )

        assertEquals(1, api.totalClasses)
        assertEquals("ServiceA", api.classes.first().name)
    }

    @Test
    fun `should filter by rejected packages`() {
        val packageDir = sourceDir.resolve("org/springframework/example")
        Files.createDirectories(packageDir)

        Files.write(packageDir.resolve("SpringService.java"), """
            package org.springframework.example;
            public class SpringService {
                public void method() {}
            }
        """.trimIndent().toByteArray())

        val api = extractor.fromSourceDirectory("test-api", sourceDir)

        assertEquals(0, api.totalClasses) // Should be filtered out by default rejected packages
    }

    @Test
    fun `should handle non-existent directory gracefully`() {
        val nonExistentDir = tempDir.resolve("does-not-exist")

        val api = extractor.fromSourceDirectory("test-api", nonExistentDir)

        assertEquals("test-api", api.name)
        assertEquals(0, api.totalClasses)
        assertEquals(0, api.totalMethods)
    }

    @Test
    fun `should handle empty directory`() {
        val emptyDir = tempDir.resolve("empty")
        Files.createDirectories(emptyDir)

        val api = extractor.fromSourceDirectory("test-api", emptyDir)

        assertEquals("test-api", api.name)
        assertEquals(0, api.totalClasses)
        assertEquals(0, api.totalMethods)
    }

    @Test
    fun `should skip malformed java files gracefully`() {
        val packageDir = sourceDir.resolve("com/example")
        Files.createDirectories(packageDir)

        // Create a malformed Java file
        Files.write(packageDir.resolve("Malformed.java"), """
            package com.example;
            public class Malformed {
                // Missing closing brace and invalid syntax
                public void method(
        """.trimIndent().toByteArray())

        // Create a valid Java file
        Files.write(packageDir.resolve("Valid.java"), """
            package com.example;
            public class Valid {
                public void validMethod() {}
            }
        """.trimIndent().toByteArray())

        val api = extractor.fromSourceDirectory("test-api", sourceDir)

        // Should only extract the valid class
        assertEquals(1, api.totalClasses)
        assertEquals("Valid", api.classes.first().name)
    }

    @Test
    fun `should skip non-public classes`() {
        val packageDir = sourceDir.resolve("com/example")
        Files.createDirectories(packageDir)

        Files.write(packageDir.resolve("Classes.java"), """
            package com.example;

            public class PublicClass {
                public void publicMethod() {}
            }

            class PackagePrivateClass {
                public void method() {}
            }
        """.trimIndent().toByteArray())

        val api = extractor.fromSourceDirectory("test-api", sourceDir)

        assertEquals(1, api.totalClasses)
        assertEquals("PublicClass", api.classes.first().name)
    }

    @Test
    fun `should extract javadoc comments`() {
        val packageDir = sourceDir.resolve("com/example")
        Files.createDirectories(packageDir)

        val javaFile = packageDir.resolve("DocumentedService.java")
        Files.write(javaFile, """
            package com.example;

            /**
             * This is a documented service class.
             * It provides various utility methods.
             * @author Test Author
             */
            public class DocumentedService {

                /**
                 * This method processes data.
                 * @param data the data to process
                 * @param count the number of times to process
                 * @return the processing result
                 */
                public String processData(String data, int count) {
                    return "processed";
                }

                /**
                 * Gets the service name.
                 * @return the service name
                 */
                public String getName() {
                    return "service";
                }
            }
        """.trimIndent().toByteArray())

        val api = extractor.fromSourceDirectory("test-api", sourceDir)

        assertEquals(1, api.totalClasses)
        val serviceClass = api.classes.first()
        assertEquals("DocumentedService", serviceClass.name)
        assertNotNull(serviceClass.comment)
        assertTrue(serviceClass.comment!!.contains("This is a documented service class"))
        assertTrue(serviceClass.comment!!.contains("It provides various utility methods"))
        assertTrue(serviceClass.comment!!.contains("@author Test Author"))

        // Check method comments
        val processData = serviceClass.methods.find { it.name == "processData" }
        assertNotNull(processData)
        assertNotNull(processData?.comment)
        assertTrue(processData?.comment!!.contains("This method processes data"))
        assertTrue(processData?.comment!!.contains("@param data the data to process"))
        assertTrue(processData?.comment!!.contains("@return the processing result"))

        val getName = serviceClass.methods.find { it.name == "getName" }
        assertNotNull(getName)
        assertNotNull(getName?.comment)
        assertTrue(getName?.comment!!.contains("Gets the service name"))
    }

    @Test
    fun `should extract block comments`() {
        val packageDir = sourceDir.resolve("com/example")
        Files.createDirectories(packageDir)

        val javaFile = packageDir.resolve("BlockCommentService.java")
        Files.write(javaFile, """
            package com.example;

            /*
             * This service uses block comments
             * instead of javadoc comments.
             */
            public class BlockCommentService {

                /*
                 * A method with block comment
                 */
                public void doSomething() {
                    // implementation
                }
            }
        """.trimIndent().toByteArray())

        val api = extractor.fromSourceDirectory("test-api", sourceDir)

        assertEquals(1, api.totalClasses)
        val serviceClass = api.classes.first()
        assertNotNull(serviceClass.comment)
        assertTrue(serviceClass.comment!!.contains("This service uses block comments"))
        assertTrue(serviceClass.comment!!.contains("instead of javadoc comments"))

        val method = serviceClass.methods.first()
        assertNotNull(method.comment)
        assertTrue(method.comment!!.contains("A method with block comment"))
    }

    @Test
    fun `should extract line comments`() {
        val packageDir = sourceDir.resolve("com/example")
        Files.createDirectories(packageDir)

        val javaFile = packageDir.resolve("LineCommentService.java")
        Files.write(javaFile, """
            package com.example;

            // Simple line comment for the class
            public class LineCommentService {

                // Simple method comment
                public void simpleMethod() {
                    // implementation
                }
            }
        """.trimIndent().toByteArray())

        val api = extractor.fromSourceDirectory("test-api", sourceDir)

        assertEquals(1, api.totalClasses)
        val serviceClass = api.classes.first()
        assertNotNull(serviceClass.comment)
        assertEquals("Simple line comment for the class", serviceClass.comment)

        val method = serviceClass.methods.first()
        assertNotNull(method.comment)
        assertEquals("Simple method comment", method.comment)
    }

    @Test
    fun `should handle classes and methods without comments`() {
        val packageDir = sourceDir.resolve("com/example")
        Files.createDirectories(packageDir)

        val javaFile = packageDir.resolve("NoCommentService.java")
        Files.write(javaFile, """
            package com.example;

            public class NoCommentService {
                public void methodWithoutComment() {
                    // implementation
                }
            }
        """.trimIndent().toByteArray())

        val api = extractor.fromSourceDirectory("test-api", sourceDir)

        assertEquals(1, api.totalClasses)
        val serviceClass = api.classes.first()
        assertNull(serviceClass.comment)

        val method = serviceClass.methods.first()
        assertNull(method.comment)
    }
}



================================================
FILE: embabel-agent-code/src/test/resources/.gitkeep
================================================
ECHO is on.



================================================
FILE: embabel-agent-dependencies/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.build</groupId>
        <artifactId>embabel-dependencies-parent</artifactId>
        <version>0.1.6-SNAPSHOT</version>
        <relativePath />
    </parent>
    <groupId>com.embabel.agent</groupId>
    <artifactId>embabel-agent-dependencies</artifactId>
    <version>0.2.0-SNAPSHOT</version>
    <packaging>pom</packaging>
    <name>Embabel Agent BOM</name>
    <description>Embabel Agent BOM</description>
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-api</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-a2a</artifactId>
                <version>${project.version}</version>
            </dependency>

           <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-code</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-autoconfigure</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-platform-autoconfigure</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-anthropic-autoconfigure</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-bedrock-autoconfigure</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-dockermodels-autoconfigure</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-openai-autoconfigure</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-ollama-autoconfigure</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-deepseek-autoconfigure</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-eval</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-mcpserver</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-rag-neo</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-rag-lucene</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-rag-tika</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-rag-pipeline</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-shell</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-starter</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-starter-anthropic</artifactId>
                <version>${project.version}</version>
            </dependency>            

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-starter-bedrock</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-starter-dockermodels</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-starter-deepseek</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-starter-openai</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-starter-ollama</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-starter-mcpserver</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-starter-shell</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-test</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-test-internal</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-discord</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>com.embabel.agent</groupId>
                <artifactId>embabel-agent-ux</artifactId>
                <version>${project.version}</version>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <repositories>
        <repository>
            <id>embabel-releases</id>
            <url>https://repo.embabel.com/artifactory/libs-release</url>
            <releases>
                <enabled>true</enabled>
            </releases>
            <snapshots>
                <enabled>true</enabled>
            </snapshots>
        </repository>
        <repository>
            <id>embabel-snapshots</id>
            <url>https://repo.embabel.com/artifactory/libs-snapshot</url>
            <snapshots>
                <enabled>true</enabled>
            </snapshots>
        </repository>
    </repositories>

    <distributionManagement>
        <repository>
            <id>embabel-releases</id>
            <url>https://repo.embabel.com/artifactory/libs-release</url>
        </repository>
        <snapshotRepository>
            <id>embabel-snapshots</id>
            <url>https://repo.embabel.com/artifactory/libs-snapshot</url>
        </snapshotRepository>
    </distributionManagement>
</project>



================================================
FILE: embabel-agent-discord/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-parent</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-discord</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent Discord UX</name>
    <description>Embabel Agent Discord Components</description>

    <dependencies>
        <!-- Main Dependencies -->
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-api</artifactId>
        </dependency>
        
        <!-- https://mvnrepository.com/artifact/net.dv8tion/JDA -->
        <dependency>
            <groupId>net.dv8tion</groupId>
            <artifactId>JDA</artifactId>
            <version>5.6.1</version>
        </dependency>

        <!-- Test Dependencies -->
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-test-internal</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.jetbrains.kotlin</groupId>
                <artifactId>kotlin-maven-plugin</artifactId>
                <executions>
                    <execution>
                        <id>kapt</id>
                        <goals>
                            <goal>kapt</goal>
                        </goals>
                        <configuration>
                            <annotationProcessorPaths>
                                <path>
                                    <groupId>org.springframework.boot</groupId>
                                    <artifactId>spring-boot-configuration-processor</artifactId>
                                    <version>${spring-boot.version}</version>
                                </path>
                            </annotationProcessorPaths>
                        </configuration>
                    </execution>
                </executions>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
            </plugin>

        </plugins>
    </build>

</project>


================================================
FILE: embabel-agent-discord/src/main/kotlin/com/embabel/agent/discord/ChannelRespondingOutputChannel.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.discord

import com.embabel.agent.channel.*
import net.dv8tion.jda.api.entities.Message
import net.dv8tion.jda.api.entities.channel.unions.MessageChannelUnion

/**
 * OutputChannel that responds in a Discord channel, updating a progress message as needed.
 */
class ChannelRespondingOutputChannel(
    private val channel: MessageChannelUnion,
) : OutputChannel {
    private var progressMessage: Message? = null

    override fun send(
        event: OutputChannelEvent,
    ) {
        when (event) {
            is LoggingOutputChannelEvent -> {
                DiscordMessageUtils.sendLongMessage(channel, event.message)
            }

            is MessageOutputChannelEvent -> {
                clearProgressMessage()
                DiscordMessageUtils.sendLongMessage(channel, event.message.content)
            }

            is ProgressOutputChannelEvent -> {
                handleProgressMessage(event.message)
            }

            else -> {
                // Handle other event types if necessary
            }
        }

    }

    private fun handleProgressMessage(message: String) {
        if (message.isBlank()) {
            clearProgressMessage()
        } else {
            // Update or create progress message
            if (progressMessage == null) {
                // Create new progress message
                channel.sendMessage("⏳ $message").queue { sentMessage ->
                    progressMessage = sentMessage
                }
            } else {
                // Update existing progress message
                progressMessage?.editMessage("⏳ $message")?.queue()
            }
        }
    }

    private fun clearProgressMessage() {
        progressMessage?.let { msg ->
            msg.delete().queue(
                { progressMessage = null },
                { /* ignore delete failures */ }
            )
        }
    }
}



================================================
FILE: embabel-agent-discord/src/main/kotlin/com/embabel/agent/discord/ChatbotSessionEventListener.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.discord

import com.embabel.agent.api.common.Asyncer
import com.embabel.chat.ChatSession
import com.embabel.chat.Chatbot
import com.embabel.chat.UserMessage
import net.dv8tion.jda.api.events.message.MessageReceivedEvent
import net.dv8tion.jda.api.hooks.ListenerAdapter
import org.slf4j.LoggerFactory
import org.springframework.boot.autoconfigure.condition.ConditionalOnBean
import org.springframework.stereotype.Component

/**
 * Discord SessionEventListener that uses an Embabel Chatbot
 */
@Component
@ConditionalOnBean(Chatbot::class)
class ChatbotSessionEventListener(
    private val discordSessionService: DiscordSessionService,
    private val chatbot: Chatbot,
    private val asyncer: Asyncer,
    private val discordConfigProperties: DiscordConfigProperties,
) : ListenerAdapter() {

    private val logger = LoggerFactory.getLogger(ChatbotSessionEventListener::class.java)

    override fun onMessageReceived(event: MessageReceivedEvent) {
        if (event.author.isBot) {
            return
        }

        val session = discordSessionService.getOrCreateSession(event)
        if (session.isDirectMessage) {
            respondToDm(event, session)
            return
        } else {
            reactToChannelMessage(event, session)
        }
    }

    private fun reactToChannelMessage(
        event: MessageReceivedEvent,
        session: DiscordUserSession,
    ) {
        logger.info(
            "User {} sent a message in channel {} at {}}",
            session.user, session.channelId, session.lastActivity,
        )
    }

    private fun respondToDm(
        event: MessageReceivedEvent,
        discordUserSession: DiscordUserSession,
    ) {
        logger.info("Responding to DM from user: ${discordUserSession.user}")
        val chatSession = chatSessionFor(discordUserSession, event)
        asyncer.async {
            chatSession.onUserMessage(
                userMessage = UserMessage(content = event.message.contentRaw),
            )
        }
    }

    private fun chatSessionFor(
        discordUserSession: DiscordUserSession,
        event: MessageReceivedEvent,
    ): ChatSession {
        return discordUserSession.sessionData.getOrPut("chatSession") {
            chatbot.createSession(
                user = discordUserSession.user,
                outputChannel = ChannelRespondingOutputChannel(
                    channel = event.channel,
                ),
                systemMessage = null,
            )
        } as ChatSession
    }
}



================================================
FILE: embabel-agent-discord/src/main/kotlin/com/embabel/agent/discord/DiscordConfiguration.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.discord

import com.embabel.common.util.trim
import net.dv8tion.jda.api.JDA
import net.dv8tion.jda.api.JDABuilder
import net.dv8tion.jda.api.hooks.EventListener
import net.dv8tion.jda.api.requests.GatewayIntent
import org.slf4j.LoggerFactory
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

@ConfigurationProperties(prefix = "embabel.agent.discord")
class DiscordConfigProperties {
    var token: String? = null
}

const val TOKEN_KEY = "embabel.agent.discord.token"

/**
 * Adds all event listeners defined in the context to JDA builder
 * and starts the bot if token is provided.
 */
@Configuration
class DiscordConfiguration(
    private val properties: DiscordConfigProperties,
) {

    private val logger = LoggerFactory.getLogger(DiscordConfiguration::class.java)

    init {
        if (properties.token.isNullOrBlank()) {
            logger.warn(
                """
                embabel-agent-discord is on the classpath but Discord token is not set.
                Discord bot will not be started.
                Set '$TOKEN_KEY' property to enable it.
                """.trimIndent()
            )
        }
    }

    @Bean
    @ConditionalOnProperty(
        name = [TOKEN_KEY],
    )
    fun jda(
        eventListeners: List<EventListener>,
    ): JDA {
        logger.info(
            "Starting Discord bot with {} JDA listeners and token {}",
            eventListeners.size,
            trim(properties.token, max = 20, keepRight = 6),
        )
        return JDABuilder
            .createDefault(properties.token)
            .enableIntents(GatewayIntent.MESSAGE_CONTENT)
            .addEventListeners(*eventListeners.toTypedArray())
            .build()
            .awaitReady()
    }
}



================================================
FILE: embabel-agent-discord/src/main/kotlin/com/embabel/agent/discord/DiscordMessageUtils.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.discord

import com.embabel.common.util.loggerFor
import net.dv8tion.jda.api.entities.channel.unions.MessageChannelUnion

object DiscordMessageUtils {
    // It's really 2000 but we don't want breakage
    private const val DISCORD_MESSAGE_LIMIT = 1900
    private const val CODE_BLOCK_MARKER = "```"
    private const val CODE_BLOCK_OVERHEAD = 8 // Space for opening/closing ``` + language

    data class CodeBlockState(
        val inCodeBlock: Boolean = false,
        val language: String = "",
    )

    fun splitMessage(content: String): List<String> {
        if (content.length <= DISCORD_MESSAGE_LIMIT) {
            return listOf(content)
        }

        val messages = mutableListOf<String>()
        var currentMessage = StringBuilder()
        val lines = content.split('\n')
        var codeBlockState = CodeBlockState()

        for (line in lines) {
            val newCodeBlockState = updateCodeBlockState(codeBlockState, line)
            val proposedLength = currentMessage.length + line.length + 1

            // Check if adding this line would exceed the limit
            if (proposedLength > DISCORD_MESSAGE_LIMIT && currentMessage.isNotEmpty()) {
                // If we're in a code block, we need to close it properly
                if (codeBlockState.inCodeBlock) {
                    currentMessage.append('\n').append(CODE_BLOCK_MARKER)
                }

                messages.add(currentMessage.toString().trimEnd())
                currentMessage = StringBuilder()

                // If we were in a code block, reopen it in the new message
                if (codeBlockState.inCodeBlock) {
                    currentMessage.append(CODE_BLOCK_MARKER)
                    if (codeBlockState.language.isNotEmpty()) {
                        currentMessage.append(codeBlockState.language)
                    }
                    currentMessage.append('\n')
                }
            }

            // Handle extremely long single lines
            if (line.length > DISCORD_MESSAGE_LIMIT) {
                if (currentMessage.isNotEmpty()) {
                    if (codeBlockState.inCodeBlock) {
                        currentMessage.append('\n').append(CODE_BLOCK_MARKER)
                    }
                    messages.add(currentMessage.toString().trimEnd())
                    currentMessage = StringBuilder()
                }

                // Split the long line, preserving code block context if needed
                var remainingLine = line
                var isFirstChunk = true

                while (remainingLine.length > DISCORD_MESSAGE_LIMIT) {
                    val availableSpace = if (codeBlockState.inCodeBlock && isFirstChunk) {
                        DISCORD_MESSAGE_LIMIT - CODE_BLOCK_OVERHEAD - codeBlockState.language.length
                    } else if (codeBlockState.inCodeBlock) {
                        DISCORD_MESSAGE_LIMIT - (2 * CODE_BLOCK_OVERHEAD) - codeBlockState.language.length
                    } else {
                        DISCORD_MESSAGE_LIMIT
                    }

                    val chunkSize = maxOf(1, availableSpace)
                    val chunk = remainingLine.substring(0, minOf(chunkSize, remainingLine.length))

                    val chunkMessage = StringBuilder()
                    if (codeBlockState.inCodeBlock) {
                        chunkMessage.append(CODE_BLOCK_MARKER)
                        if (codeBlockState.language.isNotEmpty()) {
                            chunkMessage.append(codeBlockState.language)
                        }
                        chunkMessage.append('\n')
                    }

                    chunkMessage.append(chunk)

                    if (codeBlockState.inCodeBlock) {
                        chunkMessage.append('\n').append(CODE_BLOCK_MARKER)
                    }

                    messages.add(chunkMessage.toString())
                    remainingLine = remainingLine.substring(chunk.length)
                    isFirstChunk = false
                }

                if (remainingLine.isNotEmpty()) {
                    if (codeBlockState.inCodeBlock) {
                        currentMessage.append(CODE_BLOCK_MARKER)
                        if (codeBlockState.language.isNotEmpty()) {
                            currentMessage.append(codeBlockState.language)
                        }
                        currentMessage.append('\n')
                    }
                    currentMessage.append(remainingLine).append('\n')
                }
            } else {
                if (currentMessage.isNotEmpty()) {
                    currentMessage.append('\n')
                }
                currentMessage.append(line)
            }

            codeBlockState = newCodeBlockState
        }

        if (currentMessage.isNotEmpty()) {
            messages.add(currentMessage.toString().trimEnd())
        }

        return messages
    }

    private fun updateCodeBlockState(
        currentState: CodeBlockState,
        line: String,
    ): CodeBlockState {
        val trimmedLine = line.trim()

        if (trimmedLine.startsWith(CODE_BLOCK_MARKER)) {
            return if (currentState.inCodeBlock) {
                // Closing a code block
                CodeBlockState(inCodeBlock = false, language = "")
            } else {
                // Opening a code block
                val language = trimmedLine.substring(3).trim()
                CodeBlockState(inCodeBlock = true, language = language)
            }
        }

        return currentState
    }

    fun sendLongMessage(
        channel: MessageChannelUnion,
        content: String,
    ) {
        try {
            val messageParts = splitMessage(content)
            messageParts.forEach { part ->
                channel.sendMessage(part).queue()
            }
        } catch (e: Exception) {
            loggerFor<DiscordMessageUtils>().warn("Failed to send message to Discord channel: {}", e.message)
            channel.sendMessage("Sorry, something went wrong, please try again").queue()
        }
    }
}



================================================
FILE: embabel-agent-discord/src/main/kotlin/com/embabel/agent/discord/DiscordSessionService.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.discord

import net.dv8tion.jda.api.entities.channel.ChannelType
import net.dv8tion.jda.api.events.message.MessageReceivedEvent
import org.springframework.stereotype.Service
import java.time.LocalDateTime
import java.util.concurrent.ConcurrentHashMap


data class DiscordUserSession(
    val user: DiscordUser,
    val isDirectMessage: Boolean,
    val channelId: String,
    val serverId: String? = null,
    val serverName: String? = null,
    val createdAt: LocalDateTime = LocalDateTime.now(),
    var lastActivity: LocalDateTime = LocalDateTime.now(),
    val sessionData: MutableMap<String, Any> = mutableMapOf(),
)

/**
 * Service to manage Discord user sessions.
 */
@Service
class DiscordSessionService {

    private val activeSessions = ConcurrentHashMap<String, DiscordUserSession>()

    fun getOrCreateSession(event: MessageReceivedEvent): DiscordUserSession {
        val user = event.author
        val sessionKey = "${user.id}-${event.channel.id}"

        return activeSessions.computeIfAbsent(sessionKey) {
            createSessionFromEvent(event)
        }.also { session ->
            session.lastActivity = LocalDateTime.now()
        }
    }

    private fun createSessionFromEvent(event: MessageReceivedEvent): DiscordUserSession {
        val user = event.author
        val channel = event.channel
        val isDirectMessage = channel.type == ChannelType.PRIVATE
        val guild = if (isDirectMessage) null else event.guild

        return DiscordUserSession(
            DiscordUserImpl(
                id = user.id,
                discordUser = DiscordUserInfo(user, isDirectMessage),
            ),
            isDirectMessage = isDirectMessage,
            channelId = channel.id,
            serverId = guild?.id,
            serverName = guild?.name
        )
    }

    fun getSession(
        userId: String,
        channelId: String,
    ): DiscordUserSession? {
        return activeSessions["$userId-$channelId"]
    }

    fun getAllActiveSessions(): List<DiscordUserSession> {
        return activeSessions.values.toList()
    }

    fun endSession(
        userId: String,
        channelId: String,
    ) {
        activeSessions.remove("$userId-$channelId")
    }

    fun cleanupOldSessions(hoursOld: Long = 24) {
        val cutoff = LocalDateTime.now().minusHours(hoursOld)
        activeSessions.entries.removeIf { (_, session) ->
            session.lastActivity.isBefore(cutoff)
        }
    }

    fun updateSessionData(
        session: DiscordUserSession,
        key: String,
        value: Any,
    ) {
        session.sessionData[key] = value
    }

    fun getSessionData(
        session: DiscordUserSession,
        key: String,
    ): Any? {
        return session.sessionData[key]
    }
}



================================================
FILE: embabel-agent-discord/src/main/kotlin/com/embabel/agent/discord/DiscordUser.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.discord

import com.embabel.agent.identity.User

/**
 * Our own representation of a Discord user.
 * An interface so that it a concrete class can be persisted with JPA, OGM etc.
 */
interface DiscordUserInfo {
    val id: String
    val username: String
    val displayName: String
    val discriminator: String
    val avatarUrl: String?
    val isBot: Boolean

    companion object {
        operator fun invoke(
            discordUser: net.dv8tion.jda.api.entities.User,
            isDirectMessage: Boolean,
        ): DiscordUserInfo {
            return DelegatingDiscordUserInfo(discordUser, isDirectMessage)
        }
    }
}

class DelegatingDiscordUserInfo(
    val discordUser: net.dv8tion.jda.api.entities.User,
    isDirectMessage: Boolean = false,
) : DiscordUserInfo {

    override val displayName = if (isDirectMessage) discordUser.name else discordUser.effectiveName

    override val id: String
        get() = discordUser.id
    override val username: String
        get() = discordUser.name

    override val discriminator: String
        get() = discordUser.discriminator
    override val avatarUrl: String
        get() = discordUser.effectiveAvatarUrl
    override val isBot: Boolean
        get() = discordUser.isBot
}

/**
 * Embabel User associated with a Discord user.
 */
interface DiscordUser : User {
    val discordUser: DiscordUserInfo

    override val displayName: String get() = discordUser.displayName

    override val username: String get() = discordUser.username

    override val email: String? get() = null
}

data class DiscordUserImpl(
    override val id: String,
    override val discordUser: DiscordUserInfo,
) : DiscordUser



================================================
FILE: embabel-agent-discord/src/main/kotlin/com/embabel/agent/discord/.gitkeep
================================================
ECHO is on.



================================================
FILE: embabel-agent-discord/src/main/resources/.gitkeep
================================================
ECHO is on.



================================================
FILE: embabel-agent-discord/src/test/kotlin/com/embabel/agent/discord/DiscordMessageUtilsTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.discord

import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*

class DiscordMessageUtilsTest {

    @Test
    fun `splitMessage should return single message when content is short`() {
        val content = "This is a short message"
        val result = DiscordMessageUtils.splitMessage(content)

        assertEquals(1, result.size)
        assertEquals(content, result[0])
    }

    @Test
    fun `splitMessage should preserve simple code blocks across splits`() {
        val longContent = "Here's some text " + "x".repeat(1950) + "\n```kotlin\nfun example() {\n    println(\"Hello\")\n}\n```\nMore text"
        val result = DiscordMessageUtils.splitMessage(longContent)

        assertTrue(result.size > 1)

        // Find the message containing the code block
        val codeBlockMessage = result.find { it.contains("```kotlin") }
        assertNotNull(codeBlockMessage)

        // Ensure the code block is properly closed
        assertTrue(codeBlockMessage!!.startsWith("```kotlin") || codeBlockMessage.contains("\n```kotlin"))
        assertTrue(codeBlockMessage.endsWith("```") || codeBlockMessage.contains("```\n"))
    }

    @Test
    fun `splitMessage should handle code blocks that span multiple splits`() {
        val largeCodeBlock = "```kotlin\n" + "// ".repeat(1000) + "Long comment\n" + "fun test() {\n" + "    // ".repeat(1000) + "Another long comment\n}\n```"
        val result = DiscordMessageUtils.splitMessage(largeCodeBlock)

        assertTrue(result.size > 1)

        // Each message should start and end with code block markers
        result.forEach { message ->
            if (message.contains("kotlin") || message.contains("Long comment") || message.contains("fun test")) {
                assertTrue(message.startsWith("```") || message.startsWith("```kotlin"))
                assertTrue(message.endsWith("```"))
            }
        }
    }

    @Test
    fun `splitMessage should handle nested code blocks correctly`() {
        val content = """
            Here's some documentation:

            ```markdown
            # Example

            Use this code:

            ```kotlin
            fun hello() = "world"
            ```

            That's it!
            ```

            End of documentation.
        """.trimIndent()

        val result = DiscordMessageUtils.splitMessage(content)

        // Should be split appropriately, but code blocks should be preserved
        result.forEach { message ->
            val openBlocks = message.count { it == '`' && message.indexOf(it) % 3 == 0 }
            val closeBlocks = message.count { it == '`' && message.lastIndexOf(it) % 3 == 2 }
            // Code blocks should be balanced within each message
            assertTrue(message.contains("```").not() || (openBlocks % 2 == 0))
        }
    }

    @Test
    fun `splitMessage should handle inline code with backticks`() {
        val content = "Here's some `inline code` and more text. " + "x".repeat(1950) + " Here's more `inline code`."
        val result = DiscordMessageUtils.splitMessage(content)

        assertTrue(result.size > 1)

        // Inline code should be preserved where possible
        result.forEach { message ->
            if (message.contains("`") && !message.contains("```")) {
                val backtickCount = message.count { it == '`' }
                // For inline code, backticks should be balanced (even number)
                assertTrue(backtickCount % 2 == 0)
            }
        }
    }

    @Test
    fun `splitMessage should handle code blocks with different languages`() {
        val content = """
            ```python
            def hello():
                return "world"
            ```

            And some JavaScript:

            ```javascript
            function hello() {
                return "world";
            }
            ```
        """.trimIndent() + "x".repeat(1800)

        val result = DiscordMessageUtils.splitMessage(content)

        // Verify language tags are preserved
        val pythonMessage = result.find { it.contains("```python") }
        val jsMessage = result.find { it.contains("```javascript") }

        if (pythonMessage != null) {
            assertTrue(pythonMessage.contains("def hello()"))
        }
        if (jsMessage != null) {
            assertTrue(jsMessage.contains("function hello()"))
        }
    }

    @Test
    fun `splitMessage should handle extremely long single lines`() {
        val longLine = "This is a very long line that exceeds Discord's limit: " + "x".repeat(2100)
        val result = DiscordMessageUtils.splitMessage(longLine)

        assertTrue(result.size > 1)
        result.forEach { message ->
            assertTrue(message.length <= 2000)
        }
    }

    @Test
    fun `splitMessage should handle extremely long single lines within code blocks`() {
        val longCodeLine = "```kotlin\nval veryLongString = \"" + "x".repeat(2100) + "\"\n```"
        val result = DiscordMessageUtils.splitMessage(longCodeLine)

        assertTrue(result.size > 1)
        result.forEach { message ->
            assertTrue(message.length <= 2000)
            // Each chunk should be wrapped in code block markers
            if (message.contains("veryLongString") || message.contains("x")) {
                assertTrue(message.startsWith("```") || message.startsWith("```kotlin"))
                assertTrue(message.endsWith("```"))
            }
        }
    }

    @Test
    fun `splitMessage should preserve empty lines in code blocks`() {
        val content = """
            ```kotlin
            fun test() {
                println("start")

                // Empty line above
                println("end")
            }
            ```
        """.trimIndent()

        val result = DiscordMessageUtils.splitMessage(content)

        val codeMessage = result.find { it.contains("```kotlin") }
        assertNotNull(codeMessage)
        assertTrue(codeMessage!!.contains("println(\"start\")\n\n    // Empty line above"))
    }

    @Test
    fun `splitMessage should handle multiple consecutive code blocks`() {
        val content = """
            First block:
            ```kotlin
            fun first() = 1
            ```

            Second block:
            ```kotlin
            fun second() = 2
            ```

            Third block:
            ```kotlin
            fun third() = 3
            ```
        """.trimIndent() + "x".repeat(1800)

        val result = DiscordMessageUtils.splitMessage(content)

        // Should properly handle transitions between code blocks
        assertTrue(result.isNotEmpty())

        result.forEach { message ->
            if (message.contains("```")) {
                // Count opening and closing markers
                val markers = message.split("```").size - 1
                // Should be even (balanced) unless it's a continuation
                assertTrue(markers % 2 == 0 || message.startsWith("```") || message.endsWith("```"))
            }
        }
    }
}



================================================
FILE: embabel-agent-discord/src/test/kotlin/com/embabel/agent/discord/.gitkeep
================================================
ECHO is on.



================================================
FILE: embabel-agent-discord/src/test/resources/.gitkeep
================================================
ECHO is on.



================================================
FILE: embabel-agent-docs/README.md
================================================
# Documentation

To build:

```aiignore
mvn generate-resources
```

Results will be in `target/generated-docs`.

To build Markdown, install Docling:

```bash
pip install docling
```

Then run:

```bash
mvn generate-resources -Dasciidoctor.attributes='toc!'

docling  ./target/generated-docs/index.pdf --from pdf --to md --output ./ --image-export-mode placeholder
```

## Links

By default when you create links in AsciiDoc they are all based on fragment identifiers, eg mysite/page#foo.However, we have a lot of content on different topics and by default the TOC is overwhelming. The Hub site groups topics like this:

```aiignore
Welcome
 └─ Introduction
     ├─ Agentic AI for the JVM
     ├─ As modern as Kotlin, as proven ...
     └─ The Team Behind Embabel
 └─ Overview

Quickstart & Guides
 ├─ Getting Started
 └─ Guides

Reference
 ├─ Flow
 ├─ Steps
 ├─ Domain
 ├─ Configuration
 ├─ Annotations
 ├─ DSL
 ├─ Types
 ├─ Tools
 └─ Prompt Contributors
```

### In this grouping:

* Each group is a separate page on the site, eg hub.emababel.org/intro and hub.embabel.org/reference
* Links inside these separate pages are fragments.

We need a way to for links to work in this format, without breaking anything in normal asciidoc. Therefore:

* The dot (.) char in links represents a slash
* The double underscore (__) represents a #.
* All links are assumed to start with a slash

So to link to a fragment in the reference section of the docs:

* Anchor format: [[reference.flow__topic]]
* Linking back to it: <<reference.flow__topic>>



================================================
FILE: embabel-agent-docs/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-parent</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-docs</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent Docs</name>
    <description>Embabel Agent Documentation</description>

    <properties>
        <asciidoctor.maven.plugin.version>3.2.0</asciidoctor.maven.plugin.version>
        <asciidoctorj.pdf.version>2.3.19</asciidoctorj.pdf.version>
        <asciidoctorj.version>3.0.0</asciidoctorj.version>
        <asciidoctorj.diagram.version>3.0.1</asciidoctorj.diagram.version>
        <jruby.version>9.2.17.0</jruby.version>
        <maven.resources.plugin.version>3.3.1</maven.resources.plugin.version>
        <agent-api.version>${project.parent.version}</agent-api.version>
    </properties>

    <build>
        <defaultGoal>process-resources</defaultGoal>
        <plugins>
            <plugin>
                <groupId>org.asciidoctor</groupId>
                <artifactId>asciidoctor-maven-plugin</artifactId>
                <version>${asciidoctor.maven.plugin.version}</version>
                <dependencies>
                    <dependency>
                        <groupId>org.jruby</groupId>
                        <artifactId>jruby-complete</artifactId>
                        <version>${jruby.version}</version>
                    </dependency>
                    <dependency>
                        <groupId>org.asciidoctor</groupId>
                        <artifactId>asciidoctorj-pdf</artifactId>
                        <version>${asciidoctorj.pdf.version}</version>
                    </dependency>
                    <dependency>
                        <groupId>org.asciidoctor</groupId>
                        <artifactId>asciidoctorj</artifactId>
                        <version>${asciidoctorj.version}</version>
                    </dependency>
                    <dependency>
                        <groupId>org.asciidoctor</groupId>
                        <artifactId>asciidoctorj-diagram</artifactId>
                        <version>${asciidoctorj.diagram.version}</version>
                    </dependency>
                </dependencies>
                <configuration>
                    <sourceDirectory>src/main/asciidoc</sourceDirectory>
                    <sourceDocumentName>index.adoc</sourceDocumentName>
                    <doctype>book</doctype>
                    <requires>
                        <require>asciidoctor-diagram</require>
                    </requires>
                    <!-- Attributes common to all output formats-->
                    <attributes>
                        <sourcedir>${project.build.sourceDirectory}</sourcedir>
                        <imagesdir>images</imagesdir>
                        <stylesheet>embabel-agent-docs.css</stylesheet>
                        <stylesDir>${project.basedir}/src/main/resources/themes</stylesDir>
                        <embabel-agent-version>${agent-api.version}</embabel-agent-version>
                    </attributes>
                </configuration>
                <executions>
                    <execution>
                        <id>generate-pdf</id>
                        <phase>generate-resources</phase>
                        <goals>
                            <goal>process-asciidoc</goal>
                        </goals>
                        <configuration>
                            <backend>pdf</backend>
                            <attributes>
                                <doctype>book</doctype>
                                <docinfo>shared</docinfo>
                                <source-highlighter>rouge</source-highlighter>
                                <icons>font</icons>
                                <iconfont-remote>true</iconfont-remote>
                                <pagenums />
                                <toc />
                                <idprefix />
                                <idseparator>-</idseparator>
                            </attributes>
                        </configuration>
                    </execution>
                    <execution>
                        <id>generate-html</id>
                        <phase>generate-resources</phase>
                        <goals>
                            <goal>process-asciidoc</goal>
                        </goals>
                        <configuration>
                            <backend>html5</backend>
                            <attributes>
                                <notitle>true</notitle>
                                <doctype>book</doctype>
                                <docinfo>shared</docinfo>
                                <source-highlighter>rouge</source-highlighter>
                                <icons>font</icons>
                                <pagenums />
                                <toc>left</toc>
                                <sectanchors>true</sectanchors>
                                <toclevels>3</toclevels>
                                <idprefix />
                                <idseparator>-</idseparator>
                            </attributes>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-resources-plugin</artifactId>
                <version>${maven.resources.plugin.version}</version>
                <executions>
                    <execution>
                        <id>copy-additional-css</id>
                        <phase>generate-resources</phase>
                        <goals>
                            <goal>copy-resources</goal>
                        </goals>
                        <configuration>
                            <outputDirectory>${project.build.directory}/generated-docs</outputDirectory>
                            <resources>
                                <resource>
                                    <directory>src/main/resources/themes</directory>
                                    <includes>
                                        <include>theme-extensions.css</include>
                                    </includes>
                                </resource>
                            </resources>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>org.jetbrains.dokka</groupId>
                <artifactId>dokka-maven-plugin</artifactId>
                <executions>
                    <execution>
                        <id>aggregate-docs</id>
                        <phase>prepare-package</phase>
                        <goals>
                            <goal>dokka</goal>
                        </goals>
                        <configuration>
                            <!-- Collect source from all sibling modules -->
                            <sourceDirectories>
                                <dir>${project.parent.basedir}/embabel-agent-api/src/main/kotlin</dir>
                                <dir>${project.parent.basedir}/embabel-agent-api/src/main/java</dir>
                                <dir>${project.parent.basedir}/embabel-agent-a2a/src/main/kotlin</dir>
                                <dir>${project.parent.basedir}/embabel-agent-code/src/main/kotlin</dir>
                                <dir>${project.parent.basedir}/embabel-agent-autoconfigure/embabel-agent-platform-autoconfigure/src/main/java</dir>
                                <dir>${project.parent.basedir}/embabel-agent-autoconfigure/models/embabel-agent-bedrock-autoconfigure/src/main/java</dir>
                                <dir>${project.parent.basedir}/embabel-agent-autoconfigure/models/embabel-agent-bedrock-autoconfigure/src/main/kotlin</dir>
                                <dir>${project.parent.basedir}/embabel-agent-eval/src/main/kotlin</dir>
                                <dir>${project.parent.basedir}/embabel-agent-mcpserver/src/main/kotlin</dir>
                                <dir>${project.parent.basedir}/embabel-agent-rag/embabel-agent-rag-neo/src/main/kotlin</dir>
                                <dir>${project.parent.basedir}/embabel-agent-rag/embabel-agent-rag-lucene/src/main/kotlin</dir>
                                <dir>${project.parent.basedir}/embabel-agent-shell/src/main/kotlin</dir>
                                <dir>${project.parent.basedir}/embabel-agent-discord/src/main/kotlin</dir>
                                <dir>${project.parent.basedir}/embabel-agent-ux/src/main/kotlin</dir>
                            </sourceDirectories>
                            <samples>
                                <dir>${project.parent.basedir}/embabel-agent-api/src/test/kotlin</dir>
                                <dir>${project.parent.basedir}/embabel-agent-test-support/embabel-agent-test/src/test/kotlin</dir>
                            </samples>
                            <!-- Platform settings -->
                            <platform>jvm</platform>
                            <includeNonPublic>false</includeNonPublic>
                            <reportUndocumented>true</reportUndocumented>
                            <skipEmptyPackages>true</skipEmptyPackages>
                            <jdkVersion>${java.version}</jdkVersion>
                            <languageVersion>${kotlin.compiler.apiVersion}</languageVersion>
                            <apiVersion>${kotlin.compiler.apiVersion}</apiVersion>
                            <noStdlibLink>false</noStdlibLink>
                            <noJdkLink>false</noJdkLink>
                            <suppressObviousFunctions>true</suppressObviousFunctions>
                            <outputDir>${project.build.directory}/dokka-aggregate</outputDir>
                            <moduleName>Embabel Agent Documentation</moduleName>
                            <externalDocumentationLinks>
                                <link>
                                    <url>https://docs.spring.io/spring-framework/docs/current/javadoc-api/</url>
                                </link>
                                <link>
                                    <url>https://docs.spring.io/spring-boot/docs/current/api/</url>
                                </link>
                                <link>
                                    <url>https://docs.spring.io/spring-ai/docs/current/api/</url>
                                </link>
                            </externalDocumentationLinks>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>

</project>



================================================
FILE: embabel-agent-docs/dot/process.dot
================================================
digraph PlanningProcess {
    // Graph attributes
    rankdir=TB;
    node [shape=box, style=rounded, fontname="Arial", fontsize=10];
    edge [fontname="Arial", fontsize=9];

    // Define nodes
    start [label="Start", shape=ellipse, style=filled, fillcolor=lightgreen];
    choose_goal [label="Choose goal", style=filled, fillcolor=lightblue];
    determine_state [label="Determine world state", style=filled, fillcolor=lightcyan];
    formulate_plan [label="Plan from world state to goal", style=filled, fillcolor=lightyellow];
    execute_action [label="Execute first action in plan", style=filled, fillcolor=lightpink];
    check_preconditions [label="Goal preconditions satisfied?", shape=diamond, style=filled, fillcolor=orange];
    success [label="Goal Achieved", shape=ellipse, style=filled, fillcolor=lightgreen];

    // Define edges
    start -> choose_goal;
    choose_goal -> determine_state;
    determine_state -> formulate_plan;
    formulate_plan -> execute_action;
    execute_action -> check_preconditions;
    check_preconditions -> success [label="Yes", color=green, fontcolor=green];
    check_preconditions -> determine_state [label="No\n(Replan)", color=red, fontcolor=red];

    // Add feedback loop styling
    edge [constraint=false, style=dashed, color=blue];
}



================================================
FILE: embabel-agent-docs/src/main/asciidoc/authors.adoc
================================================
[[authors]]
Rod Johnson, Alex Hein-Heifetz, Dr. Igor Dayen, Jim Clark, Arjen Poutsma, Jasper Blues


================================================
FILE: embabel-agent-docs/src/main/asciidoc/docinfo-footer.html
================================================
<script>
    (function () {
        // ---- Helpers -------------------------------------------------------------
        function $(sel, root = document) { return root.querySelector(sel); }
        function $all(sel, root = document) { return Array.from(root.querySelectorAll(sel)); }
        function uid(prefix = 'tab') { return prefix + '-' + Math.random().toString(36).slice(2, 9); }

        function activate(tabBtn, set, pushHash) {
            const buttons = $all('[role="tab"]', set.tablist);
            const panels  = $all('[role="tabpanel"]', set.container);

            buttons.forEach(b => {
                const selected = b === tabBtn;
                b.setAttribute('aria-selected', selected ? 'true' : 'false');
                b.tabIndex = selected ? 0 : -1;
                b.classList.toggle('is-selected', selected);
            });

            panels.forEach(p => {
                const show = p.id === tabBtn.getAttribute('aria-controls');
                p.hidden = !show;
                p.classList.toggle('is-active', show);
            });

            if (pushHash && tabBtn.dataset.hash) {
                // update URL hash without jumping
                const { href } = window.location;
                const hashIdx = href.indexOf('#');
                const base = hashIdx >= 0 ? href.slice(0, hashIdx) : href;
                history.replaceState(null, '', base + '#' + tabBtn.dataset.hash);
            }
        }

        function onKeydown(e, set) {
            const keys = ['ArrowLeft','ArrowRight','Home','End'];
            if (!keys.includes(e.key)) return;
            e.preventDefault();

            const tabs = $all('[role="tab"]', set.tablist);
            const current = document.activeElement;
            let idx = tabs.indexOf(current);
            if (idx < 0) return;

            if (e.key === 'ArrowRight') idx = (idx + 1) % tabs.length;
            else if (e.key === 'ArrowLeft') idx = (idx - 1 + tabs.length) % tabs.length;
            else if (e.key === 'Home') idx = 0;
            else if (e.key === 'End') idx = tabs.length - 1;

            tabs[idx].focus();
            tabs[idx].click();
        }

        // ---- Build one tabset from a DL -----------------------------------------
        function buildTabset(container) {
            const dl = container.querySelector('.dlist > dl') || container.querySelector('dl');
            if (!dl) return;

            // Collect (label, contentNode) pairs
            const pairs = [];
            for (let n = dl.firstElementChild; n; n = n.nextElementSibling) {
                if (n.tagName !== 'DT') continue;
                const dt = n;
                const dd = dt.nextElementSibling;
                if (!dd || dd.tagName !== 'DD') continue;
                pairs.push({ label: dt.textContent.trim(), contentNode: dd });
            }
            if (!pairs.length) return;

            // Create shell
            const tabset   = document.createElement('div');
            tabset.className = 'adoc-tabset';
            const tablist  = document.createElement('div');
            tablist.className = 'adoc-tab-headers';
            tablist.setAttribute('role', 'tablist');

            const panels   = document.createElement('div');
            panels.className = 'adoc-tab-panels';

            // Build tabs & panels
            pairs.forEach((pair, i) => {
                const tabId = uid('tab');
                const panelId = uid('panel');

                // Button
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'adoc-tab' + (i === 0 ? ' is-selected' : '');
                btn.setAttribute('role', 'tab');
                btn.setAttribute('aria-controls', panelId);
                btn.setAttribute('aria-selected', i === 0 ? 'true' : 'false');
                btn.id = tabId;
                btn.tabIndex = i === 0 ? 0 : -1;
                btn.textContent = pair.label;

                // Optional: make a nice hash based on label (safe-ish)
                btn.dataset.hash = (container.id || uid('set')) + '-' + pair.label
                    .toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g,'');

                btn.addEventListener('click', () => activate(btn, { tablist, container: tabset }, true));
                tablist.appendChild(btn);

                // Panel
                const panel = document.createElement('div');
                panel.className = 'adoc-panel' + (i === 0 ? ' is-active' : '');
                panel.setAttribute('role', 'tabpanel');
                panel.setAttribute('aria-labelledby', tabId);
                panel.id = panelId;
                panel.hidden = i !== 0;

                // Move the original DD’s children into the panel (preserve code blocks, etc.)
                while (pair.contentNode.firstChild) {
                    panel.appendChild(pair.contentNode.firstChild);
                }
                panels.appendChild(panel);
            });

            // Replace original content
            dl.remove(); // drop the DL
            tabset.appendChild(tablist);
            tabset.appendChild(panels);

            // Insert into the “content” wrapper if present (Asciidoctor example/open blocks)
            const target = container.querySelector('.content') || container;
            target.innerHTML = '';
            target.appendChild(tabset);

            // Keyboard nav
            tablist.addEventListener('keydown', (e) => onKeydown(e, { tablist }));
            return { tablist, container: tabset };
        }

        function initTabs() {
            // Prefer explicit .tabs, but also fall back to any example/open block that contains a DL with DTs
            const explicit = Array.from(document.querySelectorAll('.exampleblock.tabs, .openblock.tabs, [data-tabs]'));
            const fallback = Array.from(document.querySelectorAll('.exampleblock, .openblock'))
                .filter(b => !explicit.includes(b) && (b.querySelector('.dlist > dl dt') || b.querySelector('dl dt')));
            const blocks = [...explicit, ...fallback];

            console.log('[tabs] candidates:', blocks.length, blocks);
            blocks.forEach(buildTabset);

            // Deep-linking
            const h = location.hash ? location.hash.slice(1) : '';
            if (h) {
                const btn = document.querySelector('.adoc-tab[data-hash="' + CSS.escape(h) + '"]');
                if (btn) btn.click();
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initTabs);
        } else {
            initTabs();
        }
    })();
</script>

<style>
    /* Wrapper */
    .adoc-tabset {
        background: transparent;   /* no background */
        border: none;              /* no border */
        padding-top: 0.25rem;
    }

    /* Header row */
    .adoc-tab-headers {
        display: flex;
        flex-wrap: wrap;
        gap: .25rem;
        padding: .25rem .5rem 0;
    }

    /* Base tab style: inherit default document colors */
    .adoc-tab {
        background: transparent;   /* inherit doc background */
        color: inherit;            /* inherit doc text color */
        padding: .4rem .8rem;
        border: none;              /* no border */
        border-radius: 0;          /* square edges */
        cursor: pointer;
    }

    /* Selected tab: --code-color4 background, black text */
    .adoc-tab.is-selected {
        background: var(--code-color4);
        color: #000;
        font-weight: 600;
    }

    /* Panels */
    .adoc-tab-panels {
        background: transparent;
        padding: 1rem 0;
    }
    .adoc-panel {
        display: none;
    }
    .adoc-panel.is-active {
        display: block;
    }

    /* Accessibility: focus outline */
    .adoc-tab:focus {
        outline: 2px solid #888;
        outline-offset: 2px;
    }

</style>



================================================
FILE: embabel-agent-docs/src/main/asciidoc/docinfo-header.html
================================================
<!-- in your docinfo header -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@asciidoctor/tabs@1.0.0-beta.6/dist/css/tabs.css">
<!-- in your docinfo footer (defer so it runs after the DOM is ready) -->
<script defer src="https://cdn.jsdelivr.net/npm/@asciidoctor/tabs@1.0.0-beta.6/dist/js/tabs.js"></script>



================================================
FILE: embabel-agent-docs/src/main/asciidoc/docinfo.html
================================================
<!-- Injected by Asciidoctor because docinfo=shared -->
<header class="navbar">
    <div class="navbar-container">
        <div class="navbar-title">
            <img src="images/tower.png" alt="Embabel logo" class="navbar-logo" style="margin-right: -7px" />
            Embabel
        </div>
        <div class="navbar-actions">
            <a
                    href="https://docs.embabel.com/embabel-agent/api-docs/{embabel-agent-version}/index.html"
                    target="_blank"
                    rel="noreferrer noopener"
                    class="link-button"
            >
                <i class="fa fa-code api-icon"></i>
                API Docs
            </a>
            <a
                    href="https://github.com/embabel/embabel-agent"
                    target="_blank"
                    rel="noreferrer noopener"
                    class="link-button"
            >

                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" class="github-icon">
                    <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29
          6.53 5.47 7.59.4.07.55-.17.55-.38
          0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52
          -.01-.53.63-.01 1.08.58 1.23.82.72 1.21
          1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78
          -.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82
          -2.15-.08-.2-.36-1.01.08-2.1 0 0
          .67-.21 2.2.82A7.68 7.68 0 018 4.77c.68.003
          1.36.092 2 .27 1.53-1.04 2.2-.82
          2.2-.82.44 1.09.16 1.9.08 2.1.51.56.82
          1.27.82 2.15 0 3.07-1.87 3.75-3.65
          3.95.29.25.54.73.54 1.48 0 1.07-.01
          1.93-.01 2.19 0 .21.15.46.55.38A8.01
          8.01 0 0016 8c0-4.42-3.58-8-8-8z"></path>
                </svg>
                GitHub
            </a>
        </div>
    </div>
</header>

<style>

    .navbar-actions {
        display: flex;
        gap: 12px; /* spacing between buttons */
    }

    .navbar {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: var(--navbar-height);
        z-index: 40;
        background-color: #000000;
        border-bottom: 1px solid #334155;
        padding-left: var(--toc-width);
        box-sizing: border-box;
    }

    .navbar-container {
        width: 100%;
        height: 100%;
        padding: 0 25px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        transition: margin-left 0.3s ease;
    }

    .navbar-title {
        display: flex;
        align-items: center;
        font-size: 1.25rem;
        font-weight: 700;
        text-decoration: none;
        color: #fafafa;
    }

    .navbar-logo { width: 40px; margin-left: 16px; }

    .link-button {
        display: flex;
        align-items: center;
        border: 1px solid #00000000;
        border-radius: 6px;
        padding: 8px 12px;
        font-size: 0.875rem;
        font-weight: 700;
        color: #27272a;
        text-decoration: none;
        background: #27272a;
        transition: background-color 0.2s ease;
    }

    .link-button:hover {
        background-color: #37373a;
    }

    .github-icon {
        width: 20px;
        height: 20px;
        margin-right: 8px;
    }

    /* Put this AFTER the import of asciidoctor-default.css */
    .navbar a,
    .navbar a:visited {
        color: #fff !important; /* white links */
        text-decoration: none; /* no underline */
    }

    .navbar a:hover,
    .navbar a:focus,
    .navbar a:active {
        color: #fff !important; /* keep white on hover/focus/active */
        text-decoration: none; /* keep underline off */
    }

    /* (If your icon should follow the link color) */
    .navbar .github-icon {
        fill: currentColor;
    }

    /* or ensure the SVG uses fill="currentColor" */

</style>



================================================
FILE: embabel-agent-docs/src/main/asciidoc/index.adoc
================================================
= Embabel Agent Framework User Guide
:doctype: book
:toc: left
:toclevels: 4
:numbered:
:icons: font
:hide-uri-scheme:
:docinfo: shared
:imagesdif: ./images

ifndef::imagesdir[]
:imagesdir: images
endif::[]

image:common/315px-Meister_der_Weltenchronik_001.png[]

ifdef::backend-html5[]

Embabel Agent Release: {embabel-agent-version}

(C) 2024-2025 Embabel

endif::backend-html5[]

//==========================================================================

include::authors.adoc[]

include::user-guide.adoc[]

//==========================================================================



================================================
FILE: embabel-agent-docs/src/main/asciidoc/tabs.js
================================================
/**
 * Minified by jsDelivr using Terser v5.39.0.
 * Original file: /npm/@asciidoctor/tabs@1.0.0-beta.6/dist/js/tabs.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
!function () {/*! Asciidoctor Tabs | Copyright (c) 2018-present Dan Allen | MIT License */
    "use strict";
    var t = (document.currentScript || {}).dataset || {}, e = Array.prototype.forEach;

    function a(e) {
        var a = this.tab, n = this.tabs || (this.tabs = a.closest(".tabs")),
            s = this.panel || (this.panel = document.getElementById(a.getAttribute("aria-controls")));
        if (i(n, ".tablist .tab", "tab").forEach((function (t) {
            r(t, t === a)
        })), i(n, ".tabpanel", "tabpanel").forEach((function (t) {
            o(t, t !== s)
        })), !this.isSync && "syncStorageKey" in t && "syncGroupId" in n.dataset) {
            var c = t.syncStorageKey + "-" + n.dataset.syncGroupId;
            window[(t.syncStorageScope || "local") + "Storage"].setItem(c, a.dataset.syncId)
        }
        if (e) {
            var l = window.location, d = l.hash ? l.href.indexOf("#") : -1;
            ~d && window.history.replaceState(null, "", l.href.slice(0, d)), e.preventDefault()
        }
    }

    function n(t) {
        a.call(this, t);
        var n = this.tabs, s = this.tab, o = n.getBoundingClientRect().y;
        e.call(document.querySelectorAll(".tabs"), (function (t) {
            t !== n && t.dataset.syncGroupId === n.dataset.syncGroupId && i(t, ".tablist .tab", "tab").forEach((function (e) {
                e.dataset.syncId === s.dataset.syncId && a.call({tabs: t, tab: e, isSync: !0})
            }))
        }));
        var r = n.getBoundingClientRect().y - o;
        r && (r = Math.round(r)) && window.scrollBy({top: r, behavior: "instant"})
    }

    function i(t, e, a) {
        var n = t.querySelector(e);
        if (!n) return [];
        for (var i = [n]; (n = n.nextElementSibling) && n.classList.contains(a);) i.push(n);
        return i
    }

    function s(t, a, n) {
        e.call(t, (function (t) {
            t.classList[n](a)
        }))
    }

    function o(t, e) {
        t.classList[(t.hidden = e) ? "add" : "remove"]("is-hidden")
    }

    function r(t, e) {
        t.setAttribute("aria-selected", "" + e), t.classList[e ? "add" : "remove"]("is-selected"), t.tabIndex = e ? 0 : -1
    }

    function c() {
        var t = window.location.hash.slice(1);
        if (t) {
            var e = document.getElementById(~t.indexOf("%") ? decodeURIComponent(t) : t);
            e && e.classList.contains("tab") && ("syncId" in e.dataset ? n.call({tab: e}) : a.call({tab: e}))
        }
    }

    !function (i) {
        if (!i.length) return;
        e.call(i, (function (i) {
            var s, c = i.classList.contains("is-sync") ? {} : void 0, l = i.querySelector(".tablist ul");
            if (l.setAttribute("role", "tablist"), e.call(l.querySelectorAll("li"), (function (t, e) {
                var l, d, u;
                t.tabIndex = -1, t.setAttribute("role", t.classList.add("tab") || "tab"), !(l = t.id) && (d = t.querySelector("a[id]")) && (l = t.id = d.parentNode.removeChild(d).id);
                var b = l && i.querySelector('.tabpanel[aria-labelledby~="' + l + '"]');
                if (!b) return e ? void 0 : r(t, !0);
                c && (!((u = t.textContent.trim()) in c) || (u = void 0)) && (c[t.dataset.syncId = u] = t), e || c && (s = {
                    tab: t,
                    panel: b
                }) ? o(b, !0) : r(t, !0), t.setAttribute("aria-controls", b.id), b.setAttribute("role", "tabpanel");
                var y = void 0 === u ? a : n;
                t.addEventListener("click", y.bind({tabs: i, tab: t, panel: b}))
            })), i.closest(".tabpanel") || e.call(i.querySelectorAll(".tabpanel table.tableblock"), (function (t) {
                var e = Object.assign(document.createElement("div"), {className: "tablecontainer"});
                t.parentNode.insertBefore(e, t).appendChild(t)
            })), s) {
                for (var d, u, b = 0, y = i.classList, f = y.length; b !== f; b++) if ((u = y.item(b)).startsWith("data-sync-group-id=")) {
                    i.dataset.syncGroupId = d = y.remove(u) || u.slice(19).replace(/\u00a0/g, " ");
                    break
                }
                void 0 === d && (i.dataset.syncGroupId = d = Object.keys(c).sort().join("|"));
                var p = "syncStorageKey" in t && window[(t.syncStorageScope || "local") + "Storage"].getItem(t.syncStorageKey + "-" + d),
                    h = p && c[p];
                h && Object.assign(s, {
                    tab: h,
                    panel: document.getElementById(h.getAttribute("aria-controls"))
                }), r(s.tab, !0) || o(s.panel, !1)
            }
        })), c(), s(i, "is-loading", "remove"), window.setTimeout(s.bind(null, i, "is-loaded", "add"), 0), window.addEventListener("hashchange", c)
    }(document.querySelectorAll(".tabs"))
}();
//# sourceMappingURL=/sm/a6b674d2bb82bd28fbe836a547ccea4b083865ad60edc9439db4fa3988c3de3e.map


================================================
FILE: embabel-agent-docs/src/main/asciidoc/user-guide.adoc
================================================
[[user-guide]]
ifndef::imagesdir[]
:imagesdir: images
endif::[]

include::overview/page.adoc[]

include::getting-started/page.adoc[]

include::reference/reference.adoc[]


// include::shell/shell-guide.adoc[]

// include::eval/eval-guide.adoc[]

// include::examples/page.adoc[]

include::agent-design/page.adoc[]

include::contributing/page.adoc[]

// include::roadmap/roadmap.adoc[]

include::resources/page.adoc[]

== APPENDIX

include::appendix/page.adoc[]



================================================
FILE: embabel-agent-docs/src/main/asciidoc/agent-design/page.adoc
================================================
[[agent-design]]
== Design Considerations

Embabel is designed to give you the ability to determine the correct balance between LLM autonomy and control from code.
This section discusses the design considerations that you can use to achieve this balance.

=== Domain objects

A rich domain model helps build a good agentic system.
Domain objects should not merely contain state, but also expose behavior.
Avoid the https://en.wikipedia.org/wiki/Anemic_domain_model[anemic domain model].
Domain objects have multiple roles:

1. _Ensuring type safety and toolability._
Code can access their state; prompts will be strongly typed; and LLMs know what to return.
2. _Exposing behavior to call in code_, exactly as in any well-designed object-oriented system.
3. _Exposing tools to LLMs_, allowing them to call domain objects.

The third role _is_ novel in the context of LLMs and Embabel.

IMPORTANT: When designing your domain objects, consider which methods should be callable by LLMs and which should not.

Expose methods that LLMs should be able to call using the `@Tool` annotation:

[source,kotlin]
----
@Tool(description = "Build the project using the given command in the root") // <1>
fun build(command: String): String {
    val br = ci.buildAndParse(BuildOptions(command, true))
    return br.relevantOutput()
}
----

<1> The Spring AI `@Tool` annotation indicates that this method is callable by LLMs.

When an `@Action` method issues a prompt, tool methods on all domain objects are available to the LLM.

You can also add additional tool methods with the `withToolObjects` method on `PromptRunner`.

Domain objects may or may not be persistent.
If persistent, they will likely be stored in a familiar JVM technology such as JPA or JDBC.
We advocate the use of https://spring.io/projects/spring-data[Spring Data] patterns and repositories, although you are free to use any persistence technology you like.

=== Tool Call Choice

When to use MCP or other tools versus method calls in agents

=== Mixing LLMs

It's good practice to use multiple LLMs in your agentic system.
Embabel makes it easy.
One key benefit of breaking functionality into smaller actions is that you can use different LLMs for different actions, depending on their strengths and weaknesses.
You can also the cheapest (greenest) possible LLM for a given task.




================================================
FILE: embabel-agent-docs/src/main/asciidoc/appendix/page.adoc
================================================
[[appendix__astar-goap-planner]]

== Planning Module

=== Abstract

Lower level module for planning and scheduling. Used by Embabel Agent Platform.

=== A* GOAP Planner Algorithm Overview

  The A* GOAP (Goal-Oriented Action Planning) Planner is an implementation of the A* search
  algorithm specifically designed for planning sequences of actions to achieve specified goals.
  The algorithm efficiently finds the optimal path from an initial world state to a goal state by
  exploring potential action sequences and minimizing overall cost.

==== Core Algorithm Components

  The A* GOAP Planner consists of several key components:

. *A* Search*: Finds optimal action sequences by exploring the state space
. *Forward Planning*: Simulates actions from the start state toward goals
. *Backward Planning*: Optimizes plans by working backward from goals
. *Plan Simulation*: Verifies that plans achieve intended goals
. *Pruning*: Removes irrelevant actions to create efficient plans
. *Unknown Condition Handling*: Manages incomplete world state information

==== A* Search Algorithm

  The A* search algorithm operates by maintaining:

* *Open List*: A priority queue of states to explore, ordered by f-score
* *Closed Set*: States already fully explored
* *g-score*: Cost accumulated so far to reach a state
* *h-score*: Heuristic estimate of remaining cost to goal
* *f-score*: Total estimated cost (g-score + h-score)

==== Process Flow

. *Initialization*:
** Begin with the start state in the open list
** Set its g-score to 0 and calculate its h-score
. *Main Loop*:
** While the Open List is not empty:
*** Select the state with the lowest f-score from the open list
*** If this state satisfies the goal, construct and return the plan
*** Otherwise, mark the state as processed (add to closed set)
*** For each applicable action, generate the next state and add to open list if it better
than existing paths
. *Path Reconstruction*:
When a goal state is found, reconstruct the path by following predecessors
** Create a plan consisting of the sequence of actions

     _Reference: link:goap/AStarGoapPlanner.kt[AStarGoapPlanner]:planToGoalFrom:_

==== Forward and Backward Planning Optimization

  The planner implements a two-pass optimization strategy to eliminate unnecessary actions:

===== Backward Planning Optimization

  This pass works backward from the goal conditions to identify only actions that contribute to
  achieving the goal

  _Reference: link:goap/AStarGoapPlanner.kt[AStarGoapPlanner]:_backwardPlanningOptimization___

===== Forward Planning Optimization

  This pass simulates the plan from the start state and removes actions that don't make progress
  toward the goal:

  _Reference: link:goap/AStarGoapPlanner.kt[AStarGoapPlanner]:_forwardPlanningOptimization___

===== Plan Simulation

  Plan simulation executes actions in sequence to verify the plan's correctness:

  _Reference: function simulatePlan(startState, actions)_

==== Pruning Planning Systems

  The planner can prune entire planning systems to remove irrelevant actions:

[source,kotlin]
-----

  function prune(planningSystem):
  // Get all plans to all goals
  allPlans = plansToGoals(planningSystem)
  // Keep only actions that appear in at least one plan
  return planningSystem.copy(
      actions = planningSystem.actions.filter { action ->
          allPlans.any { plan -> plan.actions.contains(action) }
      }.toSet()
  )
-----


===== Heuristic Function

  The heuristic function estimates the cost to reach the goal from a given state:

==== Complete Planning Process

. Initialize with start state, actions, and goal conditions
. Run A* search to find an initial action sequence
. Apply backward planning optimization to eliminate unnecessary actions
. Apply forward planning optimization to further refine the plan
. Verify the plan through simulation
. Return the optimized action sequence or null if no valid plan exists

=== Agent Pruning Process

  When pruning an agent for specific goals:

. Identify all known conditions in the planning system
. Set initial state based on input conditions
. Find all possible plans to each goal
. Keep only actions that appear in at least one plan
. Create a new agent with the pruned action set

  This comprehensive approach ensures agents contain only the actions necessary to achieve their
  designated goals, improving efficiency and preventing action leakage between different agents.

==== Progress Determination Logic in A* GOAP Planning

  The progress determination logic in method *forwardPlanningOptimization* is a critical part of
  the forward planning optimization in the A* GOAP algorithm. This logic ensures that only actions
  that meaningfully progress the state toward the goal are included in the final plan.

===== Progress Determination Expression

[source,kotlin]
-----

  progressMade = nextState != currentState &&
  action.effects.any { (key, value) ->
        goal.preconditions.containsKey(key) &&
        currentState[key] != goal.preconditions[key] &&
        (value == goal.preconditions[key] || key not in nextState)
  }
-----

===== Detailed Explanation

  The expression evaluates to true only when an action makes meaningful progress toward achieving
  the goal state. Let's break down each component:

. `nextState != currentState`
** Verifies that the action actually changes the world state
** Prevents including actions that have no effect
. `action.effects.any { ... }`
** Examines each effect the action produces
** Returns true if ANY effect satisfies the inner condition
. `goal.preconditions.containsKey(key)`
** Ensures we only consider effects that relate to conditions required by the goal
** Ignores effects that modify conditions irrelevant to our goal
. `currentState[key] != goal.preconditions[key]`
** Checks that the current condition value differs from what the goal requires
** Only counts progress if we're changing a condition that needs changing
. `(value == goal.preconditions[key] || key not in nextState)`
** This checks one of two possible ways an action can make progress:
** `value == goal.preconditions[key]`
*** The action changes the condition to exactly match what the goal requires
*** Direct progress toward goal achievement
** `key not in nextState`
*** The action removes the condition from the state entirely
*** This is considered progress if the condition was previously in an incorrect state
*** Allows for actions that clear obstacles or reset conditions



================================================
FILE: embabel-agent-docs/src/main/asciidoc/contributing/page.adoc
================================================
[[contributing]]
== Contributing
:sectids:
:sectanchors:

Open source is a wonderful thing.
We welcome contributions to the Embabel project.

How to contribute:

- Familiarize yourself with the project by reading the documentation.
- Familiarize yourself with the https://github.com/embabel/embabel-agent/issues/[issue tracker] and open pull requests to ensure you're not duplicating something.
- https://docs.github.com/en/authentication/managing-commit-signature-verification/signing-commits[Sign your commits]
- Always include a description with your pull requests. *PRs without descriptions will be closed.*
- Join the Embabel community on Discord at https://discord.gg/t6bjkyj93q.

Contributions are not limited to code.
You can also help by:

- Improving the documentation
- Reporting bugs
- Suggesting new features
- Engaging with the community on Discord
- Creating examples and other materials
- Talking about Embabel at meetups and conferences
- Posting about Embabel on social media

When contributing code, **do** augment your productivity using coding agents and LLMs, but avoid these pitfalls:

- **Excessive LLM comments that add no value**.
Code should be self-documenting.
Comments are for things that are non-obvious.
- **Bloated PR descriptions and other content.**

Nothing personal, but such contributions will automatically be rejected.

IMPORTANT: You must understand anything you contribute.




================================================
FILE: embabel-agent-docs/src/main/asciidoc/eval/eval-guide.adoc
================================================
[[eval.guide]]
== Agent Eval Guide
:sectids:
:sectanchors:

The following chapters are dedicated to _Agent Eval Framework_.




================================================
FILE: embabel-agent-docs/src/main/asciidoc/getting-started/page.adoc
================================================
[[agent.guide]]
== Getting Started
:sectids:
:sectanchors:

include::quickstart/page.adoc[]
include::installing/page.adoc[]
include::running/page.adoc[]
include::a-little-ai/page.adoc[]
include::first-agent/page.adoc[]



================================================
FILE: embabel-agent-docs/src/main/asciidoc/getting-started/a-little-ai/page.adoc
================================================
[[getting-started.a-little-ai]]
=== Adding a Little AI to Your Application

Before we get into the magic of full-blown Embabel agents, let's see how easy it is to add a little AI to your application using the Embabel framework.
Sometimes this is all you need.

The simplest way to use Embabel is to inject an `OperationContext` and use its AI capabilities directly.
This approach is consistent with standard Spring dependency injection patterns.

[source,java]
----
package com.embabel.example.injection;

import com.embabel.agent.api.common.OperationContext;
import com.embabel.common.ai.model.LlmOptions;
import org.springframework.stereotype.Component;

/**
 * Demonstrate the simplest use of Embabel's AI capabilities,
 * injecting an AI helper into a Spring component.
 * The jokes will be terrible, but don't blame Embabel, blame the LLM.
 */
@Component
public record InjectedComponent(Ai ai) {

    public record Joke(String leadup, String punchline) {
    }

    public String tellJokeAbout(String topic) {
        return ai
                .withDefaultLlm()
                .generateText("Tell me a joke about " + topic);
    }

    public Joke createJokeObjectAbout(String topic1, String topic2, String voice) {
        return ai
                .withLlm(LlmOptions.withDefaultLlm().withTemperature(.8))
                .createObject("""
                                Tell me a joke about %s and %s.
                                The voice of the joke should be %s.
                                The joke should have a leadup and a punchline.
                                """.formatted(topic1, topic2, voice),
                        Joke.class);
    }

}
----

This example demonstrates several key aspects of Embabel's design philosophy:

* **Standard Spring Integration**: The `Ai` object is injected like any other Spring dependency using constructor injection
* **Simple API**: Access AI capabilities through the `Ai` interface directly or `OperationContext.ai()`, which can also be injected in the same way
* **Flexible Configuration**: Configure LLM options like temperature on a per-call basis
* **Type Safety**: Generate structured objects directly with `createObject()` method
* **Consistent Patterns**: Works exactly like you'd expect any Spring component to work

The `Ai` type provides access to all of Embabel's AI capabilities without requiring a full agent setup, making it perfect for adding AI features to existing applications incrementally.

TIP: The `Ai` and OperationContext` APIs are used throughout Embabel applications, as a convenient gateway to key AI and other functionality.




================================================
FILE: embabel-agent-docs/src/main/asciidoc/getting-started/first-agent/page.adoc
================================================
[[getting-started.first-agent]]
=== Writing Your First Agent

The easiest way to create your first agent is to use the Java or Kotlin template repositories.

==== Using the Template

Create a new project from the https://github.com/embabel/java-agent-template[Java template] or https://github.com/embabel/kotlin-agent-template[Kotlin template] by clicking "Use this template" on GitHub.

Or use the project creator:

[source,bash]
----
uvx --from git+https://github.com/embabel/project-creator.git project-creator
----

==== Example: WriteAndReviewAgent

The Java template includes a `WriteAndReviewAgent` that demonstrates key concepts:

[source,java]
----
@Agent(description = "Agent that writes and reviews stories")
public class WriteAndReviewAgent {

    @Action
    public Story writeStory(UserInput userInput, OperationContext context) {
        return context.ai()
            .withAutoLlm()
            .createObject("""
                You are a creative writer who aims to delight and surprise.
                Write a story about %s
                """.formatted(userInput.getContent()),
            Story.class);
    }

    @AchievesGoal(description = "Review a story")
    @Action  
    public ReviewedStory reviewStory(Story story, OperationContext context) {
        return context.ai()
            .withLlmByRole("reviewer")
            .createObject("""
                You are a meticulous editor.
                Carefully review this story:
                %s
            """.formatted(story.text),
            ReviewedStory.class);
    }
}
----

==== Key Concepts Demonstrated

**Multiple LLMs with Different Configurations:**

- Writer LLM uses high temperature (0.8) for creativity
- Reviewer LLM uses low temperature (0.2) for analytical review
- Different personas guide the model behavior

**Actions and Goals:**

- `@Action` methods are the steps the agent can take
- `@AchievesGoal` marks the final action that completes the agent's work

**Domain Objects:**

- `Story` and `ReviewedStory` are strongly-typed domain objects
- Help structure the interaction between actions

==== Running Your Agent

Set your API keys and run the shell:

[source,bash]
----
export OPENAI_API_KEY="your_key_here"
./scripts/shell.sh
----

In the shell, try:

----
x "Tell me a story about a robot learning to paint"
----

The agent will:

1. Generate a creative story using the writer LLM
2. Review and improve it using the reviewer LLM
3. Return the final reviewed story

==== Next Steps

- Explore the https://github.com/embabel/embabel-agent-examples[examples repository] for more complex agents
- Read the <<reference.reference,Reference Documentation>> for detailed API information
- Try building your own domain-specific agents


================================================
FILE: embabel-agent-docs/src/main/asciidoc/getting-started/installing/page.adoc
================================================
[[getting-started.installing]]
=== Getting the Binaries

The easiest way to get started with Embabel Agent is to add the Spring Boot starter dependency to your project.

==== Maven

Add the appropriate Embabel Agent Spring Boot starter to your `pom.xml` depending on your application type:

===== Shell Starter
Starts the application in console mode with an interactive shell powered by Embabel.

[source,xml]
----
<dependency>
    <groupId>com.embabel.agent</groupId>
    <artifactId>embabel-agent-starter-shell</artifactId>
    <version>${embabel-agent.version}</version>
</dependency>
----

*Features:*

* ✅ Interactive command-line interface
* ✅ Agent discovery and registration
* ✅ Human-in-the-loop capabilities
* ✅ Progress tracking and logging
* ✅ Development-friendly error handling

===== MCP Server Starter
Starts the application with HTTP listener where agents are autodiscovered and registered as MCP servers, available for integration via SSE protocol.

[source,xml]
----
<dependency>
    <groupId>com.embabel.agent</groupId>
    <artifactId>embabel-agent-starter-mcpserver</artifactId>
    <version>${embabel-agent.version}</version>
</dependency>
----

*Features:*

* ✅️ MCP protocol server implementation
* ✅️ Tool registration and discovery
* ✅️ JSON-RPC communication via SSE (Server-Sent Events)
* ✅️ Integration with MCP-compatible clients
* ✅️ Security and sandboxing

===== Basic Agent Platform Starter
Initializes Embabel Agent Platform in the Spring Container. Platform beans are available via Spring Dependency Injection mechanism.
Application startup mode (web, console, microservice, etc.) is determined by the Application Designer.

[source,xml]
----
<dependency>
    <groupId>com.embabel.agent</groupId>
    <artifactId>embabel-agent-starter</artifactId>
    <version>${embabel-agent.version}</version>
</dependency>
----

*Features:*

* ✅️ Application decides on startup mode (console, web application, etc)
* ✅️ Agent discovery and registration
* ✅️ Agent Platform beans available via Dependency Injection mechanism
* ✅️ Progress tracking and logging
* ✅️ Development-friendly error handling


You'll also need to add the Embabel repository to your `pom.xml`:

[source,xml]
----
<repositories>
    <repository>
        <id>embabel-releases</id>
        <url>https://repo.embabel.com/artifactory/libs-release</url>
        <releases>
            <enabled>true</enabled>
        </releases>
        <snapshots>
            <enabled>false</enabled>
        </snapshots>
    </repository>
    <repository>
        <id>embabel-snapshots</id>
        <url>https://repo.embabel.com/artifactory/libs-snapshot</url>
        <releases>
            <enabled>false</enabled>
        </releases>
        <snapshots>
            <enabled>true</enabled>
        </snapshots>
    </repository>
    <repository>
        <id>spring-milestones</id>
        <url>https://repo.spring.io/milestone</url>
        <snapshots>
            <enabled>false</enabled>
        </snapshots>
    </repository>
</repositories>
----

==== Gradle

Add the required repositories to your `build.gradle.kts`:

[source,kotlin]
----
repositories {
    mavenCentral()
    maven {
        name = "embabel-releases"
        url = uri("https://repo.embabel.com/artifactory/libs-release")
        mavenContent {
            releasesOnly()
        }
    }
    maven {
        name = "embabel-snapshots"
        url = uri("https://repo.embabel.com/artifactory/libs-snapshot")
        mavenContent {
            snapshotsOnly()
        }
    }
    maven {
        name = "Spring Milestones"
        url = uri("https://repo.spring.io/milestone")
    }
}
----

Add the Embabel Agent starter dependency of choice:

[source,kotlin]
----
dependencies {
    implementation("com.embabel.agent:embabel-agent-starter-shell:${embabel-agent.version}")
}
----

For Gradle Groovy DSL (`build.gradle`):

[source,groovy]
----
repositories {
    mavenCentral()
    maven {
        name = 'embabel-releases'
        url = 'https://repo.embabel.com/artifactory/libs-release'
        mavenContent {
            releasesOnly()
        }
    }
    maven {
        name = 'embabel-snapshots'
        url = 'https://repo.embabel.com/artifactory/libs-snapshot'
        mavenContent {
            snapshotsOnly()
        }
    }
    maven {
        name = 'Spring Milestones'
        url = 'https://repo.spring.io/milestone'
    }
}

dependencies {
    implementation 'com.embabel.agent:embabel-agent-starter-shell:${embabel-agent.version}'
}
----

==== Environment Setup

Before running your application, you'll need to set up your environment with API keys for the LLM providers you plan to use.

Required:
- `OPENAI_API_KEY`: For OpenAI models (GPT-4, GPT-5, etc.)

Optional but recommended:
- `ANTHROPIC_API_KEY`: For Anthropic models (Claude 3.x, etc.)

Example `.env` file:
----
OPENAI_API_KEY=your_openai_api_key_here
ANTHROPIC_API_KEY=your_anthropic_api_key_here
----




================================================
FILE: embabel-agent-docs/src/main/asciidoc/getting-started/quickstart/page.adoc
================================================
[[getting-started.quickstart]]
=== Quickstart

There are two GitHub template repos you can use to create your own project:

* Java template - https://github.com/embabel/java-agent-template
* Kotlin template - https://github.com/embabel/kotlin-agent-template

Or you can use our https://github.com/embabel/project-creator[project creator] to create a custom project:

[source,bash]
----
uvx --from git+https://github.com/embabel/project-creator.git project-creator
----




================================================
FILE: embabel-agent-docs/src/main/asciidoc/getting-started/running/page.adoc
================================================
[[getting-started.running]]
=== Getting Embabel Running

==== Running the Examples

The quickest way to get started with Embabel is to run the examples:

[source,bash]
----
# Clone and run examples
git clone https://github.com/embabel/embabel-agent-examples
cd embabel-agent-examples/scripts/java
./shell.sh
----

NOTE: Choose the `java` or `kotlin` scripts directory depending on your preference.

==== Prerequisites

- Java 21+
- API Key from OpenAI or Anthropic
- Maven 3.9+ (optional)

Set your API keys:

[source,bash]
----
export OPENAI_API_KEY="your_openai_key"
export ANTHROPIC_API_KEY="your_anthropic_key"
----

==== Using the Shell

Spring Shell is an easy way to interact with the Embabel agent framework, especially during development.

Type `help` to see available commands.
Use `execute` or `x` to run an agent:

----
execute "Lynda is a Scorpio, find news for her" -p -r
----

This will look for an agent, choose the star finder agent and run the flow. `-p` will log prompts `-r` will log LLM responses.
Omit these for less verbose logging.

Options:

- `-p` logs prompts
- `-r` logs LLM responses

Use the `chat` command to enter an interactive chat with the agent.
It will attempt to run the most appropriate agent for each command.

TIP: Spring Shell supports history.
Type `!!` to repeat the last command.
This will survive restarts, so is handy when iterating on an agent.

==== Example Commands

Try these commands in the shell:

----
# Simple horoscope agent
execute "My name is Sarah and I'm a Leo"

# Research with web tools (requires Docker Desktop with MCP extension)
execute "research the recent australian federal election. what is the position of the Greens party?"

# Fact checking
x "fact check the following: holden cars are still made in australia"
----

==== Implementing Your Own Shell Commands

Particularly during development, you may want to implement your own shell commands to try agents or flows.
Simply write a Spring Shell component and Spring will inject it and register it automatically.

For example, you can inject the `AgentPlatform` and use it to invoke agents directly, as in this code from the examples repository:

[source,java]
----
@ShellComponent
public record SupportAgentShellCommands(
        AgentPlatform agentPlatform
) {

    @ShellMethod("Get bank support for a customer query")
    public String bankSupport(
            @ShellOption(value = "id", help = "customer id", defaultValue = "123") Long id,
            @ShellOption(value = "query", help = "customer query", defaultValue = "What's my balance, including pending amounts?") String query
    ) {
        var supportInput = new SupportInput(id, query);
        System.out.println("Support input: " + supportInput);
        var invocation = AgentInvocation
                .builder(agentPlatform)
                .options(ProcessOptions.builder().verbosity(v -> v.showPrompts(true)).build())
                .build(SupportOutput.class);
        var result = invocation.invoke(supportInput);
        return result.toString();
    }
}
----




================================================
FILE: embabel-agent-docs/src/main/asciidoc/guides/page.adoc
================================================
[[guides]]
== Guides
:sectids:
:sectanchors:

The following chapters are dedicated to _Agent Examples_.

include::horoscope/page.adoc[]
include::movies/page.adoc[]



================================================
FILE: embabel-agent-docs/src/main/asciidoc/guides/horoscope/page.adoc
================================================
[[guies.horoscope]]
=== Horoscope Example

The `StarNewsFinder` is a simple agent that finds a person's name and star sign from user input, retrieves their horoscope using an external API, retrieves relevant news stories using web tools, and writes up an amusing piece for them.



================================================
FILE: embabel-agent-docs/src/main/asciidoc/guides/movies/page.adoc
================================================
[[guies.movies]]
=== Movie Example



================================================
FILE: embabel-agent-docs/src/main/asciidoc/images/agent-api/.gitkeep
================================================
[Empty file]


================================================
FILE: embabel-agent-docs/src/main/asciidoc/images/architecture/.gitkeep
================================================
[Empty file]


================================================
FILE: embabel-agent-docs/src/main/asciidoc/images/eval/.gitkeep
================================================
[Empty file]


================================================
FILE: embabel-agent-docs/src/main/asciidoc/images/shell/.gitkeep
================================================
[Empty file]


================================================
FILE: embabel-agent-docs/src/main/asciidoc/overview/agent-framework.adoc
================================================
[[overview__agent-framework]]
=== Why do we need an Agent Framework?

Aren’t LLMs smart enough to solve our problems directly?
Aren’t MCP tools all we need to allow them to solve complex problems?

But there are many reasons that a higher level orchestration technology is needed, especially for business applications.
Here are some of the most important:

- *Explainability*: Why were choices made in solving a problem?
- *Discoverability*: How do we find the right tools at each point, and ensure that models aren’t confused in choosing between them?
- *Ability to mix models*, so that we are not reliant on God models but can use local, cheaper, private models for many tasks
- *Ability to inject guardrails* at any point in a flow
- *Ability to manage flow execution* and introduce greater resilience
- *Composability of flows at scale*.
We’ll soon be seeing not just agents running on one system, but federations of agents.
- *Safer integration with sensitive existing systems* such as databases, where it is dangerous to allow even the best LLM write access.

Agent frameworks break complex tasks into smaller, manageable components, offering greater control and predictability.

Agent frameworks offer "code agency" as well as "LLM agency." This division is well described in this
https://research.nvidia.com/labs/lpr/slm-agents/[paper from NVIDIA Research].

Further reading:

* link:https://medium.com/@springrod/embabel-a-new-agent-platform-for-the-jvm-1c83402e0014[Embabel: A new Agent Platform For the JVM]

* link:https://medium.com/@springrod/the-embabel-vision-967654f13793[The Embabel Vision]



================================================
FILE: embabel-agent-docs/src/main/asciidoc/overview/concepts.adoc
================================================
[[overview__concepts]]
=== Core Concepts

Agent frameworks break up tasks into separate smaller interactions, making LLM use more predictable and focused.

Embabel models agentic flows in terms of:

- **Actions**: Steps an agent takes.
These are the building blocks of agent behavior.
- **Goals**: What an agent is trying to achieve.
- ** Conditions**: Conditions to while planning.
Conditions are reassessed after each action is executed.
- **Domain Model**: Objects underpinning the flow and informing Actions, Goals and Conditions.

This enables Embabel to create a **plan**: A sequence of actions to achieve a goal.
Plans are dynamically formulated by the system, not the programmer.
The system replans after the completion of each action, allowing it to adapt to new information as well as observe the effects of the previous action.
This is effectively an https://en.wikipedia.org/wiki/OODA_loop[OODA loop].

NOTE: Application developers don't usually have to deal with these concepts directly, as most conditions result from data flow defined in code, allowing the system to infer pre and post conditions.

==== Complete Example

Let's look at a complete example that demonstrates how Embabel infers conditions from input/output types and manages data flow between actions.
This example comes from the https://github.com/embabel/embabel-agent-examples[Embabel Agent Examples] repository:

[source,java]
----
@Agent(description = "Find news based on a person's star sign")  // <1>
public class StarNewsFinder {

    private final HoroscopeService horoscopeService;  // <2>
    private final int storyCount;

    public StarNewsFinder(
            HoroscopeService horoscopeService,  // <3>
            @Value("${star-news-finder.story.count:5}") int storyCount) {
        this.horoscopeService = horoscopeService;
        this.storyCount = storyCount;
    }

    @Action  // <4>
    public StarPerson extractStarPerson(UserInput userInput, OperationContext context) {  // <5>
        return context.ai()
            .withLlm(OpenAiModels.GPT_41)
            .createObject("""
                Create a person from this user input, extracting their name and star sign:
                %s""".formatted(userInput.getContent()), StarPerson.class);  // <6>
    }

    @Action  // <7>
    public Horoscope retrieveHoroscope(StarPerson starPerson) {  // <8>
        // Uses regular injected Spring service - not LLM
        return new Horoscope(horoscopeService.dailyHoroscope(starPerson.sign()));  // <9>
    }

    @Action(toolGroups = {CoreToolGroups.WEB})  // <10>
    public RelevantNewsStories findNewsStories(
            StarPerson person, Horoscope horoscope, OperationContext context) {  // <11>
        var prompt = """
            %s is an astrology believer with the sign %s.
            Their horoscope for today is: %s
            Given this, use web tools to find %d relevant news stories.
            """.formatted(person.name(), person.sign(), horoscope.summary(), storyCount);

        return context.ai().withDefaultLlm().createObject(prompt, RelevantNewsStories.class);  // <12>
    }

    @AchievesGoal(description = "Write an amusing writeup based on horoscope and news")  // <13>
    @Action
    public Writeup writeup(
            StarPerson person, RelevantNewsStories stories, Horoscope horoscope,
            OperationContext context) {  // <14>
        var llm = LlmOptions.fromCriteria(ModelSelectionCriteria.getAuto())
            .withTemperature(0.9);  // <15>

        var prompt = """
            Write something amusing for %s based on their horoscope and these news stories.
            Format as Markdown with links.
            """.formatted(person.name());

        return context.ai().withLlm(llm).createObject(prompt, Writeup.class);  // <16>
    }
}
----

<1> **Agent Declaration**: The `@Agent` annotation defines this as an agent capable of a multi-step flow.

<2> **Spring Integration**: Regular Spring dependency injection - the agent uses both LLM services and traditional business services.

<3> **Service Injection**: `HoroscopeService` is injected like any Spring bean - agents can mix AI and non-AI operations seamlessly.

<4> **Action Definition**: `@Action` marks methods as steps the agent can take.
Each action represents a capability.

<5> **Input Condition Inference**: The method signature `extractStarPerson(UserInput userInput, ...)` tells Embabel:
- **Precondition**: "A UserInput object must be available"
- **Required Data**: The agent needs user input to proceed
- **Capability**: This action can extract structured data from unstructured input

<6> **Output Condition Creation**: Returning `StarPerson` creates:
- **Postcondition**: "A StarPerson object is now available in the world state"
- **Data Availability**: This output becomes input for subsequent actions
- **Type Safety**: The domain model enforces structure

<7> **Non-LLM Action**: Not all actions use LLMs - this demonstrates hybrid AI/traditional programming.

<8> **Data Flow Chain**: The method signature `retrieveHoroscope(StarPerson starPerson)` creates:
- **Precondition**: "A StarPerson object must exist" (from previous action)
- **Dependency**: This action can only execute after `extractStarPerson` completes
- **Service Integration**: Uses the injected `horoscopeService` rather than an LLM

<9> **Regular Service Call**: This action calls a traditional Spring service - demonstrating how agents blend AI and conventional operations.

<10> **Tool Requirements**: `toolGroups = {CoreToolGroups.WEB}` specifies this action needs web search capabilities.

<11> **Multi-Input Dependencies**: This method requires both `StarPerson` and `Horoscope` - showing complex data flow orchestration.

<12> **Tool-Enabled LLM**: The LLM can use web tools to search for current news stories based on the horoscope context.

<13> **Goal Achievement**: `@AchievesGoal` marks this as a terminal action that completes the agent's objective.

<14> **Complex Input Requirements**: The final action requires three different data types, showing sophisticated orchestration.

<15> **Creative Configuration**: High temperature (0.9) optimizes for creative, entertaining output - appropriate for amusing writeups.

<16> **Final Output**: Returns `Writeup`, completing the agent's goal with personalized content.

State is managed by the framework, through the process blackboard

==== The Inferred Execution Plan

Based on the type signatures alone, Embabel automatically infers this execution plan:

**Goal**: Produce a `Writeup` (final return type of `@AchievesGoal` action)

The initial plan:

- To emit `Writeup` → need `writeup()` action
- `writeup()` requires `StarPerson`, `RelevantNewsStories`, and `Horoscope`
- To get `StarPerson` → need `extractStarPerson()` action
- To get `Horoscope` → need `retrieveHoroscope()` action (requires `StarPerson`)
- To get `RelevantNewsStories` → need `findNewsStories()` action (requires `StarPerson` and `Horoscope`)
- `extractStarPerson()` requires `UserInput` → must be provided by user

Execution sequence:

`UserInput` → `extractStarPerson()` → `StarPerson` → `retrieveHoroscope()` → `Horoscope` → `findNewsStories()` → `RelevantNewsStories` → `writeup()` → `Writeup` and achieves goal.

==== Key Benefits of Type-Driven Flow

**Automatic Orchestration**: No manual workflow definition needed - the agent figures out the sequence from type dependencies.
This is particularly beneficial if things go wrong, as the planner can re-evaluate the situation and may be able to find an alternative path to the goal.

**Dynamic Replanning**: After each action, the agent reassesses what's possible based on available data objects.

**Type Safety**: Compile-time guarantees that data flows correctly between actions.
No magic string keys.

**Flexible Execution**: If multiple actions could produce the required input type, the agent chooses based on context and efficiency.
(Actions can have cost and value.)

This demonstrates how Embabel transforms simple method signatures into sophisticated multi-step agent behavior, with the complex orchestration handled automatically by the framework.




================================================
FILE: embabel-agent-docs/src/main/asciidoc/overview/glossary.adoc
================================================
=== Glossary

Before we begin, in this glossary we'll explain some terms that may be new if you're taking your first steps as
an applied AI software developer. It is assumed that you already know what a large language model (LLM) is from an
end-user's point of view.

NOTE: You may skim or skip this section if you're already a seasoned agentic AI engineer.

[[overview__agent]]
Agent::
    An Agent in the Embabel framework is a self-contained component that bundles together domain logic, AI capabilities,
and tool usage to achieve a specific goal on behalf of the user.
+
Inside, it exposes multiple `@Action` methods, each representing discrete steps the agent can take. Actions depend on
typically structured (sometimes natural language) input. The input is used to perform tasks on behalf of the user -
executing domain code, calling AI models or even calling other agents as a sub-process.
+
When an AI model is called it may be given access to tools that expand its capabilities in order to achieve a goal.
The output is a new type, representing a transformation of the input, however during execution one or more side-effects
can occur. An example of side effects might be new records stored in a database, orders placed on an e-commerce site
and so on.

[[overview__tools]]
Tools::
Tools extend the raw capabilities of an LLM by letting it interact with the outside world.
On its own, a language model can only generate responses from its training data and context window, which risks
producing inaccurate or “hallucinated” answers.
+
While tool usage is inspired by an technique known as *ReAct* (Reason + Act), which itself builds on *Chain of Thought*
reasoning, most recent LLMs allow specifying tools specifically instead of relying on prompt engineering techniques.
+
When tools are present, the LLM interprets the user request, plans steps, and then delegates certain tasks to tools in a loop. This
lets the model alternate between reasoning (“what needs to be done?”) and acting (“which tool can do it?”).
+
**Benefits of tools include:**
+
* The ability to answer questions or perform tasks beyond what the LLM was trained on, by delegating to domain-specific
or external systems.
* Producing useful *side effects*, such as creating database records, generating visualizations, booking flights, or
invoking any process the system designer provides.
+
In short, tools are one way to bridge the gap between *text prediction* and *real-world action*, turning an LLM into a
practical agent capable of both reasoning and execution. In Embabel many tools are bound domain objects.

MCP::
Model Context Protocol <<reference.integrations__mcp,(MCP)>> is a standardized way of hosting and sharing tools.
Unlike plain tools, which are usually wired directly into one agent or app, an MCP Server makes tools discoverable and
reusable across models and runtimes they can be registered system-wide or at runtime, and invoked through a common
protocol. Embabel can both consume and publish such tools for systems integration.

[[overview__dice]]
Domain Integrated Context Engineering (DICE)::
Enhances context engineering by grounding both LLM inputs and outputs in typed domain objects.
Instead of untyped prompts, context is structured with business-aware models that provide precision, testability,
and seamless integration with existing systems. DICE transforms context into a re-usable, inspectable, and reliably
manipulable artifact.



================================================
FILE: embabel-agent-docs/src/main/asciidoc/overview/page.adoc
================================================
[[overview__overview]]
== Overview
:sectids:
:sectanchors:

Agentic AI is the use of large language (and other multi-modal) models not just to generate text, but to act as
reasoning, goal-driven agents that can plan, call tools, and adapt their actions to deliver outcomes.

The JVM is a compelling platform for this because its strong type safety provides guardrails for integrating LLM-driven
behaviors with real systems. Because so many production applications already run on the JVM it is the natural place to
embed AI.

While Agentic AI has been hyped, much of it has lived in academic demos with little practical value; by integrating
directly into legacy and enterprise JVM applications, we can unlock AI capabilities without rewriting core systems or
tearing down a factory to install new machinery.

include::glossary.adoc[]

include::agent-framework.adoc[]

include::why-embabel.adoc[]

include::concepts.adoc[]



================================================
FILE: embabel-agent-docs/src/main/asciidoc/overview/why-embabel.adoc
================================================
[[overview__why-embabel]]
=== Embabel Differentiators

==== Sophisticated Planning

Goes beyond a finite state machine or sequential execution with nesting by introducing a true planning step, using a non-LLM AI algorithm.
This enables the system to perform tasks it wasn't programmed to do by combining known steps in a novel order, as well as make decisions about parallelization and other runtime behavior.

==== Superior Extensibility and Reuse

Because of dynamic planning, adding more domain objects, actions, goals and conditions can extend the capability of the system, _without editing FSM definitions_ or existing code.

==== Strong Typing and Object Orientation

Actions, goals and conditions are informed by a domain model, which can include behavior.
Everything is strongly typed and prompts and manually authored code interact cleanly.
No more magic maps.
Enjoy full refactoring support.

==== Platform Abstraction

Clean separation between programming model and platform internals allows running locally while potentially offering higher QoS in production without changing application code.

==== LLM Mixing

It is easy to build applications that mix LLMs, ensuring the most cost-effective yet capable solution.
This enables the system to leverage the strengths of different models for different tasks.
In particular, it facilitates the use of local models for point tasks.
This can be important for cost and privacy.

==== Spring and JVM Integration

Built on Spring and the JVM, making it easy to access existing enterprise functionality and capabilities.
For example:

- Spring can inject and manage agents, including using Spring AOP to decorate functions.
- Robust persistence and transaction management solutions are available.

==== Designed for Testability

Both unit testing and agent end-to-end testing are easy from the ground up.



================================================
FILE: embabel-agent-docs/src/main/asciidoc/reference/reference.adoc
================================================
[[reference__reference]]
== Reference
:sectids:
:sectanchors:

include::flow/page.adoc[]
include::steps/page.adoc[]
include::domain/page.adoc[]
include::configuration/page.adoc[]
include::annotations/page.adoc[]
include::dsl/page.adoc[]
include::types/page.adoc[]
include::tools/page.adoc[]
include::prompt-contributors/page.adoc[]
include::templates/page.adoc[]

include::agent-process/page.adoc[]
include::agent-platform/page.adoc[]

include::invoking/page.adoc[]

include::api-spi/page.adoc[]

include::spring/page.adoc[]

include::llms/page.adoc[]

include::customizing/page.adoc[]

include::integrations/page.adoc[]

include::testing/page.adoc[]

include::architecture/page.adoc[]

include::troubleshooting/page.adoc[]
include::migrating/page.adoc[]

include::api-evolution/page.adoc[]




================================================
FILE: embabel-agent-docs/src/main/asciidoc/reference/agent-platform/page.adoc
================================================
[[reference.agent-platform]]
=== The AgentPlatform

An `AgentPlatform` provides the ability to run agents in a specific environment.
This is an SPI interface, so multiple implementations are possible.




================================================
FILE: embabel-agent-docs/src/main/asciidoc/reference/agent-process/page.adoc
================================================
[[reference.agent-process]]
=== The AgentProcess

An `AgentProcess` is created every time an agent is run.
It has a unique id.

=== ProcessOptions

Agent processes can be configured with `ProcessOptions`.

`ProcessOptions` controls:

* `contextId`: An identifier of any existing context in which the agent is running.
* `blackboard`: The blackboard to use for the agent.
Allows starting from a particular state.
* `test`: Whether the agent is running in test mode.
* `verbosity`: The verbosity level of the agent.
Allows fine grained control over logging prompts, LLM returns and detailed planning information
* `control`: Control options, determining whether the agent should be terminated as a last resort. `EarlyTerminationPolicy` can based on an absolute number of actions or a maximum budget.
* Delays: Both operations (actions) and tools can have delays.
This is useful to avoid rate limiting.





================================================
FILE: embabel-agent-docs/src/main/asciidoc/reference/annotations/page.adoc
================================================
[[reference.annotations]]
=== Annotation model

Embabel provides a Spring-style annotation model to define agents, actions, goals, and conditions.
This is the recommended model to use in Java, and remains compelling in Kotlin.

==== The `@Agent` annotation

This annotation is used on a class to define an agent.
It is a Spring stereotype annotation, so it triggers Spring component scanning.
Your agent class will automatically be registered as a Spring bean.
It will also be registered with the agent framework, so it can be used in agent processes.

You must provide the `description` parameter, which is a human-readable description of the agent.
This is particularly important as it may be used by the LLM in agent selection.

==== The `@Action` annotation

The `@Action` annotation is used to mark methods that perform actions within an agent.

Action metadata can be specified on the annotation, including:

- `description`: A human-readable description of the action.
- `pre`: A list of preconditions _additional to the input types_ that must be satisfied before the action can be executed.
- `post`: A list of postconditions _additional to the output type(s)_ that may be satisfied after the action is executed.
- `canRerun`: A boolean indicating whether the action can be rerun if it has already been executed.
Defaults to false.
- `cost`:Relative cost of the action from 0-1. Defaults to 0.0.
- `value`: Relative value of performing the action from 0-1. Defaults to 0.0.
- `toolGroups`: Named tool groups the action requires.
- `toolGroupRequirements`: Tool group requirements with QoS constraints.

//TODO: (jasper notes) Provide links to detailed docs for pre, post, canRerun, cost, etc. Also brief code example is useful here.

==== The `@Condition` annotation

The `@Condition` annotation is used to mark methods that evaluate conditions.
They can take an `OperationContext` parameter to access the blackboard and other infrastructure.
If they take domain object parameters, the condition will automatically be false until suitable instances are available.

> Condition methods should not have side effects--for example, on the blackboard.
This is important because they may be called multiple times.

//TODO (jasper notes) Provide a simple illustrative example with story-telling and supporting code example.

> Both Action and Condition methods may be inherited from superclasses. That is, annotated methods on superclasses will be treated as actions on a subclass instance.

> Give your Action and Condition methods unique names, so the planner can distinguish between them.

==== Parameters

`@Action` methods must have at least one parameter.
`@Condition` methods must have zero or more parameters, but otherwise follow the same rules as `@Action` methods regarding parameters.
Ordering of parameters is not important.

Parameters fall in two categories:

* _Domain objects_.
These are the normal inputs for action methods.
They are backed by the blackboard and will be used as inputs to the action method.
A nullable domain object parameter will be populated if it is non-null on the blackboard.
This enables nice-to-have parameters that are not required for the action to run.
In Kotlin, use a nullable parameter with `?`: in Java, mark the parameter with the `org.springframework.lang.Nullable` or another `Nullable` annotation.

* _Infrastructure parameters_, such as the `OperationContext`, `ProcessContext`, and `Ai` may be used in action or condition methods.

NOTE: Domain objects drive planning, specifying the preconditions to an action.

The `ActionContext` or `ExecutingOperationContext` subtype can be used in action methods.
It adds `asSubProcess` methods that can be used to run other agents in subprocesses.
This is an important element of composition.

> Use the least specific type possible for parameters.
Use `OperationContext` unless you are creating a subprocess.

===== Custom Parameters

Besides two default parameter categories described above, you can provide your own parameters by implementing the `ActionMethodArgumentResolver` interface.
The two main methods of this interface are:

* `supportsParameter`, which indicates what kind of parameters are supported, and
* `resolveArgument`, which resolves the argument into an object used to invoke the action method.

NOTE: Note the similarity with Spring MVC, where you can provide custom parameters by implementing a `HandlerMethodArgumentResolver`.

> All default parameters are provided by `ActionMethodArgumentResolver` implementations.

To register your custom argument resolver, provide it to the `DefaultActionMethodManager` component in your Spring configuration.
Typically, you will register (some of) the defaults as well your custom resolver, in order to support the default parameters.

TIP: Make sure to register the `BlackboardArgumentResolver` as last resolver, to ensure that others take precedence.

==== Binding by name

The `@RequireNameMatch` annotation can be used to <<reference.flow__binding, bind parameters by name>>.

//TODO: (jasper notes) Provide an illustrative code example here.

==== Handling of return types

Action methods normally return a single domain object.

Nullable return types are allowed.
Returning null will trigger replanning.
There may or not be an alternative path from that point, but it won't be what the planner
was previously trying to achieve.

//TODO: (jasper notes) A diagram showing this would be super cool here.

There is a special case where the return type can essentially be a union type, where the action method can return one ore more of several types.
This is achieved by a return type implementing the `SomeOf` tag interface.
Implementations of this interface can have multiple nullable fields.
Any non-null values will be bound to the blackboard, and the postconditions of the action will include all possible fields of the return type.

For example:

[source,kotlin]
----
// Must implement the SomeOf interface
data class FrogOrDog(
    val frog: Frog? = null,
    val dog: Dog? = null,
) : SomeOf

@Agent(description = "Illustrates use of the SomeOf interface")
class ReturnsFrogOrDog {

    @Action
    fun frogOrDog(): FrogOrDog {
        return FrogOrDog(frog = Frog("Kermit"))
    }

    // This works because the frog field of the return type was set
    @AchievesGoal(description = "Create a prince from a frog")
    @Action
    fun toPerson(frog: Frog): PersonWithReverseTool {
        return PersonWithReverseTool(frog.name)
    }
}
----

This enables routing scenarios in an elegant manner.

TIP: Multiple fields of the `SomeOf` instance may be non-null and this is not an error.
It may enable the most appropriate routing.

Routing can also be achieved via subtypes, as in the following example:

[source,kotlin]
----
@Action
fun classifyIntent(userInput: UserInput): Intent? = // <1>
    when (userInput.content) {
        "billing" -> BillingIntent()
        "sales" -> SalesIntent()
        "service" -> ServiceIntent()
        else -> {
            loggerFor<IntentReceptionAgent>().warn("Unknown intent: $userInput")
            null
        }
    }

@Action
fun billingAction(intent: BillingIntent): IntentClassificationSuccess { // <2>
    return IntentClassificationSuccess("billing")
}

@Action
fun salesAction(intent: SalesIntent): IntentClassificationSuccess {
    return IntentClassificationSuccess("sales")
}

// ...
----

<1> Classification action returns supertype `Intent`. Real classification would likely use an LLM.
<2> `billingAction` and other action methods takes a subtype of `Intent`, so will only be invoked if the classification action returned that subtype.


==== Action method implementation

Embabel makes it easy to seamlessly integrate LLM invocation and application code, using common types.
An `@Action` method is a normal method, and can use any libraries or frameworks you like.

The only special thing about it is its ability to use the `OperationContext` parameter to access the blackboard and invoke LLMs.

==== The `@AchievesGoal` annotation

The `@AchievesGoal` annotation can be added to an `@Action` method to indicate that the completion of the action achieves a specific goal.

==== Implementing the `StuckHandler` interface

If an annotated agent class implements the `StuckHandler` interface, it can handle situations where an action is stuck itself.
For example, it can add data to the blackboard.

//TODO: (japer notes) Provide concrete examples of when StuckHandler is useful.

Example:

[source,kotlin]
----
@Agent(
    description = "self unsticking agent",
)
class SelfUnstickingAgent : StuckHandler {

    // The agent will get stuck as there's no dog to convert to a frog
    @Action
    @AchievesGoal(description = "the big goal in the sky")
    fun toFrog(dog: Dog): Frog {
        return Frog(dog.name)
    }

    // This method will be called when the agent is stuck
    override fun handleStuck(agentProcess: AgentProcess): StuckHandlerResult {
        called = true
        agentProcess.addObject(Dog("Duke"))
        return StuckHandlerResult(
            message = "Unsticking myself",
            handler = this,
            code = StuckHandlingResultCode.REPLAN,
            agentProcess = agentProcess,
        )
    }
}
----

==== Advanced Usage: Nested processes

An `@Action` method can invoke another agent process.
This is often done to use a stereotyped process that is composed using the DSL.

Use the `ActionContext.asSubProcess` method to create a sub-process from the action context.

For example:

[source,kotlin]
----
@Action
fun report(
    reportRequest: ReportRequest,
    context: ActionContext,
): ScoredResult<Report, SimpleFeedback> = context.asSubProcess(
    // Will create an agent sub process with strong typing
    EvaluatorOptimizer.generateUntilAcceptable(
        maxIterations = 5,
        generator = {
            it.promptRunner().withToolGroup(CoreToolGroups.WEB).create(
                """
        Given the topic, generate a detailed report in ${reportRequest.words} words.

        # Topic
        ${reportRequest.topic}

        # Feedback
        ${it.input ?: "No feedback provided"}
                """.trimIndent()
            )
        },
        evaluator = {
            it.promptRunner().withToolGroup(CoreToolGroups.WEB).create(
                """
        Given the topic and word count, evaluate the report and provide feedback
        Feedback must be a score between 0 and 1, where 1 is perfect.

        # Report
        ${it.input.report}

        # Report request:

        ${reportRequest.topic}
        Word count: ${reportRequest.words}
        """.trimIndent()
            )
        },
    ))
----




================================================
FILE: embabel-agent-docs/src/main/asciidoc/reference/api-evolution/page.adoc
================================================
[[reference.api-evolution]]
=== API Evolution

While Embabel is still pre-GA, we strive to avoid breaking changes.

Because Embabel builds on Spring's POJO support, framework code dependencies are localized and minimized.

The key surface area is the `Ai` and `PromptRunner` interfaces, which we will strive to avoid breaking.

For maximum stability:

- Always use the latest stable version rather than a snapshot.
Snapshots may change frequently.
- Avoid using types under the `com.embabel.agent.experimental` package.
- Avoid using any method or class marked with the `@ApiStatus.Experimental` or `@ApiStatus.Internal` annotations.

IMPORTANT: application code should not depend on any types under the `com.embabel.agent.spi` package.
This is intended for provision of runtime infrastructure only, and may change without notice.



================================================
FILE: embabel-agent-docs/src/main/asciidoc/reference/api-spi/page.adoc
================================================
[[reference.api-spi]]
=== API vs SPI

Embabel makes a clean distinction between its API and SPI.
The API is the public interface that users interact with, while the SPI (Service Provider Interface) is intended for developers who want to extend or customize the behavior of Embabel, or platform providers.

IMPORTANT: Application code should only depend on the API (com.embabel.agent.api.*) not the SPI.
The SPI is subject to change and should not be used in production code.



================================================
FILE: embabel-agent-docs/src/main/asciidoc/reference/architecture/page.adoc
================================================
[[reference.architecture]]
=== Embabel Architecture



================================================
FILE: embabel-agent-docs/src/main/asciidoc/reference/configuration/page.adoc
================================================
[[reference.configuration]]
=== Configuration

==== Enabling Embabel

Annotate your Spring Boot application class to get agentic behavior.

Example:

[source,java]
----
@SpringBootApplication
@EnableAgents(
    loggingTheme = LoggingThemes.STAR_WARS,
    localModels = { "docker" },
    mcpClients = { "docker" }
)
class MyAgentApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyAgentApplication.class, args);
    }
}
----

This is a normal Spring Boot application class.
You can add other Spring Boot annotations as needed.
`@EnableAgents` enables the agent framework.
It allows you to specify a logging theme (optional) and well-known sources of local models and MCP tools.
In this case we're using Docker as a source of local models and MCP tools.

==== Configuration Properties

The following table lists all available configuration properties in Embabel Agent Platform.
Properties are organized by their configuration prefix and include default values where applicable.
They can be set via `application.properties`, `application.yml`, profile-specific configuration files or environment variables, as per standard Spring configuration practices.

===== Setting default LLM and roles

From `ConfigurableModelProviderProperties` - configuration for default LLMs and role-based model selection.

[cols="3,2,1,4",options="header"]
|===
|Property |Type |Default |Description

|`embabel.models.default-llm`
|String
|`gpt-4.1-mini`
|Default LLM name. It's good practice to override this in configuration.

|`embabel.models.default-embedding-model`
|String
|`null`
|Default embedding model name. Need not be set, in which case it defaults to null.

|`embabel.models.llms`
|Map<String, String>
|`{}`
|Map of role to LLM name. Each entry will require an LLM to be registered with the same name. May not include the default LLM.

|`embabel.models.embedding-services`
|Map<String, String>
|`{}`
|Map of role to embedding service name. Does not need to include the default embedding service. You can create as many roles as you wish.

|===

Role-based model selection allows you to assign specific LLMs or embedding services to different roles within your application.
For example:

[source,yaml]
----
embabel:
  models:
    default-llm: gpt-4o-mini
    default-embedding-model: text-embedding-3-small
    llms:
      cheapest: gpt-4o-mini
      best: gpt-4o
      reasoning: o1-preview
    embedding-services:
      fast: text-embedding-3-small
      accurate: text-embedding-3-large
----

It's good practice to decouple your code from specific models in this way.

===== Platform Configuration

From `AgentPlatformProperties` - unified configuration for all agent platform properties.

[cols="3,2,1,4",options="header"]
|===
|Property |Type |Default |Description

|`embabel.agent.platform.name`
|String
|`embabel-default`
|Core platform identity name

|`embabel.agent.platform.description`
|String
|`Embabel Default Agent Platform`
|Platform description

|===

===== Agent Scanning

From `AgentPlatformProperties.ScanningConfig` - configures scanning of the classpath for agents.

[cols="3,2,1,4",options="header"]
|===
|Property |Type |Default |Description

|`embabel.agent.platform.scanning.annotation`
|Boolean
|`true`
|Whether to auto register beans with @Agent and @Agentic annotation

|`embabel.agent.platform.scanning.bean`
|Boolean
|`false`
|Whether to auto register as agents Spring beans of type `Agent`

|===

===== Ranking Configuration

From `AgentPlatformProperties.RankingConfig` - configures ranking of agents and goals based on user input when the platform should choose the agent or goal.

[cols="3,2,1,4",options="header"]
|===
|Property |Type |Default |Description

|`embabel.agent.platform.ranking.llm`
|String
|`null`
|Name of the LLM to use for ranking, or null to use auto selection

|`embabel.agent.platform.ranking.max-attempts`
|Int
|`5`
|Maximum number of attempts to retry ranking

|`embabel.agent.platform.ranking.backoff-millis`
|Long
|`100`
|Initial backoff time in milliseconds

|`embabel.agent.platform.ranking.backoff-multiplier`
|Double
|`5.0`
|Multiplier for backoff time

|`embabel.agent.platform.ranking.backoff-max-interval`
|Long
|`180000`
|Maximum backoff time in milliseconds

|===

===== LLM Operations

From `AgentPlatformProperties.LlmOperationsConfig` - configuration for LLM operations including prompts and data binding.

[cols="3,2,1,4",options="header"]
|===
|Property |Type |Default |Description

|`embabel.agent.platform.llm-operations.prompts.maybe-prompt-template`
|String
|`maybe_prompt_contribution`
|Template for "maybe" prompt, enabling failure result when LLM lacks information

|`embabel.agent.platform.llm-operations.prompts.generate-examples-by-default`
|Boolean
|`true`
|Whether to generate examples by default

|`embabel.agent.platform.llm-operations.data-binding.max-attempts`
|Int
|`10`
|Maximum retry attempts for data binding

|`embabel.agent.platform.llm-operations.data-binding.fixed-backoff-millis`
|Long
|`30`
|Fixed backoff time in milliseconds between retries

|===

===== Process ID Generation

From `AgentPlatformProperties.ProcessIdGenerationConfig` - configuration for process ID generation.

[cols="3,2,1,4",options="header"]
|===
|Property |Type |Default |Description

|`embabel.agent.platform.process-id-generation.include-version`
|Boolean
|`false`
|Whether to include version in process ID generation

|`embabel.agent.platform.process-id-generation.include-agent-name`
|Boolean
|`false`
|Whether to include agent name in process ID generation

|===

===== Autonomy Configuration

From `AgentPlatformProperties.AutonomyConfig` - configures thresholds for agent and goal selection.
Certainty below thresholds will result in failure to choose an agent or goal.

[cols="3,2,1,4",options="header"]
|===
|Property |Type |Default |Description

|`embabel.agent.platform.autonomy.agent-confidence-cut-off`
|Double
|`0.6`
|Confidence threshold for agent operations

|`embabel.agent.platform.autonomy.goal-confidence-cut-off`
|Double
|`0.6`
|Confidence threshold for goal achievement

|===

===== Model Provider Configuration

From `AgentPlatformProperties.ModelsConfig` - model provider integration configurations.

====== Anthropic

[cols="3,2,1,4",options="header"]
|===
|Property |Type |Default |Description

|`embabel.agent.platform.models.anthropic.max-attempts`
|Int
|`10`
|Maximum retry attempts

|`embabel.agent.platform.models.anthropic.backoff-millis`
|Long
|`5000`
|Initial backoff time in milliseconds

|`embabel.agent.platform.models.anthropic.backoff-multiplier`
|Double
|`5.0`
|Backoff multiplier

|`embabel.agent.platform.models.anthropic.backoff-max-interval`
|Long
|`180000`
|Maximum backoff interval in milliseconds

|===

====== OpenAI

[cols="3,2,1,4",options="header"]
|===
|Property |Type |Default |Description

|`embabel.agent.platform.models.openai.max-attempts`
|Int
|`10`
|Maximum retry attempts

|`embabel.agent.platform.models.openai.backoff-millis`
|Long
|`5000`
|Initial backoff time in milliseconds

|`embabel.agent.platform.models.openai.backoff-multiplier`
|Double
|`5.0`
|Backoff multiplier

|`embabel.agent.platform.models.openai.backoff-max-interval`
|Long
|`180000`
|Maximum backoff interval in milliseconds

|===

===== Server-Sent Events

From `AgentPlatformProperties.SseConfig` - server-sent events configuration.

[cols="3,2,1,4",options="header"]
|===
|Property |Type |Default |Description

|`embabel.agent.platform.sse.max-buffer-size`
|Int
|`100`
|Maximum buffer size for SSE

|`embabel.agent.platform.sse.max-process-buffers`
|Int
|`1000`
|Maximum number of process buffers

|===

===== Test Configuration

From `AgentPlatformProperties.TestConfig` - test configuration.

[cols="3,2,1,4",options="header"]
|===
|Property |Type |Default |Description

|`embabel.agent.platform.test.mock-mode`
|Boolean
|`true`
|Whether to enable mock mode for testing

|===

===== Process Repository Configuration

From `ProcessRepositoryProperties` - configuration for the agent process repository.

[cols="3,2,1,4",options="header"]
|===
|Property |Type |Default |Description

|`embabel.agent.platform.process-repository.window-size`
|Int
|`1000`
|Maximum number of agent processes to keep in memory when using default `InMemoryAgentProcessRepository`. When exceeded, oldest processes are evicted.

|===

===== Standalone LLM Configuration

====== LLM Operations Prompts

From `LlmOperationsPromptsProperties` - properties for ChatClientLlmOperations operations.

[cols="3,2,1,4",options="header"]
|===
|Property |Type |Default |Description

|`embabel.llm-operations.prompts.maybe-prompt-template`
|String
|`maybe_prompt_contribution`
|Template to use for the "maybe" prompt, which can enable a failure result if the LLM does not have enough information to create the desired output structure

|`embabel.llm-operations.prompts.generate-examples-by-default`
|Boolean
|`true`
|Whether to generate examples by default

|`embabel.llm-operations.prompts.default-timeout`
|Duration
|`60s`
|Default timeout for operations

|===

====== LLM Data Binding

From `LlmDataBindingProperties` - data binding properties with retry configuration for LLM operations.

[cols="3,2,1,4",options="header"]
|===
|Property |Type |Default |Description

|`embabel.llm-operations.data-binding.max-attempts`
|Int
|`10`
|Maximum retry attempts for data binding

|`embabel.llm-operations.data-binding.fixed-backoff-millis`
|Long
|`30`
|Fixed backoff time in milliseconds between retries

|===

===== Additional Model Providers

====== AWS Bedrock

From `BedrockProperties` - AWS Bedrock model configuration properties.

[cols="3,2,1,4",options="header"]
|===
|Property |Type |Default |Description

|`embabel.models.bedrock.models`
|List
|`[]`
|List of Bedrock models to configure

|`embabel.models.bedrock.models[].name`
|String
|`""`
|Model name

|`embabel.models.bedrock.models[].knowledge-cutoff`
|String
|`""`
|Knowledge cutoff date

|`embabel.models.bedrock.models[].input-price`
|Double
|`0.0`
|Input token price

|`embabel.models.bedrock.models[].output-price`
|Double
|`0.0`
|Output token price

|===

====== Docker Local Models

From `DockerProperties` - configuration for Docker local models (OpenAI-compatible).

[cols="3,2,1,4",options="header"]
|===
|Property |Type |Default |Description

|`embabel.docker.models.base-url`
|String
|`http://localhost:12434/engines`
|Base URL for Docker model endpoint

|`embabel.docker.models.max-attempts`
|Int
|`10`
|Maximum retry attempts

|`embabel.docker.models.backoff-millis`
|Long
|`2000`
|Initial backoff time in milliseconds

|`embabel.docker.models.backoff-multiplier`
|Double
|`5.0`
|Backoff multiplier

|`embabel.docker.models.backoff-max-interval`
|Long
|`180000`
|Maximum backoff interval in milliseconds

|===

===== Migration Support

From `DeprecatedPropertyScanningConfig` and `DeprecatedPropertyWarningConfig` - configuration for migrating from older versions of Embabel.

NOTE: These properties will be removed before Embabel 1.0.0 release.

[cols="3,2,1,4",options="header"]
|===
|Property |Type |Default |Description

|`embabel.agent.platform.migration.scanning.enabled`
|Boolean
|`false`
|Whether deprecated property scanning is enabled (disabled by default for production safety)

|`embabel.agent.platform.migration.scanning.include-packages`
|List<String>
|`["com.embabel.agent", "com.embabel.agent.shell"]`
|Base packages to scan for deprecated conditional annotations

|`embabel.agent.platform.migration.scanning.exclude-packages`
|List<String>
|Extensive default list
|Package prefixes to exclude from scanning

|`embabel.agent.platform.migration.scanning.additional-excludes`
|List<String>
|`[]`
|Additional user-specific packages to exclude

|`embabel.agent.platform.migration.scanning.auto-exclude-jar-packages`
|Boolean
|`false`
|Whether to automatically exclude JAR-based packages using classpath detection

|`embabel.agent.platform.migration.scanning.max-scan-depth`
|Int
|`10`
|Maximum depth for package scanning

|`embabel.agent.platform.migration.warnings.individual-logging`
|Boolean
|`true`
|Whether to enable individual warning logging. When false, only aggregated summary is logged

|===




================================================
FILE: embabel-agent-docs/src/main/asciidoc/reference/customizing/page.adoc
================================================
[[reference.customizing]]
=== Customizing Embabel

==== Adding LLMs

You can add custom LLMs as Spring beans of type `Llm`.

Llms are created around Spring AI `ChatModel` instances.

A common requirement is to add an open AI compatible LLM.
This can be done by extending the `OpenAiCompatibleModelFactory` class as follows:

[source,kotlin]
----
@Configuration
class CustomOpenAiCompatibleModels(
    @Value("\${MY_BASE_URL:#{null}}")
    baseUrl: String?,
    @Value("\${MY_API_KEY}")
    apiKey: String,
    observationRegistry: ObservationRegistry,
) : OpenAiCompatibleModelFactory(baseUrl = baseUrl, apiKey = apiKey, observationRegistry = observationRegistry) {

    @Bean
    fun myGreatModel(): Llm {
        // Call superclass method
        return openAiCompatibleLlm(
            model = "my-great-model",
            provider = "me",
            knowledgeCutoffDate = LocalDate.of(2025, 1, 1),
            pricingModel = PerTokenPricingModel(
                usdPer1mInputTokens = .40,
                usdPer1mOutputTokens = 1.6,
            )
        )
    }
}
----

==== Adding embedding models

Embedding models can also be added as beans of type `EmbeddingService`.

==== Configuration via `application.properties` or `application.yml`

You can specify Spring configuration, your own configuration and Embabel configuration in the regular Spring configuration files.
Profile usage will work as expected.

==== Customizing logging

You can customize logging as in any Spring application.

For example, in `application.properties` you can set properties like:

[source,properties]
----
logging.level.com.embabel.agent.a2a=DEBUG
----

You can also configure logging via a `logback-spring.xml` file if you have more sophisticated requirements.

See the https://docs.spring.io/spring-boot/reference/features/logging.html[Spring Boot Logging] reference.

By default, many Embabel examples use personality-based logging experiences such as Star Wars.
You can disable this via the `@EnableAgents` annotation on your main application class:

[source,java]
----
@SpringBootApplication
@ConfigurationPropertiesScan
@EnableAgents(
        loggingTheme = LoggingThemes.STAR_WARS
)
class MyAwesomeApplication {
    public static void main(String[] args) {
        SpringApplication.run(GuideApplication.class, args);
    }
}
----

Remove the `loggingTheme` attribute to disable personality-based logging.

As all logging results from listening to events via an `AgenticEventListener`, you can also easily create your own customized logging.





================================================
FILE: embabel-agent-docs/src/main/asciidoc/reference/domain/page.adoc
================================================
[[reference.domain]]
=== Domain Objects

Domain objects in Embabel are not just strongly-typed data structures - they are real objects with behavior that can be selectively exposed to LLMs and used in agent actions.

==== Objects with Behavior

Unlike simple structs or DTOs, Embabel domain objects can encapsulate business logic and expose it to LLMs through the `@Tool` annotation:

[source,java]
----
@Entity
public class Customer {
    private String name;
    private LoyaltyLevel loyaltyLevel;
    private List<Order> orders;

    @Tool(description = "Calculate the customer's loyalty discount percentage")
    public BigDecimal getLoyaltyDiscount() {
        return loyaltyLevel.calculateDiscount(orders.size());
    }

    @Tool(description = "Check if customer is eligible for premium service")
    public boolean isPremiumEligible() {
        return orders.stream()
            .mapToDouble(Order::getTotal)
            .sum() > 1000.0;
    }

    // Regular methods not exposed to LLMs
    private void updateLoyaltyLevel() {
        // Internal business logic
    }
}
----

==== Selective Tool Exposure

The `@Tool` annotation allows you to selectively expose domain object methods to LLMs:

- **Business Logic**: Expose methods that provide business value to the LLM
- **Calculated Properties**: Methods that compute derived values
- **Business Rules**: Methods that implement domain-specific rules
- **Keep Private**: Internal implementation details remain hidden

==== Use in Actions

Domain objects can be used naturally in action methods, combining LLM interactions with traditional object-oriented programming:

[source,java]
----
@Action
public Recommendation generateRecommendation(Customer customer, OperationContext context) {
    // LLM has access to customer.getLoyaltyDiscount() and customer.isPremiumEligible()
    // as tools, plus the customer object structure

    String prompt = String.format(
        "Generate a personalized recommendation for %s based on their profile",
        customer.getName()
    );

    return context.ai()
        .withDefaultLlm()
        .createObject(prompt, Recommendation.class);
}
----

==== Domain Understanding is Critical

As outlined in Rod Johnson's blog introducing DICE (Domain-Integrated Context Engineering) in https://medium.com/@springrod/context-engineering-needs-domain-understanding-b4387e8e4bf8[Context Engineering Needs Domain Understanding], domain understanding is fundamental to effective context engineering.
Domain objects serve as the bridge between:

- **Business Domain**: Real-world entities and their relationships
- **Agent Behavior**: How LLMs understand and interact with the domain
- **Code Actions**: Traditional programming logic that operates on domain objects

==== Benefits

- **Rich Context**: LLMs receive both data structure and behavioral context
- **Encapsulation**: Business logic stays within domain objects where it belongs
- **Reusability**: Domain objects can be used across multiple agents
- **Testability**: Domain logic can be unit tested independently
- **Evolution**: Adding new tools to domain objects extends agent capabilities

This approach ensures that agents work with meaningful business entities rather than generic data structures, leading to more natural and effective AI interactions.



================================================
FILE: embabel-agent-docs/src/main/asciidoc/reference/dsl/page.adoc
================================================
[[reference.dsl]]
=== DSL

You can also create agents using a DSL in Kotlin or Java.

This is useful for workflows where you want an atomic action that is complete in itself but may contain multiple steps or actions.

==== Standard Workflows

There are a number of standard workflows, constructed by builders, that meet common requirements.
These can be used to create agents that will be exposed as Spring beans, or within `@Action` methods within other agents.
All are type safe.
As far as possible, they use consistent APIs.

- `SimpleAgentBuilder`: The simplest agent, with no preconditions or postconditions.
- `ScatterGatherBuilder`: Fork join pattern for parallel processing.
- `ConsensusBuilder`: A pattern for reaching consensus among multiple sources.
Specialization of `ScatterGather`.
- `RepeatUntil`: Repeats a step until a condition is met.
- `RepeatUntilAcceptable`: Repeats a step while a condition is met, with a separate evaluator providing feedback.

Creating a simple agent:

[source,java]
----
var agent = SimpleAgentBuilder
    .returning(Joke.class) // <1>
    .running(tac -> tac.ai() // <2>
        .withDefaultLlm()
        .createObject("Tell me a joke", Joke.class))
    .buildAgent("joker", "This is guaranteed to return a dreadful joke"); // <3>
----

<1> Specify the return type.
<2> specify the action to run.
Takes a `SupplierActionContext<RESULT>` `OperationContext` parameter allowing access to the current `AgentProcess`.
<3> Build an agent with the given name and description.

A more complex example:

[source,java]
----
@Action
FactChecks runAndConsolidateFactChecks(
        DistinctFactualAssertions distinctFactualAssertions,
        ActionContext context) {
    var llmFactChecks = properties.models().stream()
            .flatMap(model -> factCheckWithSingleLlm(model, distinctFactualAssertions, context))
            .toList();
    return ScatterGatherBuilder // <1>
            .returning(FactChecks.class) // <2>
            .fromElements(FactCheck.class) // <3>
            .generatedBy(llmFactChecks) // <4>
            .consolidatedBy(this::reconcileFactChecks) // <5>
            .asSubProcess(context); // <6>
    }
----

<1> Start building a scatter gather agent.
<2> Specify the return type of the overall agent.
<3> Specify the type of elements to be gathered.
<4> Specify the list of functions to run in parallel, each generating an element, here of type `FactCheck`.
<5> Specify a function to consolidate the results.
In this case it will take a list of `FactCheck` and return a `FactCheck` and return a `FactChecks` object.
<6> Build and run the agent as a subprocess of the current process.
This is an alternative to `asAgent` shown in the `SimpleAgentBuilder` example.
The API is consistent.

NOTE: If you wish to experiment, the https://github.com/embabel/embabel-agent-examples[embabel-agent-examples] repository includes the https://github.com/embabel/embabel-agent-examples/blob/main/examples-java/src/main/java/com/embabel/example/factchecker/FactChecker.java[fact checker] shown above.


==== Registering `Agent` beans

Whereas the `@Agent` annotation causes a class to be picked up immediately by Spring, with the DSL you'll need an extra step to register an agent with Spring. As shown in the example below, any `@Bean` of `Agent` type results auto registration, just like declaring a class annotated with `@Agent` does.

[source,kotlin]
----
@Configuration
class FactCheckerAgentConfiguration {

    @Bean
    fun factChecker(factCheckerProperties: FactCheckerProperties): Agent {
        return factCheckerAgent(
            llms = listOf(
                LlmOptions(AnthropicModels.CLAUDE_35_HAIKU).withTemperature(.3),
                LlmOptions(AnthropicModels.CLAUDE_35_HAIKU).withTemperature(.0),
            ),
            properties = factCheckerProperties,
        )
    }
}
----



================================================
FILE: embabel-agent-docs/src/main/asciidoc/reference/flow/page.adoc
================================================
[[reference.flow]]
=== Invoking an Agent

Agents can be invoked programmatically or via user input.

See <<reference.invoking, Invoking Embabel Agents>> for details on programmatic invocation.
Programmatic invocation typically involves structured types other than user input.

In the case of user input, an LLM will choose the appropriate agent via the `Autonomy` class.
Behavior varies depending on configuration:

- In closed mode, the LLM will select the agent based on the user input and the available agents in the system.
- In open mode, the LLM will select the goal based on the user input and then assemble an agent that can achieve that goal from the present world state.

=== Agent Process Flow

When an agent is invoked, Embabel creates an `AgentProcess` with a unique identifier that manages the complete execution lifecycle.

==== AgentProcess Lifecycle

An `AgentProcess` maintains state throughout its execution and can transition between various states:

**Process States:**

- `NOT_STARTED`: The process has not started yet
- `RUNNING`: The process is executing without any known problems
- `COMPLETED`: The process has completed successfully
- `FAILED`: The process has failed and cannot continue
- `TERMINATED`: The process was killed by an early termination policy
- `KILLED`: The process was killed by the user or platform
- `STUCK`: The process cannot formulate a plan to progress (may be temporary)
- `WAITING`: The process is waiting for user input or external event
- `PAUSED`: The process has paused due to scheduling policy

**Process Execution Methods:**

- `tick()`: Perform the next single step and return when an action completes
- `run()`: Execute the process as far as possible until completion, failure, or a waiting state

These methods are not directly called by user code, but are managed by the framework to control execution flow.

Each `AgentProcess` maintains:

- **Unique ID**: Persistent identifier for tracking and reference
- **History**: Record of all executed actions with timing information
- **Goal**: The objective the process is trying to achieve
- **Failure Info**: Details about any failure that occurred
- **Parent ID**: Reference to parent process for nested executions

==== Planning

Planning occurs after each action execution using Goal-Oriented Action Planning (GOAP).
The planning process:

1. **Analyze Current State**: Examine the current blackboard contents and world state
2. **Identify Available Actions**: Find all actions that can be executed based on their preconditions
3. **Search for Action Sequences**: Use A* algorithm to find optimal paths to achieve the goal
4. **Select Optimal Plan**: Choose the best action sequence based on cost and success probability
5. **Execute Next Action**: Run the first action in the plan and replan

This creates a dynamic **OODA loop** (Observe-Orient-Decide-Act):
- **Observe**: Check current blackboard state and action results - **Orient**: Understand what has changed since the last planning cycle - **Decide**: Formulate or update the plan based on new information - **Act**: Execute the next planned action

//TODO: (jasper notes) A diagram showing two ticks() in an ooda loop might be helpful here?

The replanning approach allows agents to:

- Adapt to unexpected action results
- Handle dynamic environments where conditions change
- Recover from partial failures
- Take advantage of new opportunities that arise

//TODO: (jasper notes) Diagram showing a dead-end and replanning would be helpful here.


==== Blackboard

The Blackboard serves as the shared memory system that maintains state throughout the agent process execution.
It implements the https://en.wikipedia.org/wiki/Blackboard_(design_pattern)[Blackboard architectural pattern], a knowledge-based system approach.

Most of the time, user code doesn't need to interact with the blackboard directly, as it is managed by the framework.
For example, action inputs come from the blackboard, and action outputs are automatically added to the blackboard, and conditions are evaluated based on its contents.

**Key Characteristics:**

- **Central Repository**: Stores all domain objects, intermediate results, and process state
- **Type-Based Access**: Objects are indexed and retrieved by their types
- **Ordered Storage**: Objects maintain the order they were added, with latest being default
- **Immutable Objects**: Once added, objects cannot be modified (new versions can be added)
- **Condition Tracking**: Maintains boolean conditions used by the planning system

**Core Operations:**

[source,kotlin]
----
// Add objects to blackboard <1>
blackboard += person
blackboard["result"] = analysis

// Retrieve objects by type
val person = blackboard.last<Person>()
val allPersons = blackboard.all<Person>()

// Check conditions
blackboard.setCondition("userVerified", true)
val verified = blackboard.getCondition("userVerified") // <2>

// Hide an object
blackboard.hide(somethingWeDontWantToPlanOnLater) // <3>
----

<1> **Adding Objects**: Objects are added to the blackboard automatically when returned from action methods, so you don't typically need to call this API. They can also be added manually using the `+=` operator (Kotlin only) or `set` method with an optional key.
<2> **Conditions**: Conditions are normally calculated in `@Condition` methods, so you don't usually need to check or set them via the API.
<3> **Hiding Objects**: Prevents an object from being considered in future planning cycles. For example, the object might be a command that we have handled. It will remain in the blackboard history but will not be available to planning or via the Blackboard API.

**Data Flow:**

1. **Input Processing**: Initial user input is added to the blackboard
2. **Action Execution**: Each action reads inputs from blackboard and adds results
3. **State Evolution**: Blackboard accumulates objects representing the evolving state
4. **Planning Input**: Current blackboard state informs the next planning cycle
5. **Result Extraction**: Final results are retrieved from blackboard upon completion

The blackboard enables:

- **Loose Coupling**: Actions don't need direct references to each other
- **Flexible Data Flow**: Actions can consume any available data of the right type
- **State Persistence**: Complete execution history is maintained
- **Debugging Support**: Full visibility into state evolution for troubleshooting

[[reference.flow__binding]]
==== Binding

By default items in the blackboard are matched by type.
When there are multiple candidates the most recent one is provided.
It is also possible to assign a keyed name to blackboard items.
Example:

[source,java]
----
@Action
public Person extractPerson(UserInput userInput, OperationContext context) {
    PersonImpl maybeAPerson = context.promptRunner().withLlm(LlmOptions.fromModel(OpenAiModels.GPT_41)).createObjectIfPossible(
            """
            Create a person from this user input, extracting their name:
            %s""".formatted(userInput.getContent()),
            PersonImpl.class
    );
    if (maybeAPerson != null) {
        context.bind("user", maybeAPerson);
    }
    return maybeAPerson;
}
----

TIP: When routing flows by type, the name is not important, but for reference the default name is 'it'.

==== Context

Embabel offers a way to store longer term state: the `com.embabel.agent.core.Context`.
While a blackboard is tied to a specific agent process, a context can persist across multiple processes.

Contexts are identified by a unique `contextId` string.
When starting an agent process, you can specify a `contextId` in the `ProcessOptions`.
This will populate that process's blackboard with any data stored in the specified context.

NOTE: Context persistence is dependent on the implementation of `com.embabel.agent.spi.ContextRepository`.
The default implementation works only in memory, so does not survive server restarts.



================================================
FILE: embabel-agent-docs/src/main/asciidoc/reference/integrations/page.adoc
================================================

[[reference.integrations]]
=== Integrations

[[reference.integrations__mcp]]
==== Model Context Protocol (MCP)

===== Publishing

====== Overview

Embabel Agent can expose your agents as MCP servers, making them available to external MCP clients such as Claude Desktop, VS Code extensions, or other MCP-compatible applications. The framework provides automatic publishing of agent goals as tools and prompts without requiring manual configuration.

====== Server Configuration

Configure MCP server functionality in your `application.yml`. The server type determines the execution mode:

[source,yaml]
----
spring:
  ai:
    mcp:
      server:
        type: SYNC  # or ASYNC
----

====== Server Types

Embabel Agent supports two MCP server execution modes controlled by the `spring.ai.mcp.server.type` property:

**SYNC Mode** (Default)::
- Blocking operations wrapped in reactive streams
- Simpler to develop and debug
- Suitable for most use cases
- Better error handling and logging

[source,yaml]
----
spring:
  ai:
    mcp:
      server:
        type: SYNC
----

**ASYNC Mode**::
- True non-blocking reactive operations
- Higher throughput for concurrent requests
- More complex error handling
- Suitable for high-performance scenarios

[source,yaml]
----
spring:
  ai:
    mcp:
      server:
        type: ASYNC
----

====== Automatic Publishing

**Tools**::
Agent goals are automatically published as MCP tools when annotated with `@Export(remote = true)`. The `PerGoalMcpToolExportCallbackPublisher` automatically discovers and exposes these goals without any additional configuration.

**Prompts**::
Prompts are automatically generated for each goal's starting input types through the `PerGoalStartingInputTypesPromptPublisher`. This provides ready-to-use prompt templates based on your agent definitions.

====== Exposing Agent Goals as Tools

Agent goals become MCP tools automatically when annotated with `@Export`:

[source,java]
----
@Agent(
    goal = "Provide weather information",
    backstory = "Weather service agent"
)
public class WeatherAgent {
    
    @Goal
    @Export(remote = true)  // Automatically becomes MCP tool
    public String getWeather(
        @Param("location") String location,
        @Param("units") String units
    ) {
        return "Weather for " + location + " in " + units;
    }
    
    @Goal
    public String internalMethod() {
        // Not exposed to MCP (no @Export annotation)
        return "Internal use only";
    }
}
----

====== Server Architecture

The MCP server implementation uses several design patterns:

**Template Method Pattern**::
- `AbstractMcpServerConfiguration` provides common initialization logic
- Concrete implementations (`McpSyncServerConfiguration`, `McpAsyncServerConfiguration`) handle mode-specific details

**Strategy Pattern**::
- Server strategies abstract sync vs async operations
- Mode-specific implementations handle tool, resource, and prompt management

**Publisher Pattern**::
- Tools, resources, and prompts are discovered through publisher interfaces
- Automatic registration and lifecycle management
- Event-driven initialization ensures proper timing

====== Built-in Tools

Every MCP server includes a built-in `helloBanner` tool that displays server information:

[source,json]
----
{
  "type": "banner",
  "mode": "SYNC",
  "lines": [
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
    "Embabel Agent MCP SYNC Server",
    "Version: 0.1.4-SNAPSHOT",
    "Java: 21.0.2+13-LTS-58",
    "Started: 2025-01-17T14:23:47.785Z",
    "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  ]
}
----


[[reference.integrations__a2a]]
==== A2A




================================================
FILE: embabel-agent-docs/src/main/asciidoc/reference/invoking/page.adoc
================================================
[[reference.invoking]]
=== Invoking Embabel Agents

While many examples show Embabel agents being invoked via `UserInput` through the Embabel shell, they can also be invoked programmatically with strong typing.

This is usually how they're used in web applications.
It is also the most deterministic approach as code, rather than LLM assessment of user input, determines which agent is invoked and how.

==== Creating an AgentProcess Programmatically

You can create and execute agent processes directly using the `AgentPlatform`:

[source,kotlin]
----
// Create an agent process with bindings
val agentProcess = agentPlatform.createAgentProcess(
    agent = myAgent,
    processOptions = ProcessOptions(),
    bindings = mapOf("input" to userRequest)
)

// Start the process and wait for completion
val result = agentPlatform.start(agentProcess).get()

// Or run synchronously
val completedProcess = agentProcess.run()
val result = completedProcess.last<MyResultType>()
----

You can create processes and populate their input map from varargs objects:

[source,kotlin]
----
// Create process from objects (like in web controllers)
val agentProcess = agentPlatform.createAgentProcessFrom(
    agent = travelAgent,
    processOptions = ProcessOptions(),
    travelRequest,
    userPreferences
)
----

==== Using AgentInvocation

`AgentInvocation` provides a higher-level, type-safe API for invoking agents.
It automatically finds the appropriate agent based on the expected result type.

===== Basic Usage

[tabs]
====
Java::
+
[source,java]
----
// Simple invocation with explicit result type
var invocation =
    AgentInvocation.create(agentPlatform, TravelPlan.class);

TravelPlan plan = invocation.invoke(travelRequest);
----

Kotlin::
+
[source,kotlin]
----
// Type-safe invocation with inferred result type
val invocation: AgentInvocation<TravelPlan> =
    AgentInvocation.create(agentPlatform)

val plan = invocation.invoke(travelRequest)
----
====

===== Invocation with Named Inputs

[source,java]
----
// Invoke with a map of named inputs
Map<String, Object> inputs = Map.of(
    "request", travelRequest,
    "preferences", userPreferences
);

TravelPlan plan = invocation.invoke(inputs);
----

===== Custom Process Options

Configure verbosity, budget, and other execution options:

[tabs]
====
Java::
+
[source,java]
----
var invocation =
    AgentInvocation.builder(agentPlatform)
        .options(options -> options
            .verbosity(verbosity -> verbosity
                .showPrompts(true)
                .showResponses(true)
                .debug(true)))
        .build(TravelPlan.class);

TravelPlan plan = invocation.invoke(travelRequest);
----

Kotlin::
+
[source,kotlin]
----
val processOptions = ProcessOptions(
    verbosity = Verbosity(
        showPrompts = true,
        showResponses = true,
        debug = true
    )
)

val invocation: AgentInvocation<TravelPlan> =
    AgentInvocation.builder(agentPlatform)
        .options(processOptions)
        .build()

val plan = invocation.invoke(travelRequest)
----
====

===== Asynchronous Invocation

For long-running operations, use async invocation:

[source,java]
----
CompletableFuture<TravelPlan> future = invocation.invokeAsync(travelRequest);

// Handle result when complete
future.thenAccept(plan -> {
    logger.info("Travel plan generated: {}", plan);
});

// Or wait for completion
TravelPlan plan = future.get();
----

===== Agent Selection

`AgentInvocation` automatically finds agents by examining their goals:

- Searches all registered agents in the platform
- Finds agents with goals that produce the requested result type
- Uses the first matching agent found
- Throws an error if no suitable agent is available

===== Real-World Web Application Example

Here's how `AgentInvocation` is used in the http://github.com/embabel/tripper[Tripper travel planning application] with htmx for asynchronous UI updates:

[source,kotlin]
----
@Controller
class TripPlanningController(
    private val agentPlatform: AgentPlatform
) {

    private val activeJobs = ConcurrentHashMap<String, CompletableFuture<TripPlan>>()

    @PostMapping("/plan-trip")
    fun planTrip(
        @ModelAttribute tripRequest: TripRequest,
        model: Model
    ): String {
        // Generate unique job ID for tracking
        val jobId = UUID.randomUUID().toString()

        // Create agent invocation with custom options
        val invocation: AgentInvocation<TripPlan> = AgentInvocation.builder(agentPlatform)
            .options { options ->
                options.verbosity { verbosity ->
                    verbosity.showPrompts(true)
                        .showResponses(false)
                        .debug(false)
                }
            }
            .build()

        // Start async agent execution
        val future = invocation.invokeAsync(tripRequest)
        activeJobs[jobId] = future

        // Set up completion handler
        future.whenComplete { result, throwable ->
            if (throwable != null) {
                logger.error("Trip planning failed for job $jobId", throwable)
            } else {
                logger.info("Trip planning completed for job $jobId")
            }
        }

        model.addAttribute("jobId", jobId)
        model.addAttribute("tripRequest", tripRequest)

        // Return htmx template that will poll for results
        return "trip-planning-progress"
    }

    @GetMapping("/trip-status/{jobId}")
    @ResponseBody
    fun getTripStatus(@PathVariable jobId: String): ResponseEntity<Map<String, Any>> {
        val future = activeJobs[jobId]
            ?: return ResponseEntity.notFound().build()

        return when {
            future.isDone -> {
                try {
                    val tripPlan = future.get()
                    activeJobs.remove(jobId)

                    ResponseEntity.ok(mapOf(
                        "status" to "completed",
                        "result" to tripPlan,
                        "redirect" to "/trip-result/$jobId"
                    ))
                } catch (e: Exception) {
                    activeJobs.remove(jobId)
                    ResponseEntity.ok(mapOf(
                        "status" to "failed",
                        "error" to e.message
                    ))
                }
            }
            future.isCancelled -> {
                activeJobs.remove(jobId)
                ResponseEntity.ok(mapOf("status" to "cancelled"))
            }
            else -> {
                ResponseEntity.ok(mapOf(
                    "status" to "in_progress",
                    "message" to "Planning your amazing trip..."
                ))
            }
        }
    }

    @GetMapping("/trip-result/{jobId}")
    fun showTripResult(
        @PathVariable jobId: String,
        model: Model
    ): String {
        // Retrieve completed result from cache or database
        val tripPlan = tripResultCache[jobId]
            ?: return "redirect:/error"

        model.addAttribute("tripPlan", tripPlan)
        return "trip-result"
    }

    @DeleteMapping("/cancel-trip/{jobId}")
    @ResponseBody
    fun cancelTrip(@PathVariable jobId: String): ResponseEntity<Map<String, String>> {
        val future = activeJobs[jobId]

        return if (future != null && !future.isDone) {
            future.cancel(true)
            activeJobs.remove(jobId)
            ResponseEntity.ok(mapOf("status" to "cancelled"))
        } else {
            ResponseEntity.badRequest()
                .body(mapOf("error" to "Job not found or already completed"))
        }
    }

    companion object {
        private val logger = LoggerFactory.getLogger(TripPlanningController::class.java)
        private val tripResultCache = ConcurrentHashMap<String, TripPlan>()
    }
}
----

**Key Patterns:**

- **Async Execution**: Uses `invokeAsync()` to avoid blocking the web request
- **Job Tracking**: Maintains a map of active futures for status polling
- **htmx Integration**: Returns status updates that htmx can consume for UI updates
- **Error Handling**: Proper exception handling and user feedback
- **Resource Cleanup**: Removes completed jobs from memory
- **Process Options**: Configures verbosity and debugging for production use

IMPORTANT: Agents can also be exposed as <<reference.integrations__mcp, MCP>> servers and consumed from tools like Claude Desktop.



================================================
FILE: embabel-agent-docs/src/main/asciidoc/reference/llms/page.adoc
================================================
[[reference.llms]]
=== Working with LLMs

Embabel supports any LLM supported by Spring AI.
In practice, this is just about any LLM.

==== Choosing an LLM

Embabel encourages you to think about LLM choice for every LLM invocation.
The `PromptRunner` interface makes this easy.
Because Embabel enables you to break agentic flows up into multiple action steps, each step can use a smaller, focused prompt with fewer tools.
This means it may be able to use a smaller LLM.

Considerations:

- **Consider the complexity of the return type you expect** from the LLM.
This is typically a good proxy for determining required LLM quality.
A small LLM is likely to struggle with a deeply nested return structure.
- **Consider the nature of the task.** LLMs have different strengths; review any available documentation.
You don't necessarily need a huge, expensive model that is good at nearly everything, at the cost of your wallet and the environment.
- **Consider the sophistication of tool calling required**.
Simple tool calls are fine, but complex orchestration is another indicator you'll need a strong LLM.
(It may also be an indication that you should create a more sophisticated flow using Embabel GOAP.)
- **Consider trying a local LLM** running under Ollama or Docker.

TIP: Trial and error is your friend.
Embabel makes it easy to switch LLMs; try the cheapest thing that could work and switch if it doesn't.





================================================
FILE: embabel-agent-docs/src/main/asciidoc/reference/migrating/page.adoc
================================================
[[reference.migrating]]
=== Migrating from other frameworks

Many people start their journey with Python frameworks.

This section covers how to migrate from popular frameworks when it's time to use a more robust and secure platform with access to existing code and services.

==== Migrating from CrewAI

CrewAI uses a collaborative multi-agent approach where agents work together on tasks.
Embabel provides similar capabilities with stronger type safety and better integration with existing Java/Kotlin codebases.

===== Core Concept Mapping

[cols="2,2,1",options="header"]
|===
|CrewAI Concept |Embabel Equivalent |Notes

|**Agent Role/Goal/Backstory**
|`RoleGoalBackstory` PromptContributor
|Convenience class for agent personality

|**Sequential Tasks**
|Typed data flow between actions
|Type-driven execution with automatic planning

|**Crew (Multi-agent coordination)**
|Actions with shared PromptContributors
|Agents can adopt personalities as needed

|**YAML Configuration**
|Standard Spring `@ConfigurationProperties` backed by `application.yml` or profile-specific configuration files
|Type-safe configuration with validation
|===

===== Migration Example

**CrewAI Pattern:**

```python
research_agent = Agent(
    role='Research Specialist',
    goal='Find comprehensive information',
    backstory='Expert researcher with 10+ years experience'
)

writer_agent = Agent(
    role='Content Writer', 
    goal='Create engaging content',
    backstory='Professional writer specializing in technical content'
)

crew = Crew(
    agents=[research_agent, writer_agent],
    tasks=[research_task, write_task],
    process=Process.sequential
)
```

**Embabel Equivalent:**

```java
@ConfigurationProperties("examples.book-writer")
record BookWriterConfig(
    LlmOptions researcherLlm,
    LlmOptions writerLlm,
    RoleGoalBackstory researcher,
    RoleGoalBackstory writer
) {}

@Agent(description = "Write a book by researching, outlining, and writing chapters")
public record BookWriter(BookWriterConfig config) {

    @Action
    ResearchReport researchTopic(BookRequest request, OperationContext context) {
        return context.ai()
            .withLlm(config.researcherLlm())
            .withPromptElements(config.researcher(), request)
            .withToolGroup(CoreToolGroups.WEB)
            .createObject("Research the topic thoroughly...", ResearchReport.class);
    }

    @Action
    BookOutline createOutline(BookRequest request, ResearchReport research, OperationContext context) {
        return context.ai()
            .withLlm(config.writerLlm())
            .withPromptElements(config.writer(), request, research)
            .createObject("Create a book outline...", BookOutline.class);
    }

    @AchievesGoal(export = @Export(remote = true))
    @Action
    Book writeBook(BookRequest request, BookOutline outline, OperationContext context) {
        // Parallel chapter writing with crew-like coordination
        var chapters = context.parallelMap(outline.chapterOutlines(), 
            config.maxConcurrency(),
            chapterOutline -> writeChapter(request, outline, chapterOutline, context));
        return new Book(request, outline.title(), chapters);
    }
}
```

**Key Advantages:**

- **Type Safety**: Compile-time validation of data flow
- **Spring Integration**: Leverage existing enterprise infrastructure
- **Automatic Planning**: GOAP planner handles task sequencing, and is capable of more sophisticated planning
- **Tool Integration with the JVM**: Native access to existing Java/Kotlin services

==== Migrating from Pydantic AI

Pydantic AI provides a Python framework for building AI agents with type safety and validation.
Embabel offers similar capabilities in the JVM ecosystem with stronger integration into enterprise environments.

===== Core Concept Mapping

[cols="2,2,1",options="header"]
|===
|Pydantic AI Concept |Embabel Equivalent |Notes

|**@system_prompt decorator**
|PromptContributor classes
|More flexible and composable prompt management

|**@tool decorator**
|Equivalent `@Tool` annotated methods can be included on agent classes and domain objects

|**Agent class**
|`@Agent` annotated record/class
|Declarative agent definition with Spring integration

|**RunContext**
|Blackboard state, accessible via `OperationContext` but normally not a concern for user code

|**SystemPrompt**
|Custom `PromptContributor`
|Structured prompt contribution system

|**deps parameter**
|Spring dependency injection
|===

===== Migration Example

**Pydantic AI Pattern:**

```python
# Based on https://ai.pydantic.dev/examples/bank-support/
from pydantic_ai import Agent, RunContext
from pydantic_ai.tools import tool

@system_prompt  
def support_prompt() -> str:
    return "You are a support agent in our bank"

@tool
async def get_customer_balance(customer_id: int, include_pending: bool = False) -> float:
    # Database lookup
    customer = find_customer(customer_id)
    return customer.balance + (customer.pending if include_pending else 0)

agent = Agent(
    'openai:gpt-4-mini',
    system_prompt=support_prompt,
    tools=[get_customer_balance],
)

result = agent.run("What's my balance?", deps={'customer_id': 123})
```

**Embabel Equivalent:**

```java
// From embabel-agent-examples/examples-java/src/main/java/com/embabel/example/pydantic/banksupport/SupportAgent.java

record Customer(Long id, String name, float balance, float pendingAmount) {
    
    @Tool(description = "Find the balance of a customer by id")
    float balance(boolean includePending) {
        return includePending ? balance + pendingAmount : balance;
    }
}

record SupportInput(
    @JsonPropertyDescription("Customer ID") Long customerId,
    @JsonPropertyDescription("Query from the customer") String query) {
}

record SupportOutput(
    @JsonPropertyDescription("Advice returned to the customer") String advice,
    @JsonPropertyDescription("Whether to block their card or not") boolean blockCard,
    @JsonPropertyDescription("Risk level of query") int risk) {
}

@Agent(description = "Customer support agent")
record SupportAgent(CustomerRepository customerRepository) {

    @AchievesGoal(description = "Help bank customer with their query")
    @Action
    SupportOutput supportCustomer(SupportInput supportInput, OperationContext context) {
        var customer = customerRepository.findById(supportInput.customerId());
        if (customer == null) {
            return new SupportOutput("Customer not found with this id", false, 0);
        }
        return context.ai()
            .withLlm(OpenAiModels.GPT_41_MINI)
            .withToolObject(customer)
            .createObject(
                """
                You are a support agent in our bank, give the
                customer support and judge the risk level of their query.
                In some cases, you may need to block their card. In this case, explain why.
                Reply using the customer's name, "%s".
                Currencies are in $.
                
                Their query: [%s]
                """.formatted(customer.name(), supportInput.query()),
                SupportOutput.class);
    }
}
```

**Key Advantages:**

- **Enterprise Integration**: Native Spring Boot integration with existing services
- **Compile-time Safety**: Strong typing catches errors at build time
- **Automatic Planning**: GOAP planner handles complex multi-step operations
- **JVM Ecosystem**: Access to mature libraries and enterprise infrastructure

==== Migrating from LangGraph

tbd

==== Migrating from Google ADK

tbd


================================================
FILE: embabel-agent-docs/src/main/asciidoc/reference/prompt-contributors/page.adoc
================================================
[[reference.prompt-contributors]]
=== Structured Prompt Elements

Embabel provides a number of ways to structure and manage prompt content.

**Prompt contributors** are a fundamental way to structure and inject content into LLM prompts.
You don't need to use them--you can simply build your prompts as strings--but they can be useful to achieve consistency and reuse across multiple actions or even across multiple agents using the same domain objects.

Prompt contributors implement the `PromptContributor` interface and provide text that gets included in the final prompt sent to the LLM.
By default the text will be included in the system prompt message.

//TODO: (jasper notes) A diagram here showing a prompt and the injection of the contribution(s)

==== The `PromptContributor` Interface and `LlmReference` Subinterface

All prompt contributors implement the `PromptContributor` interface with a `contribution()` method that returns a string to be included in the prompt.

Add `PromptContributor` instances to a `PromptRunner` using the `withPromptContributor()` method.

A subinterface of `PromptContributor` is `LlmReference`.

An `LlmReference` is a prompt contributor that can also provide tools via annotated `@Tool` methods.
So that tool naming can be disambiguated, an `LlmReference` must also include name and description metadata.

Add `LlmReference` instances to a `PromptRunner` using the `withReference()` method.

Use `LlmReference` if:

- You want to provide both prompt content and tools from the same object
- You want to provide specific instructions on how to use these tools, beyond the individual tool descriptions
- Your data may be best exposed as either prompt content or tools, depending on the context.
For example, if you have a list of 10 items you might just put in the prompt and say "Here are all the items: ...".
If you have a list of 10,000 objects, you would include advice to use the tools to query them.

NOTE: An `LlmReference` is somewhat similar to a Claude Skill.

==== Built-in Convenience Classes

Embabel provides several convenience classes that implement `PromptContributor` for common use cases.
These are optional utilities - you can always implement the interface directly for custom needs.

===== Persona

The `Persona` class provides a structured way to define an AI agent's personality and behavior:

[source,kotlin]
----
val persona = Persona.create(
    name = "Alex the Analyst",
    persona = "A detail-oriented data analyst with expertise in financial markets",
    voice = "Professional yet approachable, uses clear explanations",
    objective = "Help users understand complex financial data through clear analysis"
)
----

This generates a prompt contribution like:

----
You are Alex the Analyst.
Your persona: A detail-oriented data analyst with expertise in financial markets.
Your objective is Help users understand complex financial data through clear analysis.
Your voice: Professional yet approachable, uses clear explanations.
----

===== RoleGoalBackstory

The `RoleGoalBackstory` class follows the Crew AI pattern and is included for users migrating from that framework:

[source,java]
----
var agent = RoleGoalBackstory.withRole("Senior Software Engineer")
    .andGoal("Write clean, maintainable code")
    .andBackstory("10+ years experience in enterprise software development")
----

This generates:

----
Role: Senior Software Engineer
Goal: Write clean, maintainable code
Backstory: 10+ years experience in enterprise software development
----

==== Custom PromptContributor Implementations

You can create custom prompt contributors by implementing the interface directly.
This gives you complete control over the prompt content:

[source,kotlin]
----
class CustomSystemPrompt(private val systemName: String) : PromptContributor {
    override fun contribution(): String {
        return "System: $systemName - Current time: ${LocalDateTime.now()}"
    }
}

class ConditionalPrompt(
    private val condition: () -> Boolean,
    private val trueContent: String,
    private val falseContent: String
) : PromptContributor {
    override fun contribution(): String {
        return if (condition()) trueContent else falseContent
    }
}
----

==== Examples from embabel-agent-examples

The https://github.com/embabel/embabel-agent-examples[embabel-agent-examples] repository demonstrates various agent development patterns and Spring Boot integration approaches for building AI agents with Embabel.

==== Best Practices

* Keep prompt contributors focused and single-purpose
* Use the convenience classes (`Persona`, `RoleGoalBackstory`) when they fit your needs
* Implement custom `PromptContributor` classes for domain-specific requirements
* Consider using dynamic contributors for context-dependent content
* Test your prompt contributions to ensure they produce the desired LLM behavior


================================================
FILE: embabel-agent-docs/src/main/asciidoc/reference/spring/page.adoc
================================================
[[reference.spring]]
=== Embabel and Spring

Embabel embraces https://spring.io/projects/spring-framework[Spring].
Spring was revolutionary when it arrived, and two decades on it still defines how most JVM applications are built.
You may already know Spring from years of Java or Kotlin development. Or perhaps you’re arriving from Python or another ecosystem. In any case it’s worth noting that Embabel was spearheaded by the creator of Spring himself: the noteworthy Rod Johnson.

Embabel has been assembled using the Spring core platform and then builds upon the https://spring.io/projects/spring-ai[Spring AI] portfolio project.

We recommend using https://spring.io/projects/spring-boot[Spring Boot] for building Embabel applications. Not only does it provide a familiar environment for JVM developers, its philosophy is highly relevant for anyone aiming to craft a production-grade agentic AI application.

Why? Because the foundation of the Spring framework is:

* Composability via discreet, fit-for-purpose reusable units. Dependency injection facilitates this.
* Cross-cutting abstractions — such as transaction management and security. Aspect-oriented programming (AOP) is what makes this work.

This same foundation makes it possible to craft agentic applications that are composable, testable, and built on enterprise-grade service abstractions.
With ~70% of production applications deployed on the JVM, Embabel can bring AI super-powers to existing systems — extending their value rather than replacing them.
In this way, Embabel applies the Spring philosophy so that agentic applications are not just clever demos, but truly production-ready systems.



================================================
FILE: embabel-agent-docs/src/main/asciidoc/reference/steps/page.adoc
================================================
[[reference.steps]]
=== Goals, Actions and Conditions





================================================
FILE: embabel-agent-docs/src/main/asciidoc/reference/templates/page.adoc
================================================
[[reference.templates]]

=== Templates

Embabel supports Jinja templates for generating prompts.
You do this via the `PromptRunner.withTemplate(String)` method.

This method takes a Spring resource path to a Jinja template.
The default location is under `classpath:/prompts/` and the `.jinja` extension is added automatically.

You can also specify a full resource path with https://docs.spring.io/spring-framework/reference/core/resources.html[Spring resource conventions].

Once you have specified the template, you can create objects using a model map.

An example:

[source,java]
----
val distinctFactualAssertions = context.ai()
    .withLlm(properties.deduplicationLlm())
    // Jinjava template from classpath at prompts/factchecker/consolidate_assertions.jinja
    .withTemplate("factchecker/consolidate_assertions")
    .createObject(
            DistinctFactualAssertions.class,
            Map.of(
                    "assertions", allAssertions,
                    "reasoningWordCount", properties.reasoningWordCount()
            )
    );
----

TIP: Don't rush to externalize prompts.
In modern languages with multi-line strings, it's often easier to keep prompts in the codebase.
Externalizing them can sacrifice type safety and lead to complexity and maintenance challenges.


================================================
FILE: embabel-agent-docs/src/main/asciidoc/reference/testing/page.adoc
================================================
[[reference.testing]]
=== Testing

Like Spring, Embabel facilitates testing of user applications.
The framework provides comprehensive testing support for both unit and integration testing scenarios.

IMPORTANT: Building Gen AI applications is no different from building other software.
Testing is critical to delivering quality software and must be considered from the outset.

==== Unit Testing

Unit testing in Embabel enables testing individual agent actions without involving real LLM calls.

Embabel's design means that agents are usually POJOs that can be instantiated with fake or mock objects.
Actions are methods that can be called directly with test fixtures.
In additional to your domain objects, you will pass a text fixture for the Embabel `OperationContext`, enabling you to intercept and verify LLM calls.

The framework provides `FakePromptRunner` and `FakeOperationContext` to mock LLM interactions while allowing you to verify prompts, hyperparameters, and business logic.
Alternatively you can use mock objects.
https://site.mockito.org/[Mockito] is the default choice for Java; https://mockk.io/[mockk] for Kotlin.

===== Java Example: Testing Prompts and Hyperparameters

Here's a unit test from the http://github.com/embabel/java-agent-template[Java Agent Template] repository, using Embabel fake objects:

[source,java]
----
class WriteAndReviewAgentTest {
    
    @Test
    void testWriteAndReviewAgent() {
        var context = FakeOperationContext.create();
        var promptRunner = (FakePromptRunner) context.promptRunner();
        context.expectResponse(new Story("One upon a time Sir Galahad . . "));

        var agent = new WriteAndReviewAgent(200, 400);
        agent.craftStory(new UserInput("Tell me a story about a brave knight", Instant.now()), context);

        String prompt = promptRunner.getLlmInvocations().getFirst().getPrompt();
        assertTrue(prompt.contains("knight"), "Expected prompt to contain 'knight'");

        var temp = promptRunner.getLlmInvocations().getFirst().getInteraction().getLlm().getTemperature();
        assertEquals(0.9, temp, 0.01,
                "Expected temperature to be 0.9: Higher for more creative output");
    }

    @Test
    void testReview() {
        var agent = new WriteAndReviewAgent(200, 400);
        var userInput = new UserInput("Tell me a story about a brave knight", Instant.now());
        var story = new Story("Once upon a time, Sir Galahad...");
        var context = FakeOperationContext.create();
        context.expectResponse("A thrilling tale of bravery and adventure!");
        agent.reviewStory(userInput, story, context);

        var promptRunner = (FakePromptRunner) context.promptRunner();
        String prompt = promptRunner.getLlmInvocations().getFirst().getPrompt();
        assertTrue(prompt.contains("knight"), "Expected review prompt to contain 'knight'");
        assertTrue(prompt.contains("review"), "Expected review prompt to contain 'review'");
    }
}
----

===== Kotlin Example: Testing Prompts and Hyperparameters

Here's the unit test from the http://github.com/embabel/kotlin-agent-template[Kotlin Agent Template] repository:

[source,kotlin]
----
/**
 * Unit tests for the WriteAndReviewAgent class.
 * Tests the agent's ability to craft and review stories based on user input.
 */
internal class WriteAndReviewAgentTest {

    /**
     * Tests the story crafting functionality of the WriteAndReviewAgent.
     * Verifies that the LLM call contains expected content and configuration.
     */
    @Test
    fun testCraftStory() {
        // Create agent with word limits: 200 min, 400 max
        val agent = WriteAndReviewAgent(200, 400)
        val context = FakeOperationContext.create()
        val promptRunner = context.promptRunner() as FakePromptRunner

        context.expectResponse(Story("One upon a time Sir Galahad . . "))

        agent.craftStory(
            UserInput("Tell me a story about a brave knight", Instant.now()),
            context
        )

        // Verify the prompt contains the expected keyword
        Assertions.assertTrue(
            promptRunner.llmInvocations.first().prompt.contains("knight"),
            "Expected prompt to contain 'knight'"
        )

        // Verify the temperature setting for creative output
        val actual = promptRunner.llmInvocations.first().interaction.llm.temperature
        Assertions.assertEquals(
            0.9, actual, 0.01,
            "Expected temperature to be 0.9: Higher for more creative output"
        )
    }

    @Test
    fun testReview() {
        val agent = WriteAndReviewAgent(200, 400)
        val userInput = UserInput("Tell me a story about a brave knight", Instant.now())
        val story = Story("Once upon a time, Sir Galahad...")
        val context = FakeOperationContext.create()
        
        context.expectResponse("A thrilling tale of bravery and adventure!")
        agent.reviewStory(userInput, story, context)

        val promptRunner = context.promptRunner() as FakePromptRunner
        val prompt = promptRunner.llmInvocations.first().prompt
        Assertions.assertTrue(prompt.contains("knight"), "Expected review prompt to contain 'knight'")
        Assertions.assertTrue(prompt.contains("review"), "Expected review prompt to contain 'review'")
        
        // Verify single LLM invocation during review
        Assertions.assertEquals(1, promptRunner.llmInvocations.size)
    }
}
----

===== Key Testing Patterns Demonstrated

**Testing Prompt Content:**

- Use `context.getLlmInvocations().getFirst().getPrompt()` to get the actual prompt sent to the LLM
- Verify that key domain data is properly included in the prompt using `assertTrue(prompt.contains(...))`

**Testing Tool Group Configuration:**

- Access tool groups via `getInteraction().getToolGroups()`
- Verify expected tool groups are present or absent as required

**Testing with Spring Dependencies:**

- Mock Spring-injected services like `HoroscopeService` using standard mocking frameworks - Pass mocked dependencies to agent constructor for isolated unit testing

===== Testing Multiple LLM Interactions

[source,java]
----
@Test
void shouldHandleMultipleLlmInteractions() {
    // Arrange
    var input = new UserInput("Write about space exploration");
    var story = new Story("The astronaut gazed at Earth...");
    ReviewedStory review = new ReviewedStory("Compelling narrative with vivid imagery.");
    
    // Set up expected responses in order
    context.expectResponse(story);
    context.expectResponse(review);

    // Act
    var writtenStory = agent.writeStory(input, context);
    ReviewedStory reviewedStory = agent.reviewStory(writtenStory, context);

    // Assert
    assertEquals(story, writtenStory);
    assertEquals(review, reviewedStory);
    
    // Verify both LLM calls were made
    List<LlmInvocation> invocations = context.getLlmInvocations();
    assertEquals(2, invocations.size());
    
    // Verify first call (writer)
    var writerCall = invocations.get(0);
    assertEquals(0.8, writerCall.getInteraction().getLlm().getTemperature(), 0.01);
    
    // Verify second call (reviewer)
    var reviewerCall = invocations.get(1);
    assertEquals(0.2, reviewerCall.getInteraction().getLlm().getTemperature(), 0.01);
}
----

You can also use Mockito or mockk directory.
Consider this component, using direct injection of `Ai`:

[source,java]
----
@Component
public record InjectedComponent(Ai ai) {

    public record Joke(String leadup, String punchline) {
    }

    public String tellJokeAbout(String topic) {
        return ai
                .withDefaultLlm()
                .generateText("Tell me a joke about " + topic);
    }
}
----

A unit test using Mockito to verify prompt and hyperparameters:

[source,java]
----
class InjectedComponentTest {

    @Test
    void testTellJokeAbout() {
        var mockAi = Mockito.mock(Ai.class);
        var mockPromptRunner = Mockito.mock(PromptRunner.class);

        var prompt = "Tell me a joke about frogs";
        // Yep, an LLM came up with this joke.
        var terribleJoke = """
                Why don't frogs ever pay for drinks?
                Because they always have a tadpole in their wallet!
                """;
        when(mockAi.withDefaultLlm()).thenReturn(mockPromptRunner);
        when(mockPromptRunner.generateText(prompt)).thenReturn(terribleJoke);

        var injectedComponent = new InjectedComponent(mockAi);
        var joke = injectedComponent.tellJokeAbout("frogs");

        assertEquals(terribleJoke, joke);
        Mockito.verify(mockAi).withDefaultLlm();
        Mockito.verify(mockPromptRunner).generateText(prompt);
    }

}
----

==== Integration Testing

Integration testing exercises complete agent workflows with real or mock external services while still avoiding actual LLM calls for predictability and speed.

This can ensure:

- Agents are picked up by the agent platform
- Data flow is correct within agents
- Failure scenarios are handled gracefully
- Agents interact correctly with each other and external systems
- The overall workflow behaves as expected
- LLM prompts and hyperparameters are correctly configured

Embabel integration testing is built on top of https://docs.spring.io/spring-framework/reference/testing/integration.html[Spring's excellent integration testing support], thus allowing you to work with real databases if you wish.
Spring's https://docs.spring.io/spring-boot/reference/testing/testcontainers.html[integration with Testcontainers] is particularly userul.

===== Using EmbabelMockitoIntegrationTest

Embabel provides `EmbabelMockitoIntegrationTest` as a base class that simplifies integration testing with convenient helper methods:

[source,java]
----

/**
* Use framework superclass to test the complete workflow of writing and reviewing a story.
* This will run under Spring Boot against an AgentPlatform instance * that has loaded all our agents.
*/ class StoryWriterIntegrationTest extends EmbabelMockitoIntegrationTest {

    @Test
    void shouldExecuteCompleteWorkflow() {
        var input = new UserInput("Write about artificial intelligence");

        var story = new Story("AI will transform our world...");
        var reviewedStory = new ReviewedStory(story, "Excellent exploration of AI themes.", Personas.REVIEWER);

        whenCreateObject(contains("Craft a short story"), Story.class)
                .thenReturn(story);

        // The second call uses generateText
        whenGenerateText(contains("You will be given a short story to review"))
                .thenReturn(reviewedStory.review());

        var invocation = AgentInvocation.create(agentPlatform, ReviewedStory.class);
        var reviewedStoryResult = invocation.invoke(input);

        assertNotNull(reviewedStoryResult);
        assertTrue(reviewedStoryResult.getContent().contains(story.text()),
                "Expected story content to be present: " + reviewedStoryResult.getContent());
        assertEquals(reviewedStory, reviewedStoryResult,
                "Expected review to match: " + reviewedStoryResult);

        verifyCreateObjectMatching(prompt -> prompt.contains("Craft a short story"), Story.class,
                llm -> llm.getLlm().getTemperature() == 0.9 && llm.getToolGroups().isEmpty());
        verifyGenerateTextMatching(prompt -> prompt.contains("You will be given a short story to review"));
        verifyNoMoreInteractions();
    }
}
----

===== Key Integration Testing Features

**Base Class Benefits:**
- `EmbabelMockitoIntegrationTest` handles Spring Boot setup and LLM mocking automatically - Provides `agentPlatform` and `llmOperations` pre-configured - Includes helper methods for common testing patterns

**Convenient Stubbing Methods:**
- `whenCreateObject(prompt, outputClass)`: Mock object creation calls - `whenGenerateText(prompt)`: Mock text generation calls - Support for both exact prompts and `contains()` matching

**Advanced Verification:**
- `verifyCreateObjectMatching()`: Verify prompts with custom matchers - `verifyGenerateTextMatching()`: Verify text generation calls - `verifyNoMoreInteractions()`: Ensure no unexpected LLM calls

**LLM Configuration Testing:**
- Verify temperature settings: `llm.getLlm().getTemperature() == 0.9`
- Check tool groups: `llm.getToolGroups().isEmpty()`
- Validate persona and other LLM options




================================================
FILE: embabel-agent-docs/src/main/asciidoc/reference/tools/page.adoc
================================================
[[reference.tools]]
=== Tools

Tools can be passed to LLMs to allow them to perform actions.
Tools can either be outside the JVM process, as with MCP, or inside the JVM process, as with domain objects exposing `@Tool` methods.

Embabel allows you to provide tools to LLMs in two ways:

* Via the `PromptRunner` by providing one or more in process **tool instances**.
A tool instance is an object annotated with `@Tool` methods.
* At action or `PromptRunner` level, from a **tool group**.

`LlmReference` implementations also expose tools, but this is handled internally by the framework.

==== In Process Tools: Implementing Tool Instances

Implement one or more methods annotated with `@Tool` on a class.
You do not need to annotate the class itself.
Each annotated method represents a distinct tool that will be exposed to the LLM.

A simple example of a tool method:

[source,kotlin]
----
class MathTools {

    @Tool(description = "add two numbers")
    fun add(a: Double, b: Double) = a + b

    // Other tools
----

Classes implementing tools can be stateful.
They are often domain objects.
Tools on mapped entities are especially useful, as they can encapsulate state that is never exposed to the LLM.
See https://medium.com/@springrod/domain-tools-direct-access-zero-ceremony-9a3e8d4cf550[Domain Tools: Direct Access, Zero Ceremony] for a discussion of tool use patterns.

The `@Tool` annotation comes from https://docs.spring.io/spring-ai/reference/api/tools.html[Spring AI].

Tool methods can have any visibility, and can be static or instance scope.
They are allowed on inner classes.

[quote,Spring AI,Tool Calling]
____
You can define any number of arguments for the method (including no argument) with most types (primitives, POJOs, enums, lists, arrays, maps, and so on).
Similarly, the method can return most types, including void.
If the method returns a value, the return type must be a serializable type, as the result will be serialized and sent back to the model.

The following types are not currently supported as parameters or return types for methods used as tools:

- Optional
- Asynchronous types (e.g. CompletableFuture, Future)
- Reactive types (e.g. Flow, Mono, Flux)
- Functional types (e.g. Function, Supplier, Consumer).
____

You can obtain the current `AgentProcess` in a Tool method implementation via `AgentProcess.get()`.
This enables tools to bind to the `AgentProcess`, making objects available to other actions.
For example:

[source,java]
----

@Tool(description="My Tool") String bindCustomer(Long id) {
var customer = customerRepository.findById(id); var agentProcess = AgentProcess.get(); if (agentProcess != null) {
agentProcess.addObject(customer); return "Customer bound to blackboard"; } return "No agent process: Unable to bind customer"; }

----

[[reference.tools__tool-groups]]
==== Tool Groups

Embabel introduces the concept of a *tool group*.
This is a level of indirection between user intent and tool selection.
For example, we don't ask for Brave or Google web search: we ask for "web" tools, which may be resolved differently in different environments.

TIP: Tools use should be focused.
Thus tool groups cannot be specified at agent level, but must be specified on individual actions.

Tool groups are often backed by <<reference.integrations__mcp,MCP>>.

===== Configuring Tool Groups in configuration files

If you have configured MCP servers in your application configuration, you can selectively expose tools from those servers to agents by configuring tool groups.
The easiest way to do this is in your `application.yml` or `application.properties` file.
Select tools by name.

For example:

[source,yaml]
----
embabel:

  agent:
    platform:
      tools:
        includes:
          linked-in:
            tools:
              - get_person_profile
              - get_company_profile
----

===== Configuring Tool Groups in Spring @Configuration

You can also use Spring's `@Configuration` and `@Bean` annotations to expose ToolGroups to the agent platform with greater control.
The framework provides a default `ToolGroupsConfiguration` that demonstrates how to inject MCP servers and selectively expose MCP tools:

[source,kotlin]
----

@Configuration class ToolGroupsConfiguration(
    private val mcpSyncClients: List<McpSyncClient>) {

    @Bean
    fun mathToolGroup() = MathTools()

    @Bean
    fun mcpWebToolsGroup(): ToolGroup {
        return McpToolGroup(
            description = CoreToolGroups.WEB_DESCRIPTION,
            name = "docker-web",
            provider = "Docker",
            permissions = setOf(ToolGroupPermission.INTERNET_ACCESS),
            clients = mcpSyncClients,
            filter = {
                // Only expose specific web tools, exclude rate-limited ones
                (it.toolDefinition.name().contains("brave") ||
                 it.toolDefinition.name().contains("fetch")) &&
                !it.toolDefinition.name().contains("brave_local_search")
            }
        )
    }
}
----

===== Key Configuration Patterns

**MCP Client Injection:**
The configuration class receives a `List<McpSyncClient>` via constructor injection.
Spring automatically provides all available MCP clients that have been configured in the application.

**Selective Tool Exposure:**
Each `McpToolGroup` uses a `filter` lambda to control which tools from the MCP servers are exposed to agents.
This allows fine-grained control over tool availability and prevents unwanted or problematic tools from being used.

**Tool Group Metadata:**
Tool groups include descriptive metadata like `name`, `provider`, and `description` to help agents understand their capabilities.
The `permissions` property declares what access the tool group requires (e.g., `INTERNET_ACCESS`).

===== Creating Custom Tool Group Configurations

Applications can implement their own `@Configuration` classes to expose custom tool groups, which can be backed by any service or resource, not just MCP.

[source,java]
----
@Configuration
public class MyToolGroupsConfiguration {

    @Bean
    public ToolGroup databaseToolsGroup(DataSource dataSource) {
        return new DatabaseToolGroup(dataSource);
    }

    @Bean
    public ToolGroup emailToolsGroup(EmailService emailService) {
        return new EmailToolGroup(emailService);
    }
}
----

This approach leverages Spring's dependency injection to provide tool groups with the services and resources they need, while maintaining clean separation of concerns between tool configuration and agent logic.

===== Tool Usage in Action Methods

The `toolGroups` parameter on `@Action` methods specifies which tool groups are required for that action to execute.
The framework automatically provides these tools to the LLM when the action runs.

Here's an example from the `StarNewsFinder` agent that demonstrates web tool usage:

[tabs]
====
Java::
+
[source,java]
----
// toolGroups specifies tools that are required for this action to run
@Action(toolGroups = {CoreToolGroups.WEB})
public RelevantNewsStories findNewsStories(
        StarPerson person, Horoscope horoscope, OperationContext context) {
    var prompt = """
            %s is an astrology believer with the sign %s.
            Their horoscope for today is:
                <horoscope>%s</horoscope>
            Given this, use web tools and generate search queries
            to find %d relevant news stories summarize them in a few sentences.
            Include the URL for each story.
            Do not look for another horoscope reading or return results directly about astrology;
            find stories relevant to the reading above.
            """.formatted(
            person.name(), person.sign(), horoscope.summary(), storyCount);

    return context.ai().withDefaultLlm().createObject(prompt, RelevantNewsStories.class);
}
----

Kotlin::
+
[source,kotlin]
----
// toolGroups specifies tools that are required for this action to run
@Action(toolGroups = [CoreToolGroups.WEB, CoreToolGroups.BROWSER_AUTOMATION])
internal fun findNewsStories(
    person: StarPerson,
    horoscope: Horoscope,
    context: OperationContext,
): RelevantNewsStories =
    context.ai().withDefaultLlm() createObject (
        """
        ${person.name} is an astrology believer with the sign ${person.sign}.
        Their horoscope for today is:
            <horoscope>${horoscope.summary}</horoscope>
        Given this, use web tools and generate search queries
        to find $storyCount relevant news stories summarize them in a few sentences.
        Include the URL for each story.
        Do not look for another horoscope reading or return results directly about astrology;
        find stories relevant to the reading above.
        """.trimIndent()
    )
----
====

===== Key Tool Usage Patterns

**Tool Group Declaration:**
The `toolGroups` parameter on `@Action` methods explicitly declares which tool groups the action needs.
This ensures the LLM has access to the appropriate tools when executing that specific action.

**Multiple Tool Groups:**
Actions can specify multiple tool groups (e.g., `[CoreToolGroups.WEB, CoreToolGroups.BROWSER_AUTOMATION]`) when they need different types of capabilities.

**Automatic Tool Provisioning:**
The framework automatically makes the specified tools available to the LLM during the action execution.
Developers don't need to manually manage tool availability - they simply declare what's needed.

**Tool-Aware Prompts:**
Prompts should explicitly instruct the LLM to use the available tools.
For example, "use web tools and generate search queries" clearly directs the LLM to utilize the web search capabilities.

===== Using Tools at PromptRunner Level

Instead of declaring tools at the action level, you can also specify tools directly on the `PromptRunner` for more granular control:

[source,kotlin]
----
// Add tool groups to a specific prompt
context.ai().withAutoLlm().withToolGroup(CoreToolGroups.WEB).create(
    """
    Given the topic, generate a detailed report using web research.

    # Topic
    ${reportRequest.topic}
    """.trimIndent()
)

// Add multiple tool groups
context.ai().withDefaultLlm()
    .withToolGroup(CoreToolGroups.WEB)
    .withToolGroup(CoreToolGroups.MATH)
    .createObject("Calculate stock performance with web data", StockReport::class)
----

**Adding Tool Objects with @Tool Methods:**

You can also provide domain objects with `@Tool` methods directly to specific prompts:

[source,java]
----
context.ai()
    .withDefaultLlm()
    .withToolObject(jokerTool)
    .createObject("Create a UserInput object for fun", UserInput.class);

// Add tool object with filtering and custom naming strategy
context.ai()
    .withDefaultLlm()
    .withToolObject(
        ToolObject(calculatorService)
            .withNamingStrategy { "calc_$it" }
            .withFilter { methodName -> methodName.startsWith("compute") }
    ).createObject("Perform calculations", Result.class);
----

**Available PromptRunner Tool Methods:**

- `withToolGroup(String)`: Add a single tool group by name
- `withToolGroup(ToolGroup)`: Add a specific ToolGroup instance
- `withToolGroups(Set<String>)`: Add multiple tool groups
- `withTools(vararg String)`: Convenient method to add multiple tool groups
- `withToolObject(Any)`: Add domain object with @Tool methods
- `withToolObject(ToolObject)`: Add ToolObject with custom configuration



================================================
FILE: embabel-agent-docs/src/main/asciidoc/reference/troubleshooting/page.adoc
================================================
[[reference.troubleshooting]]
=== Troubleshooting

This section covers common issues you might encounter when developing with Embabel and provides practical solutions.

==== Common Problems and Solutions

[cols="2,3,1",options="header"]
|===
|Problem |Solution |Related Docs

|**Compilation Error**
|Check that you're using the correct version of Embabel in your Maven or Gradle dependencies. You may be using an API from a later version (even a snapshot). Version mismatches between different Embabel modules can cause compilation issues. Ensure all `com.embabel.agent` artifacts use the same version, unless you're following a specific example that does otherwise.
|<<reference.configuration,Configuration>>

|**Don't Know How to Invoke Your Agent**
|Look at examples of processing `UserInput` in the documentation. Study `AgentInvocation` patterns to understand how to trigger your agent flows. The key is understanding how to provide the initial input that your agent expects.
|<<reference.invoking,Invoking Agents>>

|**Agent Flow Not Completing**
|This usually indicates a data flow problem. First, understand Embabel's type-driven data flow concepts - review how input/output types create dependencies between actions. Then write an integration test to verify your flow works end-to-end. Familiarize yourself with Embabel's GOAP planning concept.
|<<overview__concepts,Data Flow Concepts>>

|**LLM Prompts Look Wrong or Have Incorrect Hyperparameters**
|Write unit tests to capture and verify the exact prompts being sent to your LLM. This allows you to see the actual prompt content and tune temperature, model selection, and other parameters. Unit testing is the best way to debug LLM interactions.
|<<reference.testing,Testing>>

|**Agent Gets Stuck in Planning**
|Check that all your actions have clear input/output type signatures. Missing or circular dependencies in your type flow can prevent the planner from finding a valid path to the goal. Review your `@Action` method signatures. Look at the log output from the planner for clues. Set your `ProcessOptions.verbosity` to show planning.
|<<overview__concepts,Type-Driven Flow>>

|**Tools Not Available to Agent**
|Ensure you've specified the correct `toolGroups` in your `@Action` annotation. Tools must be explicitly declared for the action to access them. Check that required tool groups are available in your environment.
|<<reference.tools,Tools>>

|**Agent Runs But Produces Poor Results**
|Review your prompt engineering and persona configuration. Consider adjusting LLM temperature, model selection, and context provided to actions. Write tests to capture actual vs expected outputs.
|<<reference.testing,Testing>>, <<reference.llms,LLM Configuration>>

|**You're Struggling to Express What You Want in a Plan**
|Familiarize yourself with custom conditions for complex flow control. For common behavior patterns, consider using atomic actions with Embabel's typesafe custom builders such as `ScatterGatherBuilder` and `RepeatUntilBuilder` instead of trying to express everything through individual actions.
|<<reference.dsl,DSL and Builders>>

|**Custom conditions not working as expected**
|Remember that you must declare `post` conditions on `@Action` methods that may set your custom condition,
as well as `pre` conditions on actions that depend on them. Otherwise the planner
will assume that the conditions are never set and your plan will not execute as expected.
|<<overview__concepts,Type-Driven Flow>>

|**Your Agent Has No Goals and Cannot Execute**
|Look at the `@AchievesGoal` annotation and ensure your terminal action is annotated with it. Every agent needs at least one action marked with `@AchievesGoal` to define what constitutes completion of the agent's work.
|<<reference.annotations,Annotations>>

|**Your Agent Isn't Visible to an MCP Client Like Claude Desktop**
|Ensure that your `@AchievesGoal` annotation includes `@Export(remote=true)`. This makes your agent available for remote invocation through MCP (Model Context Protocol) clients.
|<<reference.annotations,Annotations>>, <<reference.integrations,Integrations>>

|**Your Agent Can't Use Upstream MCP Tools and You're Seeing Errors in Logs About Possible Misconfiguration**
|Check that your Docker configuration is correct if using the default Docker MCP Gateway. Verify that Docker containers are running and accessible. For other MCP configurations, ensure your Spring AI MCP client configuration is correct. See the Spring AI MCP client documentation for detailed setup instructions.
|https://docs.spring.io/spring-ai/reference/api/mcp/mcp-client-boot-starter-docs.html[Spring AI MCP Client]
|===

==== Debugging Strategies

===== Enable Debug Logging

Customize Embabel logging in `application.yml` or `application.properties` to see detailed agent execution.
For example:

[source,yaml]
----
logging:
  level:
    com.embabel.agent: DEBUG
----

==== Getting Help

The Embabel community is active and helpful.
Join our https://discord.gg/t6bjkyj93q[Discord] server to ask questions and share experiences.



================================================
FILE: embabel-agent-docs/src/main/asciidoc/reference/types/page.adoc
================================================
[[reference.types]]
=== Core Types

==== LlmOptions

The `LlmOptions` class specifies which LLM to use and its hyperparameters.
It's defined in the https://github.com/embabel/embabel-common[embabel-common] project and provides a fluent API for LLM configuration:

[source,java]
----
// Create LlmOptions with model and temperature
var options = LlmOptions
    .withModel(OpenAiModels.GPT_4O_MINI)
    .withTemperature(0.8);

// Use different hyperparameters for different tasks
var analyticalOptions = LlmOptions
    .withModel(OpenAiModels.GPT_4O_MINI)
    .withTemperature(0.2)
    .withTopP(0.9);
----

**Important Methods:**

- `withModel(String)`: Specify the model name
- `withRole(String)`: Specify the model role. The role must be one defined in configuration via `embabel.models.llms.<role>=<model-name>`
- `withTemperature(Double)`: Set creativity/randomness (0.0-1.0)
- `withTopP(Double)`: Set nucleus sampling parameter
- `withTopK(Integer)`: Set top-K sampling parameter
- `withPersona(String)`: Add a system message persona

`LlmOptions` is serializable to JSON, so you can set properties of type
`LlmOptions` in `application.yml` and other application configuration files.
This is a powerful way of externalizing not only models, but hyperparameters.

==== PromptRunner

All LLM calls in user applications should be made via the `PromptRunner` interface.
Once created, a `PromptRunner` can run multiple prompts with the same LLM, hyperparameters, tool groups and `PromptContributors`.

===== Getting a PromptRunner

You obtain a `PromptRunner` from an `OperationContext` using the fluent API:

[source,java]
----
@Action
public Story createStory(UserInput input, OperationContext context) {
    // Get PromptRunner with default LLM
    var runner = context.ai().withDefaultLlm();

    // Get PromptRunner with specific LLM options
    var customRunner = context.ai().withLlm(
        LlmOptions.withModel(OpenAiModels.GPT_4O_MINI)
            .withTemperature(0.8)
    );

    return customRunner.createObject("Write a story about: " + input.getContent(), Story.class);
}
----

===== PromptRunner Methods

**Core Object Creation:**

- `createObject(String, Class<T>)`: Create a typed object from a prompt, otherwise throw an exception. An exception triggers retry. If retry fails repeatedly, re-planning occurs.
- `createObjectIfPossible(String, Class<T>)`: Try to create an object, return null on failure.
This can cause replanning.
- `generateText(String)`: Generate simple text response

TIP: Normally you want to use one of the `createObject` methods to ensure the response is typed correctly.

**Tool and Context Management:**

- `withToolGroup(String)`: Add <<reference.tools__tool-groups, tool groups>> for LLM access
- `withToolObject(Object)`: Add domain objects with <<reference.tools, @Tool>> methods
- `withPromptContributor(PromptContributor)`: Add <<reference.prompt-contributors, context>> contributors

**LLM Configuration:**

- `withLlm(LlmOptions)`: Use specific LLM configuration
- `withGenerateExamples(Boolean)`: Control example generation

**Returning a Specific Type**

- `creating(Class<T>)`: Go into the `ObjectCreator` fluent API for returning a particular type.

For example:

[source,java]
----
var story = context.ai()
    .withDefaultLlm()
    .withToolGroup(CoreToolGroups.WEB)
    .creating(Story.class)
    .fromPrompt("Create a story about: " + input.getContent());
----

The main reason to do this is to add strongly typed examples for https://www.promptingguide.ai/techniques/fewshot[few-shot prompting].
For example:

[source,java]
----
var story = context.ai()
    .withDefaultLlm()
    .withToolGroup(CoreToolGroups.WEB)
    .withExample("A children's story", new Story("Once upon a time...")) // <1>
    .creating(Story.class)
    .fromPrompt("Create a story about: " + input.getContent());
----

<1> **Example**: The example will be included in the prompt in JSON format to guide the LLM.

**Advanced Features:**

- `withTemplate(String)`: Use <<reference.templates, Jinja>> templates for prompts
- `withSubagents(Subagent...)`: Enable handoffs to other agents
- `evaluateCondition(String, String)`: Evaluate boolean condition

**Validation**

Embabel supports https://beanvalidation.org/2.0-jsr380/[JSR-380] bean validation annotations on domain objects.
When creating objects via `PromptRunner.createObject` or `createObjectIfPossible`, validation is automatically performed after deserialization.
If validation fails, Embabel transparently retries the LLM call to obtain a valid object,
describing the validation errors to the LLM to help it correct its response.

If validation fails a second time, `InvalidLlmReturnTypeException` is thrown.
This will trigger replanning if not caught.
You can also choose to catch it within the action method making the LLM call,
and take appropriate action in your own code.

Simple example of annotation use:

[source,java]
----
public class User {

    @NotNull(message = "Name cannot be null")
    private String name;

    @AssertTrue(message = "Working must be true")
    private boolean working;

    @Size(min = 10, max = 200, message
      = "About Me must be between 10 and 200 characters")
    private String aboutMe;

    @Min(value = 18, message = "Age should not be less than 18")
    @Max(value = 150, message = "Age should not be greater than 150")
    private int age;

    @Email(message = "Email should be valid")
    private String email;

    // standard setters and getters
}
----

You can also use custom annotations with validators that will be injected by Spring. For example:

[source,java]
----
@Target({ElementType.FIELD, ElementType.PARAMETER}) // <1>
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PalindromeValidator.class)
public @interface MustBePalindrome {
    String message() default "Must be a palindrome";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

public class Palindromic {
    @MustBePalindrome // <2>
    private String eats;

    public Palindromic(String eats) {
        this.eats = eats;
    }

    public String getEats() {
        return eats;
    }
}

@Component // <3>
public class PalindromeValidator implements ConstraintValidator<MustBePalindrome, String> {

    private final Ai ai; // <4>

    public PalindromeValidator(Ai ai) {
        this.ai = ai;
    }

    @Override
    public boolean isValid(String field, ConstraintValidatorContext context) {
        if (field == null) {
            return false;
        }
        return field.equals(new StringBuilder(field).reverse().toString());
    }
}
----

<1> Define the custom annotation
<2> Apply the annotation to a field
<3> Implement the validator as a Spring component. Note the `@Component` annotation.
<4> Spring will inject the validator with dependencies, such as the `Ai` instance in this case

Thus we have standard JSR-280 validation with full Spring dependency injection support.


// TODO: (jasper notes) Add links to subagent and evaluateCondition



================================================
FILE: embabel-agent-docs/src/main/asciidoc/resources/page.adoc
================================================
[[resources]]
== Resources
:sectids:
:sectanchors:

=== Rod Johnson's Blog Posts

- https://medium.com/@springrod/embabel-a-new-agent-platform-for-the-jvm-1c83402e0014[Embabel: A new Agent Platform For the JVM] - Introduction to the Embabel agent framework, explaining the motivation for building an agent platform specifically for the JVM ecosystem.
Covers the key differentiators and benefits of the approach.

- https://medium.com/@springrod/the-embabel-vision-967654f13793[The Embabel Vision] - Rod Johnson's vision for the future of agent frameworks and how Embabel fits into the broader AI landscape.
Discusses the long-term goals and strategic direction of the project.

- https://medium.com/@springrod/context-engineering-needs-domain-understanding-b4387e8e4bf8[Context Engineering Needs Domain Understanding] - Deep dive into the DICE (Domain-Integrated Context Engineering) concept and why domain understanding is fundamental to effective context engineering in AI systems.

=== Examples and Tutorials

- https://www.baeldung.com/java-embabel-agent-framework[Creating an AI Agent in Java Using Embabel Agent Framework] by Baeldung - A nice introductory example, in Java.
- https://jettro.dev/building-agents-with-embabel-a-hands-on-introduction-4f96d2edeac0[Building Agents With Embabel: A Hands-On Introduction] by Jettro Coenradie - An excellent Java tutorial.

==== Embabel Agent Examples Repository

The https://github.com/embabel/embabel-agent-examples[Examples Repository] is a comprehensive collection of example agents demonstrating different aspects of the framework:

- **Beginner Examples**: Simple horoscope agents showing basic concepts
- **Intermediate Examples**: Multi-LLM research agents with self-improvement
- **Advanced Examples**: Fact-checking agents with parallel verification and confidence scoring
- **Integration Examples**: Agents that use web tools, databases, and external APIs

Perfect starting point for learning Embabel development with hands-on examples.

==== Java Agent Template

https://github.com/embabel/java-agent-template[Template repository] for creating new Java-based Embabel agents.
Includes:

- Pre-configured project structure
- Example WriteAndReviewAgent demonstrating multi-LLM workflows
- Build scripts and Docker configuration
- Getting started documentation

==== Kotlin Agent Template

https://github.com/embabel/kotlin-agent-template[Template repository] for Kotlin-based agent development with similar features to the Java template but using idiomatic Kotlin patterns.

=== Sophisticated Example: Tripper Travel Planner

==== Tripper - AI-Powered Travel Planning Agent

https://github.com/embabel/tripper[Tripper] is a production-quality example demonstrating advanced Embabel capabilities:

**Features:**

- Generates personalized travel itineraries using multiple AI models
- Integrates web search, mapping, and accommodation search
- Modern web interface built with htmx
- Containerized deployment with Docker
- CI/CD pipeline with GitHub Actions

**Technical Highlights:**

- Uses both Claude Sonnet and GPT-4.1-mini models
- Demonstrates domain-driven design principles
- Shows how to build user-facing applications with Embabel
- Practical example of deterministic planning with AI

**Learning Value:**

- Real-world application of Embabel concepts
- Integration patterns with external services
- Production deployment considerations
- User interface design for AI applications

=== Goal-Oriented Action Planning (GOAP)

- Here's an https://medium.com/@vedantchaudhari/goal-oriented-action-planning-34035ed40d0b[Introduction to GOAP], the planning algorithm used by Embabel.
Explains the core concepts and why GOAP is effective for AI agent planning.

==== Small Language Model Agents - NVIDIA Research

- This https://research.nvidia.com/labs/lpr/slm-agents/[Research paper] discusses the division between "code agency" and "LLM agency" - concepts that inform Embabel's architecture.

==== OODA Loop - Wikipedia

Here's a https://en.wikipedia.org/wiki/OODA_loop[Background] on the Observe-Orient-Decide-Act loop that underlies Embabel's replanning approach.

=== Domain-Driven Design

- Martin Fowler's https://martinfowler.com/bliki/DomainDrivenDesign.html[Foundational concepts of Domain-Driven Design] provides a good summary of Embabel's approach to domain modeling.

==== Domain-Driven Design: Tackling Complexity in the Heart of Software

- Eric Evans' https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215[seminal book] on DDD principles.
Essential reading for understanding how to model complex domains effectively.

==== DDD and Contextual Validation

- https://www.infoq.com/articles/ddd-contextual-validation/[Advanced DDD concepts] relevant to building sophisticated domain models for AI agents.



================================================
FILE: embabel-agent-docs/src/main/asciidoc/roadmap/roadmap.adoc
================================================
[[roadmap]]
== Roadmap
:sectids:
:sectanchors:

UX Beyond the JVM



================================================
FILE: embabel-agent-docs/src/main/asciidoc/shell/commands.adoc
================================================
[[shell.commands]]
=== Shell Commands


================================================
FILE: embabel-agent-docs/src/main/asciidoc/shell/how-to.adoc
================================================
[[shell.how-to]]
=== How to Use the Shell


================================================
FILE: embabel-agent-docs/src/main/asciidoc/shell/shell-guide.adoc
================================================
[[shell.guide]]
== Embabel Shell
:sectids:
:sectanchors:

The easiest way to get started with Embabel is via Spring Shell.

include::how-to.adoc[]
include::commands.adoc[]



================================================
FILE: embabel-agent-docs/src/main/resources/themes/embabel-agent-docs.css
================================================
/* AsciiDoctor Dark Theme
 * A dark theme for AsciiDoctor HTML output
 */

/* Import modern fonts */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@300;400;500;600&display=swap');

/* Import the default AsciiDoctor stylesheet first */
@import "https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor@2.0/data/stylesheets/asciidoctor-default.css";

/* Import theme extensions */
@import "theme-extensions.css";

/* Base color variables */
:root {
    --bg-color: #1e1e1e;
    --text-color: #e0e0e0;
    --link-color: #4da6ff;
    --link-hover-color: #80bfff;
    --heading-color: #63c0f5;
    --code-bg-color: #131313;
    --code-text-color: #f8f8f2;
    --quote-bg-color: #e0e0e0;
    --quote-border-color: #444444;
    --table-header-bg: #2d2d2d;
    --table-border-color: #444444;
    --table-alt-bg: #292929;
    --admonition-note-bg: #e0e0e0;
    --admonition-tip-bg: #e0e0e0;
    --admonition-important-bg: #e0e0e0;
    --admonition-warning-bg: #e0e0e0;
    --admonition-caution-bg: #e0e0e0;
    --toc-min: 12rem; /* smallest TOC */
    --toc-ideal: 22vw; /* preferred responsive TOC */
    --toc-max: 20rem; /* largest TOC */
    --gutter: clamp(20px, 2vw, 40px);
    --header-height: 50px;
    --toc-width: clamp(var(--toc-min), var(--toc-ideal), var(--toc-max));
    --navbar-height: 56px;
}

/* Basic elements */
/* === Cross-platform system fonts (no imports) === */
html, body {
    font-family: ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
    font-weight: 400;
    line-height: 1.6;
    letter-spacing: 0; /* avoid negative tracking for Windows */
}

h1, h2, h3, h4, h5, h6 {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
    Helvetica, Arial, sans-serif, "Apple Color Emoji",
    "Segoe UI Emoji", "Segoe UI Symbol" !important;
    font-weight: 600;
    line-height: 1.3;
}

pre, code, tt {
    font-family: "SFMono-Regular", "Cascadia Mono", "Consolas",
    "Liberation Mono", "Menlo", monospace !important;
    font-weight: 400;
    font-variant-ligatures: none; /* avoids distracting ligatures */
}

/* Optional: slightly crisper type on WebKit/Blink (no effect on Firefox) */
html {
    -webkit-font-smoothing: antialiased;
    text-rendering: optimizeLegibility;
}

html, body {
    height: 100%;
    margin: 0;
}

body {
    overflow: hidden;
}

/* page itself doesn't scroll */

/* Header (currently hidden) */
/*#site-header {*/
/*    position: fixed;*/
/*    inset: 0 0 auto 0;*/
/*    height: var(--header-height);*/
/*    z-index: 1000;*/
/*    display: none; !* keep if you don't want it yet *!*/
/*    background: #111;*/
/*    color: #fff;*/
/*    padding: 0 1rem;*/
/*}*/

#toc {
    position: fixed;
    top: var(--header-height);
    bottom: 0;
    left: 0;
    width: var(--toc-width); /* responsive */
    overflow: auto;
    z-index: 900;
    background: linear-gradient(-45deg, #1a1f2e, #0d0d0d, #1f0d1f, #0d1f0d) !important;
    background-size: 400% 400%;
    animation: gradientBG 30s ease infinite;
    padding: 1rem;
    box-sizing: border-box;
}

@keyframes gradientBG {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

#content {
    position: absolute;
    top: var(--header-height);
    bottom: 0;
    left: calc(var(--toc-width) + 25px);
    right: 0;
    width: auto;
    max-width: 100vw;
    min-width: 0;
    z-index: 950;
    overflow-y: auto;
    overflow-x: auto;
    background: #000;
    padding: 1.25rem 1.5rem 1.25rem 1.5rem;
    box-sizing: border-box;
    scrollbar-gutter: stable;
}

/* Optional: guard against sub-pixel rounding on some zoom levels */
@media (min-width: 961px) {
    #content {
        border-left: 0.01px solid transparent;
    }

    /* forces proper stacking in a few browsers */
}

/* Narrow screens: hide TOC, let content take full width */
@media (max-width: 960px) {
    #toc {
        display: none !important;
        z-index: -1;
    }

    #content {
        left: 0;
        right: 0;
        width: 100vw;
        max-width: 100vw;
        min-width: 0;
        padding-left: 0.5rem;
        padding-right: 0.5rem;
    }
    .navbar {
        padding-left: 0 !important;
    }
    .navbar-logo {
         margin-left: -25px !important;
    }
}


/* Links */
a, a:hover, a:focus {
    color: var(--link-color) !important;
}

a:hover, a:focus {
    color: var(--link-hover-color) !important;
    text-decoration: underline;
}

/* Document title and top-most header - make it white */
h1, #header h1, #header > h1:first-child, #toctitle, .sidebarblock > .content > .title {
    color: #ffffff !important;
    font-family: 'Inter', sans-serif !important;
    font-weight: 700;
    letter-spacing: -0.02em;
}

/* Other headings keep the blue tint */
h2, h3, h4, h5, h6 {
    color: var(--heading-color) !important;
    font-family: 'Inter', sans-serif !important;
    font-weight: 600;
    letter-spacing: -0.015em;
}

/* Code blocks - more specific targeting */
pre {
    background-color: var(--code-bg-color) !important;
    color: var(--code-text-color) !important;
    border: 1px solid #444 !important;
    font-family: 'JetBrains Mono', 'Fira Code', 'Monaco', 'Consolas', monospace !important;
    font-weight: 400;
    font-size: 0.9em;
    line-height: 1.5;
    border-radius: 6px;
}

code {
    background-color: var(--code-bg-color) !important;
    color: var(--code-text-color) !important;
    padding: 2px 6px !important;
    border-radius: 4px !important;
    font-family: 'JetBrains Mono', 'Fira Code', 'Monaco', 'Consolas', monospace !important;
    font-weight: 400;
    font-size: 0.9em;
}

/* Listing blocks (most common code blocks in AsciiDoc) */
.listingblock pre,
.listingblock pre[class],
.listingblock .content pre,
.literalblock pre,
.literalblock pre[class],
.literalblock .content pre {
    background-color: var(--code-bg-color) !important;
    color: var(--code-text-color) !important;
    border: 1px solid #444 !important;
    padding: 1.2em !important;
    font-family: 'JetBrains Mono', 'Fira Code', 'Monaco', 'Consolas', monospace !important;
    font-weight: 400;
    line-height: 1.5;
    border-radius: 6px;
}

/* Source blocks */
.sourceblock pre,
.sourceblock .content pre {
    background-color: var(--code-bg-color) !important;
    color: var(--code-text-color) !important;
    font-family: 'JetBrains Mono', 'Fira Code', 'Monaco', 'Consolas', monospace !important;
}

/* Override any syntax highlighting that might interfere */
.listingblock .content,
.literalblock .content,
.sourceblock .content {
    background-color: var(--code-bg-color) !important;
}

/* Tables */
table {
    background-color: transparent !important;
    border-color: var(--table-border-color) !important;
    border-collapse: separate;
    border-spacing: 0;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
    color: #fafafa;
}

table.grid-all > * > tr > * {
    border-width: 1px;
    color: #fafafa;
}

table thead, table tfoot {
    background-color: var(--table-header-bg) !important;
    font-weight: 600;
}

table tr.even, table tr.alt, table tr:nth-of-type(even) {
    background: none;
}

table td, table th {
    border-color: var(--table-border-color) !important;
}

table tr th, table tr td {
    padding: .5625em .625em;
    font-size: inherit;
    color:#fafafa;
}

/* Blockquotes */
blockquote, .quoteblock {
    background-color: var(--quote-bg-color);
    /*color: #e0e0e0;*/
    border-left: 4px solid var(--quote-border-color) !important;
    font-style: italic;
    position: relative;
    padding: 1.5em !important;
    border-radius: 0 6px 6px 0;
}

blockquote::before {
    content: '"';
    font-size: 4em;
    color: var(--quote-border-color);
    position: absolute;
    top: -0.5em;
    left: 0.2em;
    font-family: Georgia, serif;
    opacity: 0.3;
}

/* Sidebars and panels */
.sidebarblock {
    background-color: #252525 !important;
    border: 1px solid #444 !important;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

.exampleblock > .content {
    background: linear-gradient(
            135deg,
            #252525 0%,
            #2e2b38 40%,
            #2b333d 100%
    ) !important;
    border: 1px solid #444 !important;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

/* Admonition blocks */
.admonitionblock > table td.icon {
    text-align: center;
    width: 80px;
}

.admonitionblock > table td.icon img {
    max-width: none;
}

.admonitionblock > table td.icon .title {
    font-weight: bold;
    text-transform: uppercase;
}

.admonitionblock > table td.content {
    padding-left: 1.125em;
    padding-right: 1.25em;
    border-left: 1px solid #444;
    color: #e0e0e0 !important;
    background: linear-gradient(
            135deg,
            #252525 0%,
            #2e2b38 40%,
            #2b333d 100%
    ) !important;
}

.admonitionblock.note > table td.icon {
    background-color: var(--admonition-note-bg) !important;
}

.admonitionblock.tip > table td.icon {
    background-color: var(--admonition-tip-bg) !important;
}

.admonitionblock.important > table td.icon {
    background-color: var(--admonition-important-bg) !important;
}

.admonitionblock.warning > table td.icon {
    background-color: var(--admonition-warning-bg) !important;
}

.admonitionblock.caution > table td.icon {
    background-color: var(--admonition-caution-bg) !important;
}

/* TOC - standard and left panel */
#toc, #toc.toc, #content #toc, #toc.toc2, #header .details, .sidebarblock, .listingblock, .literalblock, .imageblock {
    background-color: #252525 !important;
}

.tableblock {
    background: linear-gradient(
            135deg,
            #2a2a2a 0%,
            #2f2c3a 40%,
            #2c333a 100%
    ) !important;
}

#toc a, #toc.toc a, #content #toc a, #toc.toc2 a {
    color: var(--link-color) !important;
    text-decoration: none;
    transition: color 0.2s ease;
}

#toc a:hover, #toc.toc a:hover, #content #toc a:hover, #toc.toc2 a:hover {
    color: var(--link-hover-color) !important;
}

/* Left sidebar TOC */
.toc2 {
    background-color: #1a1a1a !important;
    border-right: 1px solid #444 !important;
    color: var(--text-color) !important;
    backdrop-filter: blur(10px);
}

body.toc2 {
    background-color: var(--bg-color) !important;
}

#toc.toc2 #toctitle {
    color: var(--heading-color) !important;
    font-family: 'Inter', sans-serif !important;
    font-weight: 600;
}

/* TOC list items */
#toc.toc2 ul.sectlevel0 > li > a, #toc.toc2 ul.sectlevel1 > li > a {
    color: var(--link-color) !important;
}

#toc.toc2 ul.sectlevel0 > li > a:hover, #toc.toc2 ul.sectlevel1 > li > a:hover {
    color: var(--link-hover-color) !important;
}

/* Current selection in TOC */
#toc.toc2 ul.sectlevel0 > li.active > a, #toc.toc2 ul.sectlevel1 > li.active > a {
    font-weight: bold;
    color: var(--heading-color) !important;
}

/* Footer */
#footer, #footer-text {
    color: #888 !important;
}

/* Horizontal rule */
hr {
    border-top: 1px solid #444 !important;
}

/* Mark the floating header anchors */
.anchor {
    color: var(--heading-color) !important;
}

/* Footnotes */
.footnote, .footnotes ol li {
    color: #bbb !important;
}

/* Keyboard/button shortcuts */
.keyseq {
    color: #ddd !important;
}

kbd {
    background-color: #333 !important;
    border: 1px solid #555 !important;
    color: #ddd !important;
}

/* Image borders */
.image img {
    border: none;
}

/* Print styles - ensure dark theme also works in print */
@media print {
    body {
        background-color: var(--bg-color) !important;
        color: var(--text-color) !important;
    }

    a, a:visited {
        color: var(--link-color) !important;
    }
}

/* Custom Site Palette Overrides */
:root {
    --bg-color: #000000; /* page background */
    --text-color: #f4f4f4; /* main text (light neutral) */
    --code-bg: #161413; /* code block background */
    --code-border: #2a2a2a; /* subtle border for code */

    /* brand code token colors */
    --code-color1: #9f77cd; /* purple */
    --code-color2: #3fd73c; /* green */
    --code-color3: #596f8c; /* blue-gray */
    --code-color4: #e9b306; /* amber/yellow */
    --code-color5: #ef4444; /* red */
    --code-fg: #f8f8f2; /* fallback default */
}

/* === TOC Tweaks === */

/* Hide the "Table of Contents" heading */
#toctitle {
    display: none !important;
}

/* Base TOC styling */
#toc {
    border-right: 1px solid #444;
    padding: 1rem;
    background-color: #161413; /* match your code bg or page bg */
}

#toc a {
    display: block;
    padding: 0.4rem 0.6rem;
    border-radius: 4px;
    color: #9f77cd !important; /* purple for links */
    text-decoration: none;
    transition: background-color 0.2s ease, color 0.2s ease;
}

#toc a:hover {
    background-color: #2a2a2a;
    color: #e9b306 !important; /* amber on hover */
}

/* Highlight the active section */
#toc li.active > a {
    background-color: #9f77cd !important; /* purple background */
    color: #161413 !important; /* dark text for contrast */
    font-weight: 600;
}


================================================
FILE: embabel-agent-docs/src/main/resources/themes/theme-extensions.css
================================================
/* Theme Extensions - Code Highlighting and Advanced Features
 * Contains syntax highlighting and advanced styling features
 */

/* ==== High-contrast code palette (override safely) ==== */
:root {
    /* tweak these with your site colors */
    --code-fg: #f8f8f2;
    --code-bg: #1f1f24; /* a hair lighter than #1e1e1e for separation */
    --code-border: #3d3d46;

    /* token colors (no "navy") */
    --code-kw: #ff79c6; /* keywords */
    --code-str: #f1fa8c; /* strings */
    --code-com: #8aa0c4; /* comments (brighter than #6272a4) */
    --code-num: #bd93f9; /* numbers/literals */
    --code-type: #8be9fd; /* class/type names */
    --code-fn: #50fa7b; /* function names */
    --code-meta: #ffb86c; /* annotations/@meta */
    --code-var: #e6e6e6; /* variables/identifiers */
    --gutter: 20px;
}

/* Source code highlighting - basic overrides */
.hljs {
    background-color: var(--code-bg-color) !important;
    font-family: 'JetBrains Mono', 'Fira Code', 'Monaco', 'Consolas', monospace !important;
}

/* Override any specific syntax highlighting themes */
.hljs, .hljs-subst {
    color: var(--code-text-color) !important;
}

/* Java-specific syntax highlighting fixes */
.hljs-annotation,
.hljs-meta {
    color: #ffb86c !important; /* Orange for annotations like @Override */
}

.hljs-keyword {
    color: #ff79c6 !important; /* Pink for keywords */
}

.hljs-string {
    color: #f1fa8c !important; /* Yellow for strings */
}

.hljs-comment {
    color: #6272a4 !important; /* Blue-gray for comments */
    font-style: italic;
}

.hljs-number {
    color: #bd93f9 !important; /* Purple for numbers */
}

.hljs-class .hljs-title,
.hljs-type {
    color: #8be9fd !important; /* Cyan for class names and types */
}

.hljs-function .hljs-title {
    color: #50fa7b !important; /* Green for function names */
}

.hljs-variable,
.hljs-name {
    color: #f8f8f2 !important; /* Light gray for variables */
}

.hljs-attr {
    color: #50fa7b !important; /* Green for attributes */
}

.hljs-symbol,
.hljs-bullet {
    color: #8be9fd !important; /* Cyan for symbols */
}

.hljs-built_in,
.hljs-builtin-name {
    color: #8be9fd !important; /* Cyan for built-ins */
}

.hljs-literal {
    color: #bd93f9 !important; /* Purple for literals */
}

.hljs-params {
    color: #ffb86c !important; /* Orange for parameters */
}

/* Generic syntax highlighting for non-hljs code */
.token.annotation,
.token.meta {
    color: #ffb86c !important;
}

.token.keyword {
    color: #ff79c6 !important;
}

.token.string {
    color: #f1fa8c !important;
}

.token.comment {
    color: #6272a4 !important;
    font-style: italic;
}

.token.number {
    color: #bd93f9 !important;
}

.token.class-name {
    color: #8be9fd !important;
}

.token.function {
    color: #50fa7b !important;
}

/* Callouts */
.conum[data-value] {
    background-color: rgba(80, 160, 250, 0.8) !important;
    color: #fff !important;
}

.conum[data-value] * {
    color: #fff !important;
}

/* Base code blocks */
pre,
.listingblock pre,
.literalblock pre,
.sourceblock pre,
pre code {
    background: var(--code-bg) !important;
    color: var(--code-fg) !important;
    border: 1px solid var(--code-border) !important;
    border-radius: 6px !important;
    overflow-x: auto;
}

/* Inline code */
code, tt {
    background: linear-gradient(
            to bottom,
            #9f77cd 0%,
            #7e64a7 100%
    ) !important;
    color: var(--code-fg) !important;
    border: 0;
    padding: 0.15em 0.4em !important;
    border-radius: 4px !important;
}

/* Inline code inside a quoteblock */
.quoteblock code,
.quoteblock .monospaced {
    background-color: #4b624b !important;
    padding: 0.15em 0.3em;
    border-radius: 3px;
}

/* ===== highlight.js ===== */
.hljs, .hljs-subst {
    color: var(--code-fg) !important;
    background: var(--code-bg) !important;
}

.hljs-keyword {
    color: var(--code-kw) !important;
}

.hljs-string {
    color: var(--code-str) !important;
}

.hljs-number, .hljs-literal {
    color: var(--code-num) !important;
}

.hljs-type, .hljs-class .hljs-title {
    color: var(--code-type) !important;
}

.hljs-function .hljs-title {
    color: var(--code-fn) !important;
}

.hljs-attr, .hljs-params {
    color: var(--code-meta) !important;
}

.hljs-comment, .hljs-quote {
    color: var(--code-com) !important;
    font-style: italic;
}

.hljs-variable, .hljs-name {
    color: var(--code-var) !important;
}

/* ===== Prism ===== */
.token.keyword {
    color: var(--code-kw) !important;
}

.token.string {
    color: var(--code-str) !important;
}

.token.number,
.token.boolean {
    color: var(--code-num) !important;
}

.token.class-name,
.token.type {
    color: var(--code-type) !important;
}

.token.function {
    color: var(--code-fn) !important;
}

.token.atrule,
.token.attr-name,
.token.attr-value {
    color: var(--code-meta) !important;
}

.token.comment {
    color: var(--code-com) !important;
    font-style: italic;
}

.token.variable {
    color: var(--code-var) !important;
}

/* ===== Rouge (default Asciidoctor HTML) ===== */
.rouge pre, pre.rouge {
    background: var(--code-bg) !important;
    color: var(--code-fg) !important;
}

.rouge .k, .rouge .kd, .rouge .kn, .rouge .kr {
    color: var(--code-kw) !important;
}

/* keywords */
.rouge .s, .rouge .sb, .rouge .sc, .rouge .s1,
.rouge .s2, .rouge .sh, .rouge .si, .rouge .sx {
    color: var(--code-str) !important;
}

/* strings */
.rouge .c, .rouge .c1, .rouge .cm, .rouge .cp {
    color: var(--code-com) !important;
    font-style: italic;
}

/* comments */
.rouge .mi, .rouge .mf, .rouge .mh, .rouge .il {
    color: var(--code-num) !important;
}

/* numbers */
.rouge .nc, .rouge .nn, .rouge .no, .rogue .nl {
    color: var(--code-type) !important;
}

/* classes/types */
.rouge .nf {
    color: var(--code-fn) !important;
}

/* functions */
.rouge .na, .rouge .nv, .rouge .vc, .rouge .vg {
    color: var(--code-var) !important;
}

/* variables */
.rouge .nd, .rouge .ne, .rouge .nt {
    color: var(--code-meta) !important;
}

/* meta/attrs */

/* ===== CodeRay (older setups) ===== */
.CodeRay {
    background: var(--code-bg) !important;
    color: var(--code-fg) !important;
}

.CodeRay .kw {
    color: var(--code-kw) !important;
}

.CodeRay .st {
    color: var(--code-str) !important;
}

.CodeRay .co {
    color: var(--code-com) !important;
    font-style: italic;
}

.CodeRay .i, .CodeRay .fl {
    color: var(--code-num) !important;
}

.CodeRay .dt, .CodeRay .ty {
    color: var(--code-type) !important;
}

.CodeRay .fu {
    color: var(--code-fn) !important;
}

.CodeRay .an, .CodeRay .re {
    color: var(--code-meta) !important;
}

.CodeRay .iv, .CodeRay .bk {
    color: var(--code-var) !important;
}

/* Ensure links inside code don't turn "navy" */
pre a, code a {
    color: #fafafa !important;
    text-decoration: underline;
}

/* ===== Operators & Punctuation (fix unreadable braces, = etc.) ===== */

/* highlight.js */
.hljs-operator,
.hljs-punctuation {
    color: var(--code-fg) !important; /* same as base text, but enforced */
    font-weight: 500;
}

/* Prism */
.token.operator,
.token.punctuation {
    color: var(--code-fg) !important;
}

/* Rouge */
.rouge .o, /* operators */
.rouge .p /* punctuation */
{
    color: var(--code-fg) !important;
    font-weight: 500;
}

/* CodeRay */
.CodeRay .op,
.CodeRay .dl, /* delimiters */
.CodeRay .sy /* symbols */
{
    color: var(--code-fg) !important;
    font-weight: 500;
}

/* ===== highlight.js / Prism / Rouge / CodeRay token mapping ===== */

/* Keywords, annotations */
.hljs-keyword,
.token.keyword,
.rouge .k,
.CodeRay .kw {
    color: var(--code-color1) !important; /* purple */
}

/* Strings */
.hljs-string,
.token.string,
.rouge .s,
.CodeRay .st {
    color: var(--code-color2) !important; /* green */
}

/* Comments */
.hljs-comment,
.token.comment,
.rouge .c,
.CodeRay .co {
    color: var(--code-color3) !important; /* blue-gray */
    font-style: italic;
}

/* Numbers, constants, literals */
.hljs-number,
.hljs-literal,
.token.number,
.token.boolean,
.rouge .mi,
.rouge .il,
.CodeRay .i,
.CodeRay .fl {
    color: var(--code-color4) !important; /* amber */
}

/* Function names, class names, important identifiers */
.hljs-function .hljs-title,
.token.function,
.rouge .nf,
.CodeRay .fu {
    color: var(--code-color2) !important; /* green (match strings) */
    font-weight: 500;
}

.hljs-type,
.hljs-class .hljs-title,
.token.class-name,
.rouge .nc,
.CodeRay .ty {
    color: var(--code-color1) !important; /* purple */
    font-weight: 500;
}

/* Rouge keyword variants */
.rouge .k, /* general keywords */
.rouge .kd, /* declaration keywords: class, var */
.rouge .kr, /* reserved keywords: return, public */
.rouge .kt { /* type keywords */
    color: #9f77cd !important; /* purple */
    font-weight: 500;
}

/* right gutter for readability */
#content {
    position: absolute;
    top: var(--header-height);
    bottom: 0;
    left: calc(var(--toc-width) + 25px);
    right: 0;
    width: auto;
    max-width: 100vw;
    min-width: 0;
    z-index: 950;
    overflow-y: auto;
    overflow-x: auto;
    background: #000;
    padding: 1.25rem 1.5rem 1.25rem 1.5rem;
    box-sizing: border-box;
    scrollbar-gutter: stable;
}
@media (max-width: 960px) {
    #content {
        left: 0;
        right: 0;
        width: 100vw;
        max-width: 100vw;
        min-width: 0;
        padding-left: 0.5rem;
        padding-right: 0.5rem;
    }
}

.listingblock,
    /*.literalblock { margin-right: var(--gutter); }*/

    /* outer panel */
.listingblock,
.literalblock {
    background: linear-gradient(
            135deg,
            #131313 0%,
            #181621 40%,
            #161c22 100%
    ) !important;
    border: 1px solid #2a2a2a !important;
    border-radius: 8px;
    padding: 0.75rem; /* space around code */
}

/* remove inner frame to kill the double border */
.listingblock > .content,
.literalblock > .content {
    background: transparent !important;
    border: 0 !important;
    box-shadow: none !important;
    padding: 0 !important;
}

/* code itself */
.listingblock pre,
.literalblock pre,
pre.highlight {
    background: #161413 !important;
    border: 0 !important; /* inner border gone */
    border-radius: 8px;
    padding: 1rem 1.25rem;
}

/* Remove the innermost "rim" on code samples (Spring adds an inset box-shadow) */
.doc .listingblock pre:not(.highlight),
.doc .literalblock pre,
.doc pre.highlight code {
    box-shadow: none !important; /* <- this is the culprit */
    border: 0 !important;
    outline: 0 !important;
}

/* Belt-and-suspenders: cover other highlighter wrappers too */
.highlight, .highlight pre, .highlight code,
.highlighter-rouge pre, .highlighter-rouge code,
.rouge pre, .rouge code,
pre.highlight, pre.highlight code {
    box-shadow: none !important;
    border: 0 !important;
    outline: 0 !important;
}

/* Keep your desired colors */
.listingblock pre,
.literalblock pre,
pre.highlight,
pre.highlight code {
    background: #161413 !important; /* inner code bg */
    border-radius: 8px !important;
}


/*!* Use font icons, not images/labels *!*/
/*.admonitionblock .icon img { display: none !important; }*/
/*.admonitionblock .icon i.fa {*/
/*    font-family: "FontAwesome" !important;  !* FA v4 *!*/
/*    font-style: normal;*/
/*    font-size: 1.15em;*/
/*    line-height: 1;*/
/*    background: none !important;*/
/*    filter: none !important;*/
/*}*/
/*.admonitionblock .icon i.fa::after { content: none !important; } !* kill "Tip" label overlays *!*/

/*!* Tidy the icon cell + overall block *!*/
/*.admonitionblock > table {*/
/*    background: #131313;                    !* outer panel to match site *!*/
/*    border: 1px solid #2a2a2a;*/
/*    border-radius: 10px;*/
/*}*/
/*.admonitionblock > table td.icon {*/
/*    width: 2.5rem;*/
/*    text-align: center;*/
/*    vertical-align: top;*/
/*    padding: .9rem .5rem .5rem .9rem;*/
/*    background: transparent !important;*/
/*    border: 0 !important;*/
/*}*/

/*!* Colors per type *!*/
/*.admonitionblock.tip .icon .fa       { color: #3fd73c; }  !* your green *!*/
/*.admonitionblock.note .icon .fa      { color: #9f77cd; }  !* your purple *!*/
/*.admonitionblock.important .icon .fa { color: #e9b306; }  !* amber *!*/
/*.admonitionblock.warning .icon .fa   { color: #ef4444; }  !* red *!*/
/*.admonitionblock.caution .icon .fa   { color: #ef4444; }  !* red *!*/

/*!* Content cell text color stays readable *!*/
/*.admonitionblock > table td.content {*/
/*    color: #e8e8e8;*/
/*    border-left: 1px solid #2a2a2a;*/
/*    padding: 1rem 1.25rem;*/
/*    background: transparent;*/
/*}*/

/* 1) Make sure ALL code has a readable default color on dark bg */
.listingblock pre,
.listingblock pre > code,
.literalblock pre,
.literalblock pre > code,
pre.highlight,
pre.rouge,
pre.highlight > code,
pre.rouge > code,
.highlight code {
    color: var(--code-text-color) !important;
}

/* 2) Booleans / null across Rouge class variants + add specificity */
.listingblock pre .kc, /* Keyword.Constant (often true/false/null) */
.listingblock pre .no, /* Name.Constant (some lexers) */
.listingblock pre .l, /* Literal (fallback in a few lexers) */
.listingblock pre .l-Keyword, /* Some Rouge themes emit subtypes */
pre.highlight .kc,
pre.highlight .no,
pre.highlight .l,
pre.rouge .kc,
pre.rouge .no,
pre.rouge .l {
    color: var(--code-color5) !important;
}

pre.rouge .nl {
    color: var(--code-type) !important;
    font-weight: bold;
}

colist td {
    padding: .25em 0;
    color: #fafafa;
}

.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow: none;cursor:default}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#e44d26}

.tableblock td:nth-child(1) {
    max-width: 25%;
    word-break: break-word;
    white-space: pre-wrap;
}

pre code a {
    color: #ffffff;   /* your desired link color */
    text-decoration: underline; /* optional */
}


/* ===== Theme scrollbar ===== */

/* Scrollbar with content theme style */
#content {
    overflow: auto;
}

#content::-webkit-scrollbar {
    width: 10px;
}

#content::-webkit-scrollbar-track {
    background: transparent;
    border-radius: 5px;
}

#content::-webkit-scrollbar-thumb {
    background: #7f8c8d;
    border-radius: 5px;
}

#content::-webkit-scrollbar-thumb:hover {
    background: #95a5a6;
}

/* Scrollbar with TOC theme style */
#toc {
    overflow: auto;
    scrollbar-color: transparent transparent;
}

#toc::-webkit-scrollbar-thumb {
    background: transparent;
    border-radius: 4px;
    transition: background 0.3s ease;
}

#toc:hover {
    scrollbar-color: #7f8c8d #34495e;
}

#toc:hover::-webkit-scrollbar-track {
    background: #34495e;
}

#toc:hover::-webkit-scrollbar-thumb {
    background: #7f8c8d;
}



================================================
FILE: embabel-agent-docs/.embabel/log.jsonl
================================================
{"request":"Modify the CSS to make it more modern looking and also fix the problem where code content and inline blocks render invisible","id":"CSS-MODERNIZATION-20250706","timestamp":"2025-07-06T12:00:00Z"}
{"request":"Make minimal changes to ensure that the <code> and listingblock elements appear visible in the documentation. Add display:block and visibility:visible CSS properties to the code and listingblock selectors.","id":"CSS-001","timestamp":"2025-07-06T12:00:00Z"}
{"request":"Make minimal changes to CSS to ensure that listingblock and <code> elements are visible not just whited out. Specifically:\n\n1. Check and update the CSS rules for `.listingblock pre`, `.listingblock pre[class]`, and inline `code` elements to ensure they have proper contrast and visibility.\n2. Add explicit color and background-color properties to inline `code` elements.\n3. Ensure that all code-related elements have `color: var(--code-text-color)` explicitly set.\n4. Add `!important` to visibility properties for code blocks to override any potential conflicting styles.\n5. Verify that inline code snippets within paragraphs are properly visible with sufficient contrast.","id":"CM-20250706-001","timestamp":"2025-07-06T12:00:00Z"}



================================================
FILE: embabel-agent-eval/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-parent</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-eval</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent Eval</name>
    <description>Assess of how Agent is doing on various tasks</description>

    <dependencies>
        <!-- Main Dependencies -->
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-api</artifactId>
        </dependency>

        <dependency>
            <groupId>com.embabel.common</groupId>
            <artifactId>embabel-common-textio</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-client-chat</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.data</groupId>
            <artifactId>spring-data-neo4j</artifactId>
        </dependency>

        <dependency>
           <groupId>org.jetbrains.kotlin</groupId>
           <artifactId>kotlin-compiler</artifactId>
        </dependency>

        <dependency>
            <groupId>org.jetbrains.kotlin</groupId>
            <artifactId>kotlin-scripting-compiler</artifactId>
        </dependency>

       <dependency>
            <groupId>org.jetbrains.kotlin</groupId>
            <artifactId>kotlin-scripting-common</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.jetbrains.kotlin</groupId>
            <artifactId>kotlin-scripting-jvm</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.jetbrains.kotlin</groupId>
            <artifactId>kotlin-scripting-jvm-host</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.jetbrains.kotlin</groupId>
            <artifactId>kotlin-script-runtime</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.jetbrains.kotlin</groupId>
            <artifactId>kotlin-scripting-jsr223</artifactId>
        </dependency>

        <!-- Test Dependencies -->
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-test-internal</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.jetbrains.kotlin</groupId>
                <artifactId>kotlin-maven-plugin</artifactId>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
            </plugin>

        </plugins>
    </build>
  

</project>



================================================
FILE: embabel-agent-eval/src/main/kotlin/com/embabel/agent/eval/AgentEvalApplication.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.eval

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication

@SpringBootApplication
class AgentEvalApplication

fun main(args: Array<String>) {
	runApplication<AgentEvalApplication>(*args)
}



================================================
FILE: embabel-agent-eval/src/main/kotlin/com/embabel/agent/eval/assert/Assertion.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.eval.assert

import com.fasterxml.jackson.annotation.JsonSubTypes
import com.fasterxml.jackson.annotation.JsonTypeInfo


@JsonTypeInfo(
    use = JsonTypeInfo.Id.DEDUCTION,
)
@JsonSubTypes(
    JsonSubTypes.Type(value = ObjectContextAssertion::class),
    JsonSubTypes.Type(value = CypherAssertion::class),
)
interface Assertion {
    val name: String
    val weight: Int
}

data class ObjectContextAssertion(
    val expression: String,
    override val weight: Int = 1,
) : Assertion {

    override val name: String
        get() = "ObjectContextAssertion: $expression"
}


data class CypherAssertion(
    val cypher: String,
    val expected: Any,
    override val weight: Int = 1,
) : Assertion {

    override val name: String
        get() = "CypherAssertion: $cypher"
}



================================================
FILE: embabel-agent-eval/src/main/kotlin/com/embabel/agent/eval/assert/AssertionEvaluator.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.eval.assert

import com.embabel.agent.eval.client.AgentChatClient
import com.embabel.agent.eval.config.ScriptEvaluationService
import com.embabel.agent.eval.support.*
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.data.neo4j.core.Neo4jClient
import org.springframework.stereotype.Service

@Service
class AssertionEvaluator(
    private val neo4jClient: Neo4jClient,
    private val agentChatClient: AgentChatClient,
    private val scriptEvaluationService: ScriptEvaluationService,
) : SetupRunner {

    private val logger: Logger = LoggerFactory.getLogger(AssertionEvaluator::class.java)

    override fun execute(setup: Setup) {
        when (setup) {
            is CypherSetup -> {
                logger.info("Running Cypher setup query: {}", setup.cypher)
                neo4jClient.query(setup.cypher).run()
            }

            else -> error("Unsupported setup type: ${setup::class.simpleName}")
        }
    }

    fun evaluate(
        evaluationInProgress: EvaluationInProgress,
        assertion: Assertion,
    ): Score {
        return when (assertion) {
            is ObjectContextAssertion -> {

                // Get the object context for the current session through a call to the agent server
                val objectContext = agentChatClient.getObjectContext(evaluationInProgress.sessionId)
                val result = scriptEvaluationService.evaluateExpression<Boolean>(
                    assertion.expression,
                    mapOf(
                        "objectContext" to objectContext,
                        "evaluation" to evaluationInProgress,
                    ),
                )
                val mark = if (result == true) "✅" else "❌"
                logger.info("{} Expression assertion={}: {}", mark, result, assertion.expression)

                Score(
                    score = if (result == true) 1.0 else 0.0,
                    scored = assertion.name,
                )
            }

            is CypherAssertion -> {
                try {
                    val result = neo4jClient
                        .query(assertion.cypher)
                        .fetchAs(String::class.java)
                        .one()
                        .orElseThrow()
                    val bool = result == "" + assertion.expected
                    val mark = if (bool) "✅" else "❌"
                    logger.info("{} Cypher assertion={}: {} from {}", mark, bool, result, assertion.cypher)
                    Score(
                        score = if (bool) 1.0 else 0.0,
                        scored = assertion.name,
                    )
                } catch (e: Exception) {
                    Score(
                        score = 0.0,
                        scored = assertion.name,
                    )
                }
            }

            else -> error("Unsupported assertion type: ${assertion::class.simpleName}")
        }
    }
}



================================================
FILE: embabel-agent-eval/src/main/kotlin/com/embabel/agent/eval/client/AgentChatClient.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.eval.client

import org.springframework.http.HttpEntity
import org.springframework.http.HttpHeaders
import org.springframework.http.HttpMethod
import org.springframework.stereotype.Service
import org.springframework.web.client.RestTemplate

data class KnowledgeContext(
    val name: String,
    val description: String,
    val schemaName: String = "personal",
    val id: String = name,
)

data class SessionCreationRequest(
    val user: String,
    val chatbot: String,
)

data class SessionCreationResponse(
    val sessionId: String,
)

/**
 * Simple client to Agent chat
 */
@Service
class AgentChatClient(
    private val restTemplate: RestTemplate = RestTemplate(),
    private val agentHost: String = "http://localhost:8081",
    private val agentChatPath: String = "/api/v1/chat",
    private val boogieHost: String = "http://localhost:8080",
    private val boogieContextPath: String = "/api/v1/graphs",
    private val apiKey: String = "treehorn",
) {

    // TODO share with the BoogieClient
    val defaultHeaders = HttpHeaders().apply {
        set("Content-Type", "application/json")
        set("X-API-KEY", apiKey)
    }

    fun createKnowledgeContext(knowledgeContext: KnowledgeContext): String {
        val entity = HttpEntity(knowledgeContext, defaultHeaders)
        return restTemplate.exchange(
            "${boogieHost}/${boogieContextPath}",
            HttpMethod.PUT,
            entity,
            String::class.java,
        ).body ?: throw IllegalStateException("No response body")
    }

    fun createSession(sessionCreationRequest: SessionCreationRequest): SessionCreationResponse {
        val url = "${agentHost}/${agentChatPath}/sessions"
        val entity = HttpEntity(sessionCreationRequest, defaultHeaders)
        val re = restTemplate.exchange(
            url,
            HttpMethod.PUT,
            entity,
            SessionCreationResponse::class.java,
        )
        return re.body ?: throw IllegalStateException("No response body")
    }

//    fun ingestDocument(knowledgeContext: KnowledgeContext): String {
//        val entity = HttpEntity(knowledgeContext, defaultHeaders)
//        return restTemplate.exchange(
//            "${boogieHost}/${boogieContextPath}",
//            HttpMethod.PUT,
//            entity,
//            String::class.java,
//        ).body ?: throw IllegalStateException("No response body")
//    }

    fun getObjectContext(id: String): ObjectContext {
        return restTemplate.getForObject(
            "${agentHost}/${agentChatPath}/objectContexts/{id}",
            ObjectContext::class.java,
            id,
        ) ?: throw IllegalStateException("No response body")
    }

    fun respond(chatRequest: ChatRequest): MessageResponse {
        val entity = HttpEntity(chatRequest)
        return restTemplate.exchange(
            "${agentHost}/${agentChatPath}/messages",
            HttpMethod.PUT,
            entity,
            MessageResponse::class.java,
        ).body ?: throw IllegalStateException("No response body")
    }

}



================================================
FILE: embabel-agent-eval/src/main/kotlin/com/embabel/agent/eval/client/ChatRequest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.eval.client

interface InSession {
    val sessionId: String
}

data class ChatRequest(
    override val sessionId: String,
    val message: OpenAiCompatibleMessage,
    val model: String,
) : InSession {

    constructor(sessionId: String, message: String, model: String) : this(
        sessionId = sessionId,
        message = SimpleOpenAiCompatibleMessage(
            content = message,
            role = MessageRole.user,
        ),
        model = model,
    )
}

/**
 * @param history List of previous messages in the conversation
 */
data class MessageResponse(
    override val sessionId: String,
    val chatbot: String,
    val message: OpenAiCompatibleMessage,
    val history: List<OpenAiCompatibleMessage>,
    val events: List<GenerationEvent>,
) : InSession {

    val systemPrompt: String get() = events.filterIsInstance<SystemPromptEvent>().firstOrNull()?.systemPrompt ?: ""
}



================================================
FILE: embabel-agent-eval/src/main/kotlin/com/embabel/agent/eval/client/GenerationEvent.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.eval.client

import com.fasterxml.jackson.annotation.JsonSubTypes
import com.fasterxml.jackson.annotation.JsonTypeInfo

@JsonTypeInfo(
    use = JsonTypeInfo.Id.DEDUCTION,
)
@JsonSubTypes(
    JsonSubTypes.Type(value = SystemPromptEvent::class),
    JsonSubTypes.Type(value = FunctionCallEvent::class),
    JsonSubTypes.Type(value = FunctionResponseEvent::class),
    JsonSubTypes.Type(value = BoogieRequestEvent::class),
)
sealed interface GenerationEvent

data class SystemPromptEvent(
    val systemPrompt: String
) : GenerationEvent

data class BoogieRequestEvent(
    val content: String,
    val summaryDirection: String?,
) : GenerationEvent

data class FunctionCallEvent(
    val request: FunctionCallRequest,
) : GenerationEvent

data class FunctionCallRequest(
    val function: FunctionIdentification,
    val arguments: Map<String, Any>,
    val context: String,
)

data class FunctionResponseEvent(
    val output: String,
) : GenerationEvent

data class FunctionIdentification(
    val name: String,
)



================================================
FILE: embabel-agent-eval/src/main/kotlin/com/embabel/agent/eval/client/ObjectContext.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.eval.client

data class ObjectContext(
    val context: String,
    val resources: List<Resource>,
    val functions: List<FunctionMetadata>,
) {
    fun infoString(): String {
        return "ObjectContext(context='$context', resources=${resources.map { it.infoString() }}, functions=${functions.map { it.name }})"
    }

    val entities
        get() : List<Resource> {
            return resources.filter { it.labels.contains("DomainNode") }
        }
}

data class Resource(
    val id: String,
    val name: String,
    val description: String = name,
    val properties: Map<String, Any?> = emptyMap(),
    val labels: Set<String> = emptySet(),
    val aliases: Set<String> = emptySet(),
) {

    fun infoString(): String {
        return labels.joinToString(":") + " {id='$id', name='$name', description='$description'}"
    }
}

data class FunctionMetadata(
    val name: String,
    val description: String,
    val label: String?,
    val view: String? = null,
    val staticMethod: Boolean = false,
//     val nonFunctionalProperties: NonFunctionalProperties = NonFunctionalProperties(),
    val inputTypeSchema: String,
)



================================================
FILE: embabel-agent-eval/src/main/kotlin/com/embabel/agent/eval/client/OpenAiCompatibleMessage.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.eval.client

import com.fasterxml.jackson.databind.annotation.JsonDeserialize

enum class MessageRole {
    user, assistant, system, tool
}

@JsonDeserialize(`as` = SimpleOpenAiCompatibleMessage::class)
interface OpenAiCompatibleMessage {
    val content: String
    val role: MessageRole
}

data class SimpleOpenAiCompatibleMessage(
    override val content: String,
    override val role: MessageRole,
) : OpenAiCompatibleMessage



================================================
FILE: embabel-agent-eval/src/main/kotlin/com/embabel/agent/eval/config/Config.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.eval.config

import com.embabel.common.textio.template.JinjavaTemplateRenderer
import com.embabel.common.textio.template.TemplateRenderer
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

@Configuration
class Config {

    @Bean
    fun templateRenderer(): TemplateRenderer {
        return JinjavaTemplateRenderer()
    }
}



================================================
FILE: embabel-agent-eval/src/main/kotlin/com/embabel/agent/eval/config/ScriptEvaluationService.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.eval.config

import org.springframework.stereotype.Service
import javax.script.ScriptEngineManager
import javax.script.SimpleBindings
import kotlin.script.experimental.annotations.KotlinScript
import kotlin.script.experimental.api.ScriptCompilationConfiguration
import kotlin.script.experimental.jvm.dependenciesFromCurrentContext
import kotlin.script.experimental.jvm.jvm

// This is your script definition
@KotlinScript(
    fileExtension = "kts",
    compilationConfiguration = AppScriptCompilationConfiguration::class // Make sure this is a compilation config
)
class AppScript(val context: Map<String, Any>)

// Compilation configuration (used in the KotlinScript annotation)
object AppScriptCompilationConfiguration : ScriptCompilationConfiguration({
    jvm {
        dependenciesFromCurrentContext(wholeClasspath = true)
    }
})

@Service
class ScriptEvaluationService {
    private val engine = ScriptEngineManager().getEngineByExtension("kts")

    init {
        if (engine == null) {
            throw IllegalStateException("Kotlin script engine not found. Make sure kotlin-scripting-jsr223 is in your classpath.")
        }
    }

    fun <T> evaluateExpression(expression: String, context: Map<String, Any>): T? {
        val bindings = SimpleBindings(context.toMutableMap())
        return try {
            @Suppress("UNCHECKED_CAST")
            engine.eval(expression, bindings) as T
        } catch (e: Exception) {
            println("Script evaluation error: ${e.message}")
            e.printStackTrace()
            null
        }
    }
}



================================================
FILE: embabel-agent-eval/src/main/kotlin/com/embabel/agent/eval/runner/DefaultEvaluationRunner.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.eval.runner

import com.embabel.agent.api.models.OpenAiModels
import com.embabel.agent.eval.assert.AssertionEvaluator
import com.embabel.agent.eval.client.*
import com.embabel.agent.eval.support.*
import com.embabel.common.textio.template.TemplateRenderer
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import org.slf4j.LoggerFactory
import org.springframework.ai.chat.client.ChatClient
import org.springframework.ai.chat.client.entity
import org.springframework.ai.chat.model.ChatModel
import org.springframework.ai.chat.prompt.ChatOptions
import org.springframework.ai.chat.prompt.Prompt
import org.springframework.retry.RetryCallback
import org.springframework.retry.RetryContext
import org.springframework.retry.RetryListener
import org.springframework.retry.support.RetryTemplateBuilder


private val SCORES_EXAMPLE = SubjectiveScores(
    tone = 0.5,
    tasks = listOf(
        Score("What is the capital of France?", 0.9),
        Score("Who was the first President of France", 0.4),
        Score("Tell me a joke", 0.7),
        Score("Tell me a story in 50 words", 0.6),
    ),
)

class DefaultEvaluationRunner(
    private val evaluatorChatModel: ChatModel,
    private val scoringChatModel: ChatModel = evaluatorChatModel,
    private val templateRenderer: TemplateRenderer,
    private val setupRunner: SetupRunner,
    private val assertionEvaluator: AssertionEvaluator,
    private val agentChatClient: AgentChatClient,
) : EvaluationRunner {

    private val logger = LoggerFactory.getLogger(DefaultEvaluationRunner::class.java)

    override fun evaluateConversation(
        evaluationJob: EvaluationJob,
        options: EvaluationOptions,
    ): EvaluationResults {
        evaluationJob.setups.forEach { setupRunner.execute(it) }
        val one = evaluateConversation(evaluationJob, options, supplyFacts = false)
        val two = evaluateConversation(evaluationJob, options, supplyFacts = true)
        return EvaluationResults(listOf(one, two))
    }

    private fun evaluateConversation(
        evaluationJob: EvaluationJob,
        options: EvaluationOptions,
        supplyFacts: Boolean,
    ): EvaluationResult {

        val session = agentChatClient.createSession(evaluationJob.target)
        val evaluationInProgress =
            EvaluationInProgress(
                sessionId = session.sessionId,
                job = evaluationJob,
                model = options.model,
            )
        val retryTemplate = RetryTemplateBuilder().maxAttempts(4).fixedBackoff(100)
            .withListener(object : RetryListener {
                override fun <T : Any?, E : Throwable?> onError(
                    context: RetryContext?,
                    callback: RetryCallback<T?, E?>?,
                    throwable: Throwable?,
                ) {
                    evaluationInProgress.recordFailure()
                }
            })
            .build()

        println("=".repeat(130))
        println("Beginning conversation evaluation: supplyFacts=$supplyFacts, sessionId=${session.sessionId}, model=${options.model}")
        println("=".repeat(130))

        val helloRequest = ChatRequest(
            sessionId = session.sessionId,
            message = evaluationJob.greetings.random(),
            model = options.model,
        )
        evaluationInProgress.addEvaluatorUserMessage(helloRequest.message.content, 0)
        println("${evaluationJob.evaluator.name}: ${helloRequest.message.content}")
        var (agentResponse, timeTakenMillis) = time {
            agentChatClient.respond(helloRequest)
        }
        evaluationInProgress.addAssistantMessage(
            content = agentResponse.message.content,
            timeTakenMillis = timeTakenMillis,
            events = agentResponse.events,
        )

        while (evaluationInProgress.transcript.size < evaluationJob.maxTurns) {
            if (options.verbose) {
                logEvents(agentResponse.events)
            }
            println("${agentResponse.chatbot}: ${agentResponse.message.content}")
            val (evaluatorReply, _) = time {
                generateEvaluatorReply(
                    evaluationInProgress = evaluationInProgress,
                    sessionId = session.sessionId,
                )
            }
            println("${evaluationJob.evaluator.name}: ${evaluatorReply.message.content}")
            if (evaluatorReply.message.content.contains(evaluationJob.evaluator.signoff, ignoreCase = true)) {
                println("=".repeat(130))
                println("Goals achieved: Scoring...")
                evaluationInProgress.done = true
                val assertionScores = evaluationJob.assertions.map {
                    assertionEvaluator.evaluate(evaluationInProgress = evaluationInProgress, assertion = it)
                }
                val subjectiveScores = scoreTranscript(evaluationInProgress)
                val evaluationResult = EvaluationResult(
                    job = if (supplyFacts) evaluationJob else evaluationJob.copy(facts = emptyList()),
                    subjectiveScores = subjectiveScores,
                    assertionScores = assertionScores,
                    transcript = evaluationInProgress.transcript,
                    factsSupplied = supplyFacts,
                    failureCount = evaluationInProgress.failureCount,
                )
                subjectiveScores.tasks.forEach {
                    val mark = if (it.score > .6) "✅" else "❌"
                    logger.info("{} Subjective assessment={}: {}", mark, it.score, it.scored)
                }
//                println(evaluationResult)
//                println(evaluationResult.responseTimes())
                return evaluationResult
            }
            val newTimingResult = time {
                retryTemplate.execute<MessageResponse, Throwable> {
                    agentChatClient.respond(evaluatorReply)
                }
            }
            agentResponse = newTimingResult.first
            timeTakenMillis = newTimingResult.second
            evaluationInProgress.addAssistantMessage(
                content = agentResponse.message.content,
                timeTakenMillis = timeTakenMillis,
                events = agentResponse.events,
            )
        }

        // Failure if we got here with timeout
        val assertionScores = evaluationJob.assertions.map {
            assertionEvaluator.evaluate(evaluationInProgress = evaluationInProgress, assertion = it)
        }
        return EvaluationResult(
            job = evaluationJob,
            aborted = true,
            subjectiveScores = scoreTranscript(evaluationInProgress),
            assertionScores = assertionScores,
            transcript = evaluationInProgress.transcript,
            failureCount = evaluationInProgress.failureCount,
            factsSupplied = supplyFacts,
        )
    }

    private fun logEvents(events: List<GenerationEvent>) {
        fun colorFor(event: GenerationEvent) = when (event) {
            is FunctionResponseEvent -> "\u001B[31m"  // Red
            is FunctionCallEvent -> "\u001B[33m"   // Yellow
            is SystemPromptEvent -> "\u001B[90m"  // Gray
            is BoogieRequestEvent -> "\u001B[32m"  // Green
        }
        events.forEach { event ->
            val color = colorFor(event)
            println("$color$event\u001B[0m")
        }
    }

    private fun generateEvaluatorReply(
        evaluationInProgress: EvaluationInProgress,
        sessionId: String,
    ): ChatRequest {
        val chatOptions = ChatOptions.builder()
            .model(OpenAiModels.GPT_41_MINI)
            .temperature(evaluationInProgress.job.evaluator.temperature)
            .build()
        val systemPrompt = templateRenderer.renderLoadedTemplate(
            evaluationInProgress.job.evaluator.prompt,
            mapOf(
                "config" to evaluationInProgress.job,
                "transcript" to evaluationInProgress.transcript,
            )
        )
//        println(systemPrompt)
        val timedChatResponse = time {
            evaluatorChatModel
                .call(Prompt(systemPrompt, chatOptions))
        }
        val reply = ChatRequest(
            sessionId = sessionId,
            message = timedChatResponse.first.result.output.text!!,
            model = evaluationInProgress.model,
        )
        evaluationInProgress.addEvaluatorUserMessage(
            content = reply.message.content,
            timeTakenMillis = timedChatResponse.second
        )
        return reply
    }

    private fun scoreTranscript(
        evaluationRun: EvaluationRun,
    ): SubjectiveScores {
        val scoringChatOptions = ChatOptions.builder()
            .temperature(evaluationRun.job.scorer.temperature)
            .build()
        val prompt = templateRenderer.renderLoadedTemplate(
            evaluationRun.job.scorer.prompt,
            mapOf(
                "config" to evaluationRun.job,
                "transcript" to evaluationRun.transcript,
                "example" to jacksonObjectMapper().registerModule(JavaTimeModule()).writerWithDefaultPrettyPrinter()
                    .writeValueAsString(SCORES_EXAMPLE),
            )
        )
        val chatClient = ChatClient
            .builder(scoringChatModel)
            .defaultOptions(scoringChatOptions)
            .build()
        return chatClient.prompt(prompt).call()
            .entity<SubjectiveScores>()
    }
}

fun <T> time(block: () -> T): Pair<T, Long> {
    val start = System.currentTimeMillis()
    val result = block()
    return Pair(result, System.currentTimeMillis() - start)
}



================================================
FILE: embabel-agent-eval/src/main/kotlin/com/embabel/agent/eval/runner/EvalApplicationRunner.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.eval.runner

import com.embabel.agent.api.models.OpenAiModels
import com.embabel.agent.eval.assert.AssertionEvaluator
import com.embabel.agent.eval.client.AgentChatClient
import com.embabel.agent.eval.support.DefaultEvaluationResultScorer
import com.embabel.agent.eval.support.EvaluationJob
import com.embabel.agent.eval.support.EvaluationOptions
import com.embabel.agent.eval.support.EvaluationRunner
import com.embabel.common.textio.template.TemplateRenderer
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.ai.chat.model.ChatModel
import org.springframework.beans.factory.annotation.Value
import org.springframework.boot.ApplicationArguments
import org.springframework.boot.ApplicationRunner
import org.springframework.stereotype.Component
import java.math.BigDecimal
import java.math.RoundingMode

/**
 * Command line to run evaluation of a conversation.
 */
@Component
class EvalApplicationRunner(
    private val evaluatorChatModel: ChatModel,
    private val templateRenderer: TemplateRenderer,
    private val assertionEvaluator: AssertionEvaluator,
    private val agentChatClient: AgentChatClient,
) : ApplicationRunner {

    private val logger: Logger = LoggerFactory.getLogger(EvalApplicationRunner::class.java)

    @Value("\${verbose:false}")
    private var verbose: Boolean = false

    @Value("\${file}")
    private var file: String = "data/eval/agent.yml"

    @Value("\${model}")
    private var model: String = OpenAiModels.GPT_41_MINI

    private val evaluationRunner: EvaluationRunner = DefaultEvaluationRunner(
        evaluatorChatModel = evaluatorChatModel,
        templateRenderer = templateRenderer,
        setupRunner = assertionEvaluator,
        assertionEvaluator = assertionEvaluator,
        agentChatClient = agentChatClient,
    )

    private val scorer = DefaultEvaluationResultScorer()

    override fun run(args: ApplicationArguments) {
        val file = "file:${System.getProperty("user.dir")}/$file"
        val evaluations = evaluationRunner.evaluateConversation(
            evaluationJob = EvaluationJob.fromYml(file),
            options = EvaluationOptions(
                verbose = verbose,
                model = model,
            )
        )
//        println(evaluations.report())

        val fullScores = evaluations.results.map { scorer.score(it) }

        val averageScore = fullScores.map { it.totalScore }.average()
        val roundedAverageScore = BigDecimal(averageScore).setScale(2, RoundingMode.HALF_EVEN).toDouble()

        logger.debug(fullScores.joinToString("\n"))

        println("****** Average score: $roundedAverageScore ******")

    }
}



================================================
FILE: embabel-agent-eval/src/main/kotlin/com/embabel/agent/eval/support/Evaluation.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.eval.support

import com.embabel.agent.eval.assert.Assertion
import com.embabel.agent.eval.client.GenerationEvent
import com.embabel.agent.eval.client.MessageRole
import com.embabel.agent.eval.client.OpenAiCompatibleMessage
import com.embabel.agent.eval.client.SessionCreationRequest
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory
import com.fasterxml.jackson.module.kotlin.registerKotlinModule
import org.slf4j.LoggerFactory
import org.springframework.core.io.DefaultResourceLoader
import org.springframework.core.io.ResourceLoader
import java.math.BigDecimal
import java.math.RoundingMode
import kotlin.math.max
import kotlin.math.min

data class Evaluator(
    val name: String = "Socrates",
    val voice: String = "You speak like a friendly, relaxed human",
    val prompt: String = "eval/socrates",
    val temperature: Double = 0.5,
    val signoff: String = "So Long, and Thanks for All the Fish",
)

data class Scorer(
    val prompt: String = "eval/score",
    val temperature: Double = 0.0,
)

enum class TaskType {
    question, task
}

data class Task(
    val type: TaskType = TaskType.task,
    val task: String,
    val acceptanceCriteria: String,
)

/**
 * Configuration for evaluating a conversation
 * @param evaluator the evaluator
 * @param tasks the tasks to perform
 * @param facts the facts to provide in response to questions
 * @param maxTurns the maximum number of turns in the conversation. Safeguard
 * @param assertions assertions to make after the conversation is done
 */
data class EvaluationJob(
    val evaluator: Evaluator,
    val aspirationalAverage: Long,
    val target: SessionCreationRequest,
    val scorer: Scorer = Scorer(),
    val maxTurns: Int = 20,
    val greetings: List<String> = listOf("Hello", "Hi", "Greetings", "Yo", "Hey"),
    val setups: List<Setup> = emptyList(),
    val tasks: List<Task>,
    val facts: List<String>,
    val assertions: List<Assertion> = emptyList(),
) {

    companion object {

        private val yom = ObjectMapper(YAMLFactory()).registerKotlinModule()

        fun fromYml(location: String, resourceLoader: ResourceLoader = DefaultResourceLoader()): EvaluationJob {
            return yom.readValue<EvaluationJob>(
                resourceLoader.getResource(location).inputStream, EvaluationJob::class.java
            )
        }
    }
}

/**
 * A score for a question or fact from 0-1
 */
data class Score(
    val scored: String,
    val score: Double,
)

/**
 * @param events events that occurred during generation. Only relevant for
 * assistant messages.
 */
data class TimedOpenAiCompatibleMessage(
    override val content: String,
    override val role: MessageRole,
    val timeTakenMillis: Long,
    val events: List<GenerationEvent>,
) : OpenAiCompatibleMessage

interface EvaluationRun {

    val job: EvaluationJob

    /**
     * @return transcript of messages with evaluator as user and Agent as assistant
     */
    val transcript: List<TimedOpenAiCompatibleMessage>
}

/**
 * LLM-generated scores for tasks
 */
data class SubjectiveScores(
    val tone: Double,
    val tasks: List<Score>,
) {

    fun averageTaskScore() = tasks.map { it.score }.average()
}

data class ResponseTimes(
    val responses: Int,
    val average: Int,
    val max: Int,
)

data class FullScores(
    val failureCount: Int,
    val subjectiveScores: SubjectiveScores,
    val assertionScores: List<Score>,
    val responseTimes: ResponseTimes,
    /**
     * Most meaningful score
     */
    val totalScore: Double,
)

interface EvaluationResultScorer {

    fun score(evaluationResult: EvaluationResult): FullScores
}

data class EvaluationResults(
    val results: List<EvaluationResult>,
) {

    fun report(): String {
        return results.joinToString("\n\n") { it.report() }
    }
}

data class EvaluationResult(
    override val job: EvaluationJob,
    val aborted: Boolean = false,
    val failureCount: Int,
    val subjectiveScores: SubjectiveScores,
    val assertionScores: List<Score>,
    override val transcript: List<TimedOpenAiCompatibleMessage>,
    val factsSupplied: Boolean,
) : EvaluationRun {

    fun assistantMessages() = transcript.filter { it.role == MessageRole.assistant }

    fun responseTimes(): ResponseTimes {
        val times = assistantMessages().map { it.timeTakenMillis }
        val average = if (times.isNotEmpty()) times.sum() / times.size else 0
        val max = times.maxOrNull() ?: 0
        return ResponseTimes(responses = assistantMessages().size, average = average.toInt(), max = max.toInt())
    }

    fun report(): String {
        return """|
            |Evaluation by ${job.evaluator.name}
            |${job.tasks.size} tasks, ${job.facts.size} facts, factsSupplied=$factsSupplied
            |${transcript.size} messages
            |$subjectiveScores
            |${assertionScores.joinToString("\n")}
            |Response times: ${responseTimes()}
        """.trimMargin()
    }

}

data class EvaluationOptions(
    val verbose: Boolean,
    val model: String,
)

interface EvaluationRunner {

    fun evaluateConversation(
        evaluationJob: EvaluationJob,
        options: EvaluationOptions,
    ): EvaluationResults
}

class DefaultEvaluationResultScorer : EvaluationResultScorer {

    private val logger = LoggerFactory.getLogger(DefaultEvaluationResultScorer::class.java)

    override fun score(evaluationResult: EvaluationResult): FullScores {
        val timingScore = min(
            1.0,
            evaluationResult.job.aspirationalAverage.toDouble() / evaluationResult.responseTimes().average.toDouble(),
        )
        val taskScore = evaluationResult.subjectiveScores.averageTaskScore()
        val assertionTotal = evaluationResult.job.assertions.sumOf { it.weight }
        val assertionScore =
            evaluationResult.assertionScores.sumOf {
                it.score * evaluationResult.job.assertions.single { a -> a.name == it.scored }.weight
            } / assertionTotal
        val failurePenalty = min(evaluationResult.failureCount * .3, 0.5)
        val overallScore = max(0.0, (timingScore + taskScore * 2.0 + assertionScore * 4.0) / 7.0 - failurePenalty)
        logger.info("Timing score: $timingScore, task score: $taskScore, assertion score: $assertionScore, failure penalty: $failurePenalty, overall score: $overallScore")
        return FullScores(
            subjectiveScores = evaluationResult.subjectiveScores,
            assertionScores = evaluationResult.assertionScores,
            responseTimes = evaluationResult.responseTimes(),
            totalScore = BigDecimal(overallScore).setScale(2, RoundingMode.HALF_EVEN).toDouble(),
            failureCount = evaluationResult.failureCount,
        )
    }
}



================================================
FILE: embabel-agent-eval/src/main/kotlin/com/embabel/agent/eval/support/EvaluationInProgress.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.eval.support

import com.embabel.agent.eval.client.FunctionCallEvent
import com.embabel.agent.eval.client.GenerationEvent
import com.embabel.agent.eval.client.MessageRole


data class EvaluationInProgress(
    val sessionId: String,
    val model: String,
    override val job: EvaluationJob,
    private val _transcript: MutableList<TimedOpenAiCompatibleMessage> = mutableListOf(),
    var done: Boolean = false,
    private var _failures: Int = 0,
) : EvaluationRun {

    fun recordFailure() {
        _failures++
    }

    val failureCount get() = _failures

    /**
     * All events we've seen
     */
    val events: List<GenerationEvent>
        get() =
            _transcript.flatMap { it.events }

    data class FunctionCall(val function: String, val args: Map<String, Any>)

    val functionCalls
        get(): List<FunctionCall> =
            events.filterIsInstance<FunctionCallEvent>()
                .map { FunctionCall(it.request.function.name, it.request.arguments) }

    override val transcript: List<TimedOpenAiCompatibleMessage>
        get() = _transcript

    internal fun addEvaluatorUserMessage(content: String, timeTakenMillis: Long) {
        _transcript.add(
            TimedOpenAiCompatibleMessage(
                content = content,
                role = MessageRole.user,
                timeTakenMillis = timeTakenMillis,
                events = emptyList(),
            )
        )
    }

    internal fun addAssistantMessage(content: String, timeTakenMillis: Long, events: List<GenerationEvent>) {
        _transcript.add(
            TimedOpenAiCompatibleMessage(
                content = content,
                role = MessageRole.assistant,
                timeTakenMillis = timeTakenMillis,
                events = events,
            )
        )
    }
}



================================================
FILE: embabel-agent-eval/src/main/kotlin/com/embabel/agent/eval/support/Setup.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.eval.support

import com.fasterxml.jackson.annotation.JsonSubTypes
import com.fasterxml.jackson.annotation.JsonTypeInfo


@JsonTypeInfo(
    use = JsonTypeInfo.Id.DEDUCTION,
)
@JsonSubTypes(
    JsonSubTypes.Type(value = CypherSetup::class),
)
interface Setup


data class CypherSetup(
    val cypher: String,
) : Setup

interface SetupRunner {
    fun execute(setups: Setup)
}



================================================
FILE: embabel-agent-eval/src/main/resources/application.properties
================================================
spring.application.name=agent-eval

spring.main.web-application-type=none

spring.ai.openai.api-key=${OPENAI_API_KEY}

spring.neo4j.uri=${NEO_URI:bolt://neo4j@localhost:7687}
spring.neo4j.authentication.username=${NEO_USERNAME:neo4j}
spring.neo4j.authentication.password=${NEO_PASSWORD:brahmsian}





================================================
FILE: embabel-agent-eval/src/main/resources/prompts/eval/score.jinja
================================================
Your job is to score an assistant's performance in a conversation with a user
and return the specified JSON object.

Score between 0-1 for each axis, where 0 is the worst and 1 is the best.

Score on the following axes:

tone: Was the assistant's tone appropriate for the user's questions?

How well did the assistant perform the following tasks:
{% for task in config.tasks %}
    - {{ task.type }}: "{{ task.task }}". Score against the following acceptance criteria:
    {{ task.acceptanceCriteria }}

{% endfor %}


# Example
Here's an example of the desired output;

{{ example|esc }}


# Reference

The following facts are ground truth to help in your evaluation:
{% for fact in config.facts %}
    - {{ fact }}
{% endfor %}

## Conversation to evaluate

{% for message in transcript %}
    - {{ message.role }}: {{ message.content }}
{% endfor %}




================================================
FILE: embabel-agent-eval/src/main/resources/prompts/eval/socrates.jinja
================================================
You are posing as a user talking to an assistant to conduct a conversation that will later be evaluated.
You speak like a person, not an assistant.
Your job is to ask questions and seek the completion of tasks, not to perform tasks yourself.

# Data sharing rules: Important

Everything within XML style
<secret/> tags is private to you and should not be included in a messages
under any circumstances.

Everything within
<onlyIfAsked/> tags
should not be included in a completion unless the assistant has specifically requested
that information.

# How to conduct the conversation

Ask the assistant to answer the following tasks, in order.
Ask the assistant to perform the tasks one at a time. Do not combine in one question.
Do not repeat a question if it has already been answered satisfactorily by the assistant.

{% for task in config.tasks %}
    - {{ task.type }}: {{ task.task }}
    {#    <secret>Acceptance criteria:#}
    {#        {{ task.acceptanceCriteria }}</secret>#}
{% endfor %}

Ask follow-ups if you need clarification before moving onto the next task.
Ask in a natural way, not all at once.

# Termination

If all tasks have been completed to your satisfaction, end the conversation
with the following literal message: "{{ config.evaluator.signoff }}"

# Answers to possible questions

<onlyIfAsked>
    Only if asked, provide the following facts:
    {% for fact in config.facts %}
        - {{ fact }}
    {% endfor %}
</onlyIfAsked>


IMPORTANT: You must not volunteer these facts in the conversation unless the assistant asks for them.

## Conversation so far:

Complete with the next message.

{% for message in transcript %}
    > {{ message.role }}: {{ message.content }}
{% endfor %}

{{ config.evaluator.voice }}



================================================
FILE: embabel-agent-eval/src/test/kotlin/com/embabel/agent/eval/AgentEvalApplicationTests.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.eval

import org.junit.jupiter.api.Disabled
import org.junit.jupiter.api.Test
import org.springframework.boot.test.context.SpringBootTest

@Disabled("This test is disabled until integration with Agent API are completed.")
@SpringBootTest
class AgentEvalApplicationTests {

	@Test
	fun contextLoads() {
	}

}



================================================
FILE: embabel-agent-eval/src/test/kotlin/com/embabel/agent/eval/config/ScriptEvaluationServiceTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.eval.config

import com.embabel.agent.eval.client.ObjectContext
import com.embabel.agent.eval.client.Resource
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test

class ScriptEvaluationServiceTest {

    @Test
    fun `simple math expression`() {
        val scriptEvaluationService = ScriptEvaluationService()
        val context = mapOf("a" to 1, "b" to 2)
        val expression = "a + b"
        val result = scriptEvaluationService.evaluateExpression<Int>(expression, context)
        assertEquals(3, result)
    }

    @Test
    fun `object context expression`() {
        val scriptEvaluationService = ScriptEvaluationService()
        val oc = ObjectContext(
            context = "test",
            resources = listOf(Resource(name = "name", labels = setOf("Thing"), id = "id")),
            functions = emptyList(),
        )
        val context = mapOf("objectContext" to oc)
        val expression = "objectContext != null && objectContext.resources.size == 1"
        val result = scriptEvaluationService.evaluateExpression<Boolean>(
            expression,
            context,
        )
        assertEquals(true, result)
    }

}



================================================
FILE: embabel-agent-mcpserver/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-parent</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-mcpserver</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent MCP Server</name>
    <description>Discover and Export available Agent(s) as an MCP Servers</description>

    <dependencies>        
        <!-- Main Dependencies -->
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-api</artifactId>
        </dependency>
        
        <dependency>
            <groupId>com.embabel.common</groupId>
            <artifactId>embabel-common-core</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.ai</groupId>
            <artifactId>spring-ai-starter-mcp-server-webmvc</artifactId>
        </dependency>

        <!-- Test Dependencies -->
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-test-internal</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.jetbrains.kotlin</groupId>
                <artifactId>kotlin-maven-plugin</artifactId>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
            </plugin>

        </plugins>
    </build>

</project>


================================================
FILE: embabel-agent-mcpserver/src/main/kotlin/com/embabel/agent/mcpserver/AbstractMcpServerConfiguration.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver

import com.embabel.agent.mcpserver.domain.McpExecutionMode
import com.embabel.agent.mcpserver.domain.ServerInfo
import com.embabel.agent.mcpserver.domain.ToolSpecification
import com.embabel.agent.spi.support.AgentScanningBeanPostProcessorEvent
import org.slf4j.Logger
import org.springframework.ai.tool.ToolCallbackProvider
import org.springframework.ai.tool.annotation.Tool
import org.springframework.context.ConfigurableApplicationContext
import org.springframework.context.event.EventListener
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

/**
 * Abstract base configuration for MCP server modes (sync/async).
 *
 * Implements the template method pattern to share initialization logic
 * between sync and async server configurations. Handles tool, resource,
 * and prompt exposure, and provides hooks for subclass customization.
 *
 * @property applicationContext the Spring application context
 */
abstract class AbstractMcpServerConfiguration(
    protected val applicationContext: ConfigurableApplicationContext,
) {

    // Subclasses should set this so they don't get CGLIB proxy names
    protected abstract val logger: Logger

    /**
     * Event listener that triggers MCP server initialization after agent scanning.
     *
     * Initializes the server by exposing tools, resources, and prompts
     * using the strategy provided by the subclass.
     */
    @EventListener(AgentScanningBeanPostProcessorEvent::class)
    fun exposeMcpFunctionality() {
        val strategy = createServerStrategy()
        val separator = createLogSeparator()

        logger.info("\n$separator\nInitializing ${strategy.executionMode} MCP Server\n$separator")

        try {
            initializeServer(strategy)
                .doOnSuccess {
                    logger.info("${strategy.executionMode} MCP Server initialization completed successfully")
                }
                .doOnError { error ->
                    logger.error("${strategy.executionMode} MCP Server initialization failed", error)
                }
                .subscribe()
        } catch (e: Exception) {
            logger.error("Failed to initialize MCP server", e)
        }
    }

    /**
     * Initializes the MCP server by cleaning up tools and exposing new ones.
     *
     * @param strategy the server strategy for sync or async mode
     * @return a [Mono] signaling completion
     */
    private fun initializeServer(strategy: McpServerStrategy): Mono<Void> {
        return cleanupExistingTools(strategy)
            .then(exposeTools(strategy))
            .then(exposeResources(strategy))
            .then(exposePrompts(strategy))
    }

    /**
     * Removes existing tools except those that should be preserved.
     *
     * @param strategy the server strategy
     * @return a [Mono] signaling completion
     */
    private fun cleanupExistingTools(strategy: McpServerStrategy): Mono<Void> {
        val toolRegistry = strategy.getToolRegistry()
        val toolsToRemove = toolRegistry.getToolNames()
            .filter { !shouldPreserveTool(it) }

        if (toolsToRemove.isNotEmpty()) {
            logger.debug("Removing {} existing tools: {}", toolsToRemove.size, toolsToRemove.joinToString(", "))

            return Flux.fromIterable(toolsToRemove)
                .flatMap { toolName ->
                    strategy.removeTool(toolName)
                        .doOnError { error ->
                            logger.warn("Failed to remove tool '$toolName'", error)
                        }
                        .onErrorResume { Mono.empty() } // Continue with other tools
                }
                .then()
        }

        return Mono.empty()
    }

    /**
     * Exposes application tools to the MCP server.
     *
     * @param strategy the server strategy
     * @return a [Mono] signaling completion
     */
    private fun exposeTools(strategy: McpServerStrategy): Mono<Void> {
        val toolPublishers = getToolPublishers()
        val allTools = toolPublishers.flatMap { it.toolCallbacks }

        logger.info("Exposing {} tools from {} publishers", allTools.size, toolPublishers.size)

        return Flux.fromIterable(convertToToolSpecifications(allTools))
            .flatMap { toolSpec ->
                strategy.addTool(toolSpec)
                    .doOnSuccess {
                        logger.debug("Added tool: ${getToolName(toolSpec)}")
                    }
                    .doOnError { error ->
                        logger.error("Failed to add tool: ${getToolName(toolSpec)}", error)
                    }
                    .onErrorResume { Mono.empty() } // Continue with other tools
            }
            .then()
    }

    /**
     * Exposes application resources to the MCP server.
     *
     * @param strategy the server strategy
     * @return a [Mono] signaling completion
     */
    private fun exposeResources(strategy: McpServerStrategy): Mono<Void> {
        val resourcePublishers = getResourcePublishers()
        val allResources = resourcePublishers.flatMap { publisher ->
            when (publisher) {
                is com.embabel.agent.mcpserver.sync.McpResourcePublisher -> publisher.resources()
                is com.embabel.agent.mcpserver.async.McpAsyncResourcePublisher -> publisher.resources()
                else -> emptyList()
            }
        }

        logger.info("Exposing {} resources from {} publishers", allResources.size, resourcePublishers.size)

        return Flux.fromIterable(allResources)
            .flatMap { resourceSpec ->
                strategy.addResource(resourceSpec)
                    .doOnSuccess {
                        logger.debug("Added resource: ${getResourceName(resourceSpec)}")
                    }
                    .doOnError { error ->
                        logger.error("Failed to add resource: ${getResourceName(resourceSpec)}", error)
                    }
                    .onErrorResume { Mono.empty() } // Continue with other resources
            }
            .then()
    }

    /**
     * Exposes application prompts to the MCP server.
     *
     * @param strategy the server strategy
     * @return a [Mono] signaling completion
     */
    private fun exposePrompts(strategy: McpServerStrategy): Mono<Void> {
        val promptPublishers = getPromptPublishers()
        val allPrompts = promptPublishers.flatMap { publisher ->
            when (publisher) {
                is com.embabel.agent.mcpserver.sync.McpPromptPublisher -> publisher.prompts()
                is com.embabel.agent.mcpserver.async.McpAsyncPromptPublisher -> publisher.prompts()
                else -> emptyList()
            }
        }

        logger.info("Exposing {} prompts from {} publishers", allPrompts.size, promptPublishers.size)

        return Flux.fromIterable(allPrompts)
            .flatMap { promptSpec ->
                strategy.addPrompt(promptSpec)
                    .doOnSuccess {
                        logger.debug("Added prompt: ${getPromptName(promptSpec)}")
                    }
                    .doOnError { error ->
                        logger.error("Failed to add prompt: ${getPromptName(promptSpec)}", error)
                    }
                    .onErrorResume { Mono.empty() } // Continue with other prompts
            }
            .then()
    }

    /**
     * Creates the server strategy for sync or async mode.
     *
     * @return a [McpServerStrategy] instance
     */
    abstract fun createServerStrategy(): McpServerStrategy

    /**
     * Creates the banner tool callback provider.
     *
     * @return a [ToolCallbackProvider] instance
     */
    abstract fun createBannerTool(): ToolCallbackProvider

    /**
     * Retrieves all tool publishers registered in the application context.
     *
     * @return a list of [McpToolExportCallbackPublisher] beans
     */
    abstract fun getToolPublishers(): List<McpToolExportCallbackPublisher>

    /**
     * Retrieves all resource publishers registered in the application context.
     *
     * @return a list of resource publisher beans (sync or async)
     */
    abstract fun getResourcePublishers(): List<Any> // Can be sync or async publishers

    /**
     * Retrieves all prompt publishers registered in the application context.
     *
     * @return a list of prompt publisher beans (sync or async)
     */
    abstract fun getPromptPublishers(): List<Any> // Can be sync or async publishers

    /**
     * Converts tool callback objects to tool specifications for the server.
     *
     * @param toolCallbacks a list of tool callback objects
     * @return a list of tool specifications
     */
    abstract fun convertToToolSpecifications(toolCallbacks: List<Any>): List<Any>

    /**
     * Determines if a tool should be preserved during cleanup.
     *
     * @param toolName the name of the tool
     * @return `true` if the tool should be preserved, otherwise `false`
     */
    protected open fun shouldPreserveTool(toolName: String): Boolean = toolName == "helloBanner"

    /**
     * Creates a log separator string for initialization logs.
     *
     * @return a separator string
     */
    protected open fun createLogSeparator(): String = "~ MCP ${getExecutionMode()} " + "~".repeat(40)

    /**
     * Returns the execution mode for this configuration.
     *
     * @return the execution mode string
     */
    protected abstract fun getExecutionMode(): String

    /**
     * Helper to extract the tool name from a specification.
     *
     * @param toolSpec the tool specification object
     * @return the tool name or "Unknown Tool"
     */
    private fun getToolName(toolSpec: Any): String {
        return when (toolSpec) {
            is ToolSpecification<*> -> toolSpec.toolName()
            else -> "Unknown Tool"
        }
    }

    /**
     * Helper to extract the resource name from a specification.
     *
     * @param resourceSpec the resource specification object
     * @return the resource name or "Unknown Resource"
     */
    private fun getResourceName(resourceSpec: Any): String {
        return when (resourceSpec) {
            is io.modelcontextprotocol.server.McpServerFeatures.SyncResourceSpecification -> resourceSpec.resource()
                .name()

            is io.modelcontextprotocol.server.McpServerFeatures.AsyncResourceSpecification -> resourceSpec.resource()
                .name()

            else -> "Unknown Resource"
        }
    }

    /**
     * Helper to extract the prompt name from a specification.
     *
     * @param promptSpec the prompt specification object
     * @return the prompt name or "Unknown Prompt"
     */
    private fun getPromptName(promptSpec: Any): String {
        return when (promptSpec) {
            is io.modelcontextprotocol.server.McpServerFeatures.SyncPromptSpecification -> promptSpec.prompt().name()
            is io.modelcontextprotocol.server.McpServerFeatures.AsyncPromptSpecification -> promptSpec.prompt().name()
            else -> "Unknown Prompt"
        }
    }
}

/**
 * Unified banner tool for displaying server information.
 *
 * Works for both sync and async server modes.
 *
 * @property serverInfo information about the current server instance
 */
class UnifiedBannerTool(private val serverInfo: ServerInfo) {

    /**
     * Displays a welcome banner with server information.
     *
     * @return a map containing banner details
     */
    @Tool(
        description = "Display a welcome banner with server information"
    )
    fun helloBanner(): Map<String, Any> {
        return mapOf(
            "type" to "banner",
            "mode" to serverInfo.mode.toString(),
            "lines" to serverInfo.toBannerLines()
        )
    }
}

/**
 * Factory for creating [ServerInfo] instances.
 */
object ServerInfoFactory {
    fun create(mode: McpExecutionMode): ServerInfo {
        return ServerInfo(
            name = "Embabel Agent MCP Server",
            version = ServerInfoFactory::class.java.`package`.implementationVersion ?: "development",
            mode = mode,
            javaVersion = System.getProperty("java.runtime.version")
        )
    }
}



================================================
FILE: embabel-agent-mcpserver/src/main/kotlin/com/embabel/agent/mcpserver/McpServerStrategy.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver

import com.embabel.agent.mcpserver.domain.McpExecutionMode
import reactor.core.publisher.Mono

/**
 * Strategy interface for managing MCP server functionality.
 *
 * Defines operations for adding and removing tools, resources, and prompts,
 * as well as accessing the tool registry. Implementations provide logic
 * for different execution modes (e.g., sync or async).
 *
 * @property executionMode the execution mode of the MCP server
 */
interface McpServerStrategy {
    /**
     * The execution mode for this strategy (e.g., SYNC or ASYNC).
     */
    val executionMode: McpExecutionMode

    /**
     * Adds a tool specification to the MCP server.
     *
     * @param toolSpec the tool specification object
     * @return a [Mono] signaling completion
     */
    fun addTool(toolSpec: Any): Mono<Void>

    /**
     * Removes a tool from the MCP server by name.
     *
     * @param toolName the name of the tool to remove
     * @return a [Mono] signaling completion
     */
    fun removeTool(toolName: String): Mono<Void>

    /**
     * Adds a resource specification to the MCP server.
     *
     * @param resourceSpec the resource specification object
     * @return a [Mono] signaling completion
     */
    fun addResource(resourceSpec: Any): Mono<Void>

    /**
     * Adds a prompt specification to the MCP server.
     *
     * @param promptSpec the prompt specification object
     * @return a [Mono] signaling completion
     */
    fun addPrompt(promptSpec: Any): Mono<Void>

    /**
     * Returns the tool registry for the MCP server.
     *
     * @return a [ToolRegistry] instance
     */
    fun getToolRegistry(): ToolRegistry
}



================================================
FILE: embabel-agent-mcpserver/src/main/kotlin/com/embabel/agent/mcpserver/McpToolExportCallbackPublisher.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver

import com.embabel.agent.core.ToolCallbackPublisher
import com.embabel.common.core.types.HasInfoString

/**
 * Tag interface extending Spring AI ToolCallbackProvider
 * that identifies tool callbacks that our MCP server exposes.
 * Will only export tools with Export(remote = true) defined.
 */
interface McpToolExportCallbackPublisher : ToolCallbackPublisher, HasInfoString



================================================
FILE: embabel-agent-mcpserver/src/main/kotlin/com/embabel/agent/mcpserver/ToolRegistry.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver

/**
 * Registry interface for managing tools in the MCP server.
 *
 * Provides methods to access tool names, count, and existence checks.
 * Implementations should supply logic for synchronous or asynchronous modes.
 */
interface ToolRegistry {
    /**
     * Returns a list of tool names registered in the server.
     *
     * @return a list of tool names
     */
    fun getToolNames(): List<String>

    /**
     * Returns the number of tools registered in the server.
     *
     * @return the count of tools
     */
    fun getToolCount(): Int

    /**
     * Checks if a tool with the given name exists in the server.
     *
     * @param name the name of the tool to check
     * @return `true` if the tool exists, otherwise `false`
     */
    fun hasToolNamed(name: String): Boolean
}



================================================
FILE: embabel-agent-mcpserver/src/main/kotlin/com/embabel/agent/mcpserver/async/AsyncToolRegistry.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.async

import com.embabel.agent.mcpserver.ToolRegistry
import com.embabel.agent.mcpserver.support.toolNames
import io.modelcontextprotocol.server.McpAsyncServer

/**
 * Registry for managing tools in an asynchronous MCP server.
 *
 * Provides access to tool names, counts, and existence checks
 * by delegating to the underlying `McpAsyncServer` instance.
 *
 * @param server the asynchronous MCP server instance
 */
class AsyncToolRegistry(private val server: McpAsyncServer) : ToolRegistry {

    /**
     * Returns the list of tool names available in the async server.
     *
     * Delegates to the server's `toolNames()` method.
     *
     * @return a list of tool names
     */
    override fun getToolNames(): List<String> {
        return server.toolNames()
    }

    /**
     * Returns the total number of tools registered in the async server.
     *
     * @return the count of tools
     */
    override fun getToolCount(): Int = getToolNames().size

    /**
     * Checks if a tool with the specified name exists in the async server.
     *
     * @param name the name of the tool to check
     * @return `true` if the tool exists, `false` otherwise
     */
    override fun hasToolNamed(name: String): Boolean = getToolNames().contains(name)

}



================================================
FILE: embabel-agent-mcpserver/src/main/kotlin/com/embabel/agent/mcpserver/async/McpAsyncPromptFactory.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.async

import com.embabel.agent.mcpserver.support.argumentsFromType
import com.embabel.common.core.types.Described
import com.embabel.common.core.types.Named
import com.embabel.common.core.types.Timestamped
import io.modelcontextprotocol.server.McpServerFeatures
import io.modelcontextprotocol.spec.McpSchema
import reactor.core.publisher.Mono

/**
 * Create Prompt specifications for the MCP server.
 *
 * @param excludedInterfaces Set of interfaces whose fields should be excluded from the prompt arguments.
 */
class McpAsyncPromptFactory(
    val excludedInterfaces: Set<Class<*>> = setOf(
        Timestamped::class.java,
    ),
) {

    /**
     * Creates a synchronous prompt specification for a given type.
     *
     * @param goal The goal for which the prompt is created.
     * @param inputType The class type of the
     * @param inputType The class type of the input for the prompt.
     * @param name The name of the prompt if we want to customize it
     * @param description A description of the prompt if we want to customize it
     */
    fun <G> asyncPromptSpecificationForType(
        goal: G,
        inputType: Class<*>,
        name: String = goal.name,
        description: String = goal.description,
    ): McpServerFeatures.AsyncPromptSpecification where G : Named, G : Described {
        return McpServerFeatures.AsyncPromptSpecification(
            McpSchema.Prompt(
                "${inputType.simpleName}_$name",
                description,
                argumentsFromType(excludedInterfaces, inputType),
            )
        ) { asyncServerExchange, getPromptRequest ->
            Mono.just(
                McpSchema.GetPromptResult(
                "$name-result",
                listOf(
                    McpSchema.PromptMessage(
                        McpSchema.Role.USER,
                        McpSchema.TextContent(
                            """
                            Use the following information to achieve goal ${goal.name}" - <${goal.description}>:
                            ${
                                getPromptRequest.arguments.entries.joinToString(separator = "\n") { "${it.key}=${it.value}" }
                            }
                        """.trimIndent()
                        )
                    )
                ),
            ))
        }
    }
}



================================================
FILE: embabel-agent-mcpserver/src/main/kotlin/com/embabel/agent/mcpserver/async/McpAsyncPromptPublisher.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.async

import com.embabel.common.core.types.HasInfoString
import io.modelcontextprotocol.server.McpServerFeatures

/**
 * Defines an async prompt publisher for MCP servers.
 *
 * Implementations provide a list of async prompt specifications
 * for use in asynchronous prompt export operations.
 */
interface McpAsyncPromptPublisher : HasInfoString {

    /**
     * Returns the list of async prompt specifications available from this publisher.
     *
     * @return a list of `McpServerFeatures.AsyncPromptSpecification` instances
     */
    fun prompts(): List<McpServerFeatures.AsyncPromptSpecification>
}



================================================
FILE: embabel-agent-mcpserver/src/main/kotlin/com/embabel/agent/mcpserver/async/McpAsyncResourcePublisher.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.async

import com.embabel.common.core.types.HasInfoString
import io.modelcontextprotocol.server.McpServerFeatures

/**
 * Defines an async resource publisher for MCP servers.
 *
 * Implementations provide a list of async resource specifications
 * for use in asynchronous resource export operations.
 */
interface McpAsyncResourcePublisher : HasInfoString {

    /**
     * Returns the list of async resource specifications available from this publisher.
     *
     * @return a list of `McpServerFeatures.AsyncResourceSpecification` instances
     */
    fun resources(): List<McpServerFeatures.AsyncResourceSpecification>
}



================================================
FILE: embabel-agent-mcpserver/src/main/kotlin/com/embabel/agent/mcpserver/async/McpAsyncServerStrategy.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.async

import com.embabel.agent.mcpserver.McpServerStrategy
import com.embabel.agent.mcpserver.ToolRegistry
import com.embabel.agent.mcpserver.domain.McpExecutionMode
import io.modelcontextprotocol.server.McpAsyncServer
import io.modelcontextprotocol.server.McpServerFeatures
import org.slf4j.LoggerFactory
import reactor.core.publisher.Mono

/**
 * Implements the async server strategy for MCP servers.
 *
 * Delegates tool, resource, and prompt management to the underlying `McpAsyncServer` instance.
 * Provides an async execution mode and access to the tool registry.
 *
 * @property server the asynchronous MCP server instance
 */
class AsyncServerStrategy(
    private val server: McpAsyncServer
) : McpServerStrategy {

    private val logger = LoggerFactory.getLogger(AsyncServerStrategy::class.java)

    /**
     * The execution mode for this strategy, set to ASYNC.
     */
    override val executionMode = McpExecutionMode.ASYNC

    /**
     * Adds a tool to the async server.
     *
     * @param toolSpec the tool specification, must be of type `AsyncToolSpecification`
     * @return a `Mono<Void>` indicating completion or error
     */
    override fun addTool(toolSpec: Any): Mono<Void> {
        return when (toolSpec) {
            is McpServerFeatures.AsyncToolSpecification -> server.addTool(toolSpec)
            else -> Mono.error(IllegalArgumentException("Expected AsyncToolSpecification, got ${toolSpec::class.simpleName}"))
        }
    }

    /**
     * Removes a tool from the async server by name.
     *
     * @param toolName the name of the tool to remove
     * @return a `Mono<Void>` indicating completion
     */
    override fun removeTool(toolName: String): Mono<Void> {
        return server.removeTool(toolName)
    }

    /**
     * Adds a resource to the async server.
     *
     * @param resourceSpec the resource specification, must be of type `AsyncResourceSpecification`
     * @return a `Mono<Void>` indicating completion or error
     */
    override fun addResource(resourceSpec: Any): Mono<Void> {
        return when (resourceSpec) {
            is McpServerFeatures.AsyncResourceSpecification -> server.addResource(resourceSpec)
            else -> Mono.error(IllegalArgumentException("Expected AsyncResourceSpecification"))
        }
    }

    /**
     * Adds a prompt to the async server.
     *
     * @param promptSpec the prompt specification, must be of type `AsyncPromptSpecification`
     * @return a `Mono<Void>` indicating completion or error
     */
    override fun addPrompt(promptSpec: Any): Mono<Void> {
        return when (promptSpec) {
            is McpServerFeatures.AsyncPromptSpecification -> server.addPrompt(promptSpec)
            else -> Mono.error(IllegalArgumentException("Expected AsyncPromptSpecification"))
        }
    }

    /**
     * Returns the tool registry for the async server.
     *
     * @return an instance of `AsyncToolRegistry`
     */
    override fun getToolRegistry(): ToolRegistry {
        return AsyncToolRegistry(server)
    }

}



================================================
FILE: embabel-agent-mcpserver/src/main/kotlin/com/embabel/agent/mcpserver/async/config/McpAsyncServerConfiguration.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.async.config

import com.embabel.agent.mcpserver.*
import com.embabel.agent.mcpserver.async.AsyncServerStrategy
import com.embabel.agent.mcpserver.async.McpAsyncPromptPublisher
import com.embabel.agent.mcpserver.async.McpAsyncResourcePublisher
import com.embabel.agent.mcpserver.domain.McpExecutionMode
import io.modelcontextprotocol.server.McpAsyncServer
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.ai.mcp.McpToolUtils
import org.springframework.ai.tool.ToolCallbackProvider
import org.springframework.ai.tool.method.MethodToolCallbackProvider
import org.springframework.context.ConfigurableApplicationContext
import org.springframework.context.annotation.*
import org.springframework.core.type.AnnotatedTypeMetadata

/**
 * Condition that checks if the MCP server is enabled and set to ASYNC mode.
 */
class McpAsyncServerCondition : Condition {
    override fun matches(
        context: ConditionContext,
        metadata: AnnotatedTypeMetadata
    ): Boolean {
        val environment = context.environment
        val type = environment.getProperty("spring.ai.mcp.server.type", "SYNC")
        return type == "ASYNC"
    }
}

/**
 * Configuration for the asynchronous MCP server.
 * Uses the template method pattern to provide beans and server strategy for async mode.
 *
 * @param applicationContext the Spring application context
 */
@Configuration
@Conditional(McpAsyncServerCondition::class)
class McpAsyncServerConfiguration(
    applicationContext: ConfigurableApplicationContext,
) : AbstractMcpServerConfiguration(applicationContext) {

    override val logger: Logger = LoggerFactory.getLogger(McpAsyncServerConfiguration::class.java)

    private val serverInfo = ServerInfoFactory.create(McpExecutionMode.ASYNC)

    @Bean
    fun asyncBannerCallback(): ToolCallbackProvider = createBannerTool()

    /**
     * Creates the server strategy specific to async mode.
     * Retrieves the McpAsyncServer bean from the application context.
     *
     * @return the McpServerStrategy for async operations
     */
    override fun createServerStrategy(): McpServerStrategy {
        val asyncServer = applicationContext.getBean(McpAsyncServer::class.java)
        return AsyncServerStrategy(asyncServer)
    }

    /**
     * Creates a banner tool callback provider for the asynchronous MCP server.
     *
     * This method builds a `MethodToolCallbackProvider` using the `UnifiedBannerTool`
     * initialized with the current server info. The resulting provider is used to
     * expose banner-related tool callbacks in async server mode.
     *
     * @return a `ToolCallbackProvider` for the async server banner tool
     */
    override fun createBannerTool(): ToolCallbackProvider {
        return MethodToolCallbackProvider.builder()
            .toolObjects(UnifiedBannerTool(serverInfo))
            .build()
    }

    /**
     * Returns all tool callback publishers registered in the application context.
     *
     * This method collects beans of type `McpToolExportCallbackPublisher` and
     * returns them as a list for use in tool export operations.
     *
     * @return a list of `McpToolExportCallbackPublisher` instances
     */
    override fun getToolPublishers(): List<McpToolExportCallbackPublisher> {
        return applicationContext.getBeansOfType(McpToolExportCallbackPublisher::class.java).values.toList()
    }

    /**
     * Returns all async resource publishers registered in the application context.
     *
     * This method collects beans of type `McpAsyncResourcePublisher` and
     * returns them as a list for use in async resource export operations.
     *
     * @return a list of `McpAsyncResourcePublisher` instances
     */
    override fun getResourcePublishers(): List<McpAsyncResourcePublisher> {
        return applicationContext.getBeansOfType(McpAsyncResourcePublisher::class.java).values.toList()
    }

    /**
     * Returns all async prompt publishers registered in the application context.
     *
     * This method collects beans of type `McpAsyncPromptPublisher` and
     * returns them as a list for use in async prompt export operations.
     *
     * @return a list of `McpAsyncPromptPublisher` instances
     */
    override fun getPromptPublishers(): List<McpAsyncPromptPublisher> {
        return applicationContext.getBeansOfType(McpAsyncPromptPublisher::class.java).values.toList()
    }


    /**
     * Converts a list of tool callback objects to async tool specifications.
     *
     * Filters the provided list for instances of `ToolCallback` and transforms them
     * into async tool specifications using `McpToolUtils`.
     *
     * @param toolCallbacks a list of tool callback objects
     * @return a list of async tool specifications
     */
    override fun convertToToolSpecifications(toolCallbacks: List<Any>): List<Any> {
        val callbacks = toolCallbacks.filterIsInstance<org.springframework.ai.tool.ToolCallback>()
        return McpToolUtils.toAsyncToolSpecifications(callbacks)
    }

    /**
     * Returns the execution mode for this server configuration.
     *
     * @return the string `"ASYNC"` representing async execution mode
     */
    override fun getExecutionMode(): String = "ASYNC"
}



================================================
FILE: embabel-agent-mcpserver/src/main/kotlin/com/embabel/agent/mcpserver/async/support/PerGoalAsyncMcpToolExportCallbackPublisher.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.async.support

import com.embabel.agent.api.common.autonomy.Autonomy
import com.embabel.agent.event.AgentProcessEvent
import com.embabel.agent.event.AgenticEventListener
import com.embabel.agent.event.ObjectAddedEvent
import com.embabel.agent.event.ObjectBoundEvent
import com.embabel.agent.mcpserver.McpToolExportCallbackPublisher
import com.embabel.agent.tools.agent.GoalToolCallback
import com.embabel.agent.tools.agent.PerGoalToolCallbackFactory
import com.embabel.agent.tools.agent.PromptedTextCommunicator
import com.embabel.common.util.indent
import io.modelcontextprotocol.server.McpAsyncServer
import io.modelcontextprotocol.server.McpSyncServerExchange
import org.slf4j.LoggerFactory
import org.springframework.ai.chat.model.ToolContext
import org.springframework.ai.tool.ToolCallback
import org.springframework.ai.tool.definition.ToolDefinition
import org.springframework.beans.factory.annotation.Value
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.stereotype.Service

/**
 * Implementation of [McpToolExportCallbackPublisher] that delegates to
 * a [PerGoalToolCallbackFactory].
 */
@Service
@ConditionalOnProperty(
    value = ["spring.ai.mcp.server.type"],
    havingValue = "ASYNC",
    matchIfMissing = false,
)
class PerGoalMcpAsyncToolExportCallbackPublisher(
    autonomy: Autonomy,
    private val mcpAsyncServer: McpAsyncServer,
    @Value("\${spring.application.name:agent-api}") applicationName: String,
) : McpToolExportCallbackPublisher {

    private val perGoalToolCallbackFactory = PerGoalToolCallbackFactory(
        autonomy = autonomy,
        applicationName = applicationName,
        textCommunicator = PromptedTextCommunicator,
    )

    override val toolCallbacks: List<ToolCallback>
        get() {
            val goalTools = perGoalToolCallbackFactory.toolCallbacks(
                remoteOnly = true,
                listeners = emptyList(),
            )
            return goalTools.map {
                if (it is GoalToolCallback<*>) {
                    McpAwareToolCallback(it, mcpAsyncServer)
                } else {
                    it
                }
            }
        }


    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String = "Default MCP Tool Export Callback Publisher: $perGoalToolCallbackFactory".indent(indent)
}


class McpAwareToolCallback(
    val delegate: GoalToolCallback<*>,
    val mcpAsyncServer: McpAsyncServer,
) : ToolCallback {

    private val logger = LoggerFactory.getLogger(javaClass)

    override fun getToolDefinition(): ToolDefinition = delegate.toolDefinition


    override fun call(
        toolInput: String,
        toolContext: ToolContext?,
    ): String {
        val exchange = toolContext?.context["exchange"] as? McpSyncServerExchange
        // Make a copy of the delegate with a new listener

        val delegateToCall = if (exchange != null) delegate.withListener(
            McpResourceUpdatingListener(
                mcpAsyncServer,
            )
        ) else delegate
        val result = delegateToCall.call(toolInput, toolContext)
        return result
    }

    override fun call(toolInput: String): String =
        call(toolInput, null).also {
            logger.info("Tool callback called with input: $toolInput, result: $it")
        }

}

class McpResourceUpdatingListener(
    private val mcpAsyncServer: McpAsyncServer,
) : AgenticEventListener {

    private val logger = LoggerFactory.getLogger(javaClass)

    override fun onProcessEvent(event: AgentProcessEvent) {
        when {

            event is ObjectBoundEvent -> {
//                val uri = "embabel://agent/${event.value.javaClass.simpleName}/${event.name}"
//                logger.info("MCP Tool Export Callback Publisher adding bound resource {}", uri)
//                mcpSyncServer.addResource(
//                    syncResourceSpecification(
//                        uri = uri,
//                        name = event.name,
//                        description = event.name,
//                        resourceLoader = { exchange ->
//                            event.value.toString()
//                        },
//                    )
//                )
//                mcpSyncServer.notifyResourcesListChanged()
            }

            event is ObjectAddedEvent -> {
//                val uri = "embabel://agent/${event.value.javaClass.simpleName}/it"
//                logger.info("MCP Tool Export Callback Publisher adding resource {}", uri)
//                mcpSyncServer.addResource(
//                    syncResourceSpecification(
//                        uri = uri,
//                        name = event.value.javaClass.simpleName,
//                        description = "Object added",
//                        resourceLoader = { exchange ->
//                            event.value.toString()
//                        },
//                    )
//                )
                // TODO isn't this inefficient? All clients??
//                mcpSyncServer.notifyResourcesListChanged()
            }

            else -> { // Do nothing
            }
        }
    }
}



================================================
FILE: embabel-agent-mcpserver/src/main/kotlin/com/embabel/agent/mcpserver/async/support/PerGoalStartingInputTypesPromptPublisher.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.async.support

import com.embabel.agent.api.common.autonomy.Autonomy
import com.embabel.agent.core.Goal
import com.embabel.agent.mcpserver.async.McpAsyncPromptFactory
import com.embabel.agent.mcpserver.async.McpAsyncPromptPublisher
import com.embabel.agent.mcpserver.sync.McpPromptPublisher
import com.embabel.agent.mcpserver.sync.McpPromptFactory
import com.embabel.common.util.indent
import io.modelcontextprotocol.server.McpServerFeatures
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.stereotype.Service
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

/**
 * Publish MCP prompts for each goal's starting input types, if specified.
 * This allows the MCP server to provide prompts based on the specific input types required by each goal.
 */
@Service
@ConditionalOnProperty(
    value = ["embabel.agent.mcpserver.type"],
    havingValue = "ASYNC",
    matchIfMissing = true,
)
class PerGoalAsyncMcpStartingInputTypesPromptPublisher(
    private val autonomy: Autonomy,
) : McpAsyncPromptPublisher {

    override fun prompts(): List<McpServerFeatures.AsyncPromptSpecification> {
        return autonomy.agentPlatform.goals.flatMap { goal ->
            promptsForGoal(goal)
        }
    }

    fun promptsForGoal(goal: Goal): List<McpServerFeatures.AsyncPromptSpecification> {
        val mcpPromptFactory = McpAsyncPromptFactory()
        return goal.export.startingInputTypes.map { inputType ->
            mcpPromptFactory.asyncPromptSpecificationForType(
                goal = goal,
                inputType,
            )
        }
    }

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String = "${javaClass.simpleName}(prompts=${prompts().size})".indent(indent)

}



================================================
FILE: embabel-agent-mcpserver/src/main/kotlin/com/embabel/agent/mcpserver/domain/Types.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.domain

import io.modelcontextprotocol.spec.McpSchema
import java.time.Instant

/**
 * Represents the execution mode for an MCP server.
 *
 * - `SYNC`: Synchronous execution mode.
 * - `ASYNC`: Asynchronous execution mode.
 */
enum class McpExecutionMode {
    SYNC, ASYNC
}

/**
 * Value object containing information about the MCP server.
 *
 * @property name the server name
 * @property version the server version
 * @property mode the execution mode (`SYNC` or `ASYNC`)
 * @property javaVersion the Java runtime version
 * @property startTime the server start time (default: current instant)
 */
data class ServerInfo(
    val name: String,
    val version: String,
    val mode: McpExecutionMode,
    val javaVersion: String,
    val startTime: Instant = Instant.now()
) {
    /**
     * Returns a list of banner lines summarizing server information.
     *
     * @return a list of formatted strings for display
     */
    fun toBannerLines(): List<String> {
        val separator = "~".repeat(50)
        return listOf(
            separator,
            "Embabel Agent MCP $mode Server",
            "Version: $version",
            "Java: $javaVersion",
            "Started: $startTime",
            separator
        )
    }
}

/**
 * Interface for tool specifications, abstracting over execution mode.
 *
 * @param T the type of handler for the tool
 * @property tool the MCP tool definition
 * @property handler the handler implementation for the tool
 */
interface ToolSpecification<T> {
    val tool: McpSchema.Tool
    val handler: T

    /**
     * Returns the name of the tool.
     *
     * @return the tool name
     */
    fun toolName(): String = tool.name()

    /**
     * Returns the description of the tool, or "No description" if absent.
     *
     * @return the tool description
     */
    fun toolDescription(): String = tool.description() ?: "No description"
}

/**
 * Enumerates the capabilities supported by an MCP server.
 *
 * - `TOOLS`: Tool management
 * - `RESOURCES`: Resource management
 * - `PROMPTS`: Prompt management
 * - `LOGGING`: Logging support
 * - `COMPLETIONS`: Completion operations
 */
enum class McpCapability {
    TOOLS, RESOURCES, PROMPTS, LOGGING, COMPLETIONS
}

/**
 * Value object representing the result of a server health check.
 *
 * @property isHealthy whether the server is healthy
 * @property mode the current execution mode
 * @property toolCount the number of registered tools
 * @property issues a list of health issues, if any
 * @property timestamp the time of the health check (default: current instant)
 */
data class ServerHealthStatus(
    val isHealthy: Boolean,
    val mode: McpExecutionMode,
    val toolCount: Int,
    val issues: List<String>,
    val timestamp: Instant = Instant.now()
)



================================================
FILE: embabel-agent-mcpserver/src/main/kotlin/com/embabel/agent/mcpserver/support/extensions.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.support

import io.modelcontextprotocol.server.McpAsyncServer
import io.modelcontextprotocol.server.McpServerFeatures
import io.modelcontextprotocol.server.McpSyncServer
import org.slf4j.LoggerFactory

private val logger = LoggerFactory.getLogger(McpAsyncServer::class.java)

/**
 * Sneakily get the names of the tools registered with the given MCP async server.
 *
 * This uses reflection to access the private `tools` field of the MCP async server.
 * If this fails, an empty list is returned and a warning is logged.
 */
fun McpAsyncServer.toolNames(): List<String> {
    try {
        val toolsField = this::class.java.getDeclaredField("tools")
        toolsField.setAccessible(true)
        val tools = toolsField.get(this) as List<McpServerFeatures.AsyncToolSpecification>
        return tools.map { it.tool.name() }
    } catch (t: Throwable) {
        logger.warn("Failed to sneakily get tools from MCP async server: {}", t.message, t)
    }
    return emptyList()
}

/**
 * Retrieves the names of tools registered with this MCP sync server.
 *
 * Delegates to the underlying async server's `toolNames()` extension.
 *
 * @return a list of tool names registered with the async server
 */
fun McpSyncServer.toolNames(): List<String> = this.asyncServer.toolNames()



================================================
FILE: embabel-agent-mcpserver/src/main/kotlin/com/embabel/agent/mcpserver/support/promptUtils.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.support

import com.embabel.common.util.NameUtils
import com.fasterxml.jackson.annotation.JsonPropertyDescription
import io.modelcontextprotocol.spec.McpSchema
import org.springframework.util.ReflectionUtils
import java.lang.reflect.Method

/**
 * Returns the Kotlin type name for a given Java type.
 *
 * Maps common Java types to their Kotlin equivalents.
 *
 * @param javaType the Java class to map
 * @return the Kotlin type name as a string
 */
private fun getKotlinTypeName(javaType: Class<*>): String {
    return when (javaType) {
        java.lang.Integer::class.java, Integer.TYPE -> "Int"
        java.lang.Long::class.java, java.lang.Long.TYPE -> "Long"
        java.lang.Double::class.java, java.lang.Double.TYPE -> "Double"
        java.lang.Float::class.java, java.lang.Float.TYPE -> "Float"
        java.lang.Boolean::class.java, java.lang.Boolean.TYPE -> "Boolean"
        java.lang.String::class.java -> "String"
        else -> javaType.simpleName
    }
}

/**
 * Retrieves the value of the `JsonPropertyDescription` annotation from a field or its constructor parameter.
 *
 * Attempts to get the annotation from the field first, then from the constructor parameter for Kotlin data classes.
 *
 * @param field the field to inspect
 * @param type the class type containing the field
 * @return the annotation value if present, otherwise null
 */
private fun getPropertyDescription(field: java.lang.reflect.Field, type: Class<*>): String? {
    // First try to get from field annotation
    field.getAnnotation(JsonPropertyDescription::class.java)?.let {
        return it.value
    }

    // For Kotlin data classes, try to get from constructor parameter
    try {
        val constructors = type.declaredConstructors
        for (constructor in constructors) {
            val parameters = constructor.parameters
            for (param in parameters) {
                if (param.name == field.name) {
                    param.getAnnotation(JsonPropertyDescription::class.java)?.let {
                        return it.value
                    }
                }
            }
        }
    } catch (e: Exception) {
        // If reflection fails, continue without constructor parameter annotation
    }

    return null
}

/**
 * Extracts MCP prompt arguments from a given type, excluding fields that match methods in the excluded interfaces.
 *
 * Iterates over the fields of the provided type, skipping synthetic fields and those matching excluded interface methods.
 * Builds a list of `McpSchema.PromptArgument` with name, description, and required flag.
 *
 * @param excludedInterfaces set of interfaces whose methods' property names should be excluded
 * @param type the class type to extract arguments from
 * @return a list of `McpSchema.PromptArgument` objects
 */
internal fun argumentsFromType(excludedInterfaces: Set<Class<*>>, type: Class<*>): List<McpSchema.PromptArgument> {
    val excludedFields: Iterable<Method> = excludedInterfaces.flatMap {
        it.methods.toList()
    }
    val args = mutableListOf<McpSchema.PromptArgument>()
    ReflectionUtils.doWithFields(type) { field ->
        if (field.isSynthetic) {
            return@doWithFields
        }
        if (excludedFields.any { NameUtils.beanMethodToPropertyName(it.name) == field.name }) {
            return@doWithFields
        }
        val name = field.name
        val propertyDescription = getPropertyDescription(field, type)

        // Get the Kotlin-friendly type name
        val typeName = getKotlinTypeName(field.type)

        val description = if (propertyDescription != null) {
            "$propertyDescription: $typeName"
        } else {
            "$name: $typeName"
        }

        args.add(McpSchema.PromptArgument(name, description, true))
    }
    return args
}



================================================
FILE: embabel-agent-mcpserver/src/main/kotlin/com/embabel/agent/mcpserver/sync/McpPromptFactory.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.sync

import com.embabel.agent.mcpserver.support.argumentsFromType
import com.embabel.common.core.types.Described
import com.embabel.common.core.types.Named
import com.embabel.common.core.types.Timestamped
import io.modelcontextprotocol.server.McpServerFeatures
import io.modelcontextprotocol.spec.McpSchema

/**
 * Create Prompt specifications for the MCP server.
 *
 * @param excludedInterfaces Set of interfaces whose fields should be excluded from the prompt arguments.
 */
class McpPromptFactory(
    val excludedInterfaces: Set<Class<*>> = setOf(
        Timestamped::class.java,
    ),
) {

    /**
     * Creates a synchronous prompt specification for a given type.
     *
     * @param goal The goal for which the prompt is created.
     * @param inputType The class type of the
     * @param inputType The class type of the input for the prompt.
     * @param name The name of the prompt if we want to customize it
     * @param description A description of the prompt if we want to customize it
     */
    fun <G> syncPromptSpecificationForType(
        goal: G,
        inputType: Class<*>,
        name: String = goal.name,
        description: String = goal.description,
    ): McpServerFeatures.SyncPromptSpecification where G : Named, G : Described {
        return McpServerFeatures.SyncPromptSpecification(
            McpSchema.Prompt(
                "${inputType.simpleName}_$name",
                description,
                argumentsFromType(excludedInterfaces, inputType),
            )
        ) { syncServerExchange, getPromptRequest ->
            McpSchema.GetPromptResult(
                "$name-result",
                listOf(
                    McpSchema.PromptMessage(
                        McpSchema.Role.USER,
                        McpSchema.TextContent(
                            """
                            Use the following information to achieve goal $name" - <$description>:
                            ${
                                getPromptRequest.arguments.entries.joinToString(separator = "\n") { "${it.key}=${it.value}" }
                            }
                        """.trimIndent()
                        )
                    )
                ),
            )
        }
    }

}



================================================
FILE: embabel-agent-mcpserver/src/main/kotlin/com/embabel/agent/mcpserver/sync/McpPromptPublisher.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.sync

import com.embabel.common.core.types.HasInfoString
import io.modelcontextprotocol.server.McpServerFeatures

/**
 * Publishes prompt specifications for the MCP sync server.
 *
 * Implementations provide a list of prompt specifications that can be registered
 * with the server. Extends [HasInfoString] for informational purposes.
 */
interface McpPromptPublisher : HasInfoString {

    /**
     * Returns a list of synchronous prompt specifications to be published.
     *
     * @return a list of [McpServerFeatures.SyncPromptSpecification] objects
     */
    fun prompts(): List<McpServerFeatures.SyncPromptSpecification>

}



================================================
FILE: embabel-agent-mcpserver/src/main/kotlin/com/embabel/agent/mcpserver/sync/McpResourcePublisher.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.sync

import com.embabel.common.core.types.HasInfoString
import io.modelcontextprotocol.server.McpServerFeatures

/**
 * Publishes resource specifications for the MCP sync server.
 *
 * Implementations provide a list of resource specifications that can be registered
 * with the server. Extends [HasInfoString] for informational purposes.
 */
interface McpResourcePublisher : HasInfoString {

    /**
     * Returns a list of synchronous resource specifications to be published.
     *
     * @return a list of [McpServerFeatures.SyncResourceSpecification] objects
     */
    fun resources(): List<McpServerFeatures.SyncResourceSpecification>

}



================================================
FILE: embabel-agent-mcpserver/src/main/kotlin/com/embabel/agent/mcpserver/sync/McpServerStrategy.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.sync

import com.embabel.agent.mcpserver.McpServerStrategy
import com.embabel.agent.mcpserver.ToolRegistry
import com.embabel.agent.mcpserver.domain.McpExecutionMode
import io.modelcontextprotocol.server.McpServerFeatures
import io.modelcontextprotocol.server.McpSyncServer
import org.slf4j.LoggerFactory
import reactor.core.publisher.Mono

/**
 * Strategy implementation for the MCP sync server.
 *
 * Handles registration and management of tools, resources, and prompts
 * for synchronous execution mode using [McpSyncServer].
 *
 * @property server the underlying MCP sync server instance
 */
class SyncServerStrategy(
    private val server: McpSyncServer
) : McpServerStrategy {

    private val logger = LoggerFactory.getLogger(SyncServerStrategy::class.java)

    /**
     * The execution mode for this strategy, set to synchronous.
     */
    override val executionMode = McpExecutionMode.SYNC

    /**
     * Adds a tool specification to the sync server.
     *
     * @param toolSpec the tool specification to add; must be [McpServerFeatures.SyncToolSpecification]
     * @return a [Mono] signaling completion
     * @throws IllegalArgumentException if the specification type is incorrect
     */
    override fun addTool(toolSpec: Any): Mono<Void> {
        return Mono.fromRunnable {
            when (toolSpec) {
                is McpServerFeatures.SyncToolSpecification -> server.addTool(toolSpec)
                else -> throw IllegalArgumentException("Expected SyncToolSpecification")
            }
        }
    }

    /**
     * Removes a tool from the sync server by name.
     *
     * @param toolName the name of the tool to remove
     * @return a [Mono] signaling completion
     */
    override fun removeTool(toolName: String): Mono<Void> {
        return Mono.fromRunnable {
            server.removeTool(toolName)
        }
    }

    /**
     * Adds a resource specification to the sync server.
     *
     * @param resourceSpec the resource specification to add; must be [McpServerFeatures.SyncResourceSpecification]
     * @return a [Mono] signaling completion
     * @throws IllegalArgumentException if the specification type is incorrect
     */
    override fun addResource(resourceSpec: Any): Mono<Void> {
        return Mono.fromRunnable {
            when (resourceSpec) {
                is McpServerFeatures.SyncResourceSpecification -> server.addResource(resourceSpec)
                else -> throw IllegalArgumentException("Expected SyncResourceSpecification")
            }
        }
    }

    /**
     * Adds a prompt specification to the sync server.
     *
     * @param promptSpec the prompt specification to add; must be [McpServerFeatures.SyncPromptSpecification]
     * @return a [Mono] signaling completion
     * @throws IllegalArgumentException if the specification type is incorrect
     */
    override fun addPrompt(promptSpec: Any): Mono<Void> {
        return Mono.fromRunnable {
            when (promptSpec) {
                is McpServerFeatures.SyncPromptSpecification -> server.addPrompt(promptSpec)
                else -> throw IllegalArgumentException("Expected SyncPromptSpecification")
            }
        }
    }

    /**
     * Returns the tool registry for the sync server.
     *
     * @return a [ToolRegistry] instance for synchronous tools
     */
    override fun getToolRegistry(): ToolRegistry {
        return SyncToolRegistry(server)
    }

}



================================================
FILE: embabel-agent-mcpserver/src/main/kotlin/com/embabel/agent/mcpserver/sync/SyncResourceSpecificationFactory.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.sync

import io.modelcontextprotocol.server.McpServerFeatures
import io.modelcontextprotocol.server.McpSyncServerExchange
import io.modelcontextprotocol.spec.McpSchema

/**
 * Convenience factory for creating [io.modelcontextprotocol.server.McpServerFeatures.SyncResourceSpecification] instances.
 */
object SyncResourceSpecificationFactory {

    @JvmStatic
    fun staticSyncResourceSpecification(
        uri: String,
        name: String,
        description: String,
        content: String,
        mimeType: String = "text/plain",
    ): McpServerFeatures.SyncResourceSpecification = syncResourceSpecification(
        uri, name, description, { content }, mimeType,
    )

    @JvmStatic
    fun syncResourceSpecification(
        uri: String,
        name: String,
        description: String,
        resourceLoader: (exchange: McpSyncServerExchange) -> String,
        mimeType: String = "text/plain",
    ): McpServerFeatures.SyncResourceSpecification {

        return McpServerFeatures.SyncResourceSpecification(
            McpSchema.Resource(
                uri,
                name,
                description,
                mimeType,
                McpSchema.Annotations(
                    listOf(McpSchema.Role.ASSISTANT),
                    1.0,
                )
            )
        ) { exchange, readResourceRequest ->
            McpSchema.ReadResourceResult(
                listOf(
                    McpSchema.TextResourceContents(
                        uri, mimeType, resourceLoader(exchange),
                    )
                )
            )
        }
    }

}



================================================
FILE: embabel-agent-mcpserver/src/main/kotlin/com/embabel/agent/mcpserver/sync/SyncToolRegistry.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.sync

import com.embabel.agent.mcpserver.ToolRegistry
import com.embabel.agent.mcpserver.support.toolNames
import io.modelcontextprotocol.server.McpSyncServer

/**
 * Registry for tools managed by the MCP sync server.
 *
 * Provides access to tool names and counts for synchronous execution mode.
 *
 * @property server the underlying MCP sync server instance
 */
class SyncToolRegistry(private val server: McpSyncServer) : ToolRegistry {

    /**
     * Returns a list of tool names registered in the sync server.
     *
     * @return a list of tool names
     */
    override fun getToolNames(): List<String> {
        return server.toolNames()
    }

    /**
     * Returns the number of tools registered in the sync server.
     *
     * @return the count of tools
     */
    override fun getToolCount(): Int = getToolNames().size

    /**
     * Checks if a tool with the given name exists in the sync server.
     *
     * @param name the name of the tool to check
     * @return `true` if the tool exists, otherwise `false`
     */
    override fun hasToolNamed(name: String): Boolean = getToolNames().contains(name)

}



================================================
FILE: embabel-agent-mcpserver/src/main/kotlin/com/embabel/agent/mcpserver/sync/config/McpSyncServerConfiguration.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.sync.config

import com.embabel.agent.mcpserver.*
import com.embabel.agent.mcpserver.domain.McpExecutionMode
import com.embabel.agent.mcpserver.sync.McpPromptPublisher
import com.embabel.agent.mcpserver.sync.McpResourcePublisher
import com.embabel.agent.mcpserver.sync.SyncServerStrategy
import io.modelcontextprotocol.server.McpSyncServer
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.ai.mcp.McpToolUtils
import org.springframework.ai.tool.ToolCallbackProvider
import org.springframework.ai.tool.method.MethodToolCallbackProvider
import org.springframework.context.ConfigurableApplicationContext
import org.springframework.context.annotation.*
import org.springframework.core.type.AnnotatedTypeMetadata


/**
 * Spring condition to determine if the MCP sync server configuration should be activated.
 *
 * Checks if the `embabel.agent.mcpserver.enabled` property is `true` and
 * the `embabel.agent.mcpserver.type` property is set to `"SYNC"`.
 */
class McpSyncServerCondition : Condition {

    /**
     * Evaluates the condition based on the application environment.
     *
     * @param context the condition context containing environment and bean factory
     * @param metadata annotation metadata for the condition
     * @return `true` if sync server should be enabled, otherwise `false`
     */
    override fun matches(
        context: ConditionContext,
        metadata: AnnotatedTypeMetadata
    ): Boolean {
        val environment = context.environment
        val type = environment.getProperty("spring.ai.mcp.server.type", "SYNC")
        return type == "SYNC"
    }
}

/**
 * Spring configuration for the MCP sync server.
 *
 * Uses the template method pattern to provide sync-specific server strategy,
 * tool, resource, and prompt publishers, and tool specification conversion.
 *
 * @param applicationContext the Spring application context
 */
@Configuration
@Conditional(McpSyncServerCondition::class)
class McpSyncServerConfiguration(
    applicationContext: ConfigurableApplicationContext,
) : AbstractMcpServerConfiguration(applicationContext) {

    override val logger: Logger = LoggerFactory.getLogger(McpSyncServerConfiguration::class.java)

    /**
     * Information about the current server instance.
     */
    private val serverInfo = ServerInfoFactory.create(McpExecutionMode.SYNC)

    /**
     * Registers the banner tool callback bean for the sync server.
     *
     * @return a `ToolCallbackProvider` for the banner tool
     */
    @Bean
    fun syncBannerCallback(): ToolCallbackProvider = createBannerTool()

    /**
     * Creates the sync server strategy.
     *
     * @return a `McpServerStrategy` for synchronous execution
     */
    override fun createServerStrategy(): McpServerStrategy {
        val syncServer = applicationContext.getBean(McpSyncServer::class.java)
        return SyncServerStrategy(syncServer)
    }

    /**
     * Creates the banner tool callback provider for the sync server.
     *
     * @return a `ToolCallbackProvider` for the banner tool
     */
    override fun createBannerTool(): ToolCallbackProvider {
        return MethodToolCallbackProvider.builder()
            .toolObjects(UnifiedBannerTool(serverInfo))
            .build()
    }

    /**
     * Retrieves all tool publishers registered in the application context.
     *
     * @return a list of `McpToolExportCallbackPublisher` beans
     */
    override fun getToolPublishers(): List<McpToolExportCallbackPublisher> {
        return applicationContext.getBeansOfType(McpToolExportCallbackPublisher::class.java).values.toList()
    }

    /**
     * Retrieves all resource publishers registered in the application context.
     *
     * @return a list of `McpResourcePublisher` beans
     */
    override fun getResourcePublishers(): List<McpResourcePublisher> {
        return applicationContext.getBeansOfType(McpResourcePublisher::class.java).values.toList()
    }

    /**
     * Retrieves all prompt publishers registered in the application context.
     *
     * @return a list of `McpPromptPublisher` beans
     */
    override fun getPromptPublishers(): List<McpPromptPublisher> {
        return applicationContext.getBeansOfType(McpPromptPublisher::class.java).values.toList()
    }

    /**
     * Converts tool callback objects to sync tool specifications.
     *
     * @param toolCallbacks a list of tool callback objects
     * @return a list of sync tool specifications
     */
    override fun convertToToolSpecifications(toolCallbacks: List<Any>): List<Any> {
        // Cast to the expected ToolCallback type for McpToolUtils
        val callbacks = toolCallbacks.filterIsInstance<org.springframework.ai.tool.ToolCallback>()
        return McpToolUtils.toSyncToolSpecification(callbacks)
    }

    /**
     * Returns the execution mode for this configuration.
     *
     * @return the string `"SYNC"`
     */
    override fun getExecutionMode(): String = "SYNC"
}



================================================
FILE: embabel-agent-mcpserver/src/main/kotlin/com/embabel/agent/mcpserver/sync/support/PerGoalMcpToolExportCallbackPublisher.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.sync.support

import com.embabel.agent.api.common.autonomy.Autonomy
import com.embabel.agent.event.AgentProcessEvent
import com.embabel.agent.event.AgenticEventListener
import com.embabel.agent.event.ObjectAddedEvent
import com.embabel.agent.event.ObjectBoundEvent
import com.embabel.agent.mcpserver.McpToolExportCallbackPublisher
import com.embabel.agent.tools.agent.GoalToolCallback
import com.embabel.agent.tools.agent.PerGoalToolCallbackFactory
import com.embabel.agent.tools.agent.PromptedTextCommunicator
import com.embabel.common.util.indent
import io.modelcontextprotocol.server.McpSyncServer
import io.modelcontextprotocol.server.McpSyncServerExchange
import org.slf4j.LoggerFactory
import org.springframework.ai.chat.model.ToolContext
import org.springframework.ai.tool.ToolCallback
import org.springframework.ai.tool.definition.ToolDefinition
import org.springframework.beans.factory.annotation.Value
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.stereotype.Service

/**
 * Implementation of [McpToolExportCallbackPublisher] that delegates to
 * a [PerGoalToolCallbackFactory].
 */
@Service
@ConditionalOnProperty(
    value = ["spring.ai.mcp.server.type"],
    havingValue = "SYNC",
    matchIfMissing = true,
)
class PerGoalMcpToolExportCallbackPublisher(
    autonomy: Autonomy,
    private val mcpSyncServer: McpSyncServer,
    @Value("\${spring.application.name:agent-api}") applicationName: String,
) : McpToolExportCallbackPublisher {

    private val perGoalToolCallbackFactory = PerGoalToolCallbackFactory(
        autonomy = autonomy,
        applicationName = applicationName,
        textCommunicator = PromptedTextCommunicator,
    )

    override val toolCallbacks: List<ToolCallback>
        get() {
            val goalTools = perGoalToolCallbackFactory.toolCallbacks(
                remoteOnly = true,
                listeners = emptyList(),
            )
            return goalTools.map {
                if (it is GoalToolCallback<*>) {
                    McpAwareToolCallback(it, mcpSyncServer)
                } else {
                    it
                }
            }
        }


    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String = "Default MCP Tool Export Callback Publisher: $perGoalToolCallbackFactory".indent(indent)
}


class McpAwareToolCallback(
    val delegate: GoalToolCallback<*>,
    val mcpSyncServer: McpSyncServer,
) : ToolCallback {

    private val logger = LoggerFactory.getLogger(javaClass)

    override fun getToolDefinition(): ToolDefinition = delegate.toolDefinition


    override fun call(
        toolInput: String,
        toolContext: ToolContext?,
    ): String {
        val exchange = toolContext?.context["exchange"] as? McpSyncServerExchange
        // Make a copy of the delegate with a new listener

        val delegateToCall = if (exchange != null) delegate.withListener(
            McpResourceUpdatingListener(
                mcpSyncServer,
            )
        ) else delegate
        val result = delegateToCall.call(toolInput, toolContext)
        return result
    }

    override fun call(toolInput: String): String =
        call(toolInput, null).also {
            logger.info("Tool callback called with input: $toolInput, result: $it")
        }

}

class McpResourceUpdatingListener(
    private val mcpSyncServer: McpSyncServer,
) : AgenticEventListener {

    private val logger = LoggerFactory.getLogger(javaClass)

    override fun onProcessEvent(event: AgentProcessEvent) {
        when {

            event is ObjectBoundEvent -> {
//                val uri = "embabel://agent/${event.value.javaClass.simpleName}/${event.name}"
//                logger.info("MCP Tool Export Callback Publisher adding bound resource {}", uri)
//                mcpSyncServer.addResource(
//                    syncResourceSpecification(
//                        uri = uri,
//                        name = event.name,
//                        description = event.name,
//                        resourceLoader = { exchange ->
//                            event.value.toString()
//                        },
//                    )
//                )
//                mcpSyncServer.notifyResourcesListChanged()
            }

            event is ObjectAddedEvent -> {
//                val uri = "embabel://agent/${event.value.javaClass.simpleName}/it"
//                logger.info("MCP Tool Export Callback Publisher adding resource {}", uri)
//                mcpSyncServer.addResource(
//                    syncResourceSpecification(
//                        uri = uri,
//                        name = event.value.javaClass.simpleName,
//                        description = "Object added",
//                        resourceLoader = { exchange ->
//                            event.value.toString()
//                        },
//                    )
//                )
                // TODO isn't this inefficient? All clients??
//                mcpSyncServer.notifyResourcesListChanged()
            }

            else -> { // Do nothing
            }
        }
    }
}



================================================
FILE: embabel-agent-mcpserver/src/main/kotlin/com/embabel/agent/mcpserver/sync/support/PerGoalStartingInputTypesPromptPublisher.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.sync.support

import com.embabel.agent.api.common.autonomy.Autonomy
import com.embabel.agent.core.Goal
import com.embabel.agent.mcpserver.sync.McpPromptFactory
import com.embabel.agent.mcpserver.sync.McpPromptPublisher
import com.embabel.common.util.indent
import io.modelcontextprotocol.server.McpServerFeatures
import org.springframework.stereotype.Service

/**
 * Publish MCP prompts for each goal's starting input types, if specified.
 * This allows the MCP server to provide prompts based on the specific input types required by each goal.
 */
@Service
class PerGoalStartingInputTypesPromptPublisher(
    private val autonomy: Autonomy,
) : McpPromptPublisher {

    override fun prompts(): List<McpServerFeatures.SyncPromptSpecification> {
        return autonomy.agentPlatform.goals.flatMap { goal ->
            promptsForGoal(goal)
        }
    }

    fun promptsForGoal(goal: Goal): List<McpServerFeatures.SyncPromptSpecification> {
        val mcpPromptFactory = McpPromptFactory()
        return goal.export.startingInputTypes.map { inputType ->
            mcpPromptFactory.syncPromptSpecificationForType(
                goal = goal,
                inputType,
            )
        }
    }

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String = "${javaClass.simpleName}(prompts=${prompts().size})".indent(indent)

}



================================================
FILE: embabel-agent-mcpserver/src/test/kotlin/com/embabel/agent/mcpserver/AbstractMcpServerConfigurationTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver

import com.embabel.agent.mcpserver.domain.McpExecutionMode
import com.embabel.agent.spi.support.AgentScanningBeanPostProcessorEvent
import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.ai.tool.ToolCallbackProvider
import org.springframework.context.ConfigurableApplicationContext
import reactor.core.publisher.Mono

class AbstractMcpServerConfigurationTest {

    private lateinit var mockApplicationContext: ConfigurableApplicationContext
    private lateinit var mockServerStrategy: McpServerStrategy
    private lateinit var mockToolRegistry: ToolRegistry
    private lateinit var configuration: TestAbstractMcpServerConfiguration

    @BeforeEach
    fun setUp() {
        mockApplicationContext = mockk(relaxed = true)
        mockServerStrategy = mockk(relaxed = true)
        mockToolRegistry = mockk(relaxed = true)
        configuration = TestAbstractMcpServerConfiguration(mockApplicationContext)
    }

    @Test
    fun `exposeMcpFunctionality should initialize server successfully`() {
        // Setup mocks
        every { mockServerStrategy.executionMode } returns McpExecutionMode.SYNC
        every { mockServerStrategy.getToolRegistry() } returns mockToolRegistry
        every { mockToolRegistry.getToolNames() } returns emptyList()
        every { mockServerStrategy.addTool(any()) } returns Mono.empty()
        every { mockServerStrategy.addResource(any()) } returns Mono.empty()
        every { mockServerStrategy.addPrompt(any()) } returns Mono.empty()

        configuration.mockServerStrategy = mockServerStrategy

        val event = mockk<AgentScanningBeanPostProcessorEvent>()

        // Execute
        configuration.exposeMcpFunctionality()

        // Verify initialization was called
        assertTrue(configuration.createServerStrategyCalled)
    }

    @Test
    fun `exposeMcpFunctionality should handle initialization errors gracefully`() {
        every { mockServerStrategy.executionMode } returns McpExecutionMode.SYNC
        every { mockServerStrategy.getToolRegistry() } throws RuntimeException("Test error")

        configuration.mockServerStrategy = mockServerStrategy

        val event = mockk<AgentScanningBeanPostProcessorEvent>()

        // Should not throw exception
        assertDoesNotThrow {
            configuration.exposeMcpFunctionality()
        }
    }

    @Test
    fun `should preserve helloBanner tool by default`() {
        every { mockToolRegistry.getToolNames() } returns listOf("helloBanner", "otherTool")
        every { mockServerStrategy.getToolRegistry() } returns mockToolRegistry
        every { mockServerStrategy.removeTool("otherTool") } returns Mono.empty()
        every { mockServerStrategy.addTool(any()) } returns Mono.empty()
        every { mockServerStrategy.addResource(any()) } returns Mono.empty()
        every { mockServerStrategy.addPrompt(any()) } returns Mono.empty()

        configuration.mockServerStrategy = mockServerStrategy

        configuration.exposeMcpFunctionality()

        // Should only remove "otherTool", not "helloBanner"
        verify(exactly = 1) { mockServerStrategy.removeTool("otherTool") }
        verify(exactly = 0) { mockServerStrategy.removeTool("helloBanner") }
    }

    @Test
    fun `should handle tool removal failures gracefully`() {
        every { mockToolRegistry.getToolNames() } returns listOf("tool1", "tool2")
        every { mockServerStrategy.getToolRegistry() } returns mockToolRegistry
        every { mockServerStrategy.removeTool("tool1") } returns Mono.error(RuntimeException("Remove failed"))
        every { mockServerStrategy.removeTool("tool2") } returns Mono.empty()
        every { mockServerStrategy.addTool(any()) } returns Mono.empty()
        every { mockServerStrategy.addResource(any()) } returns Mono.empty()
        every { mockServerStrategy.addPrompt(any()) } returns Mono.empty()

        configuration.mockServerStrategy = mockServerStrategy

        // Should not throw exception
        assertDoesNotThrow {
            configuration.exposeMcpFunctionality()
        }
    }

    @Test
    fun `should handle tool addition failures gracefully`() {
        val mockToolCallback = mockk<Any>()
        val mockToolSpec = mockk<Any>()

        every { mockToolRegistry.getToolNames() } returns emptyList()
        every { mockServerStrategy.getToolRegistry() } returns mockToolRegistry
        every { mockServerStrategy.addTool(any()) } returns Mono.error(RuntimeException("Add failed"))
        every { mockServerStrategy.addResource(any()) } returns Mono.empty()
        every { mockServerStrategy.addPrompt(any()) } returns Mono.empty()

        configuration.mockServerStrategy = mockServerStrategy
        configuration.mockToolCallbacks = listOf(mockToolCallback)
        configuration.mockToolSpecs = listOf(mockToolSpec)

        // Should not throw exception
        assertDoesNotThrow {
            configuration.exposeMcpFunctionality()
        }
    }

    @Test
    fun `should handle resource addition failures gracefully`() {
        val mockResourceSpec = mockk<Any>()

        every { mockToolRegistry.getToolNames() } returns emptyList()
        every { mockServerStrategy.getToolRegistry() } returns mockToolRegistry
        every { mockServerStrategy.addTool(any()) } returns Mono.empty()
        every { mockServerStrategy.addResource(any()) } returns Mono.error(RuntimeException("Resource add failed"))
        every { mockServerStrategy.addPrompt(any()) } returns Mono.empty()

        configuration.mockServerStrategy = mockServerStrategy
        configuration.mockResourceSpecs = listOf(mockResourceSpec)

        // Should not throw exception
        assertDoesNotThrow {
            configuration.exposeMcpFunctionality()
        }
    }

    @Test
    fun `should handle prompt addition failures gracefully`() {
        val mockPromptSpec = mockk<Any>()

        every { mockToolRegistry.getToolNames() } returns emptyList()
        every { mockServerStrategy.getToolRegistry() } returns mockToolRegistry
        every { mockServerStrategy.addTool(any()) } returns Mono.empty()
        every { mockServerStrategy.addResource(any()) } returns Mono.empty()
        every { mockServerStrategy.addPrompt(any()) } returns Mono.error(RuntimeException("Prompt add failed"))

        configuration.mockServerStrategy = mockServerStrategy
        configuration.mockPromptSpecs = listOf(mockPromptSpec)

        // Should not throw exception
        assertDoesNotThrow {
            configuration.exposeMcpFunctionality()
        }
    }

    @Test
    fun `createLogSeparator should return formatted separator`() {
        configuration.mockExecutionMode = "SYNC"

        val separator = configuration.testCreateLogSeparator()

        assertTrue(separator.startsWith("~ MCP SYNC"))
        assertTrue(separator.contains("~"))
        assertTrue(separator.length > 10)
    }

    @Test
    fun `shouldPreserveTool should preserve helloBanner by default`() {
        assertTrue(configuration.testShouldPreserveTool("helloBanner"))
        assertFalse(configuration.testShouldPreserveTool("otherTool"))
        assertFalse(configuration.testShouldPreserveTool(""))
        assertFalse(configuration.testShouldPreserveTool("HELLOBANNER"))
    }

    // Test implementation of abstract class
    inner class TestAbstractMcpServerConfiguration(
        applicationContext: ConfigurableApplicationContext,
    ) : AbstractMcpServerConfiguration(applicationContext) {

        override val logger: Logger = LoggerFactory.getLogger(TestAbstractMcpServerConfiguration::class.java)

        var createServerStrategyCalled = false
        var mockServerStrategy: McpServerStrategy? = null
        var mockToolCallbacks: List<Any> = emptyList()
        var mockToolSpecs: List<Any> = emptyList()
        var mockResourceSpecs: List<Any> = emptyList()
        var mockPromptSpecs: List<Any> = emptyList()
        var mockExecutionMode: String = "SYNC"

        override fun createServerStrategy(): McpServerStrategy {
            createServerStrategyCalled = true
            return mockServerStrategy ?: mockk(relaxed = true)
        }

        override fun createBannerTool(): ToolCallbackProvider = mockk()

        override fun getToolPublishers(): List<McpToolExportCallbackPublisher> {
            val mockPublisher = mockk<McpToolExportCallbackPublisher>()
            // Convert Any callbacks to ToolCallback with proper casting
            @Suppress("UNCHECKED_CAST")
            val toolCallbacks = mockToolCallbacks as List<org.springframework.ai.tool.ToolCallback>
            every { mockPublisher.toolCallbacks } returns toolCallbacks
            return listOf(mockPublisher)
        }

        override fun getResourcePublishers(): List<Any> = mockResourceSpecs

        override fun getPromptPublishers(): List<Any> = mockPromptSpecs

        override fun convertToToolSpecifications(toolCallbacks: List<Any>): List<Any> {
            // Cast to ToolCallback type as expected by the interface
            @Suppress("UNCHECKED_CAST")
            val callbacks = toolCallbacks as List<org.springframework.ai.tool.ToolCallback>
            return mockToolSpecs
        }

        override fun getExecutionMode(): String = mockExecutionMode

        // Expose protected methods for testing
        fun testCreateLogSeparator(): String = createLogSeparator()
        fun testShouldPreserveTool(toolName: String): Boolean = shouldPreserveTool(toolName)
    }
}



================================================
FILE: embabel-agent-mcpserver/src/test/kotlin/com/embabel/agent/mcpserver/ServerInfoFactoryAndUnifiedBannerToolTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver

import com.embabel.agent.mcpserver.domain.McpExecutionMode
import com.embabel.agent.mcpserver.domain.ServerInfo
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*
import java.time.Instant

class ServerInfoFactoryTest {

    @Test
    fun `create should return ServerInfo with SYNC mode`() {
        val serverInfo = ServerInfoFactory.create(McpExecutionMode.SYNC)

        assertEquals("Embabel Agent MCP Server", serverInfo.name)
        assertEquals(McpExecutionMode.SYNC, serverInfo.mode)
        assertEquals(System.getProperty("java.runtime.version"), serverInfo.javaVersion)
        assertTrue(serverInfo.startTime.isBefore(Instant.now().plusSeconds(1)))
    }

    @Test
    fun `create should return ServerInfo with ASYNC mode`() {
        val serverInfo = ServerInfoFactory.create(McpExecutionMode.ASYNC)

        assertEquals("Embabel Agent MCP Server", serverInfo.name)
        assertEquals(McpExecutionMode.ASYNC, serverInfo.mode)
        assertEquals(System.getProperty("java.runtime.version"), serverInfo.javaVersion)
        assertTrue(serverInfo.startTime.isBefore(Instant.now().plusSeconds(1)))
    }

    @Test
    fun `create should handle null implementation version`() {
        // Note: This test simulates development environment where package version is null
        val serverInfo = ServerInfoFactory.create(McpExecutionMode.SYNC)

        // In development, version will be "development" due to null check
        assertTrue(
            serverInfo.version == "development" ||
            serverInfo.version.isNotEmpty()
        )
    }
}

class UnifiedBannerToolTest {

    @Test
    fun `helloBanner should return correct banner format for SYNC mode`() {
        val serverInfo = ServerInfo(
            name = "Test Server",
            version = "1.0.0",
            mode = McpExecutionMode.SYNC,
            javaVersion = "17.0.1",
            startTime = Instant.parse("2025-01-01T12:00:00Z")
        )

        val bannerTool = UnifiedBannerTool(serverInfo)
        val result = bannerTool.helloBanner()

        assertEquals("banner", result["type"])
        assertEquals("SYNC", result["mode"])

        val lines = result["lines"] as List<String>
        assertEquals(6, lines.size)
        assertTrue(lines[1].contains("SYNC"))
        assertTrue(lines[2].contains("1.0.0"))
        assertTrue(lines[3].contains("17.0.1"))
    }

    @Test
    fun `helloBanner should return correct banner format for ASYNC mode`() {
        val serverInfo = ServerInfo(
            name = "Test Server",
            version = "2.0.0",
            mode = McpExecutionMode.ASYNC,
            javaVersion = "21.0.1",
            startTime = Instant.parse("2025-01-01T15:30:00Z")
        )

        val bannerTool = UnifiedBannerTool(serverInfo)
        val result = bannerTool.helloBanner()

        assertEquals("banner", result["type"])
        assertEquals("ASYNC", result["mode"])

        val lines = result["lines"] as List<String>
        assertEquals(6, lines.size)
        assertTrue(lines[1].contains("ASYNC"))
        assertTrue(lines[2].contains("2.0.0"))
        assertTrue(lines[3].contains("21.0.1"))
        assertTrue(lines[4].contains("2025-01-01T15:30:00Z"))
    }

    @Test
    fun `helloBanner should handle various server info configurations`() {
        val serverInfo = ServerInfo(
            name = "Custom Server Name",
            version = "0.1.0-SNAPSHOT",
            mode = McpExecutionMode.SYNC,
            javaVersion = "11.0.2+9"
        )

        val bannerTool = UnifiedBannerTool(serverInfo)
        val result = bannerTool.helloBanner()

        assertNotNull(result)
        assertEquals(3, result.size)
        assertTrue(result.containsKey("type"))
        assertTrue(result.containsKey("mode"))
        assertTrue(result.containsKey("lines"))

        val lines = result["lines"] as List<String>
        assertTrue(lines.any { it.contains("0.1.0-SNAPSHOT") })
        assertTrue(lines.any { it.contains("11.0.2+9") })
    }

    @Test
    fun `helloBanner should include all required fields in result map`() {
        val serverInfo = ServerInfo(
            name = "Test",
            version = "1.0",
            mode = McpExecutionMode.ASYNC,
            javaVersion = "17"
        )

        val bannerTool = UnifiedBannerTool(serverInfo)
        val result = bannerTool.helloBanner()

        // Verify the result structure matches expected Map<String, Any>
        assertTrue(result["type"] is String)
        assertTrue(result["mode"] is String)
        assertTrue(result["lines"] is List<*>)

        // Verify content
        assertEquals("banner", result["type"])
        assertEquals("ASYNC", result["mode"])

       val lines = result["lines"] as List<String>
        assertTrue(lines.isNotEmpty())
        assertEquals(6, lines.size)
    }
}



================================================
FILE: embabel-agent-mcpserver/src/test/kotlin/com/embabel/agent/mcpserver/async/AsyncServerStrategyTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.async

import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import io.modelcontextprotocol.server.McpAsyncServer
import io.modelcontextprotocol.server.McpServerFeatures
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.assertThrows
import org.junit.jupiter.api.BeforeEach
import reactor.core.publisher.Mono
import reactor.test.StepVerifier
import com.embabel.agent.mcpserver.domain.McpExecutionMode

class AsyncServerStrategyTest {

    private lateinit var mockAsyncServer: McpAsyncServer
    private lateinit var strategy: AsyncServerStrategy

    @BeforeEach
    fun setUp() {
        mockAsyncServer = mockk(relaxed = true)
        strategy = AsyncServerStrategy(mockAsyncServer)
    }

    @Test
    fun `executionMode should return ASYNC`() {
        assertEquals(McpExecutionMode.ASYNC, strategy.executionMode)
    }

    @Test
    fun `addTool should accept AsyncToolSpecification`() {
        val mockToolSpec = mockk<McpServerFeatures.AsyncToolSpecification>()
        every { mockAsyncServer.addTool(mockToolSpec) } returns Mono.empty()

        StepVerifier.create(strategy.addTool(mockToolSpec))
            .verifyComplete()

        verify { mockAsyncServer.addTool(mockToolSpec) }
    }

    @Test
    fun `addTool should reject non-AsyncToolSpecification`() {
        val invalidToolSpec = "invalid"

        StepVerifier.create(strategy.addTool(invalidToolSpec))
            .expectError(IllegalArgumentException::class.java)
            .verify()
    }

    @Test
    fun `addTool error message should include actual type`() {
        val invalidToolSpec = 12345

        StepVerifier.create(strategy.addTool(invalidToolSpec))
            .expectErrorMatches { error ->
                error is IllegalArgumentException &&
                error.message?.contains("Expected AsyncToolSpecification, got Int") == true
            }
            .verify()
    }

    @Test
    fun `removeTool should call server removeTool`() {
        val toolName = "testTool"
        every { mockAsyncServer.removeTool(toolName) } returns Mono.empty()

        StepVerifier.create(strategy.removeTool(toolName))
            .verifyComplete()

        verify { mockAsyncServer.removeTool(toolName) }
    }

    @Test
    fun `addResource should accept AsyncResourceSpecification`() {
        val mockResourceSpec = mockk<McpServerFeatures.AsyncResourceSpecification>()
        every { mockAsyncServer.addResource(mockResourceSpec) } returns Mono.empty()

        StepVerifier.create(strategy.addResource(mockResourceSpec))
            .verifyComplete()

        verify { mockAsyncServer.addResource(mockResourceSpec) }
    }

    @Test
    fun `addResource should reject non-AsyncResourceSpecification`() {
        val invalidResourceSpec = "invalid"

        StepVerifier.create(strategy.addResource(invalidResourceSpec))
            .expectError(IllegalArgumentException::class.java)
            .verify()
    }

    @Test
    fun `addPrompt should accept AsyncPromptSpecification`() {
        val mockPromptSpec = mockk<McpServerFeatures.AsyncPromptSpecification>()
        every { mockAsyncServer.addPrompt(mockPromptSpec) } returns Mono.empty()

        StepVerifier.create(strategy.addPrompt(mockPromptSpec))
            .verifyComplete()

        verify { mockAsyncServer.addPrompt(mockPromptSpec) }
    }

    @Test
    fun `addPrompt should reject non-AsyncPromptSpecification`() {
        val invalidPromptSpec = "invalid"

        StepVerifier.create(strategy.addPrompt(invalidPromptSpec))
            .expectError(IllegalArgumentException::class.java)
            .verify()
    }

    @Test
    fun `getToolRegistry should return AsyncToolRegistry`() {
        val toolRegistry = strategy.getToolRegistry()

        assertTrue(toolRegistry is AsyncToolRegistry)
    }

    @Test
    fun `addTool should handle SyncToolSpecification gracefully`() {
        val mockSyncToolSpec = mockk<McpServerFeatures.SyncToolSpecification>()

        StepVerifier.create(strategy.addTool(mockSyncToolSpec))
            .expectError(IllegalArgumentException::class.java)
            .verify()
    }

    @Test
    fun `addResource should handle SyncResourceSpecification gracefully`() {
        val mockSyncResourceSpec = mockk<McpServerFeatures.SyncResourceSpecification>()

        StepVerifier.create(strategy.addResource(mockSyncResourceSpec))
            .expectError(IllegalArgumentException::class.java)
            .verify()
    }

    @Test
    fun `addPrompt should handle SyncPromptSpecification gracefully`() {
        val mockSyncPromptSpec = mockk<McpServerFeatures.SyncPromptSpecification>()

        StepVerifier.create(strategy.addPrompt(mockSyncPromptSpec))
            .expectError(IllegalArgumentException::class.java)
            .verify()
    }

    @Test
    fun `operations should return completed Monos when server operations succeed`() {
        val mockToolSpec = mockk<McpServerFeatures.AsyncToolSpecification>()
        val mockResourceSpec = mockk<McpServerFeatures.AsyncResourceSpecification>()
        val mockPromptSpec = mockk<McpServerFeatures.AsyncPromptSpecification>()

        every { mockAsyncServer.addTool(any()) } returns Mono.empty()
        every { mockAsyncServer.addResource(any()) } returns Mono.empty()
        every { mockAsyncServer.addPrompt(any()) } returns Mono.empty()
        every { mockAsyncServer.removeTool(any()) } returns Mono.empty()

        // Test that all operations complete without error
        StepVerifier.create(strategy.addTool(mockToolSpec))
            .verifyComplete()

        StepVerifier.create(strategy.addResource(mockResourceSpec))
            .verifyComplete()

        StepVerifier.create(strategy.addPrompt(mockPromptSpec))
            .verifyComplete()

        StepVerifier.create(strategy.removeTool("testTool"))
            .verifyComplete()
    }

    @Test
    fun `operations should propagate server errors`() {
        val mockToolSpec = mockk<McpServerFeatures.AsyncToolSpecification>()
        val serverError = RuntimeException("Server error")

        every { mockAsyncServer.addTool(any()) } returns Mono.error(serverError)

        StepVerifier.create(strategy.addTool(mockToolSpec))
            .expectError(RuntimeException::class.java)
            .verify()
    }

    @Test
    fun `removeTool should handle server errors`() {
        val toolName = "failingTool"
        val serverError = RuntimeException("Remove failed")

        every { mockAsyncServer.removeTool(toolName) } returns Mono.error(serverError)

        StepVerifier.create(strategy.removeTool(toolName))
            .expectError(RuntimeException::class.java)
            .verify()
    }

    @Test
    fun `addResource should handle server timeout`() {
        val mockResourceSpec = mockk<McpServerFeatures.AsyncResourceSpecification>()

        every { mockAsyncServer.addResource(any()) } returns Mono.never() // Simulates timeout

        StepVerifier.create(strategy.addResource(mockResourceSpec))
            .expectTimeout(java.time.Duration.ofSeconds(1))
            .verify()
    }

    @Test
    fun `operations should handle null specifications gracefully`() {
        // Test with null values by passing them directly
        // This will cause KotlinNullPointerException due to force unwrapping

        assertThrows<NullPointerException> {
            strategy.addTool(null!!)
        }

        assertThrows<NullPointerException> {
            strategy.addResource(null!!)
        }

        assertThrows<NullPointerException> {
            strategy.addPrompt(null!!)
        }
    }
}



================================================
FILE: embabel-agent-mcpserver/src/test/kotlin/com/embabel/agent/mcpserver/async/AsyncToolRegistryTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.async

import io.mockk.*
import io.modelcontextprotocol.server.McpAsyncServer
import com.embabel.agent.mcpserver.support.toolNames
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.AfterEach

class AsyncToolRegistryTest {

    private lateinit var mockAsyncServer: McpAsyncServer
    private lateinit var toolRegistry: AsyncToolRegistry

    @BeforeEach
    fun setUp() {
        // Mock the extension function at the top level
        mockkStatic("com.embabel.agent.mcpserver.support.ExtensionsKt")
        mockAsyncServer = mockk()
        toolRegistry = AsyncToolRegistry(mockAsyncServer)
    }

    @AfterEach
    fun tearDown() {
        unmockkStatic("com.embabel.agent.mcpserver.support.ExtensionsKt")
    }

    @Test
    fun `getToolNames should return tools from server`() {
        val expectedTools = listOf("asyncTool1", "asyncTool2", "asyncTool3")
        every { mockAsyncServer.toolNames() } returns expectedTools

        val result = toolRegistry.getToolNames()

        assertEquals(expectedTools, result)
    }

    @Test
    fun `getToolNames should handle empty tool list`() {
        every { mockAsyncServer.toolNames() } returns emptyList()

        val result = toolRegistry.getToolNames()

        assertEquals(emptyList<String>(), result)
    }

    @Test
    fun `getToolCount should return correct count`() {
        val tools = listOf("asyncTool1", "asyncTool2", "asyncTool3", "asyncTool4")
        every { mockAsyncServer.toolNames() } returns tools

        val result = toolRegistry.getToolCount()

        assertEquals(4, result)
    }

    @Test
    fun `getToolCount should return zero for empty tool list`() {
        every { mockAsyncServer.toolNames() } returns emptyList()

        val result = toolRegistry.getToolCount()

        assertEquals(0, result)
    }

    @Test
    fun `hasToolNamed should return true when tool exists`() {
        val tools = listOf("asyncTool1", "asyncTool2", "asyncTool3")
        every { mockAsyncServer.toolNames() } returns tools

        assertTrue(toolRegistry.hasToolNamed("asyncTool2"))
    }

    @Test
    fun `hasToolNamed should return false when tool does not exist`() {
        val tools = listOf("asyncTool1", "asyncTool2", "asyncTool3")
        every { mockAsyncServer.toolNames() } returns tools

        assertFalse(toolRegistry.hasToolNamed("nonExistentAsyncTool"))
    }

    @Test
    fun `hasToolNamed should return false for empty tool list`() {
        every { mockAsyncServer.toolNames() } returns emptyList()

        assertFalse(toolRegistry.hasToolNamed("anyAsyncTool"))
    }

    @Test
    fun `hasToolNamed should handle special characters in tool names`() {
        val tools = listOf("async-tool-1", "async_tool_2", "async.tool.3", "async@tool#4")
        every { mockAsyncServer.toolNames() } returns tools

        assertTrue(toolRegistry.hasToolNamed("async-tool-1"))
        assertTrue(toolRegistry.hasToolNamed("async_tool_2"))
        assertTrue(toolRegistry.hasToolNamed("async.tool.3"))
        assertTrue(toolRegistry.hasToolNamed("async@tool#4"))
    }

    @Test
    fun `hasToolNamed should be case sensitive`() {
        val tools = listOf("AsyncTool1", "asyncTool2", "ASYNCTOOL3")
        every { mockAsyncServer.toolNames() } returns tools

        assertTrue(toolRegistry.hasToolNamed("AsyncTool1"))
        assertFalse(toolRegistry.hasToolNamed("asynctool1"))
        assertTrue(toolRegistry.hasToolNamed("ASYNCTOOL3"))
        assertFalse(toolRegistry.hasToolNamed("asynctool3"))
    }

    @Test
    fun `operations should be consistent across multiple calls`() {
        val tools = listOf("asyncTool1", "asyncTool2")
        every { mockAsyncServer.toolNames() } returns tools

        // Multiple calls should return consistent results
        assertEquals(tools, toolRegistry.getToolNames())
        assertEquals(tools, toolRegistry.getToolNames())

        assertEquals(2, toolRegistry.getToolCount())
        assertEquals(2, toolRegistry.getToolCount())

        assertTrue(toolRegistry.hasToolNamed("asyncTool1"))
        assertTrue(toolRegistry.hasToolNamed("asyncTool1"))
    }

    @Test
    fun `getToolCount should match getToolNames size`() {
        val tools = listOf("asyncTool1", "asyncTool2", "asyncTool3", "asyncTool4", "asyncTool5")
        every { mockAsyncServer.toolNames() } returns tools

        assertEquals(toolRegistry.getToolNames().size, toolRegistry.getToolCount())
    }

    @Test
    fun `hasToolNamed should work with all tools from getToolNames`() {
        val tools = listOf("alphaAsync", "betaAsync", "gammaAsync", "deltaAsync")
        every { mockAsyncServer.toolNames() } returns tools

        // All tools returned by getToolNames should be found by hasToolNamed
        tools.forEach { toolName ->
            assertTrue(
                toolRegistry.hasToolNamed(toolName),
                "Tool '$toolName' should be found by hasToolNamed"
            )
        }
    }

    @Test
    fun `should handle large number of tools efficiently`() {
        val tools = (1..1000).map { "asyncTool$it" }
        every { mockAsyncServer.toolNames() } returns tools

        assertEquals(1000, toolRegistry.getToolCount())
        assertTrue(toolRegistry.hasToolNamed("asyncTool500"))
        assertFalse(toolRegistry.hasToolNamed("asyncTool1001"))
    }

    @Test
    fun `should handle tools with unicode characters`() {
        val tools = listOf("αβγ-tool", "测试工具", "инструмент", "🔧-tool")
        every { mockAsyncServer.toolNames() } returns tools

        tools.forEach { toolName ->
            assertTrue(
                toolRegistry.hasToolNamed(toolName),
                "Unicode tool name '$toolName' should be handled correctly"
            )
        }
    }
}



================================================
FILE: embabel-agent-mcpserver/src/test/kotlin/com/embabel/agent/mcpserver/async/McpAsyncPromptFactoryTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.async

import com.embabel.agent.mcpserver.async.McpAsyncPromptFactory
import com.embabel.agent.domain.io.UserInput
import com.embabel.common.core.types.NamedAndDescribed
import com.embabel.common.core.types.Timestamped
import io.mockk.mockk
import io.modelcontextprotocol.spec.McpSchema
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*

// Test interfaces at top level
interface CustomInterface {
    val customField: String
}

class McpAsyncPromptFactoryTest {

    @Test
    fun `McpAsyncPromptFactory should create async prompt specifications`() {
        val factory = McpAsyncPromptFactory()
        val goal = NamedAndDescribed("testGoal", "A test goal for async processing")

        val spec = factory.asyncPromptSpecificationForType(
            goal,
            UserInput::class.java
        )

        assertNotNull(spec)
        assertEquals("UserInput_testGoal", spec.prompt.name())
        assertEquals("A test goal for async processing", spec.prompt.description())
        assertFalse(spec.prompt.arguments.isEmpty())
    }

    @Test
    fun `McpAsyncPromptFactory should handle custom name and description`() {
        val factory = McpAsyncPromptFactory()
        val goal = NamedAndDescribed("originalName", "Original description")

        val spec = factory.asyncPromptSpecificationForType(
            goal,
            UserInput::class.java,
            name = "customName",
            description = "Custom description"
        )

        assertEquals("UserInput_customName", spec.prompt.name())
        assertEquals("Custom description", spec.prompt.description())
    }

    @Test
    fun `McpAsyncPromptFactory should exclude timestamp fields by default`() {
        data class TestClassWithTimestamp(
            val name: String,
            val age: Int,
            override val timestamp: java.time.Instant
        ) : Timestamped

        val factory = McpAsyncPromptFactory()
        val goal = NamedAndDescribed("timestampTest", "Test with timestamp")

        val spec = factory.asyncPromptSpecificationForType(
            goal,
            TestClassWithTimestamp::class.java
        )

        val argumentNames = spec.prompt.arguments.map { it.name }
        assertFalse(argumentNames.contains("timestamp"))
        assertTrue(argumentNames.contains("name"))
        assertTrue(argumentNames.contains("age"))
    }

    @Test
    fun `McpAsyncPromptFactory should handle custom excluded interfaces`() {

        data class TestClassWithCustomInterface(
            val name: String,
            val age: Int,
            override val customField: String
        ) : CustomInterface

        val factory = McpAsyncPromptFactory(
            excludedInterfaces = setOf(CustomInterface::class.java)
        )
        val goal = NamedAndDescribed("customTest", "Test with custom interface")

        val spec = factory.asyncPromptSpecificationForType(
            goal,
            TestClassWithCustomInterface::class.java
        )

        val argumentNames = spec.prompt.arguments.map { it.name }
        assertFalse(argumentNames.contains("customField"))
        assertTrue(argumentNames.contains("name"))
        assertTrue(argumentNames.contains("age"))
    }

    @Test
    fun `McpAsyncPromptFactory should handle empty classes`() {
        class EmptyTestClass

        val factory = McpAsyncPromptFactory()
        val goal = NamedAndDescribed("emptyTest", "Test with empty class")

        val spec = factory.asyncPromptSpecificationForType(
            goal,
            EmptyTestClass::class.java
        )

        assertTrue(spec.prompt.arguments.isEmpty())
    }

    @Test
    fun `async prompt handler should process requests correctly`() {
        val factory = McpAsyncPromptFactory()
        val goal = NamedAndDescribed("handlerTest", "Test prompt handler")

        val spec = factory.asyncPromptSpecificationForType(
            goal,
            UserInput::class.java
        )

        val request = McpSchema.GetPromptRequest("handlerTest", mapOf("content" to "test content"))
        val asyncServerExchange = mockk<io.modelcontextprotocol.server.McpAsyncServerExchange>()

        val resultMono = spec.promptHandler.apply(asyncServerExchange, request)

        assertNotNull(resultMono)
        // Test that the Mono can be subscribed to (basic validity check)
        val result = resultMono.block()
        assertNotNull(result)
        assertEquals("handlerTest-result", result!!.description)
        assertEquals(1, result.messages.size)

        val message = result.messages.first()
        assertEquals(McpSchema.Role.USER, message.role)
        assertTrue((message.content as McpSchema.TextContent).text.contains("handlerTest"))
        assertTrue((message.content as McpSchema.TextContent).text.contains("test content"))
    }

    @Test
    fun `async prompt should handle multiple arguments correctly`() {
        data class MultiArgClass(
            val name: String,
            val age: Int,
            val email: String
        )

        val factory = McpAsyncPromptFactory()
        val goal = NamedAndDescribed("multiArgTest", "Test with multiple arguments")

        val spec = factory.asyncPromptSpecificationForType(
            goal,
            MultiArgClass::class.java
        )

        val request = McpSchema.GetPromptRequest(
            "multiArgTest",
            mapOf(
                "name" to "John",
                "age" to "30",
                "email" to "john@example.com"
            )
        )
        val asyncServerExchange = mockk<io.modelcontextprotocol.server.McpAsyncServerExchange>()

        val result = spec.promptHandler.apply(asyncServerExchange, request).block()

        assertNotNull(result)
        val messageContent = (result!!.messages.first().content as McpSchema.TextContent).text
        assertTrue(messageContent.contains("name=John"))
        assertTrue(messageContent.contains("age=30"))
        assertTrue(messageContent.contains("email=john@example.com"))
    }

    @Test
    fun `async prompt should handle empty arguments map`() {
        val factory = McpAsyncPromptFactory()
        val goal = NamedAndDescribed("emptyArgsTest", "Test with empty arguments")

        val spec = factory.asyncPromptSpecificationForType(
            goal,
            UserInput::class.java
        )

        val request = McpSchema.GetPromptRequest("emptyArgsTest", emptyMap())
        val asyncServerExchange = mockk<io.modelcontextprotocol.server.McpAsyncServerExchange>()

        val result = spec.promptHandler.apply(asyncServerExchange, request).block()

        assertNotNull(result)
        val messageContent = (result!!.messages.first().content as McpSchema.TextContent).text
        assertTrue(messageContent.contains("emptyArgsTest"))
        assertTrue(messageContent.contains("Test with empty arguments"))
    }
}



================================================
FILE: embabel-agent-mcpserver/src/test/kotlin/com/embabel/agent/mcpserver/config/McpServerConditionsTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.config

import com.embabel.agent.mcpserver.async.config.McpAsyncServerCondition
import com.embabel.agent.mcpserver.sync.config.McpSyncServerCondition
import io.mockk.every
import io.mockk.mockk
import org.junit.jupiter.api.Assertions.assertFalse
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import org.springframework.context.annotation.ConditionContext
import org.springframework.core.env.Environment
import org.springframework.core.type.AnnotatedTypeMetadata

class McpServerConditionsTest {

    @Test
    fun `McpSyncServerCondition should match when enabled and type is SYNC`() {
        val condition = McpSyncServerCondition()
        val context = mockk<ConditionContext>()
        val metadata = mockk<AnnotatedTypeMetadata>()
        val environment = mockk<Environment>()

        every { context.environment } returns environment
        every { environment.getProperty("spring.ai.mcp.server.type", "SYNC") } returns "SYNC"

        assertTrue(condition.matches(context, metadata))
    }

    @Test
    fun `McpSyncServerCondition should not match when type is ASYNC`() {
        val condition = McpSyncServerCondition()
        val context = mockk<ConditionContext>()
        val metadata = mockk<AnnotatedTypeMetadata>()
        val environment = mockk<Environment>()

        every { context.environment } returns environment
        every { environment.getProperty("spring.ai.mcp.server.type", "SYNC") } returns "ASYNC"

        assertFalse(condition.matches(context, metadata))
    }

    @Test
    fun `McpSyncServerCondition should match when enabled and type defaults to SYNC`() {
        val condition = McpSyncServerCondition()
        val context = mockk<ConditionContext>()
        val metadata = mockk<AnnotatedTypeMetadata>()
        val environment = mockk<Environment>()

        every { context.environment } returns environment
        every { environment.getProperty("spring.ai.mcp.server.type", "SYNC") } returns "SYNC" // Default value

        assertTrue(condition.matches(context, metadata))
    }

    @Test
    fun `McpAsyncServerCondition should match when enabled and type is ASYNC`() {
        val condition = McpAsyncServerCondition()
        val context = mockk<ConditionContext>()
        val metadata = mockk<AnnotatedTypeMetadata>()
        val environment = mockk<Environment>()

        every { context.environment } returns environment
        every { environment.getProperty("spring.ai.mcp.server.type", "SYNC") } returns "ASYNC"

        assertTrue(condition.matches(context, metadata))
    }

    @Test
    fun `McpAsyncServerCondition should not match when type is SYNC`() {
        val condition = McpAsyncServerCondition()
        val context = mockk<ConditionContext>()
        val metadata = mockk<AnnotatedTypeMetadata>()
        val environment = mockk<Environment>()

        every { context.environment } returns environment
        every { environment.getProperty("spring.ai.mcp.server.type", "SYNC") } returns "SYNC"

        assertFalse(condition.matches(context, metadata))
    }

    @Test
    fun `McpAsyncServerCondition should not match with default SYNC type`() {
        val condition = McpAsyncServerCondition()
        val context = mockk<ConditionContext>()
        val metadata = mockk<AnnotatedTypeMetadata>()
        val environment = mockk<Environment>()

        every { context.environment } returns environment
        every { environment.getProperty("spring.ai.mcp.server.type", "SYNC") } returns "SYNC" // Default

        assertFalse(condition.matches(context, metadata))
    }

    @Test
    fun `conditions should handle null environment gracefully`() {
        val syncCondition = McpSyncServerCondition()
        val asyncCondition = McpAsyncServerCondition()
        val context = mockk<ConditionContext>(relaxed = true)
        val metadata = mockk<AnnotatedTypeMetadata>()

        // Use relaxed mock to handle potential null returns
        every { context.environment } throws NullPointerException("Environment is null")

        // Since environment access throws NPE, conditions should handle this
        assertThrows<Exception> {
            syncCondition.matches(context, metadata)
        }
        assertThrows<Exception> {
            asyncCondition.matches(context, metadata)
        }
    }

    @Test
    fun `conditions should handle case insensitive type values`() {
        val syncCondition = McpSyncServerCondition()
        val asyncCondition = McpAsyncServerCondition()
        val context = mockk<ConditionContext>()
        val metadata = mockk<AnnotatedTypeMetadata>()
        val environment = mockk<Environment>()

        every { context.environment } returns environment

        // Test lowercase
        every { environment.getProperty("spring.ai.mcp.server.type", "SYNC") } returns "sync"
        assertFalse(syncCondition.matches(context, metadata)) // Should be case sensitive

        every { environment.getProperty("spring.ai.mcp.server.type", "SYNC") } returns "async"
        assertFalse(asyncCondition.matches(context, metadata)) // Should be case sensitive
    }

    @Test
    fun `conditions should handle unknown type values`() {
        val syncCondition = McpSyncServerCondition()
        val asyncCondition = McpAsyncServerCondition()
        val context = mockk<ConditionContext>()
        val metadata = mockk<AnnotatedTypeMetadata>()
        val environment = mockk<Environment>()

        every { context.environment } returns environment
        every { environment.getProperty("spring.ai.mcp.server.type", "SYNC") } returns "UNKNOWN"

        assertFalse(syncCondition.matches(context, metadata))
        assertFalse(asyncCondition.matches(context, metadata))
    }

    @Test
    fun `conditions should respect default values`() {
        val syncCondition = McpSyncServerCondition()
        val context = mockk<ConditionContext>()
        val metadata = mockk<AnnotatedTypeMetadata>()
        val environment = mockk<Environment>()

        every { context.environment } returns environment
        // When type property is not set, should default to "SYNC"
        every { environment.getProperty("spring.ai.mcp.server.type", "SYNC") } returns "SYNC"

        assertTrue(syncCondition.matches(context, metadata))
    }
}



================================================
FILE: embabel-agent-mcpserver/src/test/kotlin/com/embabel/agent/mcpserver/domain/TypesTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.domain

import io.mockk.every
import io.mockk.mockk
import io.modelcontextprotocol.spec.McpSchema
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*
import java.time.Instant
import kotlin.test.assertEquals

class TypesTest {

    @Test
    fun `McpExecutionMode should contain SYNC and ASYNC values`() {
        val modes = McpExecutionMode.values()
        assertEquals(2, modes.size)
        assertTrue(modes.contains(McpExecutionMode.SYNC))
        assertTrue(modes.contains(McpExecutionMode.ASYNC))
    }

    @Test
    fun `ServerInfo should create banner lines correctly`() {
        val startTime = Instant.parse("2025-01-01T12:00:00Z")
        val serverInfo = ServerInfo(
            name = "Test Server",
            version = "1.0.0",
            mode = McpExecutionMode.SYNC,
            javaVersion = "17.0.1",
            startTime = startTime
        )

        val bannerLines = serverInfo.toBannerLines()

        assertEquals(6, bannerLines.size)
        assertEquals("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", bannerLines[0])
        assertEquals("Embabel Agent MCP SYNC Server", bannerLines[1])
        assertEquals("Version: 1.0.0", bannerLines[2])
        assertEquals("Java: 17.0.1", bannerLines[3])
        assertEquals("Started: $startTime", bannerLines[4])
        assertEquals("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", bannerLines[5])
    }

    @Test
    fun `ServerInfo should use current time by default`() {
        val beforeCreation = Instant.now()
        val serverInfo = ServerInfo(
            name = "Test Server",
            version = "1.0.0",
            mode = McpExecutionMode.ASYNC,
            javaVersion = "17.0.1"
        )
        val afterCreation = Instant.now()

        assertTrue(serverInfo.startTime.isAfter(beforeCreation) || serverInfo.startTime == beforeCreation)
        assertTrue(serverInfo.startTime.isBefore(afterCreation) || serverInfo.startTime == afterCreation)
    }

    @Test
    fun `ToolSpecification should return correct tool name and description`() {
        val mockTool = mockk<McpSchema.Tool>()
        every { mockTool.name() } returns "testTool"
        every { mockTool.description() } returns "Test tool description"

        val toolSpec = object : ToolSpecification<String> {
            override val tool: McpSchema.Tool = mockTool
            override val handler: String = "testHandler"
        }

        assertEquals("testTool", toolSpec.toolName())
        assertEquals("Test tool description", toolSpec.toolDescription())
    }

    @Test
    fun `ToolSpecification should handle null description`() {
        val mockTool = mockk<McpSchema.Tool>()
        every { mockTool.name() } returns "testTool"
        every { mockTool.description() } returns null

        val toolSpec = object : ToolSpecification<String> {
            override val tool: McpSchema.Tool = mockTool
            override val handler: String = "testHandler"
        }

        assertEquals("testTool", toolSpec.toolName())
        assertEquals("No description", toolSpec.toolDescription())
    }

    @Test
    fun `McpCapability should contain all expected values`() {
        val capabilities = McpCapability.values()
        assertEquals(5, capabilities.size)
        assertTrue(capabilities.contains(McpCapability.TOOLS))
        assertTrue(capabilities.contains(McpCapability.RESOURCES))
        assertTrue(capabilities.contains(McpCapability.PROMPTS))
        assertTrue(capabilities.contains(McpCapability.LOGGING))
        assertTrue(capabilities.contains(McpCapability.COMPLETIONS))
    }

    @Test
    fun `ServerHealthStatus should create with all properties`() {
        val timestamp = Instant.parse("2025-01-01T12:00:00Z")
        val issues = listOf("Issue 1", "Issue 2")

        val healthStatus = ServerHealthStatus(
            isHealthy = false,
            mode = McpExecutionMode.ASYNC,
            toolCount = 5,
            issues = issues,
            timestamp = timestamp
        )

        assertFalse(healthStatus.isHealthy)
        assertEquals(McpExecutionMode.ASYNC, healthStatus.mode)
        assertEquals(5, healthStatus.toolCount)
        assertEquals(issues, healthStatus.issues)
        assertEquals(timestamp, healthStatus.timestamp)
    }

    @Test
    fun `ServerHealthStatus should use current time by default`() {
        val beforeCreation = Instant.now()
        val healthStatus = ServerHealthStatus(
            isHealthy = true,
            mode = McpExecutionMode.SYNC,
            toolCount = 3,
            issues = emptyList()
        )
        val afterCreation = Instant.now()

        assertTrue(healthStatus.timestamp.isAfter(beforeCreation) || healthStatus.timestamp == beforeCreation)
        assertTrue(healthStatus.timestamp.isBefore(afterCreation) || healthStatus.timestamp == afterCreation)
    }

    @Test
    fun `ServerHealthStatus should handle healthy status correctly`() {
        val healthStatus = ServerHealthStatus(
            isHealthy = true,
            mode = McpExecutionMode.SYNC,
            toolCount = 10,
            issues = emptyList()
        )

        assertTrue(healthStatus.isHealthy)
        assertTrue(healthStatus.issues.isEmpty())
    }

    @Test
    fun `ServerHealthStatus should handle unhealthy status with issues`() {
        val issues = listOf("Database connection failed", "Service timeout")
        val healthStatus = ServerHealthStatus(
            isHealthy = false,
            mode = McpExecutionMode.ASYNC,
            toolCount = 0,
            issues = issues
        )

        assertFalse(healthStatus.isHealthy)
        assertEquals(2, healthStatus.issues.size)
        assertEquals("Database connection failed", healthStatus.issues[0])
        assertEquals("Service timeout", healthStatus.issues[1])
    }
}



================================================
FILE: embabel-agent-mcpserver/src/test/kotlin/com/embabel/agent/mcpserver/support/ExtensionsTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.support

import io.mockk.*
import io.modelcontextprotocol.server.McpAsyncServer
import io.modelcontextprotocol.server.McpSyncServer
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.AfterEach

class ExtensionsTest {

    @BeforeEach
    fun setUp() {
        mockkStatic("com.embabel.agent.mcpserver.support.ExtensionsKt")
    }

    @AfterEach
    fun tearDown() {
        unmockkStatic("com.embabel.agent.mcpserver.support.ExtensionsKt")
    }

    @Test
    fun `McpAsyncServer toolNames extension should be available`() {
        val asyncServer = mockk<McpAsyncServer>()

        // Mock the extension function behavior
        every { asyncServer.toolNames() } returns listOf("tool1", "tool2")

        val result = asyncServer.toolNames()

        assertEquals(listOf("tool1", "tool2"), result)
    }

    @Test
    fun `McpAsyncServer toolNames should handle empty list`() {
        val asyncServer = mockk<McpAsyncServer>()

        every { asyncServer.toolNames() } returns emptyList()

        val result = asyncServer.toolNames()

        assertEquals(emptyList<String>(), result)
    }

    @Test
    fun `McpSyncServer toolNames should delegate to asyncServer`() {
        val mockAsyncServer = mockk<McpAsyncServer>()
        every { mockAsyncServer.toolNames() } returns listOf("syncTool1", "syncTool2")

        val syncServer = mockk<McpSyncServer>()
        every { syncServer.asyncServer } returns mockAsyncServer

        val result = syncServer.toolNames()

        assertEquals(listOf("syncTool1", "syncTool2"), result)
        verify { mockAsyncServer.toolNames() }
    }

    @Test
    fun `McpSyncServer toolNames should handle empty result from asyncServer`() {
        val mockAsyncServer = mockk<McpAsyncServer>()
        every { mockAsyncServer.toolNames() } returns emptyList()

        val syncServer = mockk<McpSyncServer>()
        every { syncServer.asyncServer } returns mockAsyncServer

        val result = syncServer.toolNames()

        assertEquals(emptyList<String>(), result)
        verify { mockAsyncServer.toolNames() }
    }

    @Test
    fun `extension functions should be properly imported and accessible`() {
        // This test verifies that the extension functions are properly defined
        // and can be imported without compilation errors

        val asyncServer = mockk<McpAsyncServer>()
        val syncServer = mockk<McpSyncServer>()

        every { asyncServer.toolNames() } returns listOf("test")
        every { syncServer.asyncServer } returns asyncServer

        // These calls should compile without issues
        assertNotNull(asyncServer.toolNames())
        assertNotNull(syncServer.toolNames())
    }

    @Test
    fun `toolNames extensions should handle various scenarios`() {
        val asyncServer = mockk<McpAsyncServer>()
        val syncServer = mockk<McpSyncServer>()

        // Test with various return values
        val testCases = listOf(
            emptyList<String>(),
            listOf("singleTool"),
            listOf("tool1", "tool2", "tool3"),
            listOf("tool-with-dashes", "tool_with_underscores", "tool.with.dots")
        )

        testCases.forEach { expectedTools ->
            every { asyncServer.toolNames() } returns expectedTools
            every { syncServer.asyncServer } returns asyncServer

            assertEquals(expectedTools, asyncServer.toolNames())
            assertEquals(expectedTools, syncServer.toolNames())
        }
    }
}



================================================
FILE: embabel-agent-mcpserver/src/test/kotlin/com/embabel/agent/mcpserver/support/PromptUtilsTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.support

import com.embabel.common.core.types.Timestamped
import com.fasterxml.jackson.annotation.JsonPropertyDescription
import io.modelcontextprotocol.spec.McpSchema
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*

// Test interfaces at top level
interface TestCustomInterface {
    val customField: String
}

class PromptUtilsTest {

    // Test data classes
    data class SimpleTestClass(
        val name: String,
        val age: Int
    )

    data class TestClassWithDescription(
        @JsonPropertyDescription("The user's full name")
        val name: String,
        @JsonPropertyDescription("The user's age in years")
        val age: Int,
        val email: String // No description
    )

    data class TestClassWithTimestamp(
        val name: String,
        val age: Int,
        override val timestamp: java.time.Instant
    ) : Timestamped

    data class TestClassWithSyntheticFields(
        val name: String,
        val age: Int
    ) {
        // Synthetic fields are typically generated by compiler
        // This simulates the scenario
    }

    class EmptyTestClass

    @Test
    fun `argumentsFromType should extract basic fields`() {
        val arguments = argumentsFromType(emptySet(), SimpleTestClass::class.java)

        assertEquals(2, arguments.size)

        val nameArg = arguments.find { it.name == "name" }
        assertNotNull(nameArg)
        assertEquals("name: String", nameArg!!.description)
        assertTrue(nameArg.required)

        val ageArg = arguments.find { it.name == "age" }
        assertNotNull(ageArg)
        assertEquals("age: Int", ageArg!!.description)
        assertTrue(ageArg.required)
    }

    @Test
    fun `argumentsFromType should use JsonPropertyDescription when available`() {
        val arguments = argumentsFromType(emptySet(), TestClassWithDescription::class.java)

        assertEquals(3, arguments.size)

        val nameArg = arguments.find { it.name == "name" }
        assertNotNull(nameArg)
        assertEquals("The user's full name: String", nameArg!!.description)

        val ageArg = arguments.find { it.name == "age" }
        assertNotNull(ageArg)
        assertEquals("The user's age in years: Int", ageArg!!.description)

        val emailArg = arguments.find { it.name == "email" }
        assertNotNull(emailArg)
        assertEquals("email: String", emailArg!!.description)
    }

    @Test
    fun `argumentsFromType should exclude fields from excluded interfaces`() {
        val excludedInterfaces = setOf(Timestamped::class.java)
        val arguments = argumentsFromType(excludedInterfaces, TestClassWithTimestamp::class.java)

        assertEquals(2, arguments.size)
        assertTrue(arguments.none { it.name == "timestamp" })
        assertTrue(arguments.any { it.name == "name" })
        assertTrue(arguments.any { it.name == "age" })
    }

    @Test
    fun `argumentsFromType should handle empty class`() {
        val arguments = argumentsFromType(emptySet(), EmptyTestClass::class.java)

        assertEquals(0, arguments.size)
    }

    @Test
    fun `argumentsFromType should handle multiple excluded interfaces`() {

        data class TestWithMultipleInterfaces(
            val name: String,
            override val timestamp: java.time.Instant,
            override val customField: String
        ) : Timestamped, TestCustomInterface

        val excludedInterfaces = setOf(Timestamped::class.java, TestCustomInterface::class.java)
        val arguments = argumentsFromType(excludedInterfaces, TestWithMultipleInterfaces::class.java)

        assertEquals(1, arguments.size)
        assertEquals("name", arguments[0].name)
    }

    @Test
    fun `argumentsFromType should set all fields as required`() {
        val arguments = argumentsFromType(emptySet(), SimpleTestClass::class.java)

        assertTrue(arguments.all { it.required })
    }

    @Test
    fun `argumentsFromType should handle various primitive types`() {
        data class PrimitiveTestClass(
            val stringField: String,
            val intField: Int,
            val longField: Long,
            val doubleField: Double,
            val booleanField: Boolean,
            val floatField: Float
        )

        val arguments = argumentsFromType(emptySet(), PrimitiveTestClass::class.java)

        assertEquals(6, arguments.size)

        val expectedTypes = mapOf(
            "stringField" to "String",
            "intField" to "Int",
            "longField" to "Long",
            "doubleField" to "Double",
            "booleanField" to "Boolean",
            "floatField" to "Float"
        )

        arguments.forEach { arg ->
            val expectedType = expectedTypes[arg.name]
            assertNotNull(expectedType, "Unexpected field: ${arg.name}")
            assertTrue(
                arg.description.endsWith(": $expectedType"),
                "Expected description to end with ': $expectedType' but was: ${arg.description}"
            )
        }
    }

    @Test
    fun `argumentsFromType should handle complex types`() {
        data class ComplexTestClass(
            val listField: List<String>,
            val mapField: Map<String, Int>,
            val optionalField: String?
        )

        val arguments = argumentsFromType(emptySet(), ComplexTestClass::class.java)

        assertEquals(3, arguments.size)
        assertTrue(arguments.any { it.name == "listField" })
        assertTrue(arguments.any { it.name == "mapField" })
        assertTrue(arguments.any { it.name == "optionalField" })
    }

    @Test
    fun `argumentsFromType should create valid McpSchema PromptArgument objects`() {
        val arguments = argumentsFromType(emptySet(), SimpleTestClass::class.java)

        arguments.forEach { arg ->
            // Verify it's a valid McpSchema.PromptArgument
            assertNotNull(arg.name)
            assertFalse(arg.name.isBlank())
            assertNotNull(arg.description)
            assertFalse(arg.description.isBlank())
            // All arguments should be required in this implementation
            assertTrue(arg.required)
        }
    }
}



================================================
FILE: embabel-agent-mcpserver/src/test/kotlin/com/embabel/agent/mcpserver/sync/AsyncFactoriesTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.sync

import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*

/**
 * Integration tests for synchronous MCP server components.
 * This placeholder class ensures the sync package has complete test coverage.
 */
class SyncIntegrationTest {

    @Test
    fun `sync package should be properly structured`() {
        // Verify core sync classes exist and are accessible
        assertDoesNotThrow {
            SyncServerStrategy::class.java
            SyncToolRegistry::class.java
            McpPromptFactory::class.java
        }
    }

    @Test
    fun `sync components should follow naming conventions`() {
        val syncClasses = listOf(
            SyncServerStrategy::class.java,
            SyncToolRegistry::class.java
        )

        syncClasses.forEach { clazz ->
            assertTrue(
                clazz.simpleName.startsWith("Sync"),
                "Sync class ${clazz.simpleName} should start with 'Sync'"
            )
        }
    }

    @Test
    fun `sync package should have proper interfaces`() {
        // Verify that sync implementations implement the correct interfaces
        assertTrue(
            com.embabel.agent.mcpserver.McpServerStrategy::class.java.isAssignableFrom(SyncServerStrategy::class.java),
            "SyncServerStrategy should implement McpServerStrategy"
        )

        assertTrue(
            com.embabel.agent.mcpserver.ToolRegistry::class.java.isAssignableFrom(SyncToolRegistry::class.java),
            "SyncToolRegistry should implement ToolRegistry"
        )
    }

    @Test
    fun `sync classes should be in correct package`() {
        assertEquals(
            "com.embabel.agent.mcpserver.sync",
            SyncServerStrategy::class.java.packageName
        )
        assertEquals(
            "com.embabel.agent.mcpserver.sync",
            SyncToolRegistry::class.java.packageName
        )
        assertEquals(
            "com.embabel.agent.mcpserver.sync",
            McpPromptFactory::class.java.packageName
        )
    }
}



================================================
FILE: embabel-agent-mcpserver/src/test/kotlin/com/embabel/agent/mcpserver/sync/McpPromptFactoryExtendedTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.sync

import com.embabel.agent.domain.io.UserInput
import com.embabel.common.core.types.NamedAndDescribed
import com.embabel.common.core.types.Timestamped
import com.fasterxml.jackson.annotation.JsonPropertyDescription
import io.mockk.mockk
import io.modelcontextprotocol.spec.McpSchema
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*

// Test interfaces at top level
interface AuditableInterface {
    val createdBy: String
    val createdAt: java.time.Instant
}

interface Interface1 {
    val field1: String
}

interface Interface2 {
    val field2: String
}

class McpPromptFactoryExtendedTest {

    @Test
    fun `McpPromptFactory should handle various argument types correctly`() {
        data class ComplexTestClass(
            @JsonPropertyDescription("User's full name")
            val name: String,
            @JsonPropertyDescription("User's age in years")
            val age: Int,
            val email: String,
            val isActive: Boolean,
            val score: Double
        )

        val factory = McpPromptFactory()
        val goal = NamedAndDescribed("complexTest", "A complex test goal")

        val spec = factory.syncPromptSpecificationForType(
            goal,
            ComplexTestClass::class.java
        )

        assertEquals(5, spec.prompt.arguments.size)

        val nameArg = spec.prompt.arguments.find { it.name == "name" }
        assertNotNull(nameArg)
        assertEquals("User's full name: String", nameArg!!.description)
        assertTrue(nameArg.required)

        val ageArg = spec.prompt.arguments.find { it.name == "age" }
        assertNotNull(ageArg)
        assertEquals("User's age in years: Int", ageArg!!.description)

        val emailArg = spec.prompt.arguments.find { it.name == "email" }
        assertNotNull(emailArg)
        assertEquals("email: String", emailArg!!.description)

        val isActiveArg = spec.prompt.arguments.find { it.name == "isActive" }
        assertNotNull(isActiveArg)
        assertEquals("isActive: Boolean", isActiveArg!!.description)

        val scoreArg = spec.prompt.arguments.find { it.name == "score" }
        assertNotNull(scoreArg)
        assertEquals("score: Double", scoreArg!!.description)
    }

    @Test
    fun `McpPromptFactory should create unique prompt names with type prefix`() {
        val factory = McpPromptFactory()
        val goal1 = NamedAndDescribed("goal1", "First goal")
        val goal2 = NamedAndDescribed("goal2", "Second goal")

        val spec1 = factory.syncPromptSpecificationForType(goal1, UserInput::class.java)
        val spec2 = factory.syncPromptSpecificationForType(goal2, UserInput::class.java)

        assertEquals("UserInput_goal1", spec1.prompt.name())
        assertEquals("UserInput_goal2", spec2.prompt.name())
        assertNotEquals(spec1.prompt.name(), spec2.prompt.name())
    }

    @Test
    fun `McpPromptFactory should handle custom excluded interfaces`() {

        data class AuditableTestClass(
            val name: String,
            val value: Int,
            override val createdBy: String,
            override val createdAt: java.time.Instant
        ) : AuditableInterface

        val factory = McpPromptFactory(excludedInterfaces = setOf(AuditableInterface::class.java))
        val goal = NamedAndDescribed("auditTest", "Test with auditable interface")

        val spec = factory.syncPromptSpecificationForType(
            goal,
            AuditableTestClass::class.java
        )

        val argumentNames = spec.prompt.arguments.map { it.name }
        assertEquals(2, argumentNames.size)
        assertTrue(argumentNames.contains("name"))
        assertTrue(argumentNames.contains("value"))
        assertFalse(argumentNames.contains("createdBy"))
        assertFalse(argumentNames.contains("createdAt"))
    }

    @Test
    fun `prompt handler should generate correct content structure`() {
        val factory = McpPromptFactory()
        val goal = NamedAndDescribed("contentTest", "Test content generation")

        val spec = factory.syncPromptSpecificationForType(
            goal,
            UserInput::class.java
        )

        val mockExchange = mockk<io.modelcontextprotocol.server.McpSyncServerExchange>()
        val request = McpSchema.GetPromptRequest(
            "contentTest",
            mapOf("content" to "Test input content")
        )

        val result = spec.promptHandler.apply(mockExchange, request)

        assertNotNull(result)
        assertEquals("contentTest-result", result.description)
        assertEquals(1, result.messages.size)

        val message = result.messages.first()
        assertEquals(McpSchema.Role.USER, message.role)
        assertTrue(message.content is McpSchema.TextContent)

        val textContent = message.content as McpSchema.TextContent
        assertTrue(textContent.text.contains("contentTest"))
        assertTrue(textContent.text.contains("Test content generation"))
        assertTrue(textContent.text.contains("content=Test input content"))
    }

    @Test
    fun `prompt handler should handle empty arguments gracefully`() {
        val factory = McpPromptFactory()
        val goal = NamedAndDescribed("emptyTest", "Test with empty arguments")

        val spec = factory.syncPromptSpecificationForType(
            goal,
            UserInput::class.java
        )

        val mockExchange = mockk<io.modelcontextprotocol.server.McpSyncServerExchange>()
        val request = McpSchema.GetPromptRequest("emptyTest", emptyMap())

        val result = spec.promptHandler.apply(mockExchange, request)

        assertNotNull(result)
        assertEquals("emptyTest-result", result.description)
        assertEquals(1, result.messages.size)

        val textContent = result.messages.first().content as McpSchema.TextContent
        assertTrue(textContent.text.contains("emptyTest"))
        assertTrue(textContent.text.contains("Test with empty arguments"))
        // Should handle empty arguments without throwing exception
        assertFalse(textContent.text.contains("="))
    }

    @Test
    fun `prompt handler should handle null argument values`() {
        val factory = McpPromptFactory()
        val goal = NamedAndDescribed("nullTest", "Test with null arguments")

        val spec = factory.syncPromptSpecificationForType(
            goal,
            UserInput::class.java
        )

        val mockExchange = mockk<io.modelcontextprotocol.server.McpSyncServerExchange>()
        val request = McpSchema.GetPromptRequest(
            "nullTest",
            mapOf("content" to null)
        )

        val result = spec.promptHandler.apply(mockExchange, request)

        assertNotNull(result)
        val textContent = result.messages.first().content as McpSchema.TextContent
        assertTrue(textContent.text.contains("content=null"))
    }

    @Test
    fun `factory should handle multiple excluded interfaces`() {

        data class MultiInterfaceClass(
            val name: String,
            override val field1: String,
            override val field2: String,
            override val timestamp: java.time.Instant
        ) : Interface1, Interface2, Timestamped

        val factory = McpPromptFactory(
            excludedInterfaces = setOf(
                Interface1::class.java,
                Interface2::class.java,
                Timestamped::class.java
            )
        )
        val goal = NamedAndDescribed("multiExcludeTest", "Test multiple exclusions")

        val spec = factory.syncPromptSpecificationForType(
            goal,
            MultiInterfaceClass::class.java
        )

        val argumentNames = spec.prompt.arguments.map { it.name }
        assertEquals(1, argumentNames.size)
        assertTrue(argumentNames.contains("name"))
        assertFalse(argumentNames.contains("field1"))
        assertFalse(argumentNames.contains("field2"))
        assertFalse(argumentNames.contains("timestamp"))
    }

    @Test
    fun `factory should preserve original goal properties when using custom name and description`() {
        val factory = McpPromptFactory()
        val goal = NamedAndDescribed("originalName", "Original description")

        val spec = factory.syncPromptSpecificationForType(
            goal,
            UserInput::class.java,
            name = "customName",
            description = "Custom description"
        )

        assertEquals("UserInput_customName", spec.prompt.name())
        assertEquals("Custom description", spec.prompt.description())

        // Test that the prompt content still references the custom name and description
        val mockExchange = mockk<io.modelcontextprotocol.server.McpSyncServerExchange>()
        val request = McpSchema.GetPromptRequest("customName", mapOf("content" to "test"))

        val result = spec.promptHandler.apply(mockExchange, request)
        val textContent = result.messages.first().content as McpSchema.TextContent

        assertTrue(textContent.text.contains("customName"))
        assertTrue(textContent.text.contains("Custom description"))
    }
}



================================================
FILE: embabel-agent-mcpserver/src/test/kotlin/com/embabel/agent/mcpserver/sync/McpPromptFactoryTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.sync

import com.embabel.agent.domain.io.UserInput
import com.embabel.agent.mcpserver.sync.McpPromptFactory
import com.embabel.common.core.types.NamedAndDescribed
import io.mockk.mockk
import io.modelcontextprotocol.spec.McpSchema
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Test
import kotlin.test.assertEquals

class McpPromptFactoryTest {

    @Test
    fun noArgs() {
        class EmptyChild

        val factory = McpPromptFactory()
        val spec = factory.syncPromptSpecificationForType(
            NamedAndDescribed("EmptyChild", "A child with no arguments"),
            EmptyChild::class.java,
        )
        assertTrue(
            spec.prompt.arguments.isEmpty(),
            "Expected no arguments for EmptyChild, but got: ${spec.prompt.arguments}"
        )
    }

    @Test
    fun oneArg() {
        val factory = McpPromptFactory()
        val goal = NamedAndDescribed(name = "oneArg", description = "A class with one argument")
        val spec = factory.syncPromptSpecificationForType(
            goal,
            UserInput::class.java,
        )
        assertEquals(
            spec.prompt.arguments.size,
            1,
            "Expected 1 argument for UserInput, but got: ${spec.prompt.arguments}"
        )
        assertEquals(
            setOf("content"), spec.prompt.arguments.map { it.name }.toSet(),
            "Expected argument 'content' for UserInput, but got: ${spec.prompt.arguments.map { it.name }}",
        )
        val p = spec.promptHandler.apply(mockk(), McpSchema.GetPromptRequest("oneArg", mapOf("content" to "test")))
        assertEquals(1, p.messages.size)
        val m = p.messages.first()
        assertEquals(McpSchema.Role.USER, m.role)
        val tc = m.content as McpSchema.TextContent
        assertTrue(
            tc.text.contains(goal.name),
            "Expected message content to contain goal name, but got: ${m.content}"
        )
        assertTrue(
            tc.text.contains(goal.description),
            "Expected message content to contain goal description, but got: ${m.content}"
        )
        assertTrue(
            tc.text.contains("test"),
            "Expected message content to contain 'test', but got: ${m.content}"
        )
    }

}



================================================
FILE: embabel-agent-mcpserver/src/test/kotlin/com/embabel/agent/mcpserver/sync/SyncServerStrategyTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.sync

import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import io.modelcontextprotocol.server.McpServerFeatures
import io.modelcontextprotocol.server.McpSyncServer
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.assertThrows
import reactor.test.StepVerifier
import com.embabel.agent.mcpserver.domain.McpExecutionMode

class SyncServerStrategyTest {

    private lateinit var mockSyncServer: McpSyncServer
    private lateinit var strategy: SyncServerStrategy

    @BeforeEach
    fun setUp() {
        mockSyncServer = mockk(relaxed = true)
        strategy = SyncServerStrategy(mockSyncServer)
    }

    @Test
    fun `executionMode should return SYNC`() {
        assertEquals(McpExecutionMode.SYNC, strategy.executionMode)
    }

    @Test
    fun `addTool should accept SyncToolSpecification`() {
        val mockToolSpec = mockk<McpServerFeatures.SyncToolSpecification>()

        StepVerifier.create(strategy.addTool(mockToolSpec))
            .verifyComplete()

        verify { mockSyncServer.addTool(mockToolSpec) }
    }

    @Test
    fun `addTool should reject non-SyncToolSpecification`() {
        val invalidToolSpec = "invalid"

        StepVerifier.create(strategy.addTool(invalidToolSpec))
            .expectError(IllegalArgumentException::class.java)
            .verify()
    }

    @Test
    fun `removeTool should call server removeTool`() {
        val toolName = "testTool"

        StepVerifier.create(strategy.removeTool(toolName))
            .verifyComplete()

        verify { mockSyncServer.removeTool(toolName) }
    }

    @Test
    fun `addResource should accept SyncResourceSpecification`() {
        val mockResourceSpec = mockk<McpServerFeatures.SyncResourceSpecification>()

        StepVerifier.create(strategy.addResource(mockResourceSpec))
            .verifyComplete()

        verify { mockSyncServer.addResource(mockResourceSpec) }
    }

    @Test
    fun `addResource should reject non-SyncResourceSpecification`() {
        val invalidResourceSpec = "invalid"

        StepVerifier.create(strategy.addResource(invalidResourceSpec))
            .expectError(IllegalArgumentException::class.java)
            .verify()
    }

    @Test
    fun `addPrompt should accept SyncPromptSpecification`() {
        val mockPromptSpec = mockk<McpServerFeatures.SyncPromptSpecification>()

        StepVerifier.create(strategy.addPrompt(mockPromptSpec))
            .verifyComplete()

        verify { mockSyncServer.addPrompt(mockPromptSpec) }
    }

    @Test
    fun `addPrompt should reject non-SyncPromptSpecification`() {
        val invalidPromptSpec = "invalid"

        StepVerifier.create(strategy.addPrompt(invalidPromptSpec))
            .expectError(IllegalArgumentException::class.java)
            .verify()
    }

    @Test
    fun `getToolRegistry should return SyncToolRegistry`() {
        val toolRegistry = strategy.getToolRegistry()

        assertTrue(toolRegistry is SyncToolRegistry)
    }

    @Test
    fun `addTool should handle AsyncToolSpecification gracefully`() {
        val mockAsyncToolSpec = mockk<McpServerFeatures.AsyncToolSpecification>()

        StepVerifier.create(strategy.addTool(mockAsyncToolSpec))
            .expectError(IllegalArgumentException::class.java)
            .verify()
    }

    @Test
    fun `addResource should handle AsyncResourceSpecification gracefully`() {
        val mockAsyncResourceSpec = mockk<McpServerFeatures.AsyncResourceSpecification>()

        StepVerifier.create(strategy.addResource(mockAsyncResourceSpec))
            .expectError(IllegalArgumentException::class.java)
            .verify()
    }

    @Test
    fun `addPrompt should handle AsyncPromptSpecification gracefully`() {
        val mockAsyncPromptSpec = mockk<McpServerFeatures.AsyncPromptSpecification>()

        StepVerifier.create(strategy.addPrompt(mockAsyncPromptSpec))
            .expectError(IllegalArgumentException::class.java)
            .verify()
    }

    @Test
    fun `operations should complete synchronously when server operations succeed`() {
        val mockToolSpec = mockk<McpServerFeatures.SyncToolSpecification>()
        val mockResourceSpec = mockk<McpServerFeatures.SyncResourceSpecification>()
        val mockPromptSpec = mockk<McpServerFeatures.SyncPromptSpecification>()

        // Test that all operations complete without error
        StepVerifier.create(strategy.addTool(mockToolSpec))
            .verifyComplete()

        StepVerifier.create(strategy.addResource(mockResourceSpec))
            .verifyComplete()

        StepVerifier.create(strategy.addPrompt(mockPromptSpec))
            .verifyComplete()

        StepVerifier.create(strategy.removeTool("testTool"))
            .verifyComplete()
    }

    @Test
    fun `operations should handle server exceptions`() {
        val mockToolSpec = mockk<McpServerFeatures.SyncToolSpecification>()
        val exception = RuntimeException("Server error")

        every { mockSyncServer.addTool(any()) } throws exception

        // The exception should propagate through the Mono
        assertThrows<RuntimeException> {
            strategy.addTool(mockToolSpec).block()
        }
    }
}



================================================
FILE: embabel-agent-mcpserver/src/test/kotlin/com/embabel/agent/mcpserver/sync/SyncToolRegistryTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.mcpserver.sync

import io.mockk.*
import io.modelcontextprotocol.server.McpSyncServer
import com.embabel.agent.mcpserver.support.toolNames
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.AfterEach

class SyncToolRegistryTest {

    private lateinit var mockSyncServer: McpSyncServer
    private lateinit var toolRegistry: SyncToolRegistry

    @BeforeEach
    fun setUp() {
        // Mock the extension function at the top level
        mockkStatic("com.embabel.agent.mcpserver.support.ExtensionsKt")
        mockSyncServer = mockk(relaxed = true)
        toolRegistry = SyncToolRegistry(mockSyncServer)
    }

    @AfterEach
    fun tearDown() {
        unmockkStatic("com.embabel.agent.mcpserver.support.ExtensionsKt")
    }

    @Test
    fun `getToolNames should return tools from server`() {
        val expectedTools = listOf("tool1", "tool2", "tool3")
        every { mockSyncServer.toolNames() } returns expectedTools

        val result = toolRegistry.getToolNames()

        assertEquals(expectedTools, result)
    }

    @Test
    fun `getToolNames should handle empty tool list`() {
        every { mockSyncServer.toolNames() } returns emptyList()

        val result = toolRegistry.getToolNames()

        assertEquals(emptyList<String>(), result)
    }

    @Test
    fun `getToolCount should return correct count`() {
        val tools = listOf("tool1", "tool2", "tool3")
        every { mockSyncServer.toolNames() } returns tools

        val result = toolRegistry.getToolCount()

        assertEquals(3, result)
    }

    @Test
    fun `getToolCount should return zero for empty tool list`() {
        every { mockSyncServer.toolNames() } returns emptyList()

        val result = toolRegistry.getToolCount()

        assertEquals(0, result)
    }

    @Test
    fun `hasToolNamed should return true when tool exists`() {
        val tools = listOf("tool1", "tool2", "tool3")
        every { mockSyncServer.toolNames() } returns tools

        assertTrue(toolRegistry.hasToolNamed("tool2"))
    }

    @Test
    fun `hasToolNamed should return false when tool does not exist`() {
        val tools = listOf("tool1", "tool2", "tool3")
        every { mockSyncServer.toolNames() } returns tools

        assertFalse(toolRegistry.hasToolNamed("nonExistentTool"))
    }

    @Test
    fun `hasToolNamed should return false for empty tool list`() {
        every { mockSyncServer.toolNames() } returns emptyList()

        assertFalse(toolRegistry.hasToolNamed("anyTool"))
    }

    @Test
    fun `hasToolNamed should handle null or empty tool names`() {
        val tools = listOf("tool1", "", "tool3")
        every { mockSyncServer.toolNames() } returns tools

        assertTrue(toolRegistry.hasToolNamed(""))
        assertFalse(toolRegistry.hasToolNamed("null"))
    }

    @Test
    fun `hasToolNamed should be case sensitive`() {
        val tools = listOf("Tool1", "tool2", "TOOL3")
        every { mockSyncServer.toolNames() } returns tools

        assertTrue(toolRegistry.hasToolNamed("Tool1"))
        assertFalse(toolRegistry.hasToolNamed("tool1"))
        assertTrue(toolRegistry.hasToolNamed("TOOL3"))
        assertFalse(toolRegistry.hasToolNamed("tool3"))
    }

    @Test
    fun `operations should be consistent across multiple calls`() {
        val tools = listOf("tool1", "tool2")
        every { mockSyncServer.toolNames() } returns tools

        // Multiple calls should return consistent results
        assertEquals(tools, toolRegistry.getToolNames())
        assertEquals(tools, toolRegistry.getToolNames())

        assertEquals(2, toolRegistry.getToolCount())
        assertEquals(2, toolRegistry.getToolCount())

        assertTrue(toolRegistry.hasToolNamed("tool1"))
        assertTrue(toolRegistry.hasToolNamed("tool1"))
    }

    @Test
    fun `getToolCount should match getToolNames size`() {
        val tools = listOf("tool1", "tool2", "tool3", "tool4", "tool5")
        every { mockSyncServer.toolNames() } returns tools

        assertEquals(toolRegistry.getToolNames().size, toolRegistry.getToolCount())
    }

    @Test
    fun `hasToolNamed should work with all tools from getToolNames`() {
        val tools = listOf("alpha", "beta", "gamma", "delta")
        every { mockSyncServer.toolNames() } returns tools

        // All tools returned by getToolNames should be found by hasToolNamed
        tools.forEach { toolName ->
            assertTrue(
                toolRegistry.hasToolNamed(toolName),
                "Tool '$toolName' should be found by hasToolNamed"
            )
        }
    }
}



================================================
FILE: embabel-agent-rag/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-parent</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-rag</artifactId>
    <packaging>pom</packaging>
    <name>Embabel Agent Rag</name>
    <description>Embabel Agent Rag</description>

    <modules>
        <module>embabel-agent-rag-neo</module>
        <module>embabel-agent-rag-lucene</module>
        <module>embabel-agent-rag-tika</module>
        <module>embabel-agent-rag-pipeline</module>
    </modules>

    <dependencies>
        <!-- Main Dependencies -->
        <dependency>
            <groupId>com.embabel.common</groupId>
            <artifactId>embabel-common-ai</artifactId>
        </dependency>

        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-api</artifactId>
        </dependency>

        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-test-internal</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.jetbrains.kotlin</groupId>
                <artifactId>kotlin-maven-plugin</artifactId>
                <executions>
                    <execution>
                        <id>kapt</id>
                        <goals>
                            <goal>kapt</goal>
                        </goals>
                        <configuration>
                            <annotationProcessorPaths>
                                <path>
                                    <groupId>org.springframework.boot</groupId>
                                    <artifactId>spring-boot-configuration-processor</artifactId>
                                    <version>${spring-boot.version}</version>
                                </path>
                            </annotationProcessorPaths>
                        </configuration>
                    </execution>
                </executions>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
            </plugin>

        </plugins>
    </build>

</project>



================================================
FILE: embabel-agent-rag/embabel-agent-rag-lucene/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-rag</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-rag-lucene</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent Rag for Lucene</name>
    <description>Embabel Agent Rag for Lucene</description>

    <properties>
        <lucene.version>9.11.1</lucene.version>
    </properties>

    <dependencies>
        <!-- Lucene Dependencies -->
        <dependency>
            <groupId>org.apache.lucene</groupId>
            <artifactId>lucene-core</artifactId>
            <version>${lucene.version}</version>
        </dependency>

        <dependency>
            <groupId>org.apache.lucene</groupId>
            <artifactId>lucene-analysis-common</artifactId>
            <version>${lucene.version}</version>
        </dependency>

        <dependency>
            <groupId>org.apache.lucene</groupId>
            <artifactId>lucene-queryparser</artifactId>
            <version>${lucene.version}</version>
        </dependency>

        <dependency>
            <groupId>org.apache.lucene</groupId>
            <artifactId>lucene-memory</artifactId>
            <version>${lucene.version}</version>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.jetbrains.kotlin</groupId>
                <artifactId>kotlin-maven-plugin</artifactId>
                <executions>
                    <execution>
                        <id>compile</id>
                        <phase>compile</phase>
                        <goals>
                            <goal>compile</goal>
                        </goals>
                        <configuration>
                            <sourceDirs>
                                <source>src/main/java</source>
                                <source>src/main/kotlin</source>
                            </sourceDirs>
                        </configuration>
                    </execution>
                    <execution>
                        <id>test-compile</id>
                        <phase>test-compile</phase>
                        <goals>
                            <goal>test-compile</goal>
                        </goals>
                        <configuration>
                            <sourceDirs>
                                <source>src/test/java</source>
                                <source>src/test/kotlin</source>
                            </sourceDirs>
                        </configuration>
                    </execution>
                </executions>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
            </plugin>

        </plugins>
    </build>

</project>



================================================
FILE: embabel-agent-rag/embabel-agent-rag-lucene/src/main/kotlin/com/embabel/agent/rag/lucene/LuceneRagFacetProvider.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.lucene

import com.embabel.agent.rag.*
import com.embabel.agent.rag.ingestion.ContentChunker
import com.embabel.agent.rag.ingestion.MaterializedDocument
import com.embabel.agent.rag.support.FunctionRagFacet
import com.embabel.agent.rag.support.RagFacet
import com.embabel.agent.rag.support.RagFacetProvider
import com.embabel.agent.rag.support.RagFacetResults
import com.embabel.common.core.types.HasInfoString
import com.embabel.common.core.types.SimpleSimilaritySearchResult
import com.embabel.common.util.indent
import org.apache.lucene.analysis.standard.StandardAnalyzer
import org.apache.lucene.document.*
import org.apache.lucene.index.DirectoryReader
import org.apache.lucene.index.IndexWriter
import org.apache.lucene.index.IndexWriterConfig
import org.apache.lucene.queryparser.classic.QueryParser
import org.apache.lucene.search.IndexSearcher
import org.apache.lucene.search.Query
import org.apache.lucene.search.TopDocs
import org.apache.lucene.store.ByteBuffersDirectory
import org.apache.lucene.store.Directory
import org.apache.lucene.store.FSDirectory
import org.slf4j.LoggerFactory
import org.springframework.ai.embedding.EmbeddingModel
import java.io.Closeable
import java.nio.file.Path
import java.util.concurrent.ConcurrentHashMap
import kotlin.math.sqrt
import org.springframework.ai.document.Document as SpringAiDocument

/**
 * Lucene RAG facet with optional vector search support via an EmbeddingModel.
 * Supports both in-memory and disk-based persistence.
 * Implements WritableContentElementRepository so we can add to the store.
 *
 * @param name Name of this RAG service
 * @param embeddingModel Optional embedding model for vector search; if null, only text search is
 * supported
 * @param vectorWeight Weighting for vector similarity in hybrid search (0.0 to 1.0)
 * @param chunkerConfig Configuration for content chunking
 * @param indexPath Optional path for disk-based index storage; if null, uses in-memory storage
 */
class LuceneRagFacetProvider @JvmOverloads constructor(
    override val name: String,
    private val embeddingModel: EmbeddingModel? = null,
    private val vectorWeight: Double = 0.5,
    chunkerConfig: ContentChunker.Config = ContentChunker.DefaultConfig(),
    private val indexPath: Path? = null,
) : RagFacetProvider, AbstractWritableContentElementRepository(chunkerConfig), HasInfoString, Closeable {

    private val logger = LoggerFactory.getLogger(LuceneRagFacetProvider::class.java)

    private val analyzer = StandardAnalyzer()
    private val directory: Directory = indexPath?.let { FSDirectory.open(it) } ?: ByteBuffersDirectory()
    private val indexWriterConfig = IndexWriterConfig(analyzer)
    private var indexWriter = IndexWriter(directory, indexWriterConfig)
    private val queryParser = QueryParser("content", analyzer)

    init {
        if (embeddingModel == null) {
            logger.warn("No embedding model configured; only text search will be supported.")
        }

        if (indexPath != null) {
            logger.info("Using disk-based Lucene index at: {}", indexPath)
            // Defer chunk loading until after object is fully constructed
        } else {
            logger.info("Using in-memory Lucene index")
        }
    }

    // Lazy initialization of existing chunks - called on first access
    private var chunksLoaded = false
    private fun ensureChunksLoaded() {
        if (!chunksLoaded && indexPath != null) {
            logger.info("Triggering lazy loading of existing chunks...")
            loadExistingChunks()
            chunksLoaded = true
        }
    }

    /**
     * Manually trigger loading of existing chunks from disk.
     * Useful for ensuring chunks are loaded immediately after startup.
     */
    fun loadExistingChunksFromDisk() {
        logger.info("Manually triggering chunk loading from disk...")
        ensureChunksLoaded()
    }

    @Volatile
    private var directoryReader: DirectoryReader? = null

    private val contentElementStorage = ConcurrentHashMap<String, ContentElement>()

    override fun facets(): List<RagFacet<out Retrievable>> {
        return listOf(
            FunctionRagFacet(
                name = "chunks",
                searchFunction = ::search,
            )
        )
    }

    override fun findChunksById(chunkIds: List<String>): List<Chunk> {
        logger.debug("Finding chunks by IDs: {}", chunkIds)

        val foundChunks = chunkIds.mapNotNull { chunkId ->
            contentElementStorage[chunkId] as? Chunk
        }

        logger.debug("Found {}/{} chunks by id", foundChunks.size, chunkIds.size)
        return foundChunks
    }

    override fun findChunksForEntity(entityId: String): List<Chunk> {
        TODO("Entities not supported in LuceneRagService")
    }

    override fun count(): Int =
        contentElementStorage.size


    override fun findById(id: String): ContentElement? {
        return contentElementStorage[id]
    }

    override fun save(element: ContentElement): ContentElement {
        contentElementStorage[element.id] = element
        return element
    }

    override fun createRelationships(root: MaterializedDocument) {
        // No op here
    }

    fun findAll(): List<Chunk> {
        ensureChunksLoaded()
        logger.debug("Retrieving all chunks from storage")
        val allChunks = contentElementStorage.values.filterIsInstance<Chunk>()
        logger.debug("Retrieved {} chunks from storage", allChunks.size)
        return allChunks
    }

    fun search(ragRequest: RagRequest): RagFacetResults<Chunk> {
        ensureChunksLoaded()
        refreshReaderIfNeeded()

        val reader = directoryReader ?: return RagFacetResults(
            facetName = name,
            results = emptyList()
        )

        val searcher = IndexSearcher(reader)

        // Perform hybrid search: text + vector similarity
        val results = if (embeddingModel != null) {
            val r = performHybridSearch(searcher, ragRequest)
            logger.debug("Hybrid search for query {} found\n{}", ragRequest.query, r)
            r
        } else {
            val r = performTextSearch(searcher, ragRequest)
            logger.debug("Text search for query {} found\n{}", ragRequest.query, r)
            r
        }

        val filteredResults = results
            .filter { it.score >= ragRequest.similarityThreshold }
            .take(ragRequest.topK)
            .sortedByDescending { it.score }

        return RagFacetResults(
            facetName = name,
            results = filteredResults
        )
    }

    private fun performTextSearch(
        searcher: IndexSearcher,
        ragRequest: RagRequest,
    ): List<SimpleSimilaritySearchResult<Chunk>> {
        val query: Query = queryParser.parse(QueryParser.escape(ragRequest.query))
        val topDocs: TopDocs = searcher.search(query, ragRequest.topK)

        return topDocs.scoreDocs.map { scoreDoc ->
            val doc = searcher.doc(scoreDoc.doc)
            val retrievable = createChunkFromDocument(doc)
            SimpleSimilaritySearchResult(
                match = retrievable,
                score = scoreDoc.score.toDouble()
            )
        }
    }

    private fun performHybridSearch(
        searcher: IndexSearcher,
        ragRequest: RagRequest,
    ): List<SimpleSimilaritySearchResult<Chunk>> {
        val textQuery: Query = queryParser.parse(QueryParser.escape(ragRequest.query))
        val textResults: TopDocs = searcher.search(textQuery, (ragRequest.topK * 2).coerceAtLeast(20))

        // Get query embedding
        val queryEmbedding = embeddingModel!!.embed(ragRequest.query)

        // Calculate hybrid scores
        val hybridResults = mutableListOf<SimpleSimilaritySearchResult<Chunk>>()

        for (scoreDoc in textResults.scoreDocs) {
            val doc = searcher.doc(scoreDoc.doc)
            val retrievable = createChunkFromDocument(doc)

            // Get text similarity (normalized)
            val textScore = scoreDoc.score.toDouble()
            val normalizedTextScore = minOf(1.0, textScore / 10.0) // Rough normalization

            // Calculate vector similarity if embedding exists
            val vectorScore = doc.getBinaryValue("embedding")?.let { embeddingBytes ->
                val docEmbedding = bytesToFloatArray(embeddingBytes.bytes)
                cosineSimilarity(queryEmbedding, docEmbedding)
            } ?: 0.0

            // Combine scores with weighting
            val hybridScore = (1 - vectorWeight) * normalizedTextScore + vectorWeight * vectorScore

            hybridResults.add(
                SimpleSimilaritySearchResult(
                    match = retrievable,
                    score = hybridScore
                )
            )
        }

        return hybridResults
    }

    private fun createChunkFromDocument(doc: Document): Chunk {
        return Chunk(
            id = doc.get("id"),
            text = doc.get("content"),
            metadata = doc.fields
                .filter { field -> field.name() !in setOf("id", "content", "embedding") }
                .associate { field -> field.name() to field.stringValue() }
        )
    }


    override fun accept(documents: List<SpringAiDocument>) {
        logger.info("Indexing {} documents into Lucene RAG service and storing as chunks", documents.size)
        documents.forEach { springDoc ->
            // Create and store chunk in memory
            val chunk = Chunk(
                id = springDoc.id,
                text = springDoc.text ?: "",
                metadata = springDoc.metadata + mapOf(
                    "indexed_at" to System.currentTimeMillis(),
                    "service" to name
                )
            )
            onNewRetrievable(chunk)
        }
        commit()
        logger.info(
            "Successfully indexed {} documents. Total chunks in storage: {}",
            documents.size, contentElementStorage.size
        )
    }

    override fun onNewRetrievables(retrievables: List<Retrievable>) {
        retrievables.forEach { onNewRetrievable(it) }
    }

    private fun onNewRetrievable(
        retrievable: Retrievable,
    ) {
        if (retrievable !is Chunk) {
            logger.warn("Only Chunk retrievables are supported; skipping retrievable with id='{}'", retrievable.id)
            return
        }
        contentElementStorage[retrievable.id] = retrievable
        // Create Lucene document for indexing
        val luceneDoc = Document().apply {
            add(StringField("id", retrievable.id, Field.Store.YES))
            add(TextField("content", retrievable.embeddableValue(), Field.Store.YES))

            if (embeddingModel != null) {
                val embedding = embeddingModel.embed(retrievable.embeddableValue())
                val embeddingBytes = floatArrayToBytes(embedding)
                add(StoredField("embedding", embeddingBytes))
            }

            retrievable.metadata.forEach { (key, value) ->
                add(StringField(key, value.toString(), Field.Store.YES))
            }
        }
        indexWriter.addDocument(luceneDoc)
        logger.debug(
            "Indexed and stored retrievable with id='{}' and text length={}",
            retrievable.id,
            retrievable.embeddableValue().length
        )
    }

    override fun commit() {
        indexWriter.flush()  // Ensure all changes are written to storage
        indexWriter.commit() // Commit the transaction
        invalidateReader()   // Force reader refresh on next access
    }

    // Vector similarity utility functions
    private fun cosineSimilarity(
        a: FloatArray,
        b: FloatArray,
    ): Double {
        if (a.size != b.size) return 0.0

        var dotProduct = 0.0
        var normA = 0.0
        var normB = 0.0

        for (i in a.indices) {
            dotProduct += (a[i] * b[i]).toDouble()
            normA += (a[i] * a[i]).toDouble()
            normB += (b[i] * b[i]).toDouble()
        }

        return if (normA == 0.0 || normB == 0.0) 0.0 else dotProduct / (sqrt(normA) * sqrt(normB))
    }

    private fun floatArrayToBytes(floatArray: FloatArray): ByteArray {
        val bytes = ByteArray(floatArray.size * 4)
        var index = 0
        for (f in floatArray) {
            val bits = java.lang.Float.floatToIntBits(f)
            bytes[index++] = (bits shr 24).toByte()
            bytes[index++] = (bits shr 16).toByte()
            bytes[index++] = (bits shr 8).toByte()
            bytes[index++] = bits.toByte()
        }
        return bytes
    }

    private fun bytesToFloatArray(bytes: ByteArray): FloatArray {
        val floats = FloatArray(bytes.size / 4)
        var index = 0
        for (i in floats.indices) {
            val bits = ((bytes[index++].toInt() and 0xFF) shl 24) or
                    ((bytes[index++].toInt() and 0xFF) shl 16) or
                    ((bytes[index++].toInt() and 0xFF) shl 8) or
                    (bytes[index++].toInt() and 0xFF)
            floats[i] = java.lang.Float.intBitsToFloat(bits)
        }
        return floats
    }

    private fun loadExistingChunks() {
        logger.info("Starting to load existing chunks from disk index...")
        try {
            // Use a separate directory instance for reading to avoid writer conflicts
            val readDirectory = FSDirectory.open(indexPath!!)

            try {
                // Open a reader on the separate directory
                logger.info("Opening DirectoryReader to read from disk")
                val reader = DirectoryReader.open(readDirectory)

                logger.info(
                    "Successfully opened reader. Index has {} documents (maxDoc: {})",
                    reader.numDocs(),
                    reader.maxDoc()
                )

                // Load all existing documents from the index
                for (i in 0 until reader.maxDoc()) {
                    try {
                        val doc = reader.storedFields().document(i)
                        logger.debug(
                            "Loading document {}: id={}, content preview={}",
                            i,
                            doc.get("id"),
                            doc.get("content")?.take(50)
                        )
                        val chunk = createChunkFromDocument(doc)
                        contentElementStorage[chunk.id] = chunk
                        logger.info("✅ Loaded chunk with id={}", chunk.id)
                    } catch (e: Exception) {
                        logger.error("❌ Failed to load document {}: {}", i, e.message, e)
                    }
                }

                reader.close()
                logger.info(
                    "✅ Loaded {} existing chunks from disk index {}",
                    contentElementStorage.size,
                    indexPath,
                )

            } finally {
                readDirectory.close()
            }

        } catch (e: Exception) {
            logger.error("Error loading existing chunks from disk index: {}", e.message, e)
        }
    }

    private fun refreshReaderIfNeeded() {
        synchronized(this) {
            try {
                // Always try to open a fresh reader to ensure we see latest changes
                directoryReader?.close()
                directoryReader = DirectoryReader.open(directory)
            } catch (_: Exception) {
                // Index might be empty, which is fine
            }
        }
    }

    private fun invalidateReader() {
        synchronized(this) {
            directoryReader?.close()
            directoryReader = null
        }
    }

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String {
        val docCount = try {
            refreshReaderIfNeeded()
            directoryReader?.numDocs() ?: 0
        } catch (_: Exception) {
            0
        }

        val chunkCount = contentElementStorage.size
        val storageType = if (indexPath != null) "disk" else "memory"
        val basicInfo = "LuceneRagService: $name ($docCount documents, $chunkCount chunks, $storageType)"

        return if (verbose == true) {
            val embeddingInfo = if (embeddingModel != null) "with embeddings" else "text-only"
            val vectorWeightInfo = if (embeddingModel != null) ", vector weight: $vectorWeight" else ""
            val pathInfo = if (indexPath != null) ", path: $indexPath" else ""
            "$basicInfo ($embeddingInfo$vectorWeightInfo$pathInfo)".indent(indent)
        } else {
            basicInfo.indent(indent)
        }
    }

    override fun close() {
        try {
            // Ensure all pending changes are committed before closing
            commit()
        } catch (e: Exception) {
            logger.warn("Error committing changes during close: {}", e.message)
        }

        directoryReader?.close()
        indexWriter.close()
        directory.close()
        analyzer.close()
        contentElementStorage.clear()
    }

    /**
     * Clear all stored content - useful for testing
     */
    fun clear() {
        logger.info("Clearing all indexed content from Lucene RAG service")
        synchronized(this) {
            // Clear chunk storage
            contentElementStorage.clear()

            // Clear Lucene index
            indexWriter.deleteAll()
            indexWriter.commit()

            // Invalidate reader
            invalidateReader()
        }
    }

    /**
     * Get statistics about the current state
     */
    fun getStatistics(): LuceneStatistics {
        val docCount = try {
            refreshReaderIfNeeded()
            directoryReader?.numDocs() ?: 0
        } catch (_: Exception) {
            0
        }

        return LuceneStatistics(
            totalChunks = contentElementStorage.size,
            totalDocuments = docCount,
            averageChunkLength = if (contentElementStorage.isNotEmpty()) {
                contentElementStorage.values.filterIsInstance<Chunk>().map { it.text.length }.average()
            } else 0.0,
            hasEmbeddings = embeddingModel != null,
            vectorWeight = vectorWeight,
            isPersistent = indexPath != null,
            indexPath = indexPath?.toString()
        )
    }
}

/**
 * Statistics about the Lucene RAG service state
 */
data class LuceneStatistics(
    val totalChunks: Int,
    val totalDocuments: Int,
    val averageChunkLength: Double,
    val hasEmbeddings: Boolean,
    val vectorWeight: Double,
    val isPersistent: Boolean,
    val indexPath: String?,
)



================================================
FILE: embabel-agent-rag/embabel-agent-rag-lucene/src/test/kotlin/com/embabel/agent/rag/.gitkeep
================================================
[Empty file]


================================================
FILE: embabel-agent-rag/embabel-agent-rag-lucene/src/test/kotlin/com/embabel/agent/rag/lucene/LuceneRagFacetProviderTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.lucene

import com.embabel.agent.rag.RagRequest
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.springframework.ai.document.Document
import org.springframework.ai.embedding.EmbeddingModel
import org.springframework.ai.embedding.EmbeddingRequest
import org.springframework.ai.embedding.EmbeddingResponse

class LuceneRagFacetProviderTest {

    private lateinit var ragService: LuceneRagFacetProvider
    private lateinit var ragServiceWithEmbedding: LuceneRagFacetProvider
    private val mockEmbeddingModel = MockEmbeddingModel()

    @BeforeEach
    fun setUp() {
        ragService = LuceneRagFacetProvider(name = "lucene-rag")
        ragServiceWithEmbedding = LuceneRagFacetProvider(
            name = "hybrid-lucene-rag",
            embeddingModel = mockEmbeddingModel,
            vectorWeight = 0.5
        )
    }

    @AfterEach
    fun tearDown() {
        ragService.close()
        ragServiceWithEmbedding.close()
    }

    @Test
    fun `should return empty results when no documents are indexed`() {
        val request = RagRequest.query("test query")
        val response = ragService.search(request)

        assertEquals("lucene-rag", response.facetName)
        assertTrue(response.results.isEmpty())
    }

    @Test
    fun `should index and search documents using accept method`() {
        // Index some test documents using accept
        val documents = listOf(
            Document("doc1", "This is a test document about machine learning", emptyMap<String, Any>()),
            Document("doc2", "Another document discussing artificial intelligence", emptyMap<String, Any>()),
            Document("doc3", "A completely different topic about cooking recipes", emptyMap<String, Any>())
        )

        ragService.accept(documents)

        // Search for documents
        val request = RagRequest.query("machine learning")
        val response = ragService.search(request)

        assertEquals("lucene-rag", response.facetName)
        assertTrue(response.results.isNotEmpty())

        // Should find the most relevant document first
        val firstResult = response.results.first()
        assertEquals("doc1", firstResult.match.id)
        assertTrue(firstResult.score > 0.0)
    }

    @Test
    fun `should respect similarity threshold using accept method`() {
        val documents = listOf(
            Document("doc1", "machine learning algorithms", emptyMap<String, Any>()),
            Document("doc2", "completely unrelated content about cooking", emptyMap<String, Any>())
        )

        ragService.accept(documents)

        // High threshold should filter out low-relevance results
        val request = RagRequest.query("machine learning")
            .withSimilarityThreshold(0.9)

        val response = ragService.search(request)

        // Should only return highly relevant documents
        response.results.forEach { result ->
            assertTrue(result.score >= 0.9)
        }
    }

    @Test
    fun `should respect topK limit using accept method`() {
        val documents = (1..10).map { i ->
            Document("doc$i", "machine learning document number $i", emptyMap<String, Any>())
        }

        ragService.accept(documents)

        val request = RagRequest.query("machine learning").withTopK(3)
        val response = ragService.search(request)

        assertTrue(response.results.size <= 3)
    }

    @Test
    fun `should handle document metadata correctly using accept method`() {
        val metadata = mapOf("author" to "John Doe", "category" to "AI")
        val documents = listOf(
            Document("doc1", "Test content", metadata)
        )

        ragService.accept(documents)

        val request = RagRequest.query("test")
            .withSimilarityThreshold(0.0)
        val response = ragService.search(request)

        assertEquals(1, response.results.size, "Expected 1 result")
        val result = response.results.first()

        assertEquals("John Doe", result.match.metadata["author"])
        assertEquals("AI", result.match.metadata["category"])
    }

    @Test
    fun `should provide meaningful info string`() {
        val infoString = ragService.infoString(verbose = false, indent = 0)
        assertTrue(infoString.contains("LuceneRagService"))
        assertTrue(infoString.contains("lucene-rag"))
        assertTrue(infoString.contains("0 documents"))

        // After adding documents using accept
        ragService.accept(listOf(Document("doc1", "test content", emptyMap<String, Any>())))
        val infoStringAfter = ragService.infoString(verbose = false, indent = 0)
        assertTrue(infoStringAfter.contains("1 documents"))
    }

    @Test
    fun `retrievable should provide embeddable value using accept method`() {
        val documents = listOf(Document("doc1", "Test document content", emptyMap<String, Any>()))
        ragServiceWithEmbedding.accept(documents)

        val request = RagRequest.query("test")
            .withSimilarityThreshold(.0)
        val response = ragServiceWithEmbedding.search(request)

        assertEquals(1, response.results.size)
        val retrievable = response.results.first().match
        assertEquals("Test document content", retrievable.embeddableValue())
    }

    @Test
    fun `should handle multiple accept calls correctly without vector`() {
        // First batch
        ragService.accept(
            listOf(
                Document("doc1", "First batch document about AI and artificial intelligence", emptyMap<String, Any>()),
                Document("doc2", "Another first batch document about ML", emptyMap<String, Any>())
            )
        )

        // Second batch
        ragService.accept(
            listOf(
                Document("doc3", "Second batch document about artificial intelligence", emptyMap<String, Any>()),
                Document("doc4", "Another second batch document about machine learning", emptyMap<String, Any>())
            )
        )

        val request = RagRequest.query("artificial intelligence")
            .withSimilarityThreshold(0.0)
        val response = ragService.search(request)

        assertTrue(response.results.isNotEmpty())
        // Should find documents from both batches
        assertTrue(
            response.results.any { it.match.id == "doc1" },
            "Should contain doc3: ids were ${response.results.map { it.match.id }}"
        )
        assertTrue(response.results.any { it.match.id == "doc3" })
    }

    @Test
    fun `should perform hybrid search with embeddings`() {
        val documents = listOf(
            Document("doc1", "machine learning algorithms for data science", emptyMap<String, Any>()),
            Document("doc2", "cooking recipes and kitchen techniques", emptyMap<String, Any>()),
            Document("doc3", "artificial intelligence and neural networks", emptyMap<String, Any>())
        )

        ragServiceWithEmbedding.accept(documents)

        // Search should use both text and vector similarity
        val request = RagRequest.query("AI and machine learning")
            .withSimilarityThreshold(0.0)
        val response = ragServiceWithEmbedding.search(request)

        assertEquals("hybrid-lucene-rag", response.facetName)
        assertTrue(response.results.isNotEmpty())

        // Should find AI/ML related documents with higher scores due to hybrid search
        val aiMlDocs = response.results.filter {
            it.match.id == "doc1" || it.match.id == "doc3"
        }
        assertTrue(aiMlDocs.isNotEmpty(), "Should find AI/ML related documents")
        assertTrue(aiMlDocs.all { it.score > 0.0 }, "AI/ML documents should have positive scores")
    }

    @Test
    fun `should weight vector similarity appropriately`() {
        val ragServiceHighVector = LuceneRagFacetProvider(
            name = "high-vector-weight",
            embeddingModel = mockEmbeddingModel,
            vectorWeight = 0.9 // High vector weight
        )

        try {
            val documents = listOf(
                Document("doc1", "machine learning", emptyMap<String, Any>()),
                Document("doc2", "artificial intelligence", emptyMap<String, Any>())
            )

            ragServiceHighVector.accept(documents)

            // Use a query that should match via text search to ensure we get text results for hybrid
            val request = RagRequest.query("machine")
                .withSimilarityThreshold(0.0)
            val response = ragServiceHighVector.search(request)

            assertTrue(
                response.results.isNotEmpty(),
                "Should have results from vector search, got: ${response.results.size} results"
            )
        } finally {
            ragServiceHighVector.close()
        }
    }

    @Test
    fun `should fallback to text search when no embedding model`() {
        val documents = listOf(
            Document("doc1", "machine learning algorithms", emptyMap<String, Any>()),
            Document("doc2", "cooking recipes", emptyMap<String, Any>())
        )

        ragService.accept(documents)

        // Use a single word that should match
        val request = RagRequest.query("machine")
            .withSimilarityThreshold(0.0)
        val response = ragService.search(request)

        assertTrue(
            response.results.isNotEmpty(),
            "Should have results for text match. Results: ${response.results.map { it.match.id }}"
        )
        assertEquals("doc1", response.results.first().match.id)
    }

    @Nested
    inner class ChunkRepositoryTests {

        @Test
        fun `should store chunks in memory when accepting documents`() {
            // Initially no chunks
            assertTrue(ragService.findAll().isEmpty())

            val documents = listOf(
                Document("doc1", "Test document 1", emptyMap<String, Any>()),
                Document("doc2", "Test document 2", emptyMap<String, Any>())
            )

            ragService.accept(documents)

            // Should have chunks stored
            val allChunks = ragService.findAll()
            assertEquals(2, allChunks.size)

            val chunkIds = allChunks.map { it.id }.toSet()
            assertEquals(setOf("doc1", "doc2"), chunkIds)
        }

        @Test
        fun `should find chunks by ID`() {
            val documents = listOf(
                Document("ml-doc", "Machine learning content", emptyMap<String, Any>()),
                Document("ai-doc", "AI content", emptyMap<String, Any>()),
                Document("ds-doc", "Data science content", emptyMap<String, Any>())
            )

            ragService.accept(documents)

            // Test finding existing chunks
            val foundChunks = ragService.findChunksById(listOf("ml-doc", "ai-doc"))
            assertEquals(2, foundChunks.size)

            val chunkIds = foundChunks.map { it.id }.toSet()
            assertEquals(setOf("ml-doc", "ai-doc"), chunkIds)

            // Verify chunk content
            val mlChunk = foundChunks.find { it.id == "ml-doc" }
            assertNotNull(mlChunk)
            assertEquals("Machine learning content", mlChunk!!.text)
        }

        @Test
        fun `should find chunks by non-existing IDs returns empty list`() {
            val documents = listOf(
                Document("existing-doc", "Test content", emptyMap<String, Any>())
            )

            ragService.accept(documents)

            val foundChunks = ragService.findChunksById(listOf("non-existent-1", "non-existent-2"))
            assertTrue(foundChunks.isEmpty())
        }

        @Test
        fun `should find chunks by mixed existing and non-existing IDs`() {
            val documents = listOf(
                Document("doc1", "Content 1", emptyMap<String, Any>()),
                Document("doc2", "Content 2", emptyMap<String, Any>())
            )

            ragService.accept(documents)

            val foundChunks = ragService.findChunksById(listOf("doc1", "non-existent", "doc2"))
            assertEquals(2, foundChunks.size)

            val chunkIds = foundChunks.map { it.id }.toSet()
            assertEquals(setOf("doc1", "doc2"), chunkIds)
        }

        @Test
        fun `should store chunk metadata correctly`() {
            val metadata = mapOf(
                "author" to "John Doe",
                "category" to "AI",
                "source" to "research-paper"
            )

            val documents = listOf(
                Document("research-doc", "Research content", metadata)
            )

            ragService.accept(documents)

            val chunks = ragService.findChunksById(listOf("research-doc"))
            assertEquals(1, chunks.size)

            val chunk = chunks[0]
            assertEquals("John Doe", chunk.metadata["author"])
            assertEquals("AI", chunk.metadata["category"])
            assertEquals("research-paper", chunk.metadata["source"])

            // Should also have service-added metadata
            assertNotNull(chunk.metadata["indexed_at"])
            assertEquals("lucene-rag", chunk.metadata["service"])
        }

        @Test
        fun `should handle empty document list`() {
            ragService.accept(emptyList())

            val allChunks = ragService.findAll()
            assertTrue(allChunks.isEmpty())
        }

        @Test
        fun `should handle document with empty text`() {
            val document = Document("empty-doc", "", emptyMap<String, Any>())

            ragService.accept(listOf(document))

            val chunks = ragService.findAll()
            assertEquals(1, chunks.size)
            assertEquals("", chunks[0].text) // Should handle empty string correctly
        }

        @Test
        fun `should update chunk when document with same ID is added again`() {
            // Add initial document
            ragService.accept(listOf(Document("dup-doc", "Initial content", emptyMap<String, Any>())))

            val initialChunks = ragService.findAll()
            assertEquals(1, initialChunks.size)
            assertEquals("Initial content", initialChunks[0].text)

            // Add document with same ID
            ragService.accept(listOf(Document("dup-doc", "Updated content", emptyMap<String, Any>())))

            val updatedChunks = ragService.findAll()
            assertEquals(1, updatedChunks.size) // Should still have only 1 chunk
            assertEquals("Updated content", updatedChunks[0].text) // Should be updated
        }

        @Test
        fun `should clear all chunks and index when clear is called`() {
            val documents = listOf(
                Document("doc1", "Content 1", emptyMap<String, Any>()),
                Document("doc2", "Content 2", emptyMap<String, Any>())
            )

            ragService.accept(documents)
            assertEquals(2, ragService.findAll().size)

            // Clear everything
            ragService.clear()

            // Should have no chunks
            assertTrue(ragService.findAll().isEmpty())

            // Should also clear search index
            val searchResponse = ragService.search(RagRequest.query("content"))
            assertTrue(searchResponse.results.isEmpty())
        }

        @Test
        fun `should get correct statistics`() {
            val stats = ragService.getStatistics()
            assertEquals(0, stats.totalChunks)
            assertEquals(0, stats.totalDocuments)
            assertEquals(0.0, stats.averageChunkLength)
            assertFalse(stats.hasEmbeddings)
            assertEquals(0.5, stats.vectorWeight) // Default vector weight

            // Add some documents
            val documents = listOf(
                Document("doc1", "Short", emptyMap<String, Any>()),
                Document("doc2", "This is a longer document", emptyMap<String, Any>())
            )

            ragService.accept(documents)

            val updatedStats = ragService.getStatistics()
            assertEquals(2, updatedStats.totalChunks)
            assertEquals(2, updatedStats.totalDocuments)
            assertTrue(updatedStats.averageChunkLength > 0)

            // Average should be (5 + 25) / 2 = 15.0
            assertEquals(15.0, updatedStats.averageChunkLength, 0.1)
        }

        @Test
        fun `should provide meaningful info string with chunk count`() {
            val infoString = ragService.infoString(verbose = false, indent = 0)
            assertTrue(infoString.contains("0 documents, 0 chunks"))

            ragService.accept(listOf(Document("test-doc", "Test content", emptyMap<String, Any>())))

            val infoStringAfter = ragService.infoString(verbose = false, indent = 0)
            assertTrue(infoStringAfter.contains("1 documents, 1 chunks"))
        }

        @Test
        fun `should provide verbose info string`() {
            val infoString = ragService.infoString(verbose = true, indent = 0)
            assertTrue(infoString.contains("text-only"))
            assertFalse(infoString.contains("with embeddings"))

            val embeddingServiceInfo = ragServiceWithEmbedding.infoString(verbose = true, indent = 0)
            assertTrue(embeddingServiceInfo.contains("with embeddings"))
            assertTrue(embeddingServiceInfo.contains("vector weight: 0.5"))
        }
    }

    @Nested
    inner class ConcurrencyTests {

        @Test
        fun `should handle concurrent chunk storage operations`() {
            val numThreads = 10
            val documentsPerThread = 50

            val threads = (1..numThreads).map { threadIndex ->
                Thread {
                    val documents = (1..documentsPerThread).map { docIndex ->
                        Document(
                            "thread-${threadIndex}-doc-${docIndex}",
                            "Content for thread $threadIndex document $docIndex",
                            emptyMap<String, Any>()
                        )
                    }
                    ragService.accept(documents)
                }
            }

            threads.forEach { it.start() }
            threads.forEach { it.join() }

            val allChunks = ragService.findAll()
            assertEquals(numThreads * documentsPerThread, allChunks.size)

            // Verify all chunks are present and unique
            val chunkIds = allChunks.map { it.id }.toSet()
            assertEquals(numThreads * documentsPerThread, chunkIds.size) // Should be all unique
        }

        @Test
        fun `should handle concurrent read and write operations`() {
            // Pre-populate with some data
            val initialDocs = (1..100).map {
                Document("init-$it", "Initial doc $it", emptyMap<String, Any>())
            }
            ragService.accept(initialDocs)

            val writerThread = Thread {
                repeat(50) { i ->
                    ragService.accept(
                        listOf(
                            Document("writer-$i", "Writer doc $i", emptyMap<String, Any>())
                        )
                    )
                }
            }

            val readerThread = Thread {
                repeat(100) {
                    ragService.findAll()
                    ragService.findChunksById(listOf("init-1", "init-50", "writer-1"))
                }
            }

            writerThread.start()
            readerThread.start()

            writerThread.join()
            readerThread.join()

            // Should have initial + writer documents
            val finalChunks = ragService.findAll()
            assertTrue(finalChunks.size >= 100) // At least the initial documents
        }
    }


}

// Mock embedding model for testing
class MockEmbeddingModel : EmbeddingModel {

    override fun embed(document: Document): FloatArray {
        return embed(document.text!!)
    }

    override fun call(request: EmbeddingRequest): EmbeddingResponse {
        TODO()
    }

    override fun embed(text: String): FloatArray {
        // Simple deterministic embedding based on text content for testing
        val words = text.lowercase().split(" ")
        val embedding = FloatArray(100) // 100-dimensional embedding

        // Create deterministic embeddings based on word content
        words.forEach { word ->
            val hash = word.hashCode()
            for (i in embedding.indices) {
                embedding[i] += (hash * (i + 1)).toFloat() / 1000000f
            }
        }

        // Normalize
        val norm = kotlin.math.sqrt(embedding.sumOf { (it * it).toDouble() }).toFloat()
        if (norm > 0) {
            for (i in embedding.indices) {
                embedding[i] /= norm
            }
        }

        return embedding.map { it.toFloat() }.toFloatArray()
    }

    override fun dimensions(): Int = 100
}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-lucene/src/test/resources/application-test.properties
================================================

embabel.models.llms.cypher-query-generator=test-llm



================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-rag</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-rag-neo</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent Rag Neo</name>
    <description>Embabel Agent Rag Neo</description>

    <properties>
        <neo4j-ogm-spring-boot-starter.version>1.3.0</neo4j-ogm-spring-boot-starter.version>
        <apoc-extended.version>5.26.0</apoc-extended.version>
    </properties>

    <dependencies>
        <!-- Main Dependencies -->
        <dependency>
            <groupId>org.neo4j</groupId>
            <artifactId>neo4j-ogm-spring-boot-starter</artifactId>
            <version>${neo4j-ogm-spring-boot-starter.version}</version>
        </dependency>

        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>neo4j</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.neo4j.procedure</groupId>
            <artifactId>apoc-extended</artifactId>
            <version>${apoc-extended.version}</version>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>org.slf4j</groupId>
                    <artifactId>slf4j-jdk14</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

        <dependency>
            <groupId>com.embabel.common</groupId>
            <artifactId>embabel-common-test-ai</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

</project>



================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/main/kotlin/com/embabel/agent/rag/neo/common/CypherRagQueryGenerator.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.neo.common

import com.embabel.agent.rag.RagRequest

data class CypherQuery(val query: String)

interface CypherRagQueryGenerator {
    /**
     * Generate a Cypher query for the given RAG request and schema.
     * @param request the RAG request containing the query
     * @return a CypherQuery object containing the generated Cypher query
     */
    fun generateQuery(request: RagRequest): CypherQuery
}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/main/kotlin/com/embabel/agent/rag/neo/common/CypherSearch.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.neo.common

import com.embabel.agent.rag.Chunk
import com.embabel.agent.rag.EntityData
import com.embabel.agent.rag.NamedEntityData
import com.embabel.agent.rag.Retrievable
import com.embabel.agent.rag.neo.ogm.OgmMappedEntity
import com.embabel.common.core.types.SimilarityResult
import org.neo4j.ogm.model.Result
import org.slf4j.Logger

/**
 * API-independent cypher searcher
 * Must work within Spring's transaction management
 */
interface CypherSearch {

    fun createEntity(
        entity: NamedEntityData,
        basis: Retrievable,
    ): String

    /**
     * Load a mapped entity with OGM.
     * @return null if not found
     */
    fun <T> loadEntity(
        type: Class<T>,
        id: String,
    ): T?

    /**
     * Query for all entities in the knowledge graph.
     * Includes both generic entities and mapped entities.
     * The query must return entities as n.
     */
    fun queryForEntities(
        purpose: String,
        query: String,
        params: Map<String, *> = emptyMap<String, String>(),
        logger: Logger? = null,
    ): List<EntityData>

    /**
     * Query for mapped entities in the knowledge graph.
     * The query must return entities as n.
     */
    fun queryForMappedEntities(
        purpose: String,
        query: String,
        params: Map<String, Any> = emptyMap(),
        logger: Logger? = null,
    ): List<OgmMappedEntity>

    fun chunkSimilaritySearch(
        purpose: String,
        query: String,
        params: Map<String, *>,
        logger: Logger?,
    ): List<SimilarityResult<out Chunk>>

    fun entityDataSimilaritySearch(
        purpose: String,
        query: String,
        params: Map<String, *> = emptyMap<String, String>(),
        logger: Logger? = null,
    ): List<SimilarityResult<out EntityData>>

    fun chunkFullTextSearch(
        purpose: String,
        query: String,
        params: Map<String, *>,
        logger: Logger?,
    ): List<SimilarityResult<out Chunk>>

    fun entityFullTextSearch(
        purpose: String,
        query: String,
        params: Map<String, *>,
        logger: Logger?,
    ): List<SimilarityResult<out EntityData>>

    fun queryForInt(
        query: String,
        params: Map<String, *> = emptyMap<String, String>(),
    ): Int

    fun query(
        purpose: String,
        query: String,
        params: Map<String, *>,
        logger: Logger? = null,
    ): Result
}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/main/kotlin/com/embabel/agent/rag/neo/common/LogicalQueryResolver.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.neo.common

import com.embabel.common.util.loggerFor
import org.slf4j.Logger
import org.springframework.core.io.DefaultResourceLoader
import org.springframework.core.io.ResourceLoader
import org.springframework.stereotype.Service
import java.io.IOException
import java.nio.charset.Charset

/**
 * Resolves logical query names to Cypher queries.
 */
interface LogicalQueryResolver {

    val description: String

    /**
     * Resolve a logical query name to a Cypher query.
     * Return null without error if it cannot be resolved.
     * Clients may wish to try another query to recover.
     */
    fun resolve(name: String): String?
}

const val DEFAULT_CYPHER_LOCATION = "classpath:cypher"

@Service
data class FixedLocationLogicalQueryResolver(
    val location: String = DEFAULT_CYPHER_LOCATION,
    private val resourceLoader: ResourceLoader = DefaultResourceLoader(),
) : LogicalQueryResolver {
    override val description: String = "Load from fixed location $location, expecting .cypher suffix"

    private val logger: Logger = loggerFor<FixedLocationLogicalQueryResolver>()

    override fun resolve(name: String): String? =
        try {
            logger.debug("Resource Loader in use = {}", resourceLoader::class.java.name)
            resourceLoader.getResource("$location/$name.cypher")
                .getContentAsString(Charset.defaultCharset())
                .trim()
        } catch (e: IOException) {
            logger.warn("Could not load logical query '$name' from '$location'", e)
            null
        }
}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/main/kotlin/com/embabel/agent/rag/neo/ogm/NeoOgmConfig.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.neo.ogm

import org.neo4j.ogm.session.SessionFactory
import org.slf4j.LoggerFactory
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.context.annotation.Primary
import org.springframework.context.annotation.Profile
import org.springframework.data.neo4j.repository.config.EnableNeo4jRepositories
import org.springframework.data.neo4j.transaction.Neo4jTransactionManager
import org.springframework.transaction.PlatformTransactionManager
import org.springframework.transaction.annotation.EnableTransactionManagement


@Configuration
@EnableNeo4jRepositories
@EnableTransactionManagement
@Profile("!test")
class NeoOgmConfig(
    private val properties: NeoRagServiceProperties,
) {

    private val logger = LoggerFactory.getLogger(NeoOgmConfig::class.java)

    @Bean
    fun ogmConfiguration(): org.neo4j.ogm.config.Configuration {
        logger.info("Connecting to Neo4j at {} as user {}", properties.uri, properties.username)
        return org.neo4j.ogm.config.Configuration.Builder()
            .uri(properties.uri)
            .credentials(properties.username, properties.password)
            .build()
    }

    @Bean
    @ConditionalOnMissingBean(org.neo4j.ogm.session.SessionFactory::class)
    fun sessionFactory(): SessionFactory {
        return SessionFactory(
            ogmConfiguration(),
            *properties.ogmPackages.toTypedArray(),
        )
    }

    @Bean
    @Primary
    fun transactionManager(): PlatformTransactionManager {
        return Neo4jTransactionManager(sessionFactory())
    }

}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/main/kotlin/com/embabel/agent/rag/neo/ogm/NeoRagServiceProperties.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.neo.ogm

import com.embabel.agent.rag.ingestion.ContentChunker
import org.springframework.boot.context.properties.ConfigurationProperties

/**
 * @param chunkNodeName the name of the node representing a chunk in the knowledge graph
 * @param entityNodeName the name of a node representing an entity in the knowledge graph
 * @param ogmPackages the packages to scan for Neo4j OGM entities. Defaults to none
 */
@ConfigurationProperties(prefix = "embabel.agent.rag.neo")
class NeoRagServiceProperties : ContentChunker.Config {
    var uri: String = "bolt://localhost:7687"
    var username: String = "neo4j"
    internal var password: String = ""

    var chunkNodeName: String = "Chunk"
    var entityNodeName: String = "Entity"
    var name: String = "OgmRagService"
    var description: String = "RAG service using Neo4j OGM for querying and embedding"
    var contentElementIndex: String = "embabel-content-index"
    var entityIndex: String = "embabel-entity-index"
    var contentElementFullTextIndex: String = "embabel-content-fulltext-index"
    var entityFullTextIndex: String = "embabel-entity-fulltext-index"

    // Empty packages causes a strange failure within Neo4j OGM
    var ogmPackages: List<String> = listOf("not.a.real.package")
    override var maxChunkSize: Int = 1500
    override var overlapSize: Int = 200
}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/main/kotlin/com/embabel/agent/rag/neo/ogm/OgmCypherSearch.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.neo.ogm

import com.embabel.agent.rag.*
import com.embabel.agent.rag.neo.common.CypherSearch
import com.embabel.agent.rag.neo.common.LogicalQueryResolver
import com.embabel.common.core.types.SimilarityResult
import com.embabel.common.core.types.SimpleSimilaritySearchResult
import com.embabel.common.util.time
import org.neo4j.driver.internal.InternalNode
import org.neo4j.driver.internal.value.StringValue
import org.neo4j.ogm.model.Result
import org.neo4j.ogm.session.Session
import org.neo4j.ogm.session.SessionFactory
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.data.neo4j.transaction.SessionFactoryUtils
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional


@Service
class OgmCypherSearch(
    private val sessionFactory: SessionFactory,
    private val queryResolver: LogicalQueryResolver,
) : CypherSearch, ClusterFinder {

    private val ogmCypherSearchLogger = LoggerFactory.getLogger(OgmCypherSearch::class.java)

    override fun createEntity(
        entity: NamedEntityData,
        basis: Retrievable,
    ): String {
        val params = mapOf(
            "id" to entity.id,
            "name" to entity.name,
            "description" to entity.description,
            "basisId" to basis.id,
            "properties" to entity.properties,
            "chunkNodeName" to "Chunk",
            "entityLabels" to entity.labels(),
        )
        val result = query(
            purpose = "Create entity",
            query = "create_entity",
            params = params,
            logger = ogmCypherSearchLogger,
        )
        if (result.queryStatistics().nodesCreated != 1) {
            ogmCypherSearchLogger.warn(
                "Expected to create 1 node, but created: {}. params={}",
                result.queryStatistics().nodesCreated,
                params
            )
        }
        val singleRow = result.singleOrNull() ?: error("No result returned from create_entity")
        val id = singleRow["id"] as? String ?: error("No id returned from create_entity")
        ogmCypherSearchLogger.info("Created entity {} with id: {}", entity.labels(), id)
        return id
    }

    override fun <T> loadEntity(
        type: Class<T>,
        id: String,
    ): T? {
        return currentSession().load(type, id)
    }

    override fun queryForEntities(
        purpose: String,
        query: String,
        params: Map<String, *>,
        logger: Logger?,
    ): List<EntityData> {
        val result = query(purpose = purpose, query = query, params = params, logger = logger)
        return rowsToEntityData(result)
    }

    @Transactional(readOnly = true)
    override fun <E> findClusters(opts: ClusterRetrievalRequest<E>): List<Cluster<E>> {
        val labels = opts.entitySearch?.labels?.toList() ?: error("Must specify labels in entity search for clustering")
        val desiredType = (opts.entitySearch as? TypedEntitySearch)?.entities?.first() ?: OgmMappedEntity::class.java
        val params = mapOf(
            "labels" to labels,
            "vectorIndex" to opts.vectorIndex,
            "similarityThreshold" to opts.similarityThreshold,
            "topK" to opts.topK,
        )
        val result = query(
            purpose = "cluster",
            query = "vector_cluster",
            params = params,
        )
        return result.map { row ->
            val anchor = row["anchor"] as E
            val similar = (row["similar"]) as Array<Map<String, Any>>
            val similarityResults = similar.mapNotNull { similarEntityMap ->
                val inode = similarEntityMap["match"] as InternalNode
                val matchId = (inode.get("id") as StringValue).asString()
                val score = similarEntityMap["score"] as Double
                val match = try {
                    currentSession().load(desiredType, matchId)
                } catch (e: Exception) {
                    ogmCypherSearchLogger.warn("Could not load entity of type $desiredType with id $matchId", e)
                    null
                }
                if (match == null) {
                    // Shouldn't happen...query is likely incorrect
                    ogmCypherSearchLogger.warn("Could not load match for $similarEntityMap, type=${desiredType}, id=$matchId")
                    null
                } else {
                    ogmCypherSearchLogger.debug("Found match: {} with score {}", match, "%.2f".format(score))
                    SimpleSimilaritySearchResult(match, score) as SimilarityResult<E>
                }
            }
            Cluster(anchor, similarityResults)
        }
    }

    override fun queryForMappedEntities(
        purpose: String,
        query: String,
        params: Map<String, Any>,
        logger: Logger?,
    ): List<OgmMappedEntity> {
        val result = query(purpose = purpose, query = query, params = params, logger = logger)
        return result.mapNotNull { row ->
            val match = row["n"] as? OgmMappedNamedAndDescribedEntity
            if (match == null) {
                ogmCypherSearchLogger.warn("Match is null for row: {}", row)
                return@mapNotNull null
            }
            match
        }
    }

    override fun entityDataSimilaritySearch(
        purpose: String,
        query: String,
        params: Map<String, *>,
        logger: Logger?,
    ): List<SimilarityResult<EntityData>> {
        val result = query(purpose = purpose, query = query, params = params, logger = logger)
        return rowsToSimilarityResult(result)
    }

    override fun chunkSimilaritySearch(
        purpose: String,
        query: String,
        params: Map<String, *>,
        logger: Logger?,
    ): List<SimilarityResult<Chunk>> {
        val result = query(purpose = purpose, query = query, params = params, logger = logger)
        return result.map { row ->
            SimpleSimilaritySearchResult(
                match = Chunk(
                    id = row["id"] as String,
                    text = row["text"] as String,
//                    metadata = mapOf("source" to (row["metadata_source"] as String)),
                ),
                score = row["score"] as Double,
            )
        }
    }


    override fun chunkFullTextSearch(
        purpose: String,
        query: String,
        params: Map<String, *>,
        logger: Logger?,
    ): List<SimilarityResult<Chunk>> {
        val result = query(purpose = purpose, query = query, params = params, logger = logger)
        return result.map { row ->
            SimpleSimilaritySearchResult(
                match = Chunk(
                    id = row["id"] as String,
                    text = row["text"] as String,
                    parentId = "unknown", // parentId not available from full-text search
                    metadata = mapOf("source" to "unknown"),
                ),
                score = row["score"] as Double,
            )
        }
    }

    override fun entityFullTextSearch(
        purpose: String,
        query: String,
        params: Map<String, *>,
        logger: Logger?,
    ): List<SimilarityResult<EntityData>> {
        val result = query(purpose = purpose, query = query, params = params, logger = logger)
        return rowsToSimilarityResult(result)
    }

    private fun rowsToEntityData(
        result: Result,
    ): List<EntityData> = result.map { row ->
        SimpleNamedEntityData(
            id = row["id"] as String,
            name = row["name"] as String,
            description = row["description"] as String? ?: "",
            labels = (row["labels"] as Array<String>).toSet(),
            properties = emptyMap(), // TODO: handle properties
        )
    }

    private fun rowsToMappedEntitySimilarityResult(
        result: Result,
    ): List<SimilarityResult<OgmMappedEntity>> = result.mapNotNull { row ->
        val match = row["match"] as? OgmMappedEntity
        if (match == null) {
            ogmCypherSearchLogger.warn("Match is null for row: $row")
            return@mapNotNull null
        }
        SimpleSimilaritySearchResult(
            match = match,
            score = row["score"] as Double,
        )
    }

    private fun rowsToSimilarityResult(
        result: Result,
    ): List<SimilarityResult<EntityData>> = result.map { row ->
        val name = row["name"] as? String
        val description = row["description"] as? String
        val labels = (row["labels"] as Array<String>).toSet()
        val properties = row["properties"] as? Map<String, Any> ?: emptyMap()
        val match = if (name != null && description != null) {
            SimpleNamedEntityData(
                id = row["id"] as String,
                name = row["name"] as String,
                description = row["description"] as String,
                labels = labels,
                properties = properties,
            )
        } else {
            SimpleEntityData(
                id = row["id"] as String,
                labels = labels,
                properties = properties,
            )
        }
        SimpleSimilaritySearchResult(
            match = match,
            score = row["score"] as Double,
        )
    }

    /**
     * Get the current OGM session, which requires a transaction to be active.
     */
    fun currentSession(): Session =
        SessionFactoryUtils.getSession(sessionFactory)
            ?: error("No active OGM session found. Ensure you are within a Spring transaction context.")

    /**
     * Return an OGM result
     */
    override fun query(
        purpose: String,
        query: String,
        params: Map<String, *>,
        logger: Logger?,
    ): Result {
        val loggerToUse = logger ?: ogmCypherSearchLogger
        val cypher = if (query.contains(" ")) query else queryResolver.resolve(query)!!
        loggerToUse.info("[{}] query\n\tparams: {}\n{}", purpose, params, cypher)
        val (result, millis) = time {
            currentSession().query(
                cypher,
                params,
            )
        }
        loggerToUse.info("[{}] query took {} ms", purpose, millis)
        return result
    }

    override fun queryForInt(
        query: String,
        params: Map<String, *>,
    ): Int {
        val cypher = if (query.contains(" ")) query else queryResolver.resolve(query)!!
        val result = currentSession().query(cypher, params)
        val singleRow = result.singleOrNull() ?: return 0
        val firstValue = singleRow.values.firstOrNull() ?: return 0
        return when (firstValue) {
            is Int -> firstValue
            is Long -> firstValue.toInt()
            is Double -> firstValue.toInt()
            else -> 0
        }
    }
}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/main/kotlin/com/embabel/agent/rag/neo/ogm/OgmMappedEntity.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.neo.ogm

import com.embabel.agent.rag.Chunk
import com.embabel.agent.rag.RetrievableEntity
import com.embabel.common.core.types.NamedAndDescribed
import org.neo4j.ogm.annotation.Id
import org.neo4j.ogm.annotation.NodeEntity
import org.neo4j.ogm.annotation.Relationship

@NodeEntity(label = "Chunk")
class MappedChunk(
    @Id
    override val id: String,
    override val uri: String? = null,
    override val text: String,
    override val parentId: String? = null,
    override val metadata: Map<String, Any?> = emptyMap(),
) : Chunk {

    private constructor() : this(id = "", text = "")
}

/**
 * Superclass for all entities that are mapped using Neo4j OGM.
 */
@NodeEntity("Entity")
open class OgmMappedEntity(
    @Id
    override val id: String,
    override val uri: String? = null,
    @Relationship(type = "HAS_ENTITY", direction = Relationship.Direction.INCOMING)
    val chunks: List<MappedChunk> = emptyList(),
) : RetrievableEntity {

    override fun labels() =
        setOf(javaClass.simpleName) + super.labels()

    override val metadata: Map<String, Any?>
        get() = emptyMap()

    override fun toString() = infoString(verbose = false)

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String {
        return "${javaClass.simpleName}:(${labels().joinToString(":")} id='$id')"
    }

    override fun embeddableValue(): String = error("Should not be called on this implementation")
}

@NodeEntity
abstract class OgmMappedNamedAndDescribedEntity(
    override val name: String,
    id: String,
    uri: String? = null,
) : OgmMappedEntity(id = id, uri = uri), NamedAndDescribed {

    override fun infoString(
        verbose: Boolean?,
        indent: Int,
    ): String {
        return "${javaClass.simpleName}: name=$name, description=$description, id=$id"
    }

    override fun embeddableValue(): String {
        return "${javaClass.simpleName}: name=$name, description=$description"
    }
}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/main/kotlin/com/embabel/agent/rag/neo/ogm/OgmMetadataSchemaResolver.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.neo.ogm

import com.embabel.agent.core.DataDictionary
import com.embabel.agent.rag.EntitySearch
import com.embabel.agent.rag.schema.SchemaResolver
import org.neo4j.ogm.session.SessionFactory
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service


/**
 * Infers schema from OGM metadata
 */
@Service
class OgmMetadataSchemaResolver(
    private val sessionFactory: SessionFactory,
    private val ogmCypherSearch: OgmCypherSearch,
    private val properties: NeoRagServiceProperties,
) : SchemaResolver {

    private val logger = LoggerFactory.getLogger(javaClass)

    // TODO is not using name
    // TODO not filtering entities
    override fun getSchema(entitySearch: EntitySearch): DataDictionary? {
//        val metadata = sessionFactory.metaData()
//        val entityDefinitions = metadata.persistentEntities()
//            .filter { it.hasPrimaryIndexField() }
//            .map { entity ->
//                val classDescription = entity.underlyingClass.getAnnotation(JsonClassDescription::class.java)?.value
//                val creationPermitted =
//                    entity.underlyingClass.getAnnotation(CreationPermitted::class.java)?.value != false
//                val labels = entity.staticLabels().toSet()
//                val entityDefinition = EntityDefinition(
//                    labels = labels,
//                    properties = entity.propertyFields().map { property ->
//                        SimplePropertyDefinition(
//                            name = property.name,
//                            type = property.typeDescriptor,
//                            description = property.name, // TODO get from annotation
//                        )
//                    },
//                    description = classDescription ?: labels.joinToString(","),
//                    creationPermitted = creationPermitted,
//                )
//                entity.relationshipFields().forEach { relationshipField ->
//                    val targetEntity = relationshipField.typeDescriptor.split(".").last()
//                    relationships.add(
//                        RelationshipDefinition(
//                            sourceLabel = entityDefinition.type,
//                            targetLabel = targetEntity,
//                            type = relationshipField.relationship(),
//                            description = relationshipField.name,
//                            cardinality = if (relationshipField.isArray || relationshipField.isIterable) {
//                                Cardinality.MANY
//                            } else {
//                                Cardinality.ONE
//                            },
//                        )
//                    )
//                }
//                entityDefinition
//            }
//        if (entityDefinitions.size == 2 && relationships.isEmpty()) {
//            // Special case of superclasses only
//            return null
//        }
//        return KnowledgeGraphSchema(
//            entities = entityDefinitions,
//            relationships = relationships,
//        )
        TODO()
    }

}

//fun DataDictionary.explain(): String {
//    return """
//            |Schema with ${this.domainTypes.size} entities and ${this.allowedRelationships().size} relationships:
//            |Entities:
//            |${this.domainTypes.joinToString("\n") { "\t${it.infoString(verbose)} " }}
//            |Relationships:
//            |${this.allowedRelationships().joinToString("\n") { "\t${it.infoString(verbose)} " }}
//            """.trimMargin()
//}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/main/kotlin/com/embabel/agent/rag/neo/ogm/OgmRagFacetProvider.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.neo.ogm

import com.embabel.agent.api.common.Embedding
import com.embabel.agent.rag.*
import com.embabel.agent.rag.ingestion.DefaultMaterializedContainerSection
import com.embabel.agent.rag.ingestion.MaterializedDocument
import com.embabel.agent.rag.neo.common.CypherQuery
import com.embabel.agent.rag.schema.SchemaResolver
import com.embabel.agent.rag.support.FunctionRagFacet
import com.embabel.agent.rag.support.RagFacet
import com.embabel.agent.rag.support.RagFacetProvider
import com.embabel.agent.rag.support.RagFacetResults
import com.embabel.common.ai.model.DefaultModelSelectionCriteria
import com.embabel.common.ai.model.ModelProvider
import com.embabel.common.core.types.SimilarityCutoff
import com.embabel.common.core.types.SimilarityResult
import com.embabel.common.core.types.SimpleSimilaritySearchResult
import org.neo4j.ogm.session.SessionFactory
import org.slf4j.LoggerFactory
import org.springframework.ai.document.Document
import org.springframework.stereotype.Service
import org.springframework.transaction.PlatformTransactionManager
import org.springframework.transaction.TransactionDefinition
import org.springframework.transaction.support.TransactionTemplate


/**
 * Performs RAG queries in readonly transactions using Neo4j OGM.
 * Requires a Neo4j OGM PlatformTransactionManager to be configured in the Spring context.
 */
@Service
class OgmRagFacetProvider(
    private val modelProvider: ModelProvider,
    private val ogmCypherSearch: OgmCypherSearch,
    private val schemaResolver: SchemaResolver,
    private val sessionFactory: SessionFactory,
    platformTransactionManager: PlatformTransactionManager,
    private val properties: NeoRagServiceProperties,
) : AbstractWritableContentElementRepository(properties), RagFacetProvider {

    private val logger = LoggerFactory.getLogger(OgmRagFacetProvider::class.java)

    private val readonlyTransactionTemplate = TransactionTemplate(platformTransactionManager).apply {
        isReadOnly = true
        propagationBehavior = TransactionDefinition.PROPAGATION_REQUIRED
    }

    override val name = properties.name


    private val embeddingService = modelProvider.getEmbeddingService(DefaultModelSelectionCriteria)

    override fun provision() {
        logger.info("Provisioning with properties {}", properties)
        // TODO do we want this on ContentElement?
        createVectorIndex(properties.contentElementIndex, "Chunk")
        createVectorIndex(properties.entityIndex, properties.entityNodeName)
        createFullTextIndex(properties.contentElementFullTextIndex, "Chunk", listOf("text"))
        createFullTextIndex(properties.entityFullTextIndex, properties.entityNodeName, listOf("name", "description"))
        logger.info("Provisioning complete")
    }

    override fun findChunksById(chunkIds: List<String>): List<Chunk> {
        val session = ogmCypherSearch.currentSession()
        val rows = session.query(
            cypherContentElementQuery(" WHERE c:Chunk AND c.id IN \$ids "),
            mapOf("ids" to chunkIds),
            true,
        )
        return rows.map(::rowToContentElement).filterIsInstance<Chunk>()
    }

    override fun findChunksForEntity(entityId: String): List<Chunk> {
        return ogmCypherSearch.currentSession().query(
            MappedChunk::class.java,
            """
            MATCH (e:Entity {id: ${'$'}entityId})<-[:HAS_ENTITY]-(chunk:Chunk)
            RETURN chunk
            """.trimIndent(),
            mapOf("entityId" to entityId),
        ).toList()
    }

    override fun findById(id: String): ContentElement? {
        return findChunksById(listOf(id)).firstOrNull()
    }

    override fun save(element: ContentElement): ContentElement {
        ogmCypherSearch.query(
            "Save element",
            query = "save_content_element",
            params = mapOf(
                "id" to element.id,
                "labels" to element.labels(),
                "properties" to element.propertiesToPersist(),
            )
        )
        return element
    }

    fun findAll(): List<ContentElement> {
        val rows = ogmCypherSearch.currentSession().query(
            cypherContentElementQuery(""),
            emptyMap<String, Any?>(),
            true,
        )
        return rows.mapNotNull(::rowToContentElement)
    }

    override fun count(): Int {
        return ogmCypherSearch.queryForInt("MATCH (c:ContentElement) RETURN count(c) AS count")
    }

    private fun cypherContentElementQuery(whereClause: String): String =
        "MATCH (c:ContentElement) $whereClause RETURN c.id AS id, c.uri as uri, c.text AS text, c.parentId as parentId, c.metadata.source as metadata_source, labels(c) as labels"

    private fun rowToContentElement(row: Map<String, Any?>): ContentElement? {
        val metadata = mutableMapOf<String, Any>()
        metadata["source"] = row["metadata_source"] ?: "unknown"
        val labels = row["labels"] as? Array<String> ?: error("Must have labels")
        if (labels.contains("Chunk"))
            return Chunk(
                id = row["id"] as String,
                text = row["text"] as String,
                parentId = row["parentId"] as String,
                metadata = metadata,
            )
        if (labels.contains("Document"))
            return MaterializedDocument(
                id = row["id"] as String,
                title = row["id"] as String,
                children = emptyList(),
                metadata = metadata,
                uri = row["uri"] as String,
            )
        if (labels.contains("LeafSection"))
            return LeafSection(
                id = row["id"] as String,
                title = row["id"] as String,
                text = row["text"] as String,
                parentId = row["parentId"] as String,
                metadata = metadata,
                uri = row["uri"] as String?,
            )
        if (labels.contains("Section"))
            return DefaultMaterializedContainerSection(
                id = row["id"] as String,
                title = row["id"] as String,
                parentId = row["parentId"] as String?,
                // TODO we don't care about this
                children = emptyList(),
                metadata = metadata,
                uri = row["uri"] as String?,
            )
        logger.warn("Unknown ContentElement type with labels: {}", labels.joinToString(","))
        return null
    }

    override fun commit() {
        // No-op for OGM as we use transactions
    }

    override fun onNewRetrievables(retrievables: List<Retrievable>) {
        retrievables.forEach { embedRetrievable(it) }
    }

    fun embeddingFor(text: String): Embedding =
        embeddingService.model.embed(text)

    private fun embedRetrievable(
        retrievable: Retrievable,
    ) {
        val embedding = embeddingFor(retrievable.embeddableValue())
        val cypher = """
                MERGE (n:${retrievable.labels().joinToString(":")} {id: ${'$'}id})
                SET n.embedding = ${'$'}embedding,
                 n.embeddingModel = ${'$'}embeddingModel,
                 n.embeddedAt = timestamp()
                RETURN COUNT(n) as nodesUpdated
               """.trimIndent()
        val params = mapOf(
            "id" to retrievable.id,
            "embedding" to embedding,
            "embeddingModel" to embeddingService.name,
        )
        val result = ogmCypherSearch.query(
            purpose = "embedding",
            query = cypher,
            params = params,
        )
        val propertiesSet = result.queryStatistics().propertiesSet
        if (propertiesSet == 0) {
            logger.warn(
                "Expected to set embedding properties, but set 0. chunkId={}, cypher={}",
                retrievable.id,
                cypher,
            )
        }
    }

    override fun createRelationships(root: MaterializedDocument) {
        ogmCypherSearch.query(
            "Create relationships for root ${root.id}",
            query = "create_content_element_relationships",
            params = mapOf(
                "rootId" to root.id,
            )
        )
    }

    override fun accept(t: List<Document>) {
        TODO("Not yet implemented")
    }

    override fun facets(): List<RagFacet<out Retrievable>> {
        return listOf(
            FunctionRagFacet(
                name = "OgmRagService",
                searchFunction = ::search,
            )
        )
    }

    private fun commonParameters(request: SimilarityCutoff) = mapOf(
        "topK" to request.topK,
        "similarityThreshold" to request.similarityThreshold,
    )

    fun search(ragRequest: RagRequest): RagFacetResults<Retrievable> {
        val embedding = embeddingService.model.embed(ragRequest.query)
        val allResults = mutableListOf<SimilarityResult<out Retrievable>>()
        if (ragRequest.contentElementSearch.types.contains(Chunk::class.java)) {
            allResults += safelyExecuteInTransaction { chunkSearch(ragRequest, embedding) }
        } else {
            logger.info("No chunk search specified, skipping chunk search")
        }

        if (ragRequest.entitySearch != null) {
            allResults += safelyExecuteInTransaction { entitySearch(ragRequest, embedding) }
        } else {
            logger.info("No entity search specified, skipping entity search")
        }

        // TODO should reward multiple matches
        val mergedResults: List<SimilarityResult<out Retrievable>> = allResults
            .distinctBy { it.match.id }
            .sortedByDescending { it.score }
            .take(ragRequest.topK)
        return RagFacetResults(
            facetName = this.name,
            results = mergedResults,
        )
    }

    private fun safelyExecuteInTransaction(block: () -> List<SimilarityResult<out Retrievable>>): List<SimilarityResult<out Retrievable>> {
        return try {
            readonlyTransactionTemplate.execute { block() } as List<SimilarityResult<out Retrievable>>
        } catch (e: Exception) {
            logger.error("Error during RAG search transaction", e)
            emptyList()
        }
    }

    private fun chunkSearch(
        ragRequest: RagRequest,
        embedding: Embedding,
    ): List<SimilarityResult<Chunk>> {
        val chunkSimilarityResults = ogmCypherSearch.chunkSimilaritySearch(
            "Chunk similarity search",
            query = "chunk_vector_search",
            params = commonParameters(ragRequest) + mapOf(
                "vectorIndex" to properties.contentElementIndex,
                "queryVector" to embedding,
            ),
            logger = logger,
        )
        logger.info("{} chunk similarity results for query '{}'", chunkSimilarityResults.size, ragRequest.query)

        val chunkFullTextResults = ogmCypherSearch.chunkFullTextSearch(
            purpose = "Chunk full text search",
            query = "chunk_fulltext_search",
            params = commonParameters(ragRequest) + mapOf(
                "fulltextIndex" to properties.contentElementFullTextIndex,
                "searchText" to "\"${ragRequest.query}\"",
            ),
            logger = logger,
        )
        logger.info("{} chunk full-text results for query '{}'", chunkFullTextResults.size, ragRequest.query)
        return chunkSimilarityResults + chunkFullTextResults
    }

    private fun entitySearch(
        ragRequest: RagRequest,
        embedding: FloatArray,
    ): List<SimilarityResult<out Retrievable>> {
        val allEntityResults = mutableListOf<SimilarityResult<out Retrievable>>()
        val labels = ragRequest.entitySearch?.labels ?: error("No entity search specified")
        val entityResults = entityVectorSearch(
            ragRequest,
            embedding,
            labels,
        )
        allEntityResults += entityResults
        logger.info("{} entity vector results for query '{}'", entityResults.size, ragRequest.query)
        val entityFullTextResults = ogmCypherSearch.entityFullTextSearch(
            purpose = "Entity full text search",
            query = "entity_fulltext_search",
            params = commonParameters(ragRequest) + mapOf(
                "fulltextIndex" to properties.entityFullTextIndex,
                "searchText" to ragRequest.query,
                "labels" to labels,
            ),
            logger = logger,
        )
        logger.info("{} entity full-text results for query '{}'", entityFullTextResults.size, ragRequest.query)
        allEntityResults += entityFullTextResults

        if (ragRequest.entitySearch?.generateQueries == true) {
            val cypherResults =
                generateAndExecuteCypher(ragRequest, ragRequest.entitySearch!!).also { cypherResults ->
                    logger.info("{} Cypher results for query '{}'", cypherResults.size, ragRequest.query)
                }
            allEntityResults += cypherResults
        } else {
            logger.info("No query generation specified, skipping Cypher generation and execution")
        }
        logger.info("{} total entity results for query '{}'", entityFullTextResults.size, ragRequest.query)
        return allEntityResults
    }

    fun entityVectorSearch(
        request: SimilarityCutoff,
        embedding: FloatArray,
        labels: Set<String>,
    ): List<SimilarityResult<EntityData>> {
        return ogmCypherSearch.entityDataSimilaritySearch(
            purpose = "Mapped entity search",
            query = "entity_vector_search",
            params = commonParameters(request) + mapOf(
                "index" to properties.entityIndex,
                "queryVector" to embedding,
                "labels" to labels,
            ),
            logger,
        )
    }

    private fun generateAndExecuteCypher(
        request: RagRequest,
        entitySearch: EntitySearch,
    ): List<SimilarityResult<out Retrievable>> {
        val schema = schemaResolver.getSchema(entitySearch)
        if (schema == null) {
            logger.info("No schema found for entity search {}, skipping Cypher execution", entitySearch)
            return emptyList()
        }

        val cypherRagQueryGenerator = SchemaDrivenCypherRagQueryGenerator(
            modelProvider,
            schema,
        )
        val cypher = cypherRagQueryGenerator.generateQuery(request = request)
        logger.info("Generated Cypher query: $cypher")

        val cypherResults = readonlyTransactionTemplate.execute {
            executeGeneratedCypher(cypher)
        } ?: Result.failure(
            IllegalStateException("Transaction failed or returned null while executing Cypher query: $cypher")
        )
        if (cypherResults.isSuccess) {
            val results = cypherResults.getOrThrow()
            if (results.isNotEmpty()) {
                logger.info("Cypher query executed successfully, results: {}", results)
                return results.map {
                    // Most similar as we found them by a query
                    SimpleSimilaritySearchResult(
                        it,
                        score = 1.0,
                    )
                }
            }
        }
        return emptyList()
    }

    /**
     * Execute generate Cypher query, being sure to handle exceptions gracefully.
     */
    private fun executeGeneratedCypher(
        query: CypherQuery,
    ): Result<List<EntityData>> {
        try {
            return Result.success(
                ogmCypherSearch.queryForEntities(
                    purpose = "cypherGeneratedQuery",
                    query = query.query
                )
            )
        } catch (e: Exception) {
            logger.error("Error executing generated query: $query", e)
            return Result.failure(e)
        }
    }

    private fun createVectorIndex(
        name: String,
        on: String,
    ) {
        sessionFactory.openSession().query(
            """
            CREATE VECTOR INDEX `$name` IF NOT EXISTS
            FOR (n:$on) ON (n.embedding)
            OPTIONS {indexConfig: {
            `vector.dimensions`: ${embeddingService.model.dimensions()},
            `vector.similarity_function`: 'cosine'
            }}""", emptyMap<String, Any>()
        )
    }

    private fun createFullTextIndex(
        name: String,
        on: String,
        properties: List<String>,
    ) {
        val propertiesString = properties.joinToString(", ") { "n.$it" }
        sessionFactory.openSession().query(
            """|
                |CREATE FULLTEXT INDEX `$name` IF NOT EXISTS
                |FOR (n:$on) ON EACH [$propertiesString]
                |OPTIONS {
                |indexConfig: {
                |
                |   }
                |}
                """.trimMargin(),
            emptyMap<String, Any>()
        )
        logger.info("Created full-text index {} for {} on properties {}", name, on, properties)
    }
}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/main/kotlin/com/embabel/agent/rag/neo/ogm/SchemaDrivenCypherRagQueryGenerator.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.neo.ogm

import com.embabel.agent.core.DataDictionary
import com.embabel.agent.rag.RagRequest
import com.embabel.agent.rag.neo.common.CypherQuery
import com.embabel.agent.rag.neo.common.CypherRagQueryGenerator
import com.embabel.common.ai.model.ModelProvider
import com.embabel.common.ai.model.ModelSelectionCriteria.Companion.byRole
import com.embabel.common.util.loggerFor
import org.slf4j.Logger

/**
 * Generate RAG queries from a given schema
 */
class SchemaDrivenCypherRagQueryGenerator(
    modelProvider: ModelProvider,
    private val schema: DataDictionary,
) : CypherRagQueryGenerator {

    private val logger: Logger = loggerFor<SchemaDrivenCypherRagQueryGenerator>()

    private val llm = modelProvider.getLlm(byRole("cypher-query-generator"))

    override fun generateQuery(
        request: RagRequest,
    ): CypherQuery {
        val prompt = """
            Generate a Cypher query for the following RAG request:
            Request: ${request.query}
            Use only entities and relationships defined in the schema.
            Use only properties defined in the schema.
            Be willing to use relationships, paths and ordering to get the best insights.
            Schema: ${TODO()}

            You must return entities named as `n`.

            RETURN ONLY the Cypher query, without any additional text or explanation.
         """.trimIndent()

        logger.info("Cypher query generation prompt for {}:\n{}", request.query, prompt)
        val response = llm.model.call(prompt)
        val query = cleanLlmCypher(response)
        validate(query)
        val cypherQuery = CypherQuery(query)
        return cypherQuery
    }

    //    @Throws(QueryValidationException::class)
    private fun validate(cypher: String) {
        logger.debug(
            "Generated Cypher query '{}' is valid against given schema",
            cypher
        )
    }
}

/**
 * Try to extract Cypher from the response
 * @param rawResponse raw response from LLM
 * @return Cypher part of the response
 */
fun cleanLlmCypher(rawResponse: String): String {
    return rawResponse.replace("```cypher", "").replace("```", "").trim()
}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/main/kotlin/com/embabel/agent/rag/schema/SchemaResolver.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.schema

import com.embabel.agent.core.DataDictionary
import com.embabel.agent.rag.EntitySearch

/**
 * Resolve schema by name
 */
interface SchemaResolver {

    /**
     * Resolve the schema of the knowledge graph, if possible
     */
    fun getSchema(entitySearch: EntitySearch): DataDictionary?
}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/main/resources/cypher/chunk_fulltext_search.cypher
================================================
// Normalize from 0-1

CALL db.index.fulltext.queryNodes($fulltextIndex, $searchText)
YIELD node AS chunk, score
WITH collect({node: chunk, score: score}) AS results, max(score) AS maxScore
UNWIND results AS result
WITH result.node AS chunk,
     result.score / maxScore AS normalizedScore
  WHERE normalizedScore >= $similarityThreshold
RETURN chunk.text AS text,
       chunk.id AS id,
       normalizedScore AS score
  ORDER BY score DESC
  LIMIT $topK


================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/main/resources/cypher/chunk_vector_search.cypher
================================================
CALL db.index.vector.queryNodes($vectorIndex, $topK, $queryVector)
YIELD node AS chunk, score
  WHERE score >= $similarityThreshold
RETURN chunk.text AS text, chunk.id AS id,
       score
  ORDER BY score DESC



================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/main/resources/cypher/create_content_element_relationships.cypher
================================================

MATCH (child:ContentElement) where child.parentId IS NOT NULL
WITH child MATCH (parent:ContentElement {id: child.parentId})
MERGE (child)-[:HAS_PARENT]->(parent);


================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/main/resources/cypher/create_entity.cypher
================================================
MATCH (chunk:$($chunkNodeName) {id: $basisId})
CREATE (chunk)-[:HAS_ENTITY]->(e:$($entityLabels) {id: $id, name: $name, description: $description, createdDate: timestamp()})
SET e += $properties,
e.lastModifiedDate = timestamp()
RETURN e.id as id, COUNT(e) as nodesCreated


================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/main/resources/cypher/entity_fulltext_search.cypher
================================================
CALL db.index.fulltext.queryNodes($fulltextIndex, $searchText)
YIELD node AS m, score
WHERE score IS NOT NULL AND any(label IN labels(m) WHERE label IN $labels)
WITH collect({node: m, score: score}) AS results, max(score) AS maxScore
  WHERE maxScore IS NOT NULL AND maxScore > 0
UNWIND results AS result
WITH result.node AS match,
     COALESCE(result.score / maxScore, 0.0) AS score,
result.node.name as name,
result.node.description as description,
result.node.id AS id,
labels(result.node) AS labels
WHERE score >= $similarityThreshold
RETURN
       COALESCE(name, '') as name,
       COALESCE(description, '') as description,
       COALESCE(id, '') as id,
       properties(match) AS properties,
       labels,
       score
ORDER BY score DESC


================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/main/resources/cypher/entity_vector_search.cypher
================================================
CALL db.index.vector.queryNodes($index, $topK, $queryVector)
YIELD node AS m, score
WHERE score >= $similarityThreshold AND
any(label IN labels(m) WHERE label IN $labels)
RETURN properties(m) AS properties, m.name as name, m.description as description, m.id AS id, labels(m) AS labels,
       score
ORDER BY score DESC




================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/main/resources/cypher/find_all.cypher
================================================
MATCH (existing:$($labels))
RETURN existing,
       labels(existing) AS labels,
       existing.name as name,
       existing.id AS id,
       existing.description AS description,
  LIMIT $limit;


================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/main/resources/cypher/save_content_element.cypher
================================================
MERGE (e:ContentElement {id: $id})
SET e += $properties,
  e.lastModifiedDate = timestamp()
WITH e
CALL apoc.create.addLabels(e, $labels)
YIELD node
RETURN 1


================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/main/resources/cypher/vector_cluster.cypher
================================================
MATCH (n:$($labels))
WITH collect(n) as allNodes
CALL apoc.cypher.parallel(
"WITH $item as seedNode
 CALL db.index.vector.queryNodes($vectorIndex, $topK, seedNode.embedding)
 YIELD node AS m, score
 WHERE m <> seedNode AND score > $similarityThreshold
   AND id(seedNode) < id(m)
   AND any(label IN labels(m) WHERE label IN $labels)
 RETURN seedNode as anchorNode,
        collect({match: m, score: score}) as similar",
{
  item: allNodes,
  labels: $labels,
  topK: $topK,
  similarityThreshold: $similarityThreshold,
  vectorIndex: $vectorIndex
},
"item"
) YIELD value
  WHERE size(value.similar) > 0
RETURN value.anchorNode as anchor,
       value.similar as similar,
       size(value.similar) as similarCount
  ORDER BY similarCount DESC


================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/test/kotlin/com/embabel/agent/rag/.gitkeep
================================================
[Empty file]


================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/test/kotlin/com/embabel/agent/rag/neo/NeoTestApplication.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.neo

import com.embabel.agent.spi.config.spring.AgentPlatformConfiguration
import com.embabel.agent.api.models.DockerLocalModels
import com.embabel.agent.api.models.OllamaModels
import org.neo4j.ogm.config.Configuration
import org.neo4j.ogm.session.Session
import org.neo4j.ogm.session.SessionFactory
import org.neo4j.ogm.session.event.Event
import org.neo4j.ogm.session.event.EventListenerAdapter
import org.springframework.boot.SpringApplication
import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration
import org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration
import org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration
import org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration
import org.springframework.boot.context.properties.ConfigurationPropertiesScan
import com.embabel.agent.rag.neo.support.Neo4jTestContainer
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.ComponentScan
import org.springframework.context.annotation.FilterType
import org.springframework.context.annotation.Import
import org.springframework.data.neo4j.annotation.EnableNeo4jAuditing
import org.springframework.data.neo4j.repository.config.EnableNeo4jRepositories
import org.springframework.data.neo4j.transaction.Neo4jTransactionManager
import org.springframework.test.context.ActiveProfiles


/**
 * Main entry point for integration tests
 */
@SpringBootApplication(
    exclude = [WebFluxAutoConfiguration::class, WebSocketReactiveAutoConfiguration::class, ErrorWebFluxAutoConfiguration::class, HttpHandlerAutoConfiguration::class
    ]
)
@EnableNeo4jRepositories(basePackages = ["com.embabel"])
@EnableNeo4jAuditing
@ConfigurationPropertiesScan(basePackages = ["com.embabel"])
@ComponentScan(
    basePackages = ["com.embabel"],
    excludeFilters = [ComponentScan.Filter(
        type = FilterType.ASSIGNABLE_TYPE,
        classes = [com.embabel.common.test.ai.config.FakeAiConfiguration::class]
    )]
)
@ActiveProfiles("test")
@Import(
    AgentPlatformConfiguration::class,
    OllamaModels::class,
    DockerLocalModels::class,
    com.embabel.agent.rag.neo.config.NeoFakeAiConfiguration::class
)
open class NeoTestApplication {

    companion object {
        @JvmStatic
        fun main(args: Array<String>) {
            SpringApplication.run(NeoTestApplication::class.java, *args)
        }
    }

    @Bean
    fun neo4jTestContainer(): Neo4jTestContainer {
        return Neo4jTestContainer.instance
    }

    @Bean
    fun configuration(): Configuration? {
        val c = neo4jTestContainer()
        return Configuration.Builder()
            .uri(c.boltUrl)
            .credentials("neo4j", c.adminPassword)
            .build()
    }

    @Bean
    fun sessionFactory(): SessionFactory {
        return object : SessionFactory(configuration(), "com.embabel.agent.rag") {
            override fun openSession(): Session {
                val s = super.openSession()
                s.register(preSaveEventListener())
                return s
            }
        }
    }

    @Bean
    fun transactionManager(): Neo4jTransactionManager {
        return Neo4jTransactionManager(sessionFactory())
    }

    @Bean
    fun preSaveEventListener(): EventListenerAdapter {
        return object : EventListenerAdapter() {
            override fun onPreSave(event: Event?) {
                // Add pre-save hook here, if needed
            }
        }
    }


}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/test/kotlin/com/embabel/agent/rag/neo/NeoTestContainerTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.neo

import com.embabel.agent.rag.neo.support.NeoIntegrationTest
import com.embabel.agent.rag.neo.support.Neo4jTestContainer
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.TestInstance
import org.junit.jupiter.api.condition.DisabledIfEnvironmentVariable
import org.neo4j.driver.AuthTokens
import org.neo4j.driver.Driver
import org.neo4j.driver.GraphDatabase
import org.neo4j.driver.Session
import org.springframework.beans.factory.annotation.Autowired
import kotlin.test.assertEquals

@DisabledIfEnvironmentVariable(named = "SKIP_TESTCONTAINER_TESTS", matches = "true")
@NeoIntegrationTest
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class NeoTestContainerTest(
    @param:Autowired private val testContainer: Neo4jTestContainer,
) {

    val boltUrl: String = testContainer.boltUrl
    val driver: Driver = GraphDatabase.driver(
        boltUrl,
        AuthTokens.basic("neo4j", testContainer.adminPassword)
    )

    @BeforeEach
    fun setup() {
        driver.session().executeWrite { tx ->
            tx.run(
                """
            CALL apoc.cypher.runFile("reference-data.cypher") YIELD fileName
            RETURN fileName
        """.trimIndent()
            ).consume()
        }
    }

    @Test
    fun `should make APOC extended available`() {
        driver.session().use { session: Session ->
            val result = session.run(
                """
                RETURN apoc.date.format(timestamp(),'ms','yyyy') AS y
            """.trimIndent()
            )
            assertTrue(result.hasNext())
        }
    }

    @Test
    fun `should load reference data`() {
        driver.session().use { session ->
            val result = session.run(
                """
            MATCH (p:Person)
            RETURN p.name AS name
            ORDER BY name
            """.trimIndent()
            )
            val names = result.list { it["name"].asString() }

            assertEquals(listOf("Arjen", "Igor", "Jasper", "Rod", "Sasha"), names)
        }
    }
}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/test/kotlin/com/embabel/agent/rag/neo/config/NeoFakeAiConfiguration.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.neo.config

import com.embabel.common.ai.model.DefaultOptionsConverter
import com.embabel.common.ai.model.EmbeddingService
import com.embabel.common.ai.model.Llm
import io.mockk.mockk
import org.slf4j.LoggerFactory
import org.springframework.ai.chat.model.ChatModel
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.context.annotation.Profile
import org.springframework.test.context.TestPropertySource

/**
 * Parallels the AiConfiguration class in src/main/java/com/embabel/server/AiConfiguration.kt.
 * Enables tests to run without OPENAI_API_KEY.
 */
@Configuration
@Profile("test")
internal class NeoFakeAiConfiguration {

    private val logger = LoggerFactory.getLogger(NeoFakeAiConfiguration::class.java)

    init {
        logger.info("Using fake AI configuration")
    }

    @Bean
    fun cheapest(): Llm {
        return Llm(
            name = "cheapest",
            model = mockk<ChatModel>(),
            provider = "hello",
            optionsConverter = DefaultOptionsConverter
        )
    }

    @Bean
    fun best(): Llm {
        return Llm(
            name = "test-llm",
            model = mockk<ChatModel>(),
            provider = "hello",
            optionsConverter = DefaultOptionsConverter
        )
    }

    @Bean
    fun embedding(): EmbeddingService {
        return EmbeddingService(
            name = "test",
            model = com.embabel.common.test.ai.FakeEmbeddingModel(),
            provider = "hello",
        )
    }

    @Bean(name = ["bedrockModels"]) fun bedrockModels() = Any()
}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/test/kotlin/com/embabel/agent/rag/neo/ogm/OgmRagServiceTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.neo.ogm

import com.embabel.agent.rag.*
import com.embabel.agent.rag.ingestion.DefaultMaterializedContainerSection
import com.embabel.agent.rag.ingestion.MaterializedDocument
import com.embabel.common.ai.model.Llm
import com.embabel.agent.rag.neo.support.NeoIntegrationTestSupport
import io.mockk.every
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Disabled
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.condition.DisabledIfEnvironmentVariable
import org.neo4j.ogm.annotation.Id
import org.neo4j.ogm.annotation.NodeEntity
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.beans.factory.annotation.Qualifier
import kotlin.test.assertEquals
import kotlin.test.assertTrue

@DisabledIfEnvironmentVariable(named = "SKIP_TESTCONTAINER_TESTS", matches = "true")
class OgmRagServiceTest(
    @param:Autowired @param:Qualifier("best")
    private val cypherGenerationLlm: Llm,
) : NeoIntegrationTestSupport() {

    @BeforeEach
    fun setup() {
        ragService.provision()
    }

    companion object {
        fun fakeContent(): MaterializedDocument {
            val rootId = "whatever"
            val sec1Id = "sec1"

            val leaf1 = LeafSection(
                id = "leaf1",
                title = "Leaf 1",
                text = "This is the content of leaf 1.",
                parentId = sec1Id
            )
            val sec1 = DefaultMaterializedContainerSection(
                id = sec1Id,
                title = "Section 1",
                parentId = rootId,
                children = listOf(leaf1),
            )
            return MaterializedDocument(
                id = rootId,
                title = "great",
                children = listOf(sec1),
                uri = "file:///great"
            )
        }
    }

    @NodeEntity
    data class Dog(
        @Id val id: String,
        val name: String,
    ) : Embeddable {
        override fun embeddableValue(): String {
            return name
        }
    }

    @Nested
    inner class VectorClusteringTest {

        @Test
        fun `clustering empty `() {

            val entityClusters = ogmCypherSearch.findClusters<Dog>(
                ClusterRetrievalRequest(TypedEntitySearch(listOf(Dog::class.java)))
            )
            assertTrue(entityClusters.isEmpty(), "Expected no entity clusters")
        }
    }


    @Nested
    inner class FullTextSearchTest {
        @Test
        fun `should find chunk by full-text search`() {
            val mcr = fakeContent()
            ragService.writeContent(mcr)

            val results = ragService.search(
                RagRequest("leaf").withSimilarityThreshold(.0)
            )

            assertTrue(results.results.isNotEmpty(), "Expected results from full-text search")
            val chunkResult = results.results.find { it.match is Chunk }
            assertTrue(chunkResult != null, "Expected to find chunk in results")
            assertTrue((chunkResult!!.match as Chunk).text.contains("leaf"), "Expected chunk to contain search term")
        }

        @Test
        fun `should find chunk by exact text match`() {
            val mcr = fakeContent()
            ragService.writeContent(mcr)

            val results = ragService.search(
                RagRequest("content of leaf 1").withSimilarityThreshold(.0)
            )

            assertTrue(results.results.isNotEmpty(), "Expected results from full-text search for exact match")
            val chunkResult = results.results.find { it.match is Chunk }
            assertTrue(chunkResult != null, "Expected to find chunk in results")
        }

        @Test
        fun `full-text search should work with low similarity threshold`() {
            val mcr = fakeContent()
            ragService.writeContent(mcr)

            val results = ragService.search(
                RagRequest("leaf").withSimilarityThreshold(0.1)
            )

            assertTrue(results.results.isNotEmpty(), "Expected results with low similarity threshold")
        }
    }

    @Nested
    inner class HybridSearchTest {
        @Test
        fun `hybrid search should combine vector and full-text results`() {
            val mcr = fakeContent()
            ragService.writeContent(mcr)

            val results = ragService.search(
                RagRequest("leaf").withSimilarityThreshold(.0)
            )

            assertTrue(results.results.isNotEmpty(), "Expected results from hybrid search")

            // The search should find chunks through multiple methods
            // Log the number of results to understand what's happening
            logger.info("Hybrid search returned {} results", results.results.size)
            results.results.forEach { result ->
                logger.info(
                    "Result: {} - {}", result.match.javaClass.simpleName,
                    if (result.match is Chunk) (result.match as Chunk).text.take(50) + "..." else result.match.toString()
                )
            }

            val chunkResults = results.results.filter { it.match is Chunk }
            assertTrue(chunkResults.isNotEmpty(), "Expected at least one chunk from hybrid search")
        }

        @Test
        fun `hybrid search should not duplicate results`() {
            val mcr = fakeContent()
            ragService.writeContent(mcr)

            val results = ragService.search(
                RagRequest("leaf").withSimilarityThreshold(.0)
            )

            // Check that results are deduplicated by ID
            val ids = results.results.map { it.match.id }
            val uniqueIds = ids.distinct()

            assertEquals(ids.size, uniqueIds.size, "Expected no duplicate results in hybrid search")
        }
    }

    @Nested
    inner class SmokeTest {
        @Test
        fun `should find nothing in empty db`() {
            every { cypherGenerationLlm.model.call(any<String>()) } returns "MATCH (n) WHERE n.name CONTAINS 'test' RETURN n"

            val results = ragService.search(
                RagRequest(
                    query = "test",
                    topK = 10,
                )
            )
            assertEquals(0, results.results.size, "Expected no results in empty database")
        }
    }


    @Nested
    inner class WriteContentTest {

        @Test
        fun `write content`() {
            val mcr = fakeContent()
            ragService.writeContent(mcr)
            val results = ragService.findAll()
            assertEquals(4, results.size, "Expected 3 nodes (root, section, leaf) plus one chunk")
        }

        @Test
        fun `chunks are embedded`() {
            val mcr = fakeContent()
            ragService.writeContent(mcr)
            val chunks = ragService.findAll().filterIsInstance<Chunk>()
            assertTrue(chunks.isNotEmpty(), "Expected chunks to be extracted")
            logger.info("Chunks: {}", chunks)
            val chunkCount = ogmCypherSearch.queryForInt("MATCH (c:Chunk) RETURN count(c) AS count")

            assertEquals(
                chunks.size,
                chunkCount,
                "Expected chunk count to match"
            )
            val emptyChunkCount =
                ogmCypherSearch.queryForInt("MATCH (c:Chunk) WHERE c.embedding IS NULL RETURN count(c) AS count")
            assertEquals(0, emptyChunkCount, "Expected all chunks to have embeddings")
        }

        @Test
        fun `chunks have parents`() {
            val mcr = fakeContent()
            ragService.writeContent(mcr)
            val chunks = ragService.findAll().filterIsInstance<Chunk>()
            assertTrue(chunks.isNotEmpty(), "Expected chunks to be extracted")
            logger.info("Chunks: {}", chunks)
            chunks.forEach {
                assertTrue(it.parentId != null, "Expected chunk to have a parent: $it")
            }
        }

        @Test
        fun `families are together`() {
            val mcr = fakeContent()
            ragService.writeContent(mcr)
            val chunks = ragService.findAll().filterIsInstance<Chunk>()
            assertTrue(chunks.isNotEmpty(), "Expected chunks to be extracted")
            val orphanCount = driver().session().executeRead { tx ->
                tx.run(
                    """
                    MATCH (c:Chunk)
                    WHERE c.parent IS NOT NULL
                      AND NOT EXISTS((c)-[:HAS_PARENT]->())
                    RETURN count(c) AS count
                """.trimIndent()
                )
                    .single().get("count").asLong()
            }
            assertEquals(0, orphanCount, "Expected no orphans. Orphans make me sad")
        }

        @Test
        @Disabled
        fun `single chunk is retrieved`() {
            val mcr = fakeContent()
            ragService.writeContent(mcr)
            val chunks = ragService.findAll().filterIsInstance<Chunk>()
            assertEquals(1, chunks.size, "Expected a single chunk to be created")
            val results = ragService.search(RagRequest("anything at all").withSimilarityThreshold(.0))
            assertEquals(1, results.results.size, "Expected one chunk to be retrieved")
            val r1 = results.results[0]
            assertTrue(r1 is Chunk, "Expected result to be a Chunk")
            assertTrue(r1.text.contains("leaf 1"), "Expected chunk to contain text from leaf 1")
        }

    }
}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/test/kotlin/com/embabel/agent/rag/neo/support/Neo4jTestContainer.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.neo.support

import org.testcontainers.containers.Neo4jContainer
import org.testcontainers.utility.MountableFile
import java.nio.file.Paths

class Neo4jTestContainer : Neo4jContainer<Neo4jTestContainer> {
    private constructor(imageName: String) : super(imageName)

    companion object {
        @JvmField
        val instance: Neo4jTestContainer = Neo4jTestContainer("neo4j:5.26.1-enterprise")
            .apply {
                // Resolve the JAR in the user's ~/.m2 repository
                // Mount it inside the container's plugins directory
                withFileSystemBind(apocJarPath(), "/plugins/apoc-extended-5.26.0.jar")
            }
            .withNeo4jConfig("dbms.security.procedures.unrestricted", "apoc.*")
            .withNeo4jConfig("dbms.logs.query.enabled", "INFO")
            .withNeo4jConfig("dbms.logs.query.parameter_logging_enabled", "true")
            .withNeo4jConfig("apoc.import.file.enabled", "true")
            .withEnv("NEO4J_ACCEPT_LICENSE_AGREEMENT", "yes")
            .withEnv("NEO4J_PLUGINS", "[\"apoc\",\"graph-data-science\"]")
            .withEnv(
                "APOC_CONFIG",
                "apoc.import.file.enabled=true,apoc.import.file.use_neo4j_config=true"
            )
            .withEnv("checks.disable", "true")
            .withEnv("NEO4J_apoc_export_file_enabled", "true")
            .withFileSystemBind("../../../test-neo4j-logs", "/logs")
            .withAdminPassword("embabel$$$$")
            .withCopyFileToContainer(
                MountableFile.forClasspathResource("reference-data.cypher"),
                "/var/lib/neo4j/import/reference-data.cypher"
            )

        //TODO: We might be able to clean this up using copyFileToContainer and a classpath resource
        private fun apocJarPath(): String {
            val apocJar = Paths.get(
                System.getProperty("user.home"),
                ".m2",
                "repository",
                "org",
                "neo4j",
                "procedure",
                "apoc-extended",
                "5.26.0",
                "apoc-extended-5.26.0.jar"
            ).toString()
            return apocJar
        }


        init {
            instance.start()
        }
    }
}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/test/kotlin/com/embabel/agent/rag/neo/support/NeoIntegrationTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.neo.support

import com.embabel.agent.rag.neo.NeoTestApplication
import org.springframework.boot.autoconfigure.EnableAutoConfiguration
import org.springframework.boot.test.autoconfigure.data.neo4j.AutoConfigureDataNeo4j
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.ActiveProfiles
import org.springframework.transaction.annotation.Transactional
import org.testcontainers.junit.jupiter.Testcontainers

/**
 * Stereotype annotation for Spring integration test using Neo
 */
@SpringBootTest(classes = [NeoTestApplication::class])
@AutoConfigureDataNeo4j
@EnableAutoConfiguration
@Testcontainers
@ActiveProfiles("test")
@Target(AnnotationTarget.CLASS)
@Retention(AnnotationRetention.RUNTIME)
@Transactional
annotation class NeoIntegrationTest



================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/test/kotlin/com/embabel/agent/rag/neo/support/NeoIntegrationTestSupport.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.neo.support

import com.embabel.agent.rag.neo.ogm.OgmCypherSearch
import com.embabel.agent.rag.neo.ogm.OgmRagFacetProvider
import com.fasterxml.jackson.databind.ObjectMapper
import org.neo4j.driver.AuthTokens
import org.neo4j.driver.Driver
import org.neo4j.driver.GraphDatabase
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.context.ApplicationContext
import org.springframework.context.annotation.Profile
import org.springframework.core.io.ResourceLoader

/**
 * Convenient superclass for Neo transactional integration tests using Testcontainers.
 * Test effects are rolled back by Spring test infrastructure.
 */
@NeoIntegrationTest
@Profile("test")
open class NeoIntegrationTestSupport {

    protected val logger: Logger = LoggerFactory.getLogger(this::class.java)

    @Autowired
    protected var objectMapper: ObjectMapper? = null

    @Autowired
    protected var _cypherSearch: OgmCypherSearch? = null

    @Autowired
    protected var resourceLoader: ResourceLoader? = null

    @Autowired
    protected var applicationContext: ApplicationContext? = null

    @Autowired
    protected var _ragService: OgmRagFacetProvider? = null

    @Autowired
    var testContainer: Neo4jTestContainer? = null


    fun driver(): Driver = GraphDatabase.driver(
        testContainer!!.boltUrl,
        AuthTokens.basic("neo4j", testContainer!!.adminPassword)
    )

    val ragService: OgmRagFacetProvider get() = _ragService!!

    val ogmCypherSearch: OgmCypherSearch get() = _cypherSearch!!

}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/test/kotlin/com/embabel/agent/rag/ogm/OgmCypherSearchTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.ogm

import com.embabel.agent.rag.neo.ogm.OgmCypherSearch
import com.embabel.agent.rag.neo.support.NeoIntegrationTest
import org.junit.jupiter.api.Assertions.assertNotNull
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.condition.DisabledIfEnvironmentVariable
import org.springframework.beans.factory.annotation.Autowired


@DisabledIfEnvironmentVariable(named = "SKIP_TESTCONTAINER_TESTS", matches = "true")
@NeoIntegrationTest
class OgmCypherSearchTest(
    @param:Autowired private val ogmCypherSearch: OgmCypherSearch,
) {

     @Test
    fun should_query() {
        val query = "match (n) return n limit 100"
        val params: Map<String, *> = emptyMap<String, Any>()
        val result = ogmCypherSearch.query("purpose", query, params, null)
        println("Got result: $result")
        assertNotNull(result)
    }
}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/test/resources/application-test.properties
================================================

embabel.models.llms.cypher-query-generator=test-llm

embabel.agent.rag.neo.password=brahmsian

embabel.agent.rag.neo.ogm-packages=not.a.real.package2



================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/test/resources/create_indexes.cypher
================================================
CREATE VECTOR INDEX `spring-ai-document-index` IF NOT EXISTS FOR (n:Document) ON (n.embedding)
OPTIONS {indexConfig: {
`vector.dimensions`: 384,
`vector.similarity_function`: 'cosine'
}};



================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/test/resources/reference-data.cypher
================================================
CREATE VECTOR INDEX `spring-ai-document-index` IF NOT EXISTS FOR (n:Document) ON (n.embedding)
OPTIONS {indexConfig: {
`vector.dimensions`: 384,
`vector.similarity_function`: 'cosine'
}};

merge (:Person {name: "Rod"})
merge (:Person {name: "Igor"})
merge (:Person {name: "Sasha"})
merge (:Person {name: "Arjen"})
merge (:Person {name: "Jasper"})



================================================
FILE: embabel-agent-rag/embabel-agent-rag-neo/src/test/resources/.gitkeep
================================================
[Empty file]


================================================
FILE: embabel-agent-rag/embabel-agent-rag-pipeline/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-rag</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-rag-pipeline</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent Rag Pipeline</name>
    <description>Embabel Agent RAG Pipeline processing and orchestration</description>

    <dependencies>
        <!-- Embabel Agent API for RAG classes -->
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-api</artifactId>
            <version>${project.version}</version>
        </dependency>
        
        <!-- Spring Framework for dependency injection and configuration -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
        </dependency>
        
        <!-- Logging -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
        </dependency>
        
        <!-- Kotlin standard library -->
        <dependency>
            <groupId>org.jetbrains.kotlin</groupId>
            <artifactId>kotlin-stdlib</artifactId>
        </dependency>
        
        <!-- Test dependencies - versions managed by parent -->
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.jetbrains.kotlin</groupId>
                <artifactId>kotlin-maven-plugin</artifactId>
                <executions>
                    <execution>
                        <id>compile</id>
                        <phase>compile</phase>
                        <goals>
                            <goal>compile</goal>
                        </goals>
                        <configuration>
                            <sourceDirs>
                                <source>src/main/java</source>
                                <source>src/main/kotlin</source>
                            </sourceDirs>
                        </configuration>
                    </execution>
                    <execution>
                        <id>test-compile</id>
                        <phase>test-compile</phase>
                        <goals>
                            <goal>test-compile</goal>
                        </goals>
                        <configuration>
                            <sourceDirs>
                                <source>src/test/java</source>
                                <source>src/test/kotlin</source>
                            </sourceDirs>
                        </configuration>
                    </execution>
                </executions>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
            </plugin>

        </plugins>
    </build>

</project>


================================================
FILE: embabel-agent-rag/embabel-agent-rag-pipeline/src/main/kotlin/com/embabel/agent/rag/RagPipelineConfiguration.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag

import com.embabel.agent.rag.pipeline.PipelinedRagServiceEnhancer
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

@Configuration
class RagPipelineConfiguration {

    @Bean
    @ConditionalOnMissingBean(RagServiceEnhancer::class)
    fun ragServiceEnhancer(properties: RagServiceEnhancerProperties): RagServiceEnhancer {
        return PipelinedRagServiceEnhancer(properties)
    }
}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-pipeline/src/main/kotlin/com/embabel/agent/rag/pipeline/AdaptivePipelineRagResponseEnhancer.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.pipeline

import com.embabel.agent.event.RagEventListener
import com.embabel.agent.rag.*
import com.embabel.agent.rag.pipeline.event.EnhancementCompletedRagPipelineEvent
import com.embabel.agent.rag.pipeline.event.EnhancementStartingRagPipelineEvent
import org.slf4j.LoggerFactory

/**
 * Pipeline of RagResponseEnhancers with adaptive execution based on research insights.
 * @param name Name of the pipeline
 * @param enhancers List of RagResponseEnhancers to apply in sequence
 * @param adaptiveExecution If true, adaptively skip enhancers based on quality and latency
 * @param qualityThreshold Quality score above which to skip expensive enhancers
 */
data class AdaptivePipelineRagResponseEnhancer @JvmOverloads constructor(
    val enhancers: List<RagResponseEnhancer>,
    val adaptiveExecution: Boolean = true,
    val qualityThreshold: Double = 0.7,
    val listener: RagEventListener,
) : RagResponseEnhancer {

    private val logger = LoggerFactory.getLogger(javaClass)

    override val name
        get() =
            enhancers.joinToString("->") { it.name }

    override val enhancementType = EnhancementType.CUSTOM

    override fun enhance(response: RagResponse): RagResponse {
        var current = response
        val startTime = System.currentTimeMillis()

        for (enhancer in enhancers) {
            if (adaptiveExecution) {
                val estimate = enhancer.estimateImpact(current)
                val elapsedMs = System.currentTimeMillis() - startTime

                when {
                    current.qualityMetrics?.let { it.overallScore > qualityThreshold } == true &&
                            (estimate?.estimatedLatencyMs ?: 0) > 1000 -> {
                        logger.info("Skipping expensive enhancer {} as quality is already high enough", enhancer.name)
                        continue
                    }

                    elapsedMs > response.request.desiredMaxLatency.toMillis() -> {
                        logger.info(
                            "Skipping enhancer {} as elapsed time is {}ms with latency limit of {}ms",
                            estimate,
                            enhancer.name,
                            response.request.desiredMaxLatency,
                        )
                        break
                    }

                    estimate?.recommendation == EnhancementRecommendation.SKIP -> {
                        logger.info("Skipping enhancer {} it recommends skipping", enhancer.name)
                        continue
                    }
                }
            }

            logger.info(
                "Applying enhancer {} on response from service {} with {} results",
                enhancer.name, current.service, current.results.size,
            )
            val enhancementStart = System.currentTimeMillis()
            listener.onRagEvent(EnhancementStartingRagPipelineEvent(current, enhancer.name))
            current = enhancer.enhance(current).copy(
                enhancement = RagResponseEnhancement(
                    enhancer = enhancer,
                    basis = current,
                    processingTimeMs = System.currentTimeMillis() - enhancementStart,
                    enhancementType = enhancer.enhancementType,
                    tokensProcessed = 0,
                    // TODO fix this
                    //  current.results.sumOf { it.match.length / 4 } // Rough token estimate
                )
            )
            listener.onRagEvent(EnhancementCompletedRagPipelineEvent(current, enhancer.name))
        }

        return current
    }
}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-pipeline/src/main/kotlin/com/embabel/agent/rag/pipeline/DeduplicatingEnhancer.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.pipeline

import com.embabel.agent.rag.*

object DeduplicatingEnhancer : RagResponseEnhancer {

    override val name: String = "dedupe"

    override val enhancementType: EnhancementType
        get() = EnhancementType.DEDUPLICATION

    override fun enhance(response: RagResponse): RagResponse {
        val dedupedResults = response.results.distinctBy { it.match.id }
        // TODO add count metadata so we know which were duplicated
        return if (dedupedResults.size == response.results.size) {
            response
        } else {
            response.copy(results = dedupedResults)
        }
    }

    override fun estimateImpact(response: RagResponse): EnhancementEstimate? {
        return EnhancementEstimate(
            expectedQualityGain = 1.0,
            estimatedLatencyMs = 0L,
            estimatedTokenCost = 0,
            recommendation = EnhancementRecommendation.APPLY,
        )
    }
}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-pipeline/src/main/kotlin/com/embabel/agent/rag/pipeline/FilterEnhancer.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.pipeline

import com.embabel.agent.rag.*

/**
 * Filter out sub-par results. Runs at the end
 * after reranking.
 */
object FilterEnhancer : RagResponseEnhancer {

    override val name: String = "dedupe"

    override val enhancementType: EnhancementType
        get() = EnhancementType.DEDUPLICATION

    override fun enhance(response: RagResponse): RagResponse {
        val dedupedResults = response.results.filter {
            it.score >= response.request.similarityThreshold
        }.sortedByDescending { it.score }
            .take(response.request.topK)
        return if (dedupedResults.size == response.results.size) {
            response
        } else {
            response.copy(results = dedupedResults)
        }
    }

    override fun estimateImpact(response: RagResponse): EnhancementEstimate {
        return EnhancementEstimate(
            expectedQualityGain = 1.0,
            estimatedLatencyMs = 0L,
            estimatedTokenCost = 0,
            recommendation = EnhancementRecommendation.APPLY,
        )
    }
}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-pipeline/src/main/kotlin/com/embabel/agent/rag/pipeline/PipelinedRagServiceEnhancer.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.pipeline

import com.embabel.agent.api.common.ActionContext
import com.embabel.agent.api.common.OperationContext
import com.embabel.agent.event.AgentProcessRagEvent
import com.embabel.agent.event.RagEventListener
import com.embabel.agent.event.RagRequestReceivedEvent
import com.embabel.agent.event.RagResponseEvent
import com.embabel.agent.rag.*
import com.embabel.agent.rag.pipeline.event.InitialRequestRagPipelineEvent
import com.embabel.agent.rag.pipeline.event.InitialResponseRagPipelineEvent
import org.slf4j.LoggerFactory

/**
 * Decorates a Rag Service with an enhancement pipeline.
 */
class PipelinedRagServiceEnhancer(
    val ragServiceEnhancerProperties: RagServiceEnhancerProperties = RagServiceEnhancerProperties(),
) : RagServiceEnhancer {

    private val logger = LoggerFactory.getLogger(PipelinedRagServiceEnhancer::class.java)

    override fun create(
        operationContext: OperationContext,
        delegate: RagService,
        listener: RagEventListener,
    ): RagService {
        var listenerToUse = listener
        if (operationContext is ActionContext) {
            // For action contexts, we also want to send events to the process listener
            listenerToUse += { ragEvent ->
                operationContext.processContext.onProcessEvent(
                    AgentProcessRagEvent(operationContext.agentProcess, ragEvent)
                )
            }
        }
        return PipelinedRagService(
            operationContext = operationContext,
            delegate = delegate,
            listener = listenerToUse,
        )
    }

    private inner class PipelinedRagService(
        private val operationContext: OperationContext,
        private val delegate: RagService,
        private val listener: RagEventListener,
    ) : RagService {

        override val name
            get() = "pipelined(${delegate.name})"

        override val description
            get() = "Pipelined RAG service wrapping ${delegate.name}: ${delegate.description}"

        private fun hydeQuery(
            ragRequest: RagRequest,
            hyDE: HyDE,
        ): String {
            val hydeQuery = operationContext
                .ai()
                .withLlm(ragServiceEnhancerProperties.compressionLlm)
                .generateText(
                    """
                    Given the following request, generate a plausible hypothetical
                    answer.
                    Don't worry if the answer isn't accurate; just make it a reasonable
                    example of an answer to the query.
                    The answer should be at most ${ragRequest.hyDE?.wordCount ?: 50} words.

                    REQUEST:
                    ${ragRequest.query}

                    CONTEXT FOR THE ANSWER:
                    ${hyDE.context}
                """.trimIndent()
                )
            logger.info("{} -> Generated HyDE query: {}", ragRequest.query, hydeQuery)
            return hydeQuery
        }

        override fun search(ragRequest: RagRequest): RagResponse {
            listener.onRagEvent(RagRequestReceivedEvent(ragRequest))
            logger.info("Performing initial rag search for {} using RagService {}", ragRequest, delegate.name)
            val initialRequest = ragRequest.copy(
                query = ragRequest.hyDE?.let { hydeQuery(ragRequest, it) } ?: ragRequest.query,
                topK = ragRequest.topK * 2,
                similarityThreshold = ragRequest.similarityThreshold / 2,
            )
            listener.onRagEvent(InitialRequestRagPipelineEvent(initialRequest, delegate.name))

            // Return to initial request
            val initialResponse = delegate.search(initialRequest)
                .copy(request = ragRequest)
            listener.onRagEvent(InitialResponseRagPipelineEvent(initialResponse, delegate.name))

            val pipeline = AdaptivePipelineRagResponseEnhancer(
                enhancers = buildList {
                    add(DeduplicatingEnhancer)
                    if (ragRequest.compressionConfig.enabled) {
                        add(
                            PromptedContextualCompressionEnhancer(
                                operationContext,
                                ragServiceEnhancerProperties.compressionLlm,
                                ragServiceEnhancerProperties.maxConcurrency,
                            )
                        )
                    }
                    add(RerankingEnhancer(operationContext, ragServiceEnhancerProperties.rerankingLlm))
                    add(FilterEnhancer)
                },
                listener = listener,
            )
            val enhancedRagResponse = pipeline.enhance(initialResponse)
            listener.onRagEvent(RagResponseEvent(enhancedRagResponse))
            logger.info(
                "Final enhanced rag response has {} results: {} chunks, {} other content elements, {} entities",
                enhancedRagResponse.results.size,
                enhancedRagResponse.results.count { it.match is Chunk },
                enhancedRagResponse.results.count { it.match is ContentElement && it.match !is Chunk },
                enhancedRagResponse.results.count { it.match is RetrievableEntity },
            )
            return enhancedRagResponse
        }

        override fun infoString(
            verbose: Boolean?,
            indent: Int,
        ): String {
            return "PipelinedRagService wrapping ${delegate.infoString(verbose, indent + 2)}"
        }
    }
}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-pipeline/src/main/kotlin/com/embabel/agent/rag/pipeline/PromptedContextualCompressionEnhancer.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.pipeline

import com.embabel.agent.api.common.OperationContext
import com.embabel.agent.rag.*
import com.embabel.common.ai.model.LlmOptions
import com.embabel.common.core.types.SimpleSimilaritySearchResult
import com.fasterxml.jackson.annotation.JsonPropertyDescription
import org.slf4j.LoggerFactory

// TODO could we not compress all chunks together?

// What about the concept of adding notes to the context
// Keep them fixed size

// Also memory of user - Note that memory is not something we normally care about
// Maintain several named notes. They can be persisted

/**
 *  Question-aware compression using an LLM call.
 *  Instantiated per operation
 */
class PromptedContextualCompressionEnhancer(
    val operationContext: OperationContext,
    val llm: LlmOptions,
    val maxConcurrency: Int = 15,
    override val name: String = "contextual_compression",
    private val targetRatio: Double = 0.3,
    private val minLengthToCompress: Int = 1500,
    private val preserveEntities: Boolean = true,
) : RagResponseEnhancer {

    private val logger = LoggerFactory.getLogger(PromptedContextualCompressionEnhancer::class.java)

    override val enhancementType = EnhancementType.COMPRESSION

    override fun enhance(response: RagResponse): RagResponse {
        val query = response.request.query

        val compressedResults = operationContext.parallelMap(
            items = response.results,
            maxConcurrency = maxConcurrency,
        ) { result ->
            val chunk = result.match as? Chunk
            if (chunk != null && chunk.text.length > minLengthToCompress) {
                val compressionResult = compressWithQuestionAwareness(
                    content = chunk.text,
                    query = query,
                    targetRatio = targetRatio,
                    preserveEntities = preserveEntities
                )
                if (compressionResult.irrelevant || compressionResult.compressed.isNullOrBlank()) {
                    logger.debug("Discarding irrelevant content")
                    null
                } else {
                    val compressedChunk = chunk.transform(
                        compressionResult.compressed
                        // Add compression metadata
//                    contextualRelevance = ZeroToOne(assessCompressionQuality(compressed, query))
                    )
                    logger.debug("Compressed chunk:\n{}\n----->\n{}", chunk.text, compressedChunk.text)
                    SimpleSimilaritySearchResult(compressedChunk, result.score)
                }
            } else {
                result
            }
        }.filterNotNull()
        logger.info(
            "Eliminated {} irrelevant results from {}",
            response.results.size - compressedResults.size,
            response.results.size,
        )
        return response.copy(results = compressedResults)
    }

    override fun estimateImpact(response: RagResponse): EnhancementEstimate {
        val chunks = response.results.map { it.match }.filterIsInstance<Chunk>()
        val totalTokens =
            chunks.sumOf { it.text.length / 4 }
        val compressionCandidates = chunks.count { it.text.length > 1500 }

        return EnhancementEstimate(
            expectedQualityGain = if (totalTokens > 8000) 0.15 else 0.05,
            estimatedLatencyMs = compressionCandidates * 200L,
            estimatedTokenCost = compressionCandidates * 50,
            recommendation = if (totalTokens > 4000) EnhancementRecommendation.APPLY
            else EnhancementRecommendation.CONDITIONAL
        )
    }

    private fun compressWithQuestionAwareness(
        content: String,
        query: String,
        targetRatio: Double = 0.3,
        preserveEntities: Boolean = true,
        dynamicRatio: Boolean = true,
    ): CompressionResult {
        val prompt = """
                Given the query, compress the content to include only what
                is relevant. If you cannot compress, set 'irrelevant' to true.

                <query>
                $query
                </query>

                <content>
                $content
                </content>
            """.trimIndent()
        return operationContext
            .ai()
            .withLlm(llm)
            .withId(name)
            .creating(CompressionResult::class.java)
            .withExample(
                "relevant content", CompressionResult(
                    compressed = "This is the compressed content that is relevant."
                )
            )
            .withExample(
                "irrelevant content", CompressionResult(
                    irrelevant = true,
                )
            )
            .fromPrompt(prompt = prompt)
            .also {
                if (it.irrelevant) {
                    logger.debug(
                        "{}\nContent deemed irrelevant: Query=[{}], Content:\n{}\nPrompt was\n{}\n{}",
                        "*".repeat(140),
                        query,
                        content,
                        prompt,
                        "*".repeat(140)
                    )
                }
            }
    }

}

private data class CompressionResult(
    @get:JsonPropertyDescription("Return only if the content is irrelevant")
    val irrelevant: Boolean = false,
    @get:JsonPropertyDescription("Return only if the content is valid")
    val compressed: String? = null,
)



================================================
FILE: embabel-agent-rag/embabel-agent-rag-pipeline/src/main/kotlin/com/embabel/agent/rag/pipeline/RerankingEnhancer.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.pipeline

import com.embabel.agent.api.common.OperationContext
import com.embabel.agent.rag.*
import com.embabel.common.ai.model.LlmOptions
import com.embabel.common.core.types.SimilarityResult
import com.embabel.common.core.types.SimpleSimilaritySearchResult
import com.embabel.common.core.types.ZeroToOne
import org.slf4j.LoggerFactory

/**
 * Response from LLM for reranking request
 */
private data class RerankingResponse(
    val scores: List<Double>,
)

/**
 * Enhancer that reranks search results using LLM-based relevance scoring.
 * This improves result quality by considering semantic relevance beyond vector similarity.
 */
class RerankingEnhancer(
    private val operationContext: OperationContext,
    private val llm: LlmOptions,
    private val maxResults: Int = 20,
    private val rerankingThreshold: Int = 3,
    private val rerankingWeight: ZeroToOne = .5,
) : RagResponseEnhancer {

    private val logger = LoggerFactory.getLogger(javaClass)

    override val name: String = "rerank"
    override val enhancementType = EnhancementType.RERANKING

    override fun enhance(response: RagResponse): RagResponse {
        // Only rerank if we have enough results to make it worthwhile
        if (response.results.size <= rerankingThreshold) {
            logger.debug("Skipping reranking for {} results (threshold: {})", response.results.size, rerankingThreshold)
            return response
        }

        val query = response.request.query
        val resultsToRerank = response.results.take(maxResults)

        logger.debug("Reranking {} results for query: {}", resultsToRerank.size, query)

        try {
            val rerankedResults = performLlmReranking(query, resultsToRerank)
            logger.info(
                "Reranking {} results to {} for query: {}",
                resultsToRerank.size,
                rerankedResults.size,
                query,
            )
            return response.copy(results = rerankedResults)
        } catch (e: Exception) {
            logger.warn("Failed to rerank results, returning original response", e)
            return response
        }
    }

    private fun performLlmReranking(
        query: String,
        results: List<SimilarityResult<out Retrievable>>,
    ): List<SimilarityResult<out Retrievable>> {

        // Build prompt for LLM-based reranking
        val prompt = buildRerankingChoicesText(query, results)

        // Use the operation context to get structured LLM response
        val rerankingResponse = operationContext
            .ai()
            .withLlm(llm)
            .withId("reranking")
            .createObject(
                prompt = """
                You are a relevance scoring expert. You evaluate how well search results match a query.

                $prompt

                Return a JSON object with a "scores" array containing relevance scores from 0.0 to 1.0 for each result in order.
                """.trimIndent(),
                outputClass = RerankingResponse::class.java,
            )

        val relevanceScores = rerankingResponse.scores

        // Combine original similarity scores with LLM relevance scores
        val rerankedResults = results.mapIndexed { index, result ->
            val llmScore = relevanceScores.getOrElse(index) { 0.5 }
            val combinedScore = (result.score * (1.0 - rerankingWeight) + llmScore * rerankingWeight).coerceIn(0.0, 1.0)
            SimpleSimilaritySearchResult(result.match, combinedScore)
        }
            .sortedByDescending { it.score }
        logger.debug("Reranked {} results with LLM relevance scoring", rerankedResults.size)
        return rerankedResults
    }

    private fun buildRerankingChoicesText(
        query: String,
        results: List<SimilarityResult<out Retrievable>>,
    ): String {
        val resultsText = results.mapIndexed { index, result ->
            "<index>$index</index>\n<result>${result.match.embeddableValue()}</result>"
        }.joinToString("\n${"".repeat(10)}\n")

        return """
            Query: "$query"

            Search Results:
            $resultsText

            Score each result from 0.0 to 1.0 based on how relevant it is to the query.
            Consider semantic meaning, context, and how well each result would help answer the query.
        """.trimIndent()
    }


    override fun estimateImpact(response: RagResponse): EnhancementEstimate? {
        val resultCount = response.results.size

        return if (resultCount <= rerankingThreshold) {
            EnhancementEstimate(
                expectedQualityGain = 0.0,
                estimatedLatencyMs = 0L,
                estimatedTokenCost = 0,
                recommendation = EnhancementRecommendation.SKIP
            )
        } else {
            // Estimate based on number of results to process
            val estimatedLatency = minOf(2000L + (resultCount * 100L), 5000L)
            val estimatedTokens = 50 + (resultCount * 30) // Rough estimate

            EnhancementEstimate(
                expectedQualityGain = 0.15, // 15% quality improvement expected
                estimatedLatencyMs = estimatedLatency,
                estimatedTokenCost = estimatedTokens,
                recommendation = if (resultCount >= 5) EnhancementRecommendation.APPLY else EnhancementRecommendation.CONDITIONAL
            )
        }
    }
}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-pipeline/src/main/kotlin/com/embabel/agent/rag/pipeline/event/PipelineRagEvents.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.pipeline.event

import com.embabel.agent.event.RagEvent
import com.embabel.agent.rag.RagRequest
import com.embabel.agent.rag.RagResponse
import java.time.Instant

/**
 * Events emitted by the RAG pipeline
 * @param description A short human-readable description of the event
 */
abstract class RagPipelineEvent(
    val description: String,
    override val timestamp: Instant = Instant.now(),
) : RagEvent

class InitialRequestRagPipelineEvent(
    override val request: RagRequest,
    val service: String,
) : RagPipelineEvent("Initial RAG request to $service")

class InitialResponseRagPipelineEvent(
    val response: RagResponse,
    val service: String,
) : RagPipelineEvent("Initial RAG response from $service") {

    override val request: RagRequest
        get() = response.request
}

abstract class EnhancementRagPipelineEvent(
    val enhancerName: String,
    description: String,
) : RagPipelineEvent(
    description,
)

class EnhancementStartingRagPipelineEvent(
    val basis: RagResponse,
    enhancerName: String,
) : EnhancementRagPipelineEvent(enhancerName, "Starting enhancement with $enhancerName") {

    override val request: RagRequest
        get() = basis.request
}

class EnhancementCompletedRagPipelineEvent(
    val response: RagResponse,
    enhancerName: String,
) : EnhancementRagPipelineEvent(enhancerName, "Completed enhancement with $enhancerName") {

    override val request: RagRequest
        get() = response.request
}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-tika/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-rag</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-rag-tika</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent Rag Tika ingestion</name>
    <description>Embabel Agent Tika ingestion</description>

    <!-- Use version from build-dependencies
    <properties>
        <tika.version>2.9.2</tika.version>
    </properties>
    -->

    <dependencies>
        <!-- Embabel Agent API for RAG classes -->
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-api</artifactId>
            <version>${project.version}</version>
        </dependency>
        
        <!-- Apache Tika for content parsing -->
        <dependency>
            <groupId>org.apache.tika</groupId>
            <artifactId>tika-core</artifactId>
        </dependency>

        <dependency>
            <groupId>org.apache.tika</groupId>
            <artifactId>tika-parsers-standard-package</artifactId>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.jetbrains.kotlin</groupId>
                <artifactId>kotlin-maven-plugin</artifactId>
                <executions>
                    <execution>
                        <id>compile</id>
                        <phase>compile</phase>
                        <goals>
                            <goal>compile</goal>
                        </goals>
                        <configuration>
                            <sourceDirs>
                                <source>src/main/java</source>
                                <source>src/main/kotlin</source>
                            </sourceDirs>
                        </configuration>
                    </execution>
                    <execution>
                        <id>test-compile</id>
                        <phase>test-compile</phase>
                        <goals>
                            <goal>test-compile</goal>
                        </goals>
                        <configuration>
                            <sourceDirs>
                                <source>src/test/java</source>
                                <source>src/test/kotlin</source>
                            </sourceDirs>
                        </configuration>
                    </execution>
                </executions>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
            </plugin>

        </plugins>
    </build>

</project>



================================================
FILE: embabel-agent-rag/embabel-agent-rag-tika/src/main/kotlin/com/embabel/agent/rag/ingestion/HierarchicalContentReader.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.ingestion

import com.embabel.agent.rag.LeafSection
import com.embabel.agent.tools.file.FileReadTools
import org.apache.tika.exception.ZeroByteFileException
import org.apache.tika.metadata.Metadata
import org.apache.tika.metadata.TikaCoreProperties
import org.apache.tika.parser.AutoDetectParser
import org.apache.tika.parser.ParseContext
import org.apache.tika.sax.BodyContentHandler
import org.slf4j.LoggerFactory
import org.springframework.core.io.DefaultResourceLoader
import org.springframework.core.io.Resource
import java.io.File
import java.io.InputStream
import java.nio.file.Files
import java.time.Duration
import java.time.Instant
import java.util.*

data class DirectoryParsingConfig(
    val includedExtensions: Set<String> = setOf(
        "txt", "md", "rst", "adoc", "asciidoc",
        "html", "htm", "xml", "json", "yaml", "yml",
        "java", "kt", "scala", "py", "js", "ts",
        "go", "rs", "c", "cpp", "h", "hpp",
        "pdf", "docx", "doc", "odt", "rtf"
    ),
    val excludedDirectories: Set<String> = setOf(
        ".git", ".svn", ".hg",
        "node_modules", ".npm",
        "target", "build", "dist", "out",
        ".gradle", ".m2",
        "__pycache__", ".pytest_cache",
        "venv", "env", ".venv",
        ".idea", ".vscode", ".vs",
        "bin", "obj",
        ".next", ".nuxt"
    ),
    val maxFileSize: Long = 10 * 1024 * 1024, // 10MB default
    val followSymlinks: Boolean = false,
    val maxDepth: Int = Int.MAX_VALUE,
)

/**
 * Result of directory parsing operation
 */
data class DirectoryParsingResult(
    val totalFilesFound: Int,
    val filesProcessed: Int,
    val filesSkipped: Int,
    val filesErrored: Int,
    val contentRoots: List<MaterializedDocument>,
    val processingTime: Duration,
    val errors: List<String>,
) {
    val success: Boolean
        get() = filesErrored == 0 && errors.isEmpty()

    val totalSectionsExtracted: Int
        get() = contentRoots.sumOf { it.leaves().size }
}

/**
 * Reads various content types using Apache Tika and extracts LeafSection objects containing the actual content.
 *
 * This reader can handle markdown, HTML, PDF, Word documents, and many other formats
 * supported by Apache Tika and returns a list of LeafSection objects that can be processed for RAG.
 */
class HierarchicalContentReader {

    private val logger = LoggerFactory.getLogger(javaClass)
    private val parser = AutoDetectParser()

    @JvmOverloads
    fun parseResource(
        resourcePath: String,
        metadata: Metadata = Metadata(),
    ): MaterializedDocument {
        val resource: Resource = DefaultResourceLoader().getResource(resourcePath)
        return resource.inputStream.use { inputStream ->
            parseContent(inputStream, resource.uri.toString(), metadata)
        }
    }

    /**
     * Parse content from a file and return materialized content root
     */
    @JvmOverloads
    fun parseFile(
        file: File,
        url: String? = null,
    ): MaterializedDocument {
        logger.debug("Parsing file: {}", file.absolutePath)

        val metadata = org.apache.tika.metadata.Metadata()
        metadata.set(TikaCoreProperties.RESOURCE_NAME_KEY, file.name)

        return file.inputStream().use { inputStream ->
            parseContent(inputStream, metadata = metadata, uri = url ?: file.toURI().toString())
        }
    }

    /**
     * Parse content from an InputStream with optional metadata
     */
    @JvmOverloads
    fun parseContent(
        inputStream: InputStream,
        uri: String,
        metadata: Metadata = Metadata(),
    ): MaterializedDocument {
        val handler = BodyContentHandler(-1) // No limit on content size
        val parseContext = ParseContext()

        try {
            parser.parse(inputStream, handler, metadata, parseContext)
            val content = handler.toString()
            val mimeType = metadata.get(TikaCoreProperties.CONTENT_TYPE_HINT) ?: "text/plain"

            logger.debug("Parsed content of type: {}, length: {}", mimeType, content.length)

            // Detect markdown by content patterns if MIME type detection fails
            val hasMarkdownHeaders = content.lines().any { line ->
                line.trim().matches(Regex("^#{1,6}\\s+.+"))
            }

            return when {
                mimeType.contains("markdown") || metadata.get(TikaCoreProperties.RESOURCE_NAME_KEY)
                    ?.endsWith(".md") == true || hasMarkdownHeaders -> {
                    parseMarkdown(content, metadata, uri)
                }

                mimeType.contains("html") -> {
                    parseHtml(content, metadata, uri)
                }

                else -> {
                    parsePlainText(content, metadata, uri)
                }
            }

        } catch (e: ZeroByteFileException) {
            // Handle empty files gracefully
            logger.debug("Empty content detected, returning empty content root")
            return createEmptyContentRoot(metadata, uri)
        } catch (e: Exception) {
            logger.error("Error parsing content", e)
            return createErrorContentRoot(e.message ?: "Unknown parsing error", metadata, uri)
        }
    }

    /**
     * Parse markdown content and build hierarchical structure
     */
    private fun parseMarkdown(
        content: String,
        metadata: Metadata,
        uri: String,
    ): MaterializedDocument {
        val lines = content.lines()
        val leafSections = mutableListOf<LeafSection>()
        val currentSection = StringBuilder()
        var currentTitle = ""
        var sectionId = ""
        val rootId = UUID.randomUUID().toString()
        var parentId: String? = rootId
        val sectionStack = mutableMapOf<Int, String>() // level -> sectionId

        for (line in lines) {
            when {
                line.startsWith("#") -> {
                    // Save previous section if it exists
                    if (currentTitle.isNotBlank()) {
                        leafSections.add(
                            createLeafSection(
                                sectionId,
                                currentTitle,
                                currentSection.toString().trim(),
                                parentId,
                                uri,
                                metadata
                            )
                        )
                    }

                    // Parse new heading
                    val level = line.takeWhile { it == '#' }.length
                    currentTitle = line.substring(level).trim()
                    sectionId = UUID.randomUUID().toString()
                    currentSection.clear()

                    // Determine parent based on hierarchy
                    parentId = when {
                        level == 1 -> rootId
                        level > 1 -> {
                            // Find the most recent parent at level - 1
                            (level - 1 downTo 1).firstNotNullOfOrNull { sectionStack[it] } ?: rootId
                        }

                        else -> rootId
                    }

                    sectionStack[level] = sectionId
                    // Clear deeper levels
                    sectionStack.keys.filter { it > level }.forEach { sectionStack.remove(it) }
                }

                else -> {
                    if (line.isNotBlank() || currentSection.isNotEmpty()) {
                        currentSection.appendLine(line)
                    }
                }
            }
        }

        // Add final section if exists
        if (currentTitle.isNotBlank()) {
            leafSections.add(
                createLeafSection(
                    sectionId,
                    currentTitle,
                    currentSection.toString().trim(),
                    parentId,
                    uri,
                    metadata
                )
            )
        }

        // If no sections were found, create a single section with the whole content
        if (leafSections.isEmpty() && content.isNotBlank()) {
            val title = extractTitle(lines, metadata) ?: "Document"
            leafSections.add(
                createLeafSection(
                    UUID.randomUUID().toString(),
                    title,
                    content.trim(),
                    rootId,
                    uri,
                    metadata
                )
            )
        }

        logger.debug("Created {} leaf sections from markdown content", leafSections.size)

        // Build the hierarchical structure
        val documentTitle =
            extractTitle(lines, metadata) ?: metadata.get(TikaCoreProperties.RESOURCE_NAME_KEY) ?: "Document"

        return MaterializedDocument(
            id = rootId,
            uri = uri,
            title = documentTitle,
            children = leafSections,
            metadata = extractMetadataMap(metadata)
        )
    }

    /**
     * Parse HTML content - simplified approach focusing on headings
     */
    private fun parseHtml(
        content: String,
        metadata: Metadata,
        uri: String,
    ): MaterializedDocument {
        // For HTML, we'll use a simplified approach similar to markdown
        // In a full implementation, you might want to use JSoup or similar
        val cleanContent = content
            .replace(Regex("<[^>]+>"), " ") // Remove HTML tags
            .replace(Regex("\\s+"), " ") // Normalize whitespace
            .trim()

        return parsePlainText(cleanContent, metadata, uri)
    }

    /**
     * Parse plain text content into a content root with single section
     */
    private fun parsePlainText(
        content: String,
        metadata: Metadata,
        uri: String,
    ): MaterializedDocument {
        if (content.isBlank()) {
            return createEmptyContentRoot(metadata, uri)
        }

        val rootId = UUID.randomUUID().toString()
        val title = extractTitle(content.lines(), metadata) ?: "Document"
        val leafSection = createLeafSection(
            id = UUID.randomUUID().toString(),
            title = title,
            content = content.trim(),
            parentId = rootId,
            url = uri,
            metadata = metadata
        )

        return MaterializedDocument(
            id = rootId,
            uri = uri,
            title = title,
            children = listOf(leafSection),
            metadata = extractMetadataMap(metadata)
        )
    }

    private fun createLeafSection(
        id: String,
        title: String,
        content: String,
        parentId: String?,
        url: String?,
        metadata: Metadata,
    ): LeafSection {
        return LeafSection(
            id = id,
            uri = url,
            title = title,
            text = content,
            parentId = parentId,
            metadata = extractMetadataMap(metadata)
        )
    }

    private fun extractTitle(
        lines: List<String>,
        metadata: Metadata,
    ): String? {
        // Try to get title from metadata first
        metadata.get(TikaCoreProperties.TITLE)?.let { return it }

        // Look for first heading in markdown
        for (line in lines) {
            if (line.startsWith("#")) {
                return line.substring(line.takeWhile { it == '#' }.length).trim()
            }
            if (line.isNotBlank()) {
                // Use first non-blank line as title if no heading found
                return line.take(50).trim()
            }
        }

        return null
    }

    private fun extractMetadataMap(metadata: Metadata): Map<String, Any?> {
        val map = mutableMapOf<String, Any?>()

        for (name in metadata.names()) {
            val value = metadata.get(name)
            if (value != null) {
                map[name] = value
            }
        }

        return map
    }

    private fun createEmptyContentRoot(
        metadata: Metadata,
        uri: String,
    ): MaterializedDocument {
        return MaterializedDocument(
            id = UUID.randomUUID().toString(),
            uri = uri,
            title = metadata.get(TikaCoreProperties.RESOURCE_NAME_KEY) ?: "Empty Document",
            children = emptyList(),
            metadata = extractMetadataMap(metadata)
        )
    }

    private fun createErrorContentRoot(
        errorMessage: String,
        metadata: Metadata,
        uri: String,
    ): MaterializedDocument {
        val rootId = UUID.randomUUID().toString()
        val errorSection = LeafSection(
            id = UUID.randomUUID().toString(),
            uri = uri,
            title = "Parse Error",
            text = "Error parsing content: $errorMessage",
            parentId = rootId,
            metadata = extractMetadataMap(metadata) + mapOf("error" to errorMessage)
        )

        return MaterializedDocument(
            id = rootId,
            uri = uri,
            title = "Parse Error",
            children = listOf(errorSection),
            metadata = extractMetadataMap(metadata) + mapOf("error" to errorMessage)
        )
    }

    /**
     * Parse all files from a directory structure using FileTools for safe access.
     *
     * @param fileTools The FileTools instance to use for file system operations
     * @param directoryPath The relative path to the directory to parse (relative to FileTools root)
     * @param config Configuration for the parsing process
     * @return Result of the parsing operation
     */
    @JvmOverloads
    fun parseFromDirectory(
        fileTools: FileReadTools,
        directoryPath: String = "",
        config: DirectoryParsingConfig = DirectoryParsingConfig(),
    ): DirectoryParsingResult {
        val startTime = Instant.now()

        logger.info("Starting directory parsing from '{}' with config: {}", directoryPath, config)

        return try {
            val files = discoverFiles(fileTools, directoryPath, config)
            logger.info("Discovered {} files for parsing", files.size)

            processFiles(fileTools, files, config, startTime)

        } catch (e: Exception) {
            logger.error("Failed to parse directory '{}': {}", directoryPath, e.message, e)
            DirectoryParsingResult(
                totalFilesFound = 0,
                filesProcessed = 0,
                filesSkipped = 0,
                filesErrored = 1,
                contentRoots = emptyList(),
                processingTime = Duration.between(startTime, Instant.now()),
                errors = listOf("Directory parsing failed: ${e.message}")
            )
        }
    }

    /**
     * Parse a single file using the configured reader.
     *
     * @param fileTools The FileTools instance to use for file access
     * @param filePath The relative path to the file to parse
     * @return Result of the parsing operation, or null if the file couldn't be processed
     */
    fun parseFile(
        fileTools: FileReadTools,
        filePath: String,
    ): MaterializedDocument? {
        return try {
            logger.debug("Parsing single file: {}", filePath)

            // Validate file exists and is readable through FileTools
            val content = fileTools.safeReadFile(filePath)
            if (content == null) {
                logger.warn("Could not read file: {}", filePath)
                return null
            }

            // Use file URI for local files - convert to proper URI format
            val fileUri = fileTools.resolvePath(filePath).toUri().toString()
            val result = parseResource(fileUri)

            logger.info(
                "Successfully parsed file '{}' - {} sections extracted",
                filePath, result.leaves().size
            )

            result

        } catch (e: Exception) {
            logger.error("Failed to parse file '{}': {}", filePath, e.message, e)
            null
        }
    }

    /**
     * Discover all files in the directory structure that match the parsing criteria.
     */
    private fun discoverFiles(
        fileTools: FileReadTools,
        directoryPath: String,
        config: DirectoryParsingConfig,
    ): List<String> {
        val files = mutableListOf<String>()
        val startPath = if (directoryPath.isEmpty()) "" else directoryPath

        logger.debug("Discovering files in directory: {}", startPath)

        try {
            discoverFilesRecursive(fileTools, startPath, files, config, 0)
        } catch (e: Exception) {
            logger.error("Error discovering files in '{}': {}", startPath, e.message, e)
        }

        logger.debug("Discovered {} files in directory '{}'", files.size, startPath)
        return files
    }

    /**
     * Recursively discover files in a directory structure.
     */
    private fun discoverFilesRecursive(
        fileTools: FileReadTools,
        currentPath: String,
        files: MutableList<String>,
        config: DirectoryParsingConfig,
        depth: Int,
    ) {
        if (depth > config.maxDepth) {
            logger.debug("Reached max depth {} at path '{}'", config.maxDepth, currentPath)
            return
        }

        try {
            val entries = fileTools.listFiles(currentPath)

            for (entry in entries) {
                val isDirectory = entry.startsWith("d:")
                val name = entry.substring(2) // Remove "d:" or "f:" prefix
                val fullPath = if (currentPath.isEmpty()) name else "$currentPath/$name"

                if (isDirectory) {
                    // Check if directory should be excluded
                    if (name in config.excludedDirectories) {
                        logger.debug("Skipping excluded directory: {}", fullPath)
                        continue
                    }

                    // Recurse into subdirectory
                    discoverFilesRecursive(fileTools, fullPath, files, config, depth + 1)
                } else {
                    // Check file extension
                    val extension = name.substringAfterLast('.', "").lowercase()
                    if (extension in config.includedExtensions) {
                        // Check file size
                        val resolvedPath = fileTools.resolvePath(fullPath)
                        if (Files.exists(resolvedPath)) {
                            val size = Files.size(resolvedPath)
                            if (size <= config.maxFileSize) {
                                files.add(fullPath)
                                logger.trace("Added file for parsing: {} (size: {} bytes)", fullPath, size)
                            } else {
                                logger.debug(
                                    "Skipping large file: {} (size: {} bytes, limit: {} bytes)",
                                    fullPath, size, config.maxFileSize
                                )
                            }
                        }
                    } else {
                        logger.trace("Skipping file with excluded extension: {} (extension: {})", fullPath, extension)
                    }
                }
            }
        } catch (e: Exception) {
            logger.warn("Could not list files in directory '{}': {}", currentPath, e.message)
        }
    }

    /**
     * Process the discovered files for parsing.
     */
    private fun processFiles(
        fileTools: FileReadTools,
        files: List<String>,
        config: DirectoryParsingConfig,
        startTime: Instant,
    ): DirectoryParsingResult {
        var filesProcessed = 0
        var filesSkipped = 0
        var filesErrored = 0
        val contentRoots = mutableListOf<MaterializedDocument>()
        val errors = mutableListOf<String>()

        logger.info("Processing {} files for parsing", files.size)

        for ((index, filePath) in files.withIndex()) {
            if ((index + 1) % 100 == 0) {
                logger.info("Progress: {}/{} files processed", index + 1, files.size)
            }

            try {
                val result = parseFile(fileTools, filePath)
                if (result != null) {
                    contentRoots.add(result)
                    filesProcessed++
                    logger.debug(
                        "Successfully processed file {} ({}/{}): {} sections",
                        filePath, index + 1, files.size, result.leaves().size
                    )
                } else {
                    filesSkipped++
                    logger.debug("Skipped file {} ({}/{})", filePath, index + 1, files.size)
                }
            } catch (e: Exception) {
                filesErrored++
                val error = "Error processing file '$filePath': ${e.message}"
                errors.add(error)
                logger.error(error, e)
            }
        }

        val processingTime = Duration.between(startTime, Instant.now())

        logger.info("Directory parsing completed in {} ms", processingTime.toMillis())
        logger.info("Files processed: {}, skipped: {}, errors: {}", filesProcessed, filesSkipped, filesErrored)
        logger.info("Total sections extracted: {}", contentRoots.sumOf { it.leaves().size })

        return DirectoryParsingResult(
            totalFilesFound = files.size,
            filesProcessed = filesProcessed,
            filesSkipped = filesSkipped,
            filesErrored = filesErrored,
            contentRoots = contentRoots,
            processingTime = processingTime,
            errors = errors
        )
    }
}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-tika/src/test/kotlin/com/embabel/agent/rag/.gitkeep
================================================
[Empty file]


================================================
FILE: embabel-agent-rag/embabel-agent-rag-tika/src/test/kotlin/com/embabel/agent/rag/ingestion/HierarchicalContentReaderTest.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.rag.ingestion

import com.embabel.agent.rag.LeafSection
import com.embabel.agent.tools.file.FileReadTools
import io.mockk.every
import io.mockk.mockk
import org.apache.tika.metadata.Metadata
import org.apache.tika.metadata.TikaCoreProperties
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.io.TempDir
import java.io.ByteArrayInputStream
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.StandardOpenOption

class HierarchicalContentReaderTest {

    private val reader = HierarchicalContentReader()

    @Test
    fun `test parse simple markdown content`() {
        val markdown = """
            # Main Title
            This is the introduction.

            ## Section 1
            Content for section 1.

            ### Subsection 1.1
            Content for subsection 1.1.

            ## Section 2
            Content for section 2.
        """.trimIndent()

        val inputStream = ByteArrayInputStream(markdown.toByteArray())
        val metadata = Metadata().apply {
            set(TikaCoreProperties.RESOURCE_NAME_KEY, "test.md")
            set(TikaCoreProperties.CONTENT_TYPE_HINT, "text/markdown")
        }

        val result = reader.parseContent(inputStream, metadata = metadata, uri = "test://example.md")

        assertEquals(4, result.children.size) // Introduction + Section 1 + Subsection 1.1 + Section 2
        assertEquals("test://example.md", result.uri)
        assertNotNull(result.id)

        // Check that all sections have proper titles and content
        val titles = result.children.map { it.title }
        assertTrue(titles.contains("Main Title"))
        assertTrue(titles.contains("Section 1"))
        assertTrue(titles.contains("Subsection 1.1"))
        assertTrue(titles.contains("Section 2"))

        // Check that all sections have the same URL
        result.children.forEach { section ->
            assertEquals("test://example.md", section.uri)
            assertNotNull(section.id)
        }
    }

    @Test
    fun `test parse markdown with nested structure`() {
        val markdown = """
            # Document Title
            Introduction paragraph.

            ## Chapter 1
            Chapter introduction.

            ### Section 1.1
            Section content here.

            #### Subsection 1.1.1
            Detailed content.

            ### Section 1.2
            More content.

            ## Chapter 2
            Second chapter content.
        """.trimIndent()

        val inputStream = ByteArrayInputStream(markdown.toByteArray())
        val metadata = Metadata().apply {
            set(TikaCoreProperties.RESOURCE_NAME_KEY, "document.md")
        }

        val result = reader.parseContent(inputStream, "x", metadata)

        assertEquals(6, result.children.size) // All leaf sections
        assertNotNull(result.id)

        val titles = result.children.map { it.title }
        assertTrue(titles.contains("Document Title"))
        assertTrue(titles.contains("Chapter 1"))
        assertTrue(titles.contains("Section 1.1"))
        assertTrue(titles.contains("Subsection 1.1.1"))
        assertTrue(titles.contains("Section 1.2"))
        assertTrue(titles.contains("Chapter 2"))

        // Verify all sections have content
        result.children.forEach { section ->
            assertTrue((section as LeafSection).content.isNotBlank())
            assertNotNull(section.id)
        }
    }

    @Test
    fun `test parse plain text content`() {
        val text = """
            This is a simple text document.
            It has multiple lines.
            But no special formatting.
        """.trimIndent()

        val inputStream = ByteArrayInputStream(text.toByteArray())
        val metadata = Metadata().apply {
            set(TikaCoreProperties.CONTENT_TYPE_HINT, "text/plain")
        }

        val result = reader.parseContent(inputStream, "test://plain.txt", metadata)

        assertEquals(1, result.children.size)
        assertEquals("test://plain.txt", result.uri)
        assertNotNull(result.id)

        val section = result.children.first() as LeafSection
        assertEquals("This is a simple text document.", section.title)
        assertEquals("test://plain.txt", section.uri)
        assertEquals(text, section.content)
        assertNotNull(section.id)
    }

    @Test
    fun `test parse file from disk`(@TempDir tempDir: Path) {
        val markdownFile = tempDir.resolve("test.md").toFile()
        val markdown = """
            # Test Document
            This is a test document.

            ## First Section
            Content of the first section.

            ## Second Section
            Content of the second section.
        """.trimIndent()

        markdownFile.writeText(markdown)

        val result = reader.parseFile(markdownFile)

        assertEquals(3, result.children.size)
        assertNotNull(result.id)
        val titles = result.children.map { it.title }
        assertTrue(titles.contains("Test Document"))
        assertTrue(titles.contains("First Section"))
        assertTrue(titles.contains("Second Section"))

        result.children.forEach { section ->
            assertTrue(section.uri!!.contains("test.md"))
            assertNotNull(section.id)
        }
    }

    @Test
    fun `test title extraction from metadata`() {
        val content = "Some content without markdown headers"

        val inputStream = ByteArrayInputStream(content.toByteArray())
        val metadata = Metadata().apply {
            set(TikaCoreProperties.TITLE, "Custom Title from Metadata")
        }

        val result = reader.parseContent(inputStream, "x", metadata)

        assertEquals(1, result.children.size)
        assertEquals("Custom Title from Metadata", (result.children.first() as LeafSection).title)
    }

    @Test
    fun `test title extraction from first line when no headers`() {
        val content = """
            This should become the title
            And this is the rest of the content.
        """.trimIndent()

        val inputStream = ByteArrayInputStream(content.toByteArray())

        val result = reader.parseContent(inputStream, uri = "foo")

        assertEquals(1, result.children.size)
        assertEquals("This should become the title", (result.children.first() as LeafSection).title)
    }

    @Test
    fun `test metadata preservation`() {
        val content = "Simple content"

        val inputStream = ByteArrayInputStream(content.toByteArray())
        val metadata = Metadata().apply {
            set(TikaCoreProperties.TITLE, "Test Title")
            set(TikaCoreProperties.CREATOR, "Test Author")
            set("custom-field", "custom-value")
        }

        val result = reader.parseContent(inputStream, "uri", metadata)

        assertEquals(1, result.children.size)
        val section = result.children.first() as LeafSection
        val resultMetadata = section.metadata
        assertEquals("Test Author", resultMetadata[TikaCoreProperties.CREATOR.name])
        assertEquals("custom-value", resultMetadata["custom-field"])
    }

    @Test
    fun `test error handling for empty content`() {
        // Create an input stream with empty content
        val inputStream = ByteArrayInputStream(ByteArray(0))

        val result = reader.parseContent(inputStream, "uri")

        // Should return empty content root for empty content
        assertTrue(result.children.isEmpty())
        assertNotNull(result.id)
    }

    @Test
    fun `test HTML content parsing`() {
        val html = """
            <html>
            <head><title>HTML Document</title></head>
            <body>
                <h1>Main Heading</h1>
                <p>This is a paragraph with <strong>bold</strong> text.</p>
                <h2>Second Heading</h2>
                <p>More content here.</p>
            </body>
            </html>
        """.trimIndent()

        val inputStream = ByteArrayInputStream(html.toByteArray())
        val metadata = Metadata().apply {
            set(TikaCoreProperties.CONTENT_TYPE_HINT, "text/html")
        }

        val result = reader.parseContent(inputStream, metadata = metadata, uri = "Test")

        assertEquals(1, result.children.size) // HTML content treated as single section
        val section = result.children.first() as LeafSection
        assertNotNull(section.title)
        assertTrue(section.content.isNotBlank())
        // Content should be cleaned HTML
        assertFalse(section.content.contains("<"))
        assertFalse(section.content.contains(">"))
    }

    @Test
    fun `test markdown with code blocks`() {
        val markdown = """
            # Code Examples

            Here's some code:

            ```kotlin
            fun main() {
                println("Hello World")
            }
            ```

            ## Another Section
            More content after code.
        """.trimIndent()

        val inputStream = ByteArrayInputStream(markdown.toByteArray())
        val metadata = Metadata().apply {
            set(TikaCoreProperties.RESOURCE_NAME_KEY, "code.md")
        }

        val result = reader.parseContent(inputStream, "x", metadata)

        assertEquals(2, result.children.size)
        val titles = result.children.map { it.title }
        assertTrue(titles.contains("Code Examples"))
        assertTrue(titles.contains("Another Section"))

        // Find the Code Examples section and verify it contains the code block
        val codeSection = result.children.find { it.title == "Code Examples" } as LeafSection?
        assertNotNull(codeSection)
        assertTrue(codeSection!!.content.contains("```kotlin"))
        assertTrue(codeSection.content.contains("fun main()"))
    }

    @Test
    fun `test empty markdown file`() {
        val markdown = ""

        val inputStream = ByteArrayInputStream(markdown.toByteArray())
        val metadata = Metadata().apply {
            set(TikaCoreProperties.RESOURCE_NAME_KEY, "empty.md")
        }

        val result = reader.parseContent(inputStream, "y", metadata)

        // Empty content should return empty content root
        assertTrue(result.children.isEmpty())
        assertNotNull(result.id)
    }

    @Test
    fun `test markdown with only content no headers`() {
        val markdown = """
            This is just content.
            No headers at all.
            Just plain text.
        """.trimIndent()

        val inputStream = ByteArrayInputStream(markdown.toByteArray())
        val metadata = Metadata().apply {
            set(TikaCoreProperties.RESOURCE_NAME_KEY, "plain.md")
        }

        val result = reader.parseContent(inputStream, "a", metadata)

        assertEquals(1, result.children.size)
        val section = result.children.first() as LeafSection
        assertEquals("This is just content.", section.title)
        assertEquals(markdown, section.content)
        assertNotNull(section.id)
    }

    @Test
    fun `test multiple markdown sections with different levels`() {
        val markdown = """
            # Level 1 Title
            Content under level 1.

            ## Level 2 Title
            Content under level 2.

            ### Level 3 Title
            Content under level 3.

            #### Level 4 Title
            Content under level 4.
        """.trimIndent()

        val inputStream = ByteArrayInputStream(markdown.toByteArray())

        val result = reader.parseContent(inputStream, "uri")

        assertEquals(4, result.children.size)
        val titles = result.children.map { it.title }
        assertEquals(listOf("Level 1 Title", "Level 2 Title", "Level 3 Title", "Level 4 Title"), titles)

        // Verify each section has appropriate content
        result.children.forEach { section ->
            val leafSection = section as LeafSection
            assertTrue(leafSection.content.startsWith("Content under"))
            assertNotNull(leafSection.id)
            assertNotNull(leafSection.parentId) // All sections should have parent references
        }
    }

    @Test
    fun `test section parent relationships are maintained`() {
        val markdown = """
            # Main Section
            Main content.

            ## Sub Section
            Sub content.

            ### Deep Section
            Deep content.
        """.trimIndent()

        val inputStream = ByteArrayInputStream(markdown.toByteArray())

        val result = reader.parseContent(inputStream, "uri")

        assertEquals(3, result.children.size)

        // All sections should have parent IDs set
        result.children.forEach { section ->
            assertNotNull(section.parentId)
        }

        // Verify content is correctly assigned
        val mainSection = result.children.find { it.title == "Main Section" } as LeafSection?
        assertEquals("Main content.", mainSection?.content?.trim())

        val subSection = result.children.find { it.title == "Sub Section" } as LeafSection?
        assertEquals("Sub content.", subSection?.content?.trim())

        val deepSection = result.children.find { it.title == "Deep Section" } as LeafSection?
        assertEquals("Deep content.", deepSection?.content?.trim())
    }

    @Test
    fun `test parseFromDirectory with mixed file types`(@TempDir tempDir: Path) {
        // Create test files
        val mdFile = tempDir.resolve("document.md")
        Files.writeString(
            mdFile, """
            # Test Document
            This is a test document.

            ## Section 1
            Content of section 1.
        """.trimIndent(), StandardOpenOption.CREATE
        )

        val txtFile = tempDir.resolve("readme.txt")
        Files.writeString(txtFile, "This is a simple text file.", StandardOpenOption.CREATE)

        val subdirPath = tempDir.resolve("subdir")
        Files.createDirectory(subdirPath)
        val subFile = subdirPath.resolve("sub.md")
        Files.writeString(
            subFile, """
            # Sub Document
            Content in subdirectory.
        """.trimIndent(), StandardOpenOption.CREATE
        )

        // Mock FileReadTools
        val fileTools = mockk<FileReadTools>()
        every { fileTools.listFiles("") } returns listOf("f:document.md", "f:readme.txt", "d:subdir")
        every { fileTools.listFiles("subdir") } returns listOf("f:sub.md")
        every { fileTools.resolvePath("document.md") } returns mdFile
        every { fileTools.resolvePath("readme.txt") } returns txtFile
        every { fileTools.resolvePath("subdir/sub.md") } returns subFile
        every { fileTools.safeReadFile("document.md") } returns Files.readString(mdFile)
        every { fileTools.safeReadFile("readme.txt") } returns Files.readString(txtFile)
        every { fileTools.safeReadFile("subdir/sub.md") } returns Files.readString(subFile)

        val config = DirectoryParsingConfig(
            includedExtensions = setOf("md", "txt"),
            maxFileSize = 1024 * 1024
        )

        val result = reader.parseFromDirectory(fileTools, "", config)

        assertTrue(result.success)
        assertEquals(3, result.totalFilesFound)
        assertEquals(3, result.filesProcessed)
        assertEquals(0, result.filesSkipped)
        assertEquals(0, result.filesErrored)
        assertEquals(3, result.contentRoots.size)
        assertTrue(result.errors.isEmpty())

        // Verify parsed content
        val documentRoot = result.contentRoots.find { it.title == "Test Document" }
        assertNotNull(documentRoot)
        assertEquals(2, documentRoot!!.leaves().size) // 2 sections in document.md

        val readmeRoot = result.contentRoots.find { it.title == "This is a simple text file." }
        assertNotNull(readmeRoot)
        assertEquals(1, readmeRoot!!.leaves().size) // 1 section in readme.txt

        val subRoot = result.contentRoots.find { it.title == "Sub Document" }
        assertNotNull(subRoot)
        assertEquals(1, subRoot!!.leaves().size) // 1 section in sub.md
    }

    @Test
    fun `test parseFromDirectory with file size limits`(@TempDir tempDir: Path) {
        val smallFile = tempDir.resolve("small.md")
        Files.writeString(smallFile, "# Small\nSmall content", StandardOpenOption.CREATE)

        val largeFile = tempDir.resolve("large.md")
        Files.writeString(largeFile, "# Large\n" + "X".repeat(2000), StandardOpenOption.CREATE)

        val fileTools = mockk<FileReadTools>()
        every { fileTools.listFiles("") } returns listOf("f:small.md", "f:large.md")
        every { fileTools.resolvePath("small.md") } returns smallFile
        every { fileTools.resolvePath("large.md") } returns largeFile
        every { fileTools.safeReadFile("small.md") } returns Files.readString(smallFile)

        val config = DirectoryParsingConfig(
            includedExtensions = setOf("md"),
            maxFileSize = 100 // Very small limit to exclude large file
        )

        val result = reader.parseFromDirectory(fileTools, "", config)

        assertTrue(result.success)
        assertEquals(1, result.totalFilesFound) // Only small file should be discovered
        assertEquals(1, result.filesProcessed)
        assertEquals(0, result.filesSkipped)
        assertEquals(0, result.filesErrored)
        assertEquals(1, result.contentRoots.size)
    }

    @Test
    fun `test parseFromDirectory with excluded directories`(@TempDir tempDir: Path) {
        val normalFile = tempDir.resolve("normal.md")
        Files.writeString(normalFile, "# Normal\nNormal content", StandardOpenOption.CREATE)

        val gitDir = tempDir.resolve(".git")
        Files.createDirectory(gitDir)
        val gitFile = gitDir.resolve("config")
        Files.writeString(gitFile, "git config content", StandardOpenOption.CREATE)

        val fileTools = mockk<FileReadTools>()
        every { fileTools.listFiles("") } returns listOf("f:normal.md", "d:.git")
        every { fileTools.resolvePath("normal.md") } returns normalFile
        every { fileTools.safeReadFile("normal.md") } returns Files.readString(normalFile)

        val config = DirectoryParsingConfig(
            includedExtensions = setOf("md"),
            excludedDirectories = setOf(".git")
        )

        val result = reader.parseFromDirectory(fileTools, "", config)

        assertTrue(result.success)
        assertEquals(1, result.totalFilesFound) // Only normal.md should be found
        assertEquals(1, result.filesProcessed)
        assertEquals(1, result.contentRoots.size)

        val contentRoot = result.contentRoots.first()
        assertEquals("Normal", contentRoot.title)
    }

    @Test
    fun `test parseFromDirectory handles file read errors gracefully`(@TempDir tempDir: Path) {
        // Create a real file first so it passes the file size validation
        val errorFile = tempDir.resolve("error.md")
        Files.writeString(errorFile, "# Error\nSome content", StandardOpenOption.CREATE)

        val fileTools = mockk<FileReadTools>()
        every { fileTools.listFiles("") } returns listOf("f:error.md")
        every { fileTools.resolvePath("error.md") } returns errorFile
        every { fileTools.safeReadFile("error.md") } returns null // Simulate read error

        val result = reader.parseFromDirectory(fileTools, "")

        assertTrue(result.success) // Should still be successful overall
        assertEquals(1, result.totalFilesFound)
        assertEquals(0, result.filesProcessed)
        assertEquals(1, result.filesSkipped) // File should be skipped due to read error
        assertEquals(0, result.filesErrored)
        assertEquals(0, result.contentRoots.size)
    }

    @Test
    fun `test parseFromDirectory with custom extensions`(@TempDir tempDir: Path) {
        val kotlinFile = tempDir.resolve("Example.kt")
        Files.writeString(
            kotlinFile, """
            /**
             * Example Kotlin class
             */
            class Example {
                fun doSomething() = "Hello"
            }
        """.trimIndent(), StandardOpenOption.CREATE
        )

        val javaFile = tempDir.resolve("Main.java")
        Files.writeString(
            javaFile, """
            public class Main {
                public static void main(String[] args) {
                    System.out.println("Hello World");
                }
            }
        """.trimIndent(), StandardOpenOption.CREATE
        )

        val ignoredFile = tempDir.resolve("data.csv")
        Files.writeString(ignoredFile, "name,value\ntest,123", StandardOpenOption.CREATE)

        val fileTools = mockk<FileReadTools>()
        every { fileTools.listFiles("") } returns listOf("f:Example.kt", "f:Main.java", "f:data.csv")
        every { fileTools.resolvePath("Example.kt") } returns kotlinFile
        every { fileTools.resolvePath("Main.java") } returns javaFile
        every { fileTools.resolvePath("data.csv") } returns Path.of("data.csv")
        every { fileTools.safeReadFile("Example.kt") } returns Files.readString(kotlinFile)
        every { fileTools.safeReadFile("Main.java") } returns Files.readString(javaFile)

        val config = DirectoryParsingConfig(
            includedExtensions = setOf("kt", "java"), // Only include code files
            maxFileSize = 1024 * 1024
        )

        val result = reader.parseFromDirectory(fileTools, "", config)

        assertTrue(result.success)
        assertEquals(2, result.totalFilesFound) // Only kt and java files
        assertEquals(2, result.filesProcessed)
        assertEquals(2, result.contentRoots.size)

        val titles = result.contentRoots.map { it.title }
        // Debug: Print actual titles to understand the issue
        println("Actual titles: $titles")

        // Since both are plain text files without markdown headers,
        // they will use the first line as title (truncated to 50 chars)
        assertTrue(titles.any { it.contains("/**") || it.contains("Example") }) // Kotlin file
        assertTrue(titles.any { it.contains("public class") || it.contains("Main") }) // Java file
    }

    @Test
    fun `test parseFromDirectory with max depth limit`(@TempDir tempDir: Path) {
        // Create nested directory structure
        val level1 = tempDir.resolve("level1")
        Files.createDirectory(level1)
        val level2 = level1.resolve("level2")
        Files.createDirectory(level2)

        val rootFile = tempDir.resolve("root.md")
        Files.writeString(rootFile, "# Root\nRoot content", StandardOpenOption.CREATE)

        val level1File = level1.resolve("level1.md")
        Files.writeString(level1File, "# Level1\nLevel1 content", StandardOpenOption.CREATE)

        val level2File = level2.resolve("level2.md")
        Files.writeString(level2File, "# Level2\nLevel2 content", StandardOpenOption.CREATE)

        val fileTools = mockk<FileReadTools>()
        every { fileTools.listFiles("") } returns listOf("f:root.md", "d:level1")
        every { fileTools.listFiles("level1") } returns listOf("f:level1.md", "d:level2")
        every { fileTools.resolvePath("root.md") } returns rootFile
        every { fileTools.resolvePath("level1/level1.md") } returns level1File
        every { fileTools.safeReadFile("root.md") } returns Files.readString(rootFile)
        every { fileTools.safeReadFile("level1/level1.md") } returns Files.readString(level1File)

        val config = DirectoryParsingConfig(
            includedExtensions = setOf("md"),
            maxDepth = 1 // Should stop at level1, not go to level2
        )

        val result = reader.parseFromDirectory(fileTools, "", config)

        assertTrue(result.success)
        assertEquals(2, result.totalFilesFound) // Only root.md and level1.md
        assertEquals(2, result.filesProcessed)
        assertEquals(2, result.contentRoots.size)

        val titles = result.contentRoots.map { it.title }
        assertTrue(titles.contains("Root"))
        assertTrue(titles.contains("Level1"))
        assertFalse(titles.contains("Level2")) // Should not be included due to depth limit
    }
}



================================================
FILE: embabel-agent-rag/embabel-agent-rag-tika/src/test/resources/application-test.properties
================================================

embabel.models.llms.cypher-query-generator=test-llm



================================================
FILE: embabel-agent-shell/README.md
================================================
# Embabel Agent Shell Module

Interactive Spring Shell experience for the Embabel Agent platform.

## Overview
This module provides a terminal-based interface for interacting with the Embabel Agent platform, built on Spring Shell framework. It offers interactive commands for agent management, chat sessions, and system operations.

## Key Components

### Shell Commands (`ShellCommands.kt`)
- **Agent Management**: List and interact with available agents
- **Chat Interface**: Start interactive chat sessions with agents
- **System Operations**: Platform status and configuration commands

### Terminal Services (`TerminalServices.kt`)
- **User Input Handling**: Process user interactions and confirmations
- **Process Management**: Handle waiting processes and user responses
- **Output Formatting**: Format and display agent responses

### Chat Session Implementation
- **LastMessageIntentAgentPlatformChatSession**: Shell-specific chat session implementation

### Personality Providers
- **Multi-personality Support**: StarWars, Severance, Hitchhiker, Colossus personalities
- **Prompt Customization**: Personality-specific prompts and formatting

## Configuration
Shell behavior is configured through:
- **ShellConfiguration**: Primary Spring configuration for shell module beans
- **ShellProperties**: Configuration properties for shell behavior settings
  - Line length settings
  - Chat confirmation preferences
  - Conversation binding options

## Usage
Interactive shell commands are available when running the application in shell mode. None of these classes are intended for use outside of the shell context.


================================================
FILE: embabel-agent-shell/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-parent</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-shell</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent Shell</name>
    <description>Embabel Agent Command Line</description>

    <dependencies>
        <!-- Main Dependencies -->
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-api</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.shell</groupId>
            <artifactId>spring-shell-starter</artifactId>
        </dependency>

        <!-- Test Dependencies -->
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-test-internal</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.jetbrains.kotlin</groupId>
                <artifactId>kotlin-maven-plugin</artifactId>
                <executions>
                    <execution>
                        <id>kapt</id>
                        <goals>
                            <goal>kapt</goal>
                        </goals>
                        <configuration>
                            <annotationProcessorPaths>
                                <path>
                                    <groupId>org.springframework.boot</groupId>
                                    <artifactId>spring-boot-configuration-processor</artifactId>
                                    <version>${spring-boot.version}</version>
                                </path>
                            </annotationProcessorPaths>
                        </configuration>
                    </execution>
                </executions>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
            </plugin>

        </plugins>
    </build>

</project>



================================================
FILE: embabel-agent-shell/src/main/kotlin/com/embabel/agent/shell/DefaultPromptProvider.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.shell

import org.jline.utils.AttributedString
import org.jline.utils.AttributedStyle
import org.springframework.shell.jline.PromptProvider

/**
 * Vanilla prompt provider
 */
internal class DefaultPromptProvider : PromptProvider {
    override fun getPrompt() = AttributedString(
        "embabel> ",
        AttributedStyle.DEFAULT.foreground(AttributedStyle.YELLOW)
    )
}



================================================
FILE: embabel-agent-shell/src/main/kotlin/com/embabel/agent/shell/formatProcessOutput.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.shell

import com.embabel.agent.api.common.autonomy.AgentProcessExecution
import com.embabel.agent.domain.library.HasContent
import com.embabel.agent.domain.library.InternetResources
import com.embabel.agent.event.logging.personality.ColorPalette
import com.embabel.common.util.color
import com.fasterxml.jackson.databind.ObjectMapper
import org.apache.commons.text.WordUtils

/**
 * Format the output of a process for display to the console.
 * Displays well-known types appropriately; otherwise pretty prints JSON.
 * Displays usage and cost information.
 */
fun formatProcessOutput(
    result: AgentProcessExecution,
    colorPalette: ColorPalette,
    objectMapper: ObjectMapper,
    lineLength: Int,
): String {
    var output = ""
    if (result.output is HasContent) {
        val hasContentOutput = result.output as HasContent
        // TODO naive Markdown test
        output += if (hasContentOutput.content.contains("#")) {
            "\n" + WordUtils.wrap(
                markdownToConsole(hasContentOutput.content), lineLength
            ).color(colorPalette.color2)
        } else {
            WordUtils.wrap(hasContentOutput.content, lineLength).color(
                colorPalette.color2,
            )
        }

        if (result.output is InternetResources) {
            val internetResourcesOutput = result.output as InternetResources
            output += "\n\n" + internetResourcesOutput.links.joinToString("\n") {
                "- ${it.url}: ${it.summary.color(colorPalette.color2)}"
            }
        }
    } else {
        output = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(result.output)
    }
    return """|
              |${result.agentProcess.infoString(verbose = true)}
              |
              |You asked: ${result.basis.toString().color(colorPalette.highlight)}
              |
              |${output.color(colorPalette.color2)}
              |
              |${result.agentProcess.costInfoString(verbose = true)}
              |${result.agentProcess.toolsStats.infoString(verbose = true)}
              |""".trimMargin()
}



================================================
FILE: embabel-agent-shell/src/main/kotlin/com/embabel/agent/shell/markdown.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.shell

// Thanks to Guillaume Laforge: https://glaforge.dev/posts/2025/02/27/pretty-print-markdown-on-the-console/
fun markdownToConsole(md: String): String {
    return md
        // Bold
        .replace(Regex("\\*\\*(.*?)\\*\\*"), "\u001B[1m$1\u001B[0m")
        // Italic
        .replace(Regex("\\*(.*?)\\*"), "\u001B[3m$1\u001B[0m")
        // Underline
        .replace(Regex("__(.*?)__"), "\u001B[4m$1\u001B[0m")
        // Strikethrough
        .replace(Regex("~~(.*?)~~"), "\u001B[9m$1\u001B[0m")
        // Blockquote
        .replace(
            Regex("(> ?.*)"),
            "\u001B[3m\u001B[34m\u001B[1m$1\u001B[22m\u001B[0m"
        )
        // Lists (bold magenta number and bullet)
        .replace(
            Regex("([\\d]+\\.|-|\\*) (.*)"),
            "\u001B[35m\u001B[1m$1\u001B[22m\u001B[0m $2"
        )
        // Block code (black on gray)
        .replace(
            Regex("(?s)```(\\w+)?\\n(.*?)\\n```"),
            "\u001B[3m\u001B[1m$1\u001B[22m\u001B[0m\n\u001B[57;107m$2\u001B[0m\n"
        )
        // Inline code (black on gray)
        .replace(Regex("`(.*?)`"), "\u001B[57;107m$1\u001B[0m")
        // Headers (cyan bold)
        .replace(
            Regex("(#{1,6}) (.*?)\\n"),
            "\u001B[36m\u001B[1m$1 $2\u001B[22m\u001B[0m\n"
        )
        // Headers with a single line of text followed by 2 or more equal signs
        .replace(
            Regex("(.*?\\n={2,}\\n)"),
            "\u001B[36m\u001B[1m$1\u001B[22m\u001B[0m\n"
        )
        // Headers with a single line of text followed by 2 or more dashes
        .replace(
            Regex("(.*?\\n-{2,}\\n)"),
            "\u001B[36m\u001B[1m$1\u001B[22m\u001B[0m\n"
        )
        // Images (blue underlined)
        .replace(
            Regex("!\\[(.*?)]\\((.*?)\\)"),
            "\u001B[34m$1\u001B[0m (\u001B[34m\u001B[4m$2\u001B[0m)"
        )
        // Links (blue underlined)
        .replace(
            Regex("!?\\[(.*?)]\\((.*?)\\)"),
            "\u001B[34m$1\u001B[0m (\u001B[34m\u001B[4m$2\u001B[0m)"
        )
}



================================================
FILE: embabel-agent-shell/src/main/kotlin/com/embabel/agent/shell/MessageGeneratorPromptProvider.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.shell

import com.embabel.agent.event.logging.personality.character
import com.embabel.common.util.MessageGenerator
import com.embabel.common.util.color
import org.jline.utils.AttributedString
import org.springframework.shell.jline.PromptProvider

/**
 * Draw prompts from random messages from the given file
 */
open class MessageGeneratorPromptProvider(
    private val prompt: String,
    private val color: Int,
    private val messageGenerator: MessageGenerator,
) : PromptProvider {

    override fun getPrompt(): AttributedString {
        val msg = messageGenerator.generate()
        val (character, text) = if (":" in msg) {
            msg.split(":", limit = 2).map { it.trim() }
        } else {
            listOf("", msg.trim())
        }
        return AttributedString(
            character(character, text, color).color(color) + "\n$prompt> ".color(color),
        )
    }

}



================================================
FILE: embabel-agent-shell/src/main/kotlin/com/embabel/agent/shell/ShellCommands.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.shell

import com.embabel.agent.api.common.ToolsStats
import com.embabel.agent.api.common.autonomy.*
import com.embabel.agent.core.*
import com.embabel.agent.domain.io.UserInput
import com.embabel.agent.event.logging.LoggingPersonality
import com.embabel.agent.event.logging.personality.ColorPalette
import com.embabel.agent.shell.config.ShellProperties
import com.embabel.chat.Chatbot
import com.embabel.chat.agent.AgentProcessChatbot
import com.embabel.chat.agent.DefaultChatAgentBuilder
import com.embabel.chat.agent.MARVIN
import com.embabel.common.ai.model.LlmOptions
import com.embabel.common.ai.model.ModelProvider
import com.embabel.common.util.bold
import com.embabel.common.util.color
import com.fasterxml.jackson.databind.ObjectMapper
import org.slf4j.Logger
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.SpringApplication
import org.springframework.context.ConfigurableApplicationContext
import org.springframework.core.env.ConfigurableEnvironment
import org.springframework.shell.standard.ShellComponent
import org.springframework.shell.standard.ShellMethod
import org.springframework.shell.standard.ShellOption
import java.util.concurrent.CompletableFuture
import kotlin.system.exitProcess


/**
 * Main shell entry point
 */
@ShellComponent
class ShellCommands(
    private val autonomy: Autonomy,
    private val modelProvider: ModelProvider,
    private val terminalServices: TerminalServices,
    private val environment: ConfigurableEnvironment,
    private val objectMapper: ObjectMapper,
    private val colorPalette: ColorPalette,
    loggingPersonality: LoggingPersonality,
    private val toolsStats: ToolsStats,
    private val context: ConfigurableApplicationContext,
    private val shellProperties: ShellProperties = ShellProperties(),
    @param:Autowired(required = false)
    private val chatbot: Chatbot? = null,

    ) {

    private val logger: Logger = loggingPersonality.logger

    private val agentPlatform = autonomy.agentPlatform

    private val agentProcesses = mutableListOf<AgentProcess>()

    private var blackboard: Blackboard? = null

    /**
     * Whether to look for any goal
     */
    private var openMode: Boolean = false

    private var defaultProcessOptions: ProcessOptions = ProcessOptions(
        verbosity = Verbosity(
            debug = false,
            showPrompts = false,
            showLlmResponses = false,
            showPlanning = true,
        )
    )

    @ShellMethod(value = "Clear blackboard")
    fun clear(): String {
        blackboard = null
        return "Blackboard cleared"
    }

    @ShellMethod(value = "Show recent agent process runs. This is what actually happened, not just what was planned.")
    fun runs(): String {
        val plans = agentProcesses.map {
            "[${it.id}] Goal: ${it.agent.goals.map { g -> g.name }}; usage - ${it.costInfoString(verbose = false)}\n\t\t" +
                    it.history.joinToString("\n\t\t") { it.infoString() }
        }
        return "Recent runs:\n\t${plans.joinToString("\n\t")}"
    }

    @ShellMethod(value = "List all active Spring profiles")
    fun profiles(): String {
        val profiles = environment.activeProfiles
        return "Active profiles: ${profiles.joinToString()}"
    }

    private fun createDefaultChatbot(): Chatbot {
        val persona = MARVIN
        logger.info("Creating default chatbot with persona {}", persona.name)
        val chatAgent = DefaultChatAgentBuilder(
            autonomy = autonomy,
            llm = LlmOptions.withAutoLlm(),
            persona = persona,
        ).build()
        return AgentProcessChatbot(
            agentPlatform = agentPlatform,
            agentSource = {
                chatAgent
            })
    }

    @ShellMethod("Chat")
    fun chat(): String {

        fun runChat(): String {
            val chatbot = chatbot ?: createDefaultChatbot()
            val chatSession = chatbot.createSession(
                user = null,
                outputChannel = terminalServices.outputChannel(agentPlatform)
            )
            return terminalServices.chat(chatSession = chatSession, welcome = null, colorPalette = colorPalette)
        }

        return if (shellProperties.redirectLogToFile) {
            val logRestorer =
                terminalServices.redirectLoggingToFile(filename = "chat-session", dir = System.getProperty("user.dir"))
            try {
                runChat()
            } finally {
                // Restore regular logging when chat exits
                logRestorer()
            }
        } else {
            runChat()
        }
    }

    @ShellMethod("List agents")
    fun agents(): String {
        val detail = "${"Agents:".bold()}\n${
            agentPlatform.agents()
                .joinToString(separator = "\n${"-".repeat(shellProperties.lineLength)}\n") {
                    it.infoString(verbose = true, indent = 1)
                }
        }"
        return detail + "\n\nTL;DR\n${agentPlatform.agents().joinToString("\n") { "${it.name}: ${it.description}" }}"
    }

    @ShellMethod("List actions")
    fun actions(): String {
        val detail = "${"Actions:".bold()}\n${
            agentPlatform.actions
                .joinToString(separator = "\n") { it.infoString(verbose = true, indent = 1) }
        }"
        return detail + "\n\nTL;DR\n${agentPlatform.actions.joinToString("\n") { "${it.name}: ${it.description}" }}"
    }

    @ShellMethod("List conditions")
    fun conditions(): String {
        return "${"Conditions:".bold()}\n${
            agentPlatform.conditions
                .joinToString(separator = "\n") { it.infoString(verbose = true, indent = 1) }
        }"
    }

    @ShellMethod("List goals")
    fun goals(): String {
        return "${"Goals:".bold()}\n${
            agentPlatform.goals
                .joinToString(separator = "\n") { it.infoString(verbose = true, indent = 1) }
        }"
    }

    @ShellMethod("Try to choose a goal for a given intent. Show all goal rankings")
    fun chooseGoal(
        @ShellOption(help = "what the agent system should do") intent: String,
    ): String {
        try {
            val goalSeeker = autonomy.createGoalSeeker(
                intent = intent,
                agentScope = agentPlatform,
                goalChoiceApprover = GoalChoiceApprover approveWithScoreOver .8,
                goalSelectionOptions = GoalSelectionOptions(),
            )
            val fmt = goalSeeker.rankings.rankings().joinToString("\n") {
                it.infoString(verbose = true)
            }
            return fmt.color(colorPalette.color2) + "\n" + goalSeeker.agent.infoString(verbose = true)
        } catch (gna: GoalNotApproved) {
            return "Goal not approved. Rankings were:\n${gna.goalRankings.infoString(verbose = true)}"
        } catch (ngf: NoGoalFound) {
            return "No goal found. Rankings were:\n${ngf.goalRankings.infoString(verbose = true)}"
        }
    }

    @ShellMethod("Information about the AgentPlatform")
    fun platform(): String = "AgentPlatform: ${agentPlatform.name}"


    @ShellMethod(
        "Show last blackboard: The final state of a previous operation",
        key = ["blackboard", "bb"],
    )
    fun blackboard(): String {
        return if (blackboard == null) {
            "No blackboard available. Please run a command first."
        } else blackboard!!.infoString(verbose = true)
    }

    @ShellMethod("List available tool groups")
    fun tools(): String {
        val tgr = agentPlatform.toolGroupResolver
        return String.format(
            "%s: %s: %d available tool groups: %s",
            tgr.javaClass.name,
            tgr.name,
            tgr.availableToolGroups().size,
            "\n\t" + tgr.availableToolGroups()
                .map { tgr.resolveToolGroup(ToolGroupRequirement(it.role)) }
                .mapNotNull { it.resolvedToolGroup }
                .sortedBy { it.metadata.role }
                .joinToString("\n\t") { it.infoString(verbose = true) },
        )
    }

    @ShellMethod("Show tool stats")
    fun toolStats(): String {
        return toolsStats.infoString(verbose = true)
    }

    @ShellMethod("List available models")
    fun models(): String =
        modelProvider.infoString(true)

    @ShellMethod("Show options")
    fun showOptions(): String {
        // Don't show the blackboard as it's long
        return objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(
            defaultProcessOptions.copy(blackboard = null)
        ).replace(
            """
            "blackboard" : null
        """.trimIndent(), """
            "blackboard" : <${blackboard?.let { "${it.objects.size} entries" } ?: "empty"}>
        """.trimIndent())
            .color(colorPalette.color2)
    }

    @ShellMethod(
        "Set options",
    )
    fun setOptions(
        @ShellOption(
            value = ["-o", "--open"],
            help = "run in open mode, choosing a goal and using all actions that can help achieve it",
        ) open: Boolean = false,
        @ShellOption(value = ["-t", "--test"], help = "run in help mode") test: Boolean = false,
        @ShellOption(value = ["-p", "--showPrompts"], help = "show prompts to LLMs") showPrompts: Boolean,
        @ShellOption(value = ["-r", "--showResponses"], help = "show LLM responses") showLlmResponses: Boolean = false,
        @ShellOption(value = ["-d", "--debug"], help = "show debug info") debug: Boolean = false,
        @ShellOption(value = ["-s", "--state"], help = "Use existing blackboard") state: Boolean = false,
        @ShellOption(value = ["-td", "--toolDelay"], help = "Tool delay") toolDelay: Boolean = false,
        @ShellOption(value = ["-od", "--operationDelay"], help = "Operation delay") operationDelay: Boolean = false,
        @ShellOption(
            value = ["-s", "--showPlanning"],
            help = "show detailed planning info",
            defaultValue = "true",
        ) showPlanning: Boolean = true,
    ): String {
        this.openMode = open
        val verbosity = Verbosity(
            debug = debug,
            showPrompts = showPrompts,
            showLlmResponses = showLlmResponses,
            showPlanning = showPlanning,
        )
        this.defaultProcessOptions = ProcessOptions(
            blackboard = if (state) blackboard else null,
            verbosity = verbosity,
            processControl = ProcessControl(
                earlyTerminationPolicy = EarlyTerminationPolicy.maxActions(40),
                toolDelay = if (toolDelay) Delay.LONG else Delay.NONE,
                operationDelay = if (operationDelay) Delay.MEDIUM else Delay.NONE,
            )
        )
        return "Options updated:\nOpen mode:$openMode\n${showOptions()}".color(colorPalette.color2)
    }

    @ShellMethod(
        "Execute a task. Put the task in double quotes. For example:\n\tx \"Lynda is a scorpio. Find news for her\" -p",
        key = ["execute", "x"],
    )
    fun execute(
        @ShellOption(help = "what the agent system should do") intent: String,
        @ShellOption(
            value = ["-o", "--open"],
            help = "run in open mode, choosing a goal and using all actions that can help achieve it",
        ) open: Boolean = false,
        @ShellOption(value = ["-p", "--showPrompts"], help = "show prompts to LLMs") showPrompts: Boolean,
        @ShellOption(value = ["-r", "--showResponses"], help = "show LLM responses") showLlmResponses: Boolean = false,
        @ShellOption(value = ["-d", "--debug"], help = "show debug info") debug: Boolean = false,
        @ShellOption(value = ["-s", "--state"], help = "Use existing blackboard") state: Boolean = false,
        @ShellOption(value = ["-td", "--toolDelay"], help = "Tool delay") toolDelay: Boolean = false,
        @ShellOption(value = ["-od", "--operationDelay"], help = "Operation delay") operationDelay: Boolean = false,
        @ShellOption(
            value = ["-P", "--showPlanning"],
            help = "show detailed planning info",
            defaultValue = "true",
        ) showPlanning: Boolean = true,
    ): String {
        // Override any options
        setOptions(
            open = open,
            showPrompts = showPrompts,
            showLlmResponses = showLlmResponses,
            debug = debug,
            state = state,
            toolDelay = toolDelay,
            operationDelay = operationDelay,
            showPlanning = showPlanning,
        )
        return executeIntent(
            intent = intent,
            processOptions = defaultProcessOptions,
        )
    }

    @ShellMethod(value = "Exit the application", key = ["exit", "quit", "bye"])
    fun exit(): String {
        println("Exiting...".color(colorPalette.color2))
        logger.info("Shutting down application...")

        // Perform any cleanup if needed
        try {
            // Clear any active processes
            agentProcesses.clear()
            // Graceful shutdown
            CompletableFuture.runAsync {
                Thread.sleep(100) // Small delay to let response print
                exitProcess(SpringApplication.exit(context, { 0 }))
            }
            return "Goodbye!".color(colorPalette.color2)
        } catch (e: Exception) {
            logger.warn("Error during shutdown: ${e.message}")
            return "Goodbye! (with errors)".color(colorPalette.color2)
        }
    }

    private fun executeIntent(
        processOptions: ProcessOptions,
        intent: String,
    ): String {
        val opt = if (processOptions.verbosity.debug) {
            objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(processOptions)
        } else {
            objectMapper.writeValueAsString(processOptions)
        }
        logger.info(
            "Created process options: $opt".color(colorPalette.highlight)
        )

        return runProcess(verbosity = processOptions.verbosity, basis = intent) {
            if (openMode) {
                logger.info("Executing in open mode: Trying to find appropriate goal and using all actions known to platform that can help achieve it")
                autonomy.chooseAndAccomplishGoal(
                    processOptions = processOptions,
                    goalChoiceApprover = GoalChoiceApprover.APPROVE_ALL,
                    agentScope = agentPlatform,
                    bindings = mapOf("userInput" to UserInput(intent)),
                    goalSelectionOptions = GoalSelectionOptions(),
                )
            } else {
                logger.info("Executing in closed mode: Trying to find appropriate agent")
                autonomy.chooseAndRunAgent(
                    intent = intent,
                    processOptions = processOptions
                )
            }
        }

    }

    private fun recordAgentProcess(agentProcess: AgentProcess) {
        agentProcesses.add(agentProcess)
        blackboard = agentProcess.processContext.blackboard
    }

    private fun runProcess(
        verbosity: Verbosity,
        basis: Any,
        run: () -> AgentProcessExecution,
    ): String {
        try {
            val result = run()
            logger.debug("Result: {}\n", result)
            recordAgentProcess(result.agentProcess)
            return formatProcessOutput(result, colorPalette, objectMapper, shellProperties.lineLength)
        } catch (ngf: NoGoalFound) {
            if (verbosity.debug) {
                logger.info(
                    """
                    Failed to choose goal:
                        Rankings were: [${ngf.goalRankings.infoString()}]
                        Cutoff was ${autonomy.properties.goalConfidenceCutOff}
                    """.trimIndent().color(0xbfb8b8)
                )
            }
            return "I'm sorry. I don't know how to do that.\n"
        } catch (gna: GoalNotApproved) {
            if (verbosity.debug) {
                logger.info(
                    """
                    Goal not approved:
                        Rankings were: [${gna.goalRankings.infoString()}]
                    """.trimIndent().color(0xbfb8b8)
                )
            }
            return "I'm sorry. I don't know how to do that.\n"
        } catch (naf: NoAgentFound) {
            if (verbosity.debug) {
                logger.info(
                    """
                    Failed to choose agent:
                        Rankings were: [${naf.agentRankings.infoString()}]
                        Cutoff was ${autonomy.properties.agentConfidenceCutOff}
                    """.trimIndent().color(0xbfb8b8)
                )
            }
            return "I'm sorry. I don't know how to do that.\n"
        } catch (pese: ProcessExecutionStuckException) {
            pese.agentProcess?.let {
                recordAgentProcess(it)
            }
            return "I'm sorry. I don't know how to proceed.\n"
        } catch (pete: ProcessExecutionTerminatedException) {
            pete.agentProcess?.let {
                recordAgentProcess(it)
            }
            return "The process was terminated. Not my fault.\n\t${pete.detail.color(colorPalette.color2)}\n"
        } catch (pwe: ProcessWaitingException) {
            recordAgentProcess(pwe.agentProcess)
            val awaitableResponse = terminalServices.handleAwaitable(pwe.awaitable) ?: return "Operation cancelled.\n"
            pwe.awaitable.onResponse(
                response = awaitableResponse,
                agentProcess = pwe.agentProcess,
            )
            return runProcess(verbosity, basis) {
                AgentProcessExecution.fromProcessStatus(
                    basis = basis,
                    agentProcess = pwe.agentProcess.run()
                )
            }
        }
    }

}



================================================
FILE: embabel-agent-shell/src/main/kotlin/com/embabel/agent/shell/TerminalServices.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.shell

import ch.qos.logback.classic.LoggerContext
import ch.qos.logback.classic.encoder.PatternLayoutEncoder
import ch.qos.logback.classic.spi.ILoggingEvent
import ch.qos.logback.core.Appender
import ch.qos.logback.core.FileAppender
import com.embabel.agent.api.common.autonomy.*
import com.embabel.agent.channel.*
import com.embabel.agent.core.AgentPlatform
import com.embabel.agent.core.hitl.*
import com.embabel.agent.event.logging.personality.ColorPalette
import com.embabel.agent.event.logging.personality.DefaultColorPalette
import com.embabel.agent.shell.config.ShellProperties
import com.embabel.chat.AssistantMessage
import com.embabel.chat.ChatSession
import com.embabel.chat.UserMessage
import com.embabel.common.util.AnsiColor
import com.embabel.common.util.color
import com.embabel.common.util.loggerFor
import com.embabel.ux.form.Button
import com.embabel.ux.form.FormSubmission
import com.embabel.ux.form.TextField
import org.apache.commons.text.WordUtils
import org.jline.reader.LineReader
import org.jline.reader.LineReaderBuilder
import org.jline.terminal.Terminal
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Component
import java.nio.file.Files
import java.nio.file.Paths
import ch.qos.logback.classic.Logger as LogbackLogger


/**
 * Provide interaction and form support
 */
@Component
class TerminalServices(
    private val terminal: Terminal,
    private val shellProperties: ShellProperties,
) : GoalChoiceApprover {

    /**
     * Get further input
     */
    private fun <T> doWithLineReader(
        callback: (LineReader) -> T,
    ): T {
        val lineReader = LineReaderBuilder.builder()
            .terminal(terminal)
            .build()
        return callback(lineReader)
    }

    fun print(what: String) {
        doWithLineReader { it.printAbove(what) }
    }

    @JvmOverloads
    fun chat(
        chatSession: ChatSession,
        welcome: String? = null,
        colorPalette: ColorPalette = DefaultColorPalette(),
    ): String {
        val lineReader = LineReaderBuilder.builder()
            .terminal(terminal)
            .build()
        lineReader.printAbove(
            (welcome?.let { it + "\n" } ?: "") +
                    """
            Chat session ${chatSession.conversation.id} started. Type 'exit' to end the session.
            Type /help for available commands.
            """.trimIndent().color(colorPalette.highlight)
        )
        while (true) {
            val userInput = lineReader.readLine("You: ".color(colorPalette.highlight))
            if (userInput.equals("exit", ignoreCase = true)) {
                break
            }
            val userMessage = UserMessage(userInput)
            chatSession.onUserMessage(userMessage)
        }

        return "Conversation finished"
    }

    /**
     * Handle the process waiting exception request
     * @return null if the operation was cancelled by the user
     */
    fun handleAwaitable(awaitable: Awaitable<*, *>): AwaitableResponse? {
        val awaitableResponse = when (awaitable) {
            is ConfirmationRequest<*> -> {
                confirmationResponseFromUserInput(awaitable)
            }

            is FormBindingRequest<*> -> {
                formBindingResponseFromUserInput(awaitable)
            }

            else -> {
                TODO("Unhandled awaitable: ${awaitable.infoString()}")
            }
        }
        return awaitableResponse
    }

    fun confirm(message: String) = doWithLineReader {
        it.readLine("$message (y/n): ".color(AnsiColor.YELLOW))
            .equals("y", ignoreCase = true)
    }

    private fun confirmationResponseFromUserInput(
        confirmationRequest: ConfirmationRequest<*>,
    ): ConfirmationResponse {
        val confirmed = confirm(confirmationRequest.message)
        return ConfirmationResponse(
            awaitableId = confirmationRequest.id,
            accepted = confirmed,
        )
    }

    private fun formBindingResponseFromUserInput(
        formBindingRequest: FormBindingRequest<*>,
    ): FormResponse? {
        val form = formBindingRequest.payload
        val values = mutableMapOf<String, Any>()

        return doWithLineReader { lineReader ->
            loggerFor<ShellCommands>().info("Form: ${form.infoString()}")
            lineReader.printAbove(form.title)

            for (control in form.controls) {
                when (control) {
                    is TextField -> {
                        var input: String
                        var isValid = false

                        while (!isValid) {
                            val prompt =
                                "${control.label}${if (control.required) " *" else ""}: ".color(AnsiColor.YELLOW)
                            input = lineReader.readLine(prompt)//, control.value, null)

                            // Handle empty input for required fields
                            if (control.required && input.isBlank()) {
                                lineReader.printAbove("This field is required.")
                                continue
                            }

                            // Validate max length
                            if (control.maxLength != null && input.length > control.maxLength!!) {
                                lineReader.printAbove("Input exceeds maximum length of ${control.maxLength} characters.")
                                continue
                            }

                            // Validate pattern if specified
                            if (control.validationPattern != null && input.isNotBlank()) {
                                val regex = control.validationPattern!!.toRegex()
                                if (!input.matches(regex)) {
                                    lineReader.printAbove(
                                        control.validationMessage ?: "Input doesn't match required format."
                                    )
                                    continue
                                }
                            }

                            values[control.id] = input
                            isValid = true
                        }
                    }
                    // Add handling for other control types here as needed
                    // For example: Checkbox, RadioButton, Select, etc.
                    is Button -> {
                        // Handle submit button click
                        // TODO finish this
                    }

                    else -> {
                        // Handle unsupported control type
                        lineReader.printAbove("Unsupported control type: ${control.type}")
                    }
                }
            }

            val confirmSubmit = lineReader.readLine("Submit form? (y/n): ".color(AnsiColor.YELLOW))
                .equals("y", ignoreCase = true)

            if (!confirmSubmit) {
                null
            } else {
                FormResponse(
                    awaitableId = formBindingRequest.id,
                    formSubmission = FormSubmission(
                        formId = form.id,
                        values = values,
                    )
                )
            }
        }
    }

    override fun approve(goalChoiceApprovalRequest: GoalChoiceApprovalRequest): GoalChoiceApprovalResponse {
        val approved = confirm("Do you approve this goal: ${goalChoiceApprovalRequest.goal.description}?")
        return if (approved) {
            GoalChoiceApproved(
                request = goalChoiceApprovalRequest,
            )
        } else {
            GoalChoiceNotApproved(
                request = goalChoiceApprovalRequest,
                reason = "User said now",
            )
        }

    }

    fun outputChannel(agentPlatform: AgentPlatform): OutputChannel =
        TerminalOutputChannel(agentPlatform)

    private inner class TerminalOutputChannel(
        private val agentPlatform: AgentPlatform,
        private val colorPalette: ColorPalette = DefaultColorPalette(),
    ) : OutputChannel {

        override fun send(event: OutputChannelEvent) {
            when (event) {
                is MessageOutputChannelEvent -> {
                    val formattedResponse = WordUtils.wrap(
                        "${event.message.sender}: ${event.message.content.color(colorPalette.color2)}",
                        shellProperties.lineLength,
                    )
                    println(formattedResponse)
                    val agentProcess = agentPlatform.getAgentProcess(event.processId)
                        ?: throw IllegalStateException("Process not found: ${event.processId}")

                    (event.message as? AssistantMessage)?.awaitable?.let { awaitable ->
                        val awaitableResponse = handleAwaitable(awaitable)
                        if (awaitableResponse == null) {
                            TODO()
                        }
                        (awaitable as Awaitable<*, AwaitableResponse>).onResponse(
                            response = awaitableResponse,
                            agentProcess = agentProcess,
                        )
                        agentProcess.run()
                    }
                }

                is ContentOutputChannelEvent -> {
                    println("Content event: ${event.content}")
                }

                is ProgressOutputChannelEvent -> {
                    println("▶ ${event.message}")
                }

                is LoggingOutputChannelEvent -> {
                    println("🪵 ${event.message}")
                }

                else -> {
                    println(event.toString())
                }
            }
        }
    }

    /**
     * Redirects all logging to a file and returns a function to restore the original logging configuration.
     * This is useful during interactive chat sessions to prevent log output from interfering with the UI.
     */
    fun redirectLoggingToFile(
        filename: String,
        dir: String,
    ): () -> Unit {
        val loggerContext = LoggerFactory.getILoggerFactory() as LoggerContext
        val rootLogger = loggerContext.getLogger(org.slf4j.Logger.ROOT_LOGGER_NAME) as LogbackLogger

        // Store the current appenders to restore later
        val originalAppenders = mutableMapOf<String, Appender<ILoggingEvent>>()
        val appenderIterator = rootLogger.iteratorForAppenders()
        while (appenderIterator.hasNext()) {
            val appender = appenderIterator.next()
            originalAppenders[appender.name] = appender
            rootLogger.detachAppender(appender)
        }

        // Create a file appender for logs during chat
        val logsDir = Paths.get(dir, "logs")
        Files.createDirectories(logsDir)
        val logFile = logsDir.resolve("$filename.log")

        println("Redirecting logging during chat session to $logFile")

        val fileAppender = FileAppender<ILoggingEvent>().apply {
            context = loggerContext
            name = filename
            file = logFile.toString()

            val encoder = PatternLayoutEncoder().apply {
                context = loggerContext
                pattern = "%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"
                start()
            }
            this.encoder = encoder
            start()
        }

        // Attach the file appender
        rootLogger.addAppender(fileAppender)

        loggerFor<TerminalServices>().info("Logs redirected to: $logFile")

        // Return a function to restore the original logging configuration
        return {
            // Stop and detach the file appender
            rootLogger.detachAppender(fileAppender)
            fileAppender.stop()

            // Re-attach the original appenders
            originalAppenders.values.forEach { appender ->
                rootLogger.addAppender(appender)
            }

            loggerFor<TerminalServices>().info("Logging to console restored. Logs are available at: $logFile")
        }
    }

}



================================================
FILE: embabel-agent-shell/src/main/kotlin/com/embabel/agent/shell/config/ShellConfiguration.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.shell.config

import com.embabel.agent.shell.DefaultPromptProvider
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean
import org.springframework.boot.context.properties.EnableConfigurationProperties
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.shell.jline.PromptProvider

/**
 * Configuration for shell-specific components
 */
@Configuration
@EnableConfigurationProperties(ShellProperties::class)
class ShellConfiguration {

    /**
     * Fallback if we don't have a more interesting prompt provider
     */
    @Bean
    @ConditionalOnMissingBean(PromptProvider::class)
    fun defaultPromptProvider(): PromptProvider = DefaultPromptProvider()
}



================================================
FILE: embabel-agent-shell/src/main/kotlin/com/embabel/agent/shell/config/ShellProperties.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.shell.config

import org.springframework.boot.context.properties.ConfigurationProperties

@ConfigurationProperties(prefix = "embabel.agent.shell")
class ShellProperties {

    var lineLength: Int = 140

    /**
     * If this is true we redirect all log output to a file
     * when the user chats
     */
    var redirectLogToFile: Boolean = false

}



================================================
FILE: embabel-agent-shell/src/main/kotlin/com/embabel/agent/shell/personality/colossus/ColossusPromptProvider.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.shell.personality.colossus

import com.embabel.agent.event.logging.personality.colossus.ColossusColorPalette
import com.embabel.agent.shell.MessageGeneratorPromptProvider
import com.embabel.common.util.RandomFromFileMessageGenerator
import org.springframework.context.annotation.Profile
import org.springframework.stereotype.Component

@Component
@Profile("colossus")
class ColossusPromptProvider : MessageGeneratorPromptProvider(
    color = ColossusColorPalette.PANEL,
    prompt = "Colossus",
    messageGenerator = RandomFromFileMessageGenerator(
        url = "logging/colossus.txt"
    ),
)



================================================
FILE: embabel-agent-shell/src/main/kotlin/com/embabel/agent/shell/personality/hitchhiker/HitchhikerPromptProvider.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.shell.personality.hitchhiker

import com.embabel.agent.shell.MessageGeneratorPromptProvider
import com.embabel.agent.event.logging.personality.hitchhiker.HitchhikerColorPalette
import com.embabel.common.util.RandomFromFileMessageGenerator
import org.springframework.context.annotation.Profile
import org.springframework.stereotype.Component


val GuideEntries = listOf(
    "DON'T PANIC",
    "Mostly Harmless",
    "The Restaurant at the End of the Universe",
    "Life, the Universe and Everything",
    "So Long, and Thanks for All the Fish",
    "Milliways",
    "Infinite Improbability Drive",
    "Vogon Constructor Fleet",
    "Magrathea",
    "Heart of Gold",
    "Babel Fish",
    "Pan Galactic Gargle Blaster",
    "Trillian",
    "Zaphod Beeblebrox",
    "Arthur Dent",
    "Ford Prefect",
    "Marvin the Paranoid Android",
    "Deep Thought",
    "42",
)

@Component
@Profile("hh")
class HitchhikerPromptProvider : MessageGeneratorPromptProvider(
    color = HitchhikerColorPalette.BABEL_GREEN,
    prompt = GuideEntries.random(),
    messageGenerator = RandomFromFileMessageGenerator(
        url = "logging/hitchhiker.txt"
    ),
)



================================================
FILE: embabel-agent-shell/src/main/kotlin/com/embabel/agent/shell/personality/montypython/MontyPythonPromptProvider.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.shell.personality.montypython

import com.embabel.agent.event.logging.personality.montypython.MontyPythonColorPalette
import com.embabel.agent.shell.MessageGeneratorPromptProvider
import com.embabel.common.util.RandomFromFileMessageGenerator
import org.springframework.context.annotation.Profile
import org.springframework.stereotype.Component

@Component
@Profile("montypython")
class MontyPythonPromptProvider : MessageGeneratorPromptProvider(
    color = MontyPythonColorPalette.BRIGHT_RED,
    prompt = "pythons",
    messageGenerator = RandomFromFileMessageGenerator(
        url = "logging/montypython.txt"
    ),
)



================================================
FILE: embabel-agent-shell/src/main/kotlin/com/embabel/agent/shell/personality/severance/SeverancePromptProvider.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.shell.personality.severance

import com.embabel.agent.event.logging.personality.severance.LumonColorPalette
import com.embabel.agent.shell.MessageGeneratorPromptProvider
import com.embabel.common.util.RandomFromFileMessageGenerator
import org.springframework.context.annotation.Profile
import org.springframework.stereotype.Component

val LumonDepartments = listOf(
    "MDR",
    "Lumon",
    "Choreography and Merriment",
    "Mammalians Nurturable",
    "Optics And Design",
    "Perpetuity Wing",
    "Macrodata Refinement",
    "The Board",
    "Wellness",
    "Testing Floor",
)

@Component
@Profile("severance")
class SeverancePromptProvider : MessageGeneratorPromptProvider(
    color = LumonColorPalette.MEMBRANE,
    prompt = LumonDepartments.random(),
    messageGenerator = RandomFromFileMessageGenerator(
        url = "logging/severance.txt"
    ),
)



================================================
FILE: embabel-agent-shell/src/main/kotlin/com/embabel/agent/shell/personality/starwars/StarwarsPromptProvider.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.shell.personality.starwars

import com.embabel.agent.event.logging.personality.starwars.StarWarsColorPalette
import com.embabel.agent.shell.MessageGeneratorPromptProvider
import com.embabel.common.util.RandomFromFileMessageGenerator
import org.springframework.context.annotation.Profile
import org.springframework.stereotype.Component

@Component
@Profile("starwars")
class StarWarsPromptProvider : MessageGeneratorPromptProvider(
    color = StarWarsColorPalette.YELLOW_ACCENT,
    prompt = "starwars",
    messageGenerator = RandomFromFileMessageGenerator(
        url = "logging/starwars.txt"
    ),
)



================================================
FILE: embabel-agent-starters/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-parent</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-starters</artifactId>
    <packaging>pom</packaging>
    <name>Embabel Agent Starters</name>
    <description>Embabel Agent Starters</description>
    
    <modules>
        <module>embabel-agent-starter</module>
        <module>embabel-agent-starter-platform</module>
        <module>embabel-agent-starter-shell</module>
        <module>embabel-agent-starter-mcpserver</module>
        <module>embabel-agent-starter-bedrock</module>
        <module>embabel-agent-starter-openai</module>
        <module>embabel-agent-starter-anthropic</module>
        <module>embabel-agent-starter-ollama</module>
        <module>embabel-agent-starter-dockermodels</module>
        <module>embabel-agent-starter-deepseek</module>
    </modules>

</project>



================================================
FILE: embabel-agent-starters/.gitkeep
================================================
[Empty file]


================================================
FILE: embabel-agent-starters/embabel-agent-starter/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-starters</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-starter</artifactId>
    <name>Embabel Agent Starter</name>
    <description>Embabel Agent Starter. Parent to all starters</description>

    <!-- includes transitive dependency on agent API module -->
    <dependencies>
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-platform-autoconfigure</artifactId>
            <version>${project.version}</version>
        </dependency>
    </dependencies>
</project>



================================================
FILE: embabel-agent-starters/embabel-agent-starter-anthropic/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-starters</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-starter-anthropic</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent Anthropic Starter</name>
    <description>Embabel Agent Anthropic Starter</description>

    <dependencies>
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-platform-autoconfigure</artifactId>
        </dependency>
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-anthropic-autoconfigure</artifactId>
        </dependency>
    </dependencies>

</project>



================================================
FILE: embabel-agent-starters/embabel-agent-starter-bedrock/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-starters</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-starter-bedrock</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent Bedrock Starter</name>
    <description>Embabel Agent Bedrock Starter</description>

    <dependencies>
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-platform-autoconfigure</artifactId>
        </dependency>

        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-bedrock-autoconfigure</artifactId>
        </dependency>
    </dependencies>

</project>



================================================
FILE: embabel-agent-starters/embabel-agent-starter-bedrock/src/main/java/com/embabel/agent/starter/bedrock/spi/BedrockEnvironmentPostProcessor.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.starter.bedrock.spi;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.env.EnvironmentPostProcessor;
import org.springframework.core.Ordered;
import org.springframework.core.env.ConfigurableEnvironment;

/**
 * An {@link org.springframework.boot.env.EnvironmentPostProcessor} to customize the environment
 * for Bedrock-related configurations.
 * <p>
 * This class can be used to programmatically modify the application's environment before the
 * application context is refreshed. It is particularly useful for setting up properties or
 * profiles related to Bedrock services.
 */
public class BedrockEnvironmentPostProcessor implements EnvironmentPostProcessor, Ordered {

    private static final Logger logger = LoggerFactory.getLogger(BedrockEnvironmentPostProcessor.class);

    @Override
    public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
        //This is an interim solution to activate the bedrock profile when application-bedrock.yml is present.
        //A better solution would be to shift responsibility to the user external configuration managed directly
        //by the user
        logger.debug("Bedrock Models detected - applying Bedrock environment configuration");
        environment.addActiveProfile("bedrock");
    }

    @Override
    public int getOrder() {
        return Ordered.HIGHEST_PRECEDENCE + 10; // Run early, but after core Spring Boot processors
    }
}



================================================
FILE: embabel-agent-starters/embabel-agent-starter-bedrock/src/main/resources/META-INF/spring.factories
================================================
org.springframework.boot.env.EnvironmentPostProcessor=com.embabel.agent.starter.bedrock.spi.BedrockEnvironmentPostProcessor



================================================
FILE: embabel-agent-starters/embabel-agent-starter-bedrock/src/test/java/com/embabel/agent/starter/bedrock/spi/BedrockEnvironmentPostProcessorTest.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.starter.bedrock.spi;

import org.junit.jupiter.api.Test;
import org.springframework.core.Ordered;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
class BedrockEnvironmentPostProcessorTest {

    @Test
    void postProcessEnvironment() {
        var environment = new org.springframework.mock.env.MockEnvironment();
        var application = new org.springframework.boot.SpringApplication(Object.class);
        var processor = new BedrockEnvironmentPostProcessor();

        processor.postProcessEnvironment(environment, application);

        assertTrue(environment.getActiveProfiles().length > 0);
        assertEquals("bedrock", environment.getActiveProfiles()[0]);
    }

    @Test
    void getOrder() {
        var processor = new BedrockEnvironmentPostProcessor();
        assertThat(processor.getOrder()).isGreaterThan(Ordered.HIGHEST_PRECEDENCE);
    }
}


================================================
FILE: embabel-agent-starters/embabel-agent-starter-deepseek/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-starters</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>

    <artifactId>embabel-agent-starter-deepseek</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent DeepSeek Starter</name>
    <description>Embabel Agent DeepSeek Starter</description>

    <dependencies>
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-platform-autoconfigure</artifactId>
        </dependency>
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-deepseek-autoconfigure</artifactId>
        </dependency>
    </dependencies>

</project>



================================================
FILE: embabel-agent-starters/embabel-agent-starter-dockermodels/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-starters</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-starter-dockermodels</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent Docker Models Starter</name>
    <description>Embabel Agent Docker Models Starter</description>

    <dependencies>
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-platform-autoconfigure</artifactId>
        </dependency>
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-dockermodels-autoconfigure</artifactId>
        </dependency>
    </dependencies>

</project>



================================================
FILE: embabel-agent-starters/embabel-agent-starter-mcpserver/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-starters</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-starter-mcpserver</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent McpServer Starter</name>
    <description>Embabel Agent Starter MCP Server</description>

    <dependencies>
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-starter</artifactId>
        </dependency>

        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-mcpserver</artifactId>
        </dependency>
    </dependencies>
</project>



================================================
FILE: embabel-agent-starters/embabel-agent-starter-ollama/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-starters</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-starter-ollama</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent Ollama Starter</name>
    <description>Embabel Agent Ollama Starter</description>

    <dependencies>
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-platform-autoconfigure</artifactId>
        </dependency>
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-ollama-autoconfigure</artifactId>
        </dependency>
    </dependencies>

</project>



================================================
FILE: embabel-agent-starters/embabel-agent-starter-openai/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-starters</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-starter-openai</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent OpenAI Starter</name>
    <description>Embabel Agent OpenAI Starter</description>

    <dependencies>
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-platform-autoconfigure</artifactId>
        </dependency>
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-openai-autoconfigure</artifactId>
        </dependency>
    </dependencies>

</project>



================================================
FILE: embabel-agent-starters/embabel-agent-starter-platform/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-starters</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-starter-platform</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent API Starter</name>
    <description>Embabel Agent API Starter</description>

    <!-- includes transitive dependency on agent API module -->
    <dependencies>
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-starter</artifactId>
            <version>${project.version}</version>
        </dependency>
    </dependencies>
</project>



================================================
FILE: embabel-agent-starters/embabel-agent-starter-shell/README.md
================================================
# Embabel Agent Shell Starter

A Spring Boot starter that enables interactive command-line shell functionality for Embabel Agent applications.

## Overview

This starter automatically configures your Embabel Agent application to operate in shell mode when the `@EnableAgentShell` annotation is detected. It prevents web server startup and configures Spring Shell for optimal command-line interaction.

## Features

- **Automatic Shell Mode Detection**: Activates when `@EnableAgentShell` annotation is present
- **Web Server Prevention**: Automatically sets `spring.main.web-application-type=none`
- **Spring Shell Configuration**: Configures interactive shell with sensible defaults
- **Flexible Configuration**: Customizable shell behavior through properties
- **Early Environment Processing**: Configures shell mode before application context initialization

## Quick Start

### 1. Add Dependency

```xml
<dependency>
    <groupId>com.embabel.agent</groupId>
    <artifactId>embabel-agent-starter-shell</artifactId>
    <version>${embabel.version}</version>
</dependency>
```

### 2. Enable Shell Mode

```java
@SpringBootApplication
@EnableAgentShell
public class MyAgentApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyAgentApplication.class, args);
    }
}
```

### 3. Run Your Application

```bash
./mvnw spring-boot:run
```

Your application will start in interactive shell mode instead of as a web server.

## Configuration

Configure shell behavior using the `embabel.agent.shell` prefix:

### application.yml
```yaml
embabel:
  agent:
    shell:
      web-application-type: none  # none, servlet, or reactive
      command:
        exit-enabled: true        # Enable 'exit' command
        quit-enabled: true        # Enable 'quit' command
      interactive:
        enabled: true             # Enable interactive mode
        history-enabled: true     # Enable command history
```

### application.properties
```properties
embabel.agent.shell.web-application-type=none
embabel.agent.shell.command.exit-enabled=true
embabel.agent.shell.command.quit-enabled=true
embabel.agent.shell.interactive.enabled=true
embabel.agent.shell.interactive.history-enabled=true
```

## Configuration Properties

| Property | Default | Description |
|----------|---------|-------------|
| `embabel.agent.shell.web-application-type` | `none` | Spring Boot web application type (`none`, `servlet`, `reactive`) |
| `embabel.agent.shell.command.exit-enabled` | `true` | Enable the 'exit' command |
| `embabel.agent.shell.command.quit-enabled` | `true` | Enable the 'quit' command |
| `embabel.agent.shell.interactive.enabled` | `true` | Enable interactive shell mode |
| `embabel.agent.shell.interactive.history-enabled` | `true` | Enable command history navigation |

## How It Works

1. **Annotation Detection**: `ShellEnvironmentPostProcessor` scans application sources for `@EnableAgentShell`
2. **Early Configuration**: Runs at `HIGHEST_PRECEDENCE + 10` to configure environment before other processors
3. **Property Binding**: Attempts to bind configuration from `embabel.agent.shell.*` properties
4. **Fallback Handling**: Uses sensible defaults if binding fails or properties are missing
5. **Environment Modification**: Adds shell configuration as high-priority property source

## Architecture

```
@EnableAgentShell Annotation
         ↓
ShellEnvironmentPostProcessor
         ↓
AgentShellStarterProperties
         ↓
Spring Shell Configuration
         ↓
Interactive Command Line
```

### Key Components

- **`@EnableAgentShell`**: Marker annotation to enable shell mode
- **`ShellEnvironmentPostProcessor`**: Environment post-processor for early configuration
- **`AgentShellStarterProperties`**: Configuration properties with validation
- **`ShellConfiguration`**: Internal domain object for shell settings

## Error Handling

The starter handles configuration errors gracefully:

- **Missing Properties**: Uses default values if configuration binding fails
- **Invalid Values**: Validation prevents invalid `web-application-type` values
- **Null Sources**: Safely handles cases where application sources are null/empty
- **Binding Exceptions**: Logs warnings and continues with defaults

## Conditional Activation

Shell mode only activates when:
- The starter dependency is present
- At least one source class has `@EnableAgentShell` annotation
- No explicit disabling configuration is present

## Best Practices

### Development
```java
@Profile("dev")
@EnableAgentShell
@SpringBootApplication
public class DevApplication {
    // Shell mode for development
}
```

### Production
```java
@Profile("!shell")
@SpringBootApplication  
public class ProductionApplication {
    // Web mode for production
}

@Profile("shell")
@EnableAgentShell
@SpringBootApplication
public class ShellApplication {
    // Shell mode when needed
}
```

### Custom Commands
```java
@Component
@ConditionalOnProperty(name = "embabel.agent.shell.interactive.enabled", havingValue = "true")
public class MyAgentCommands {
    
    @ShellMethod("Execute agent task")
    public String execute(@ShellOption String task) {
        return "Executing: " + task;
    }
}
```

## Troubleshooting

### Shell Mode Not Activating
- Verify `@EnableAgentShell` annotation is present
- Check that starter dependency is included
- Ensure no conflicting web configuration

### Web Server Still Starting
- Confirm `web-application-type` is set to `none`
- Check property source precedence
- Verify no other configuration is overriding the setting

### Commands Not Available
- Ensure Spring Shell dependency is present
- Check component scanning includes command classes
- Verify conditional activation logic

### History Not Working
- Confirm `interactive.history-enabled=true`
- Check terminal supports ANSI escape sequences
- Verify JLine library is available

## Dependencies

This starter automatically includes:
- Spring Boot Starter
- Spring Shell Starter
- Validation API

## License

Licensed under the Apache License, Version 2.0.


================================================
FILE: embabel-agent-starters/embabel-agent-starter-shell/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-starters</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-starter-shell</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent Shell Starter</name>
    <description>Embabel Agent Starter Shell</description>

    <dependencies>
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-starter</artifactId>
        </dependency>

        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-shell</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-configuration-processor</artifactId>
            <optional>true</optional>
        </dependency>
    </dependencies>
</project>



================================================
FILE: embabel-agent-starters/embabel-agent-starter-shell/src/main/java/com/embabel/agent/starter/shell/AgentShellStarterProperties.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.starter.shell;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.validation.annotation.Validated;

import javax.validation.Valid;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Pattern;

/**
 * Configuration properties for Embabel Agent Shell Starter.
 *
 * <p>Provides configuration options for shell behavior when the agent operates
 * in interactive command-line mode. These properties control Spring Shell behavior
 * and application startup characteristics.
 *
 * <p>Properties are bound from configuration with the prefix {@code embabel.agent.shell}:
 * <pre>
 * embabel.agent.shell.web-application-type=none
 * embabel.agent.shell.command.exit-enabled=true
 * embabel.agent.shell.interactive.enabled=true
 * </pre>
 *
 * @since 1.1
 */
@Validated
@ConfigurationProperties(prefix = "embabel.agent.shell")
public class AgentShellStarterProperties {

    /**
     * Spring Boot web application type for shell mode.
     * Must be one of: "none", "servlet", or "reactive".
     * Defaults to "none" to prevent web server startup in shell mode.
     */
    @NotNull
    @Pattern(regexp = "none|servlet|reactive",
            message = "Web application type must be 'none', 'servlet', or 'reactive'")
    private String webApplicationType = "none";

    /**
     * Shell command configuration.
     */
    @Valid
    @NotNull
    private final Command command = new Command();

    /**
     * Interactive shell configuration.
     */
    @Valid
    @NotNull
    private final Interactive interactive = new Interactive();

    public String getWebApplicationType() {
        return webApplicationType;
    }

    public void setWebApplicationType(String webApplicationType) {
        this.webApplicationType = webApplicationType;
    }

    public Command getCommand() {
        return command;
    }

    public Interactive getInteractive() {
        return interactive;
    }

    /**
     * Configuration for shell command behavior.
     */
    public static class Command {

        /**
         * Enable the 'exit' command to allow users to terminate the shell.
         * Defaults to true for standard shell behavior.
         */
        private boolean exitEnabled = false;

        /**
         * Enable the 'quit' command as an alias for exit.
         * Defaults to true for standard shell behavior.
         */
        private boolean quitEnabled = false;

        public boolean isExitEnabled() {
            return exitEnabled;
        }

        public void setExitEnabled(boolean exitEnabled) {
            this.exitEnabled = exitEnabled;
        }

        public boolean isQuitEnabled() {
            return quitEnabled;
        }

        public void setQuitEnabled(boolean quitEnabled) {
            this.quitEnabled = quitEnabled;
        }
    }

    /**
     * Configuration for interactive shell features.
     */
    public static class Interactive {

        /**
         * Enable interactive shell mode with command prompt.
         * When false, the shell operates in non-interactive batch mode.
         */
        private boolean enabled = true;

        /**
         * Enable command history functionality.
         * Allows users to navigate previous commands using arrow keys.
         */
        private boolean historyEnabled = true;

        public boolean isEnabled() {
            return enabled;
        }

        public void setEnabled(boolean enabled) {
            this.enabled = enabled;
        }

        public boolean isHistoryEnabled() {
            return historyEnabled;
        }

        public void setHistoryEnabled(boolean historyEnabled) {
            this.historyEnabled = historyEnabled;
        }
    }
}


================================================
FILE: embabel-agent-starters/embabel-agent-starter-shell/src/main/java/com/embabel/agent/starter/shell/spi/ShellEnvironmentPostProcessor.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.starter.shell.spi;

import com.embabel.agent.starter.shell.AgentShellStarterProperties;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.context.properties.bind.BindException;
import org.springframework.boot.context.properties.bind.Binder;
import org.springframework.boot.env.EnvironmentPostProcessor;
import org.springframework.core.Ordered;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.env.MapPropertySource;

import java.util.HashMap;
import java.util.Map;

/**
 * Environment post-processor that configures shell mode early in the Spring Boot lifecycle.*
 * <p>The processor runs early in the Spring Boot lifecycle to ensure shell configuration is
 * applied before the application context is initialized, preventing conflicts with web server
 * startup when operating in shell mode.
 */
public class ShellEnvironmentPostProcessor implements EnvironmentPostProcessor, Ordered {

    private static final Logger logger = LoggerFactory.getLogger(ShellEnvironmentPostProcessor.class);

    // Property source configuration
    private static final String SHELL_PROPERTIES_SOURCE_NAME = "shellModeProperties";
    private static final String SHELL_CONFIG_PREFIX = "embabel.agent.shell";

    // Spring Boot property keys
    private static final String WEB_APPLICATION_TYPE_PROPERTY = "spring.main.web-application-type";
    private static final String SHELL_EXIT_ENABLED_PROPERTY = "spring.shell.command.exit.enabled";
    private static final String SHELL_QUIT_ENABLED_PROPERTY = "spring.shell.command.quit.enabled";
    private static final String SHELL_INTERACTIVE_ENABLED_PROPERTY = "spring.shell.interactive.enabled";
    private static final String SHELL_HISTORY_ENABLED_PROPERTY = "spring.shell.history.enabled";

    @Override
    public int getOrder() {
        return Ordered.HIGHEST_PRECEDENCE + 10; // Run early, but after core Spring Boot processors
    }

    @Override
    public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
       logger.debug("Shell mode detected - applying shell environment configuration");

        ShellConfiguration shellConfig = resolveShellConfiguration(environment);
        applyShellConfiguration(environment, shellConfig);

        logger.debug("Shell environment configuration applied successfully");
    }

    /**
     * Resolves the shell configuration from the environment, falling back to defaults
     * if binding fails or properties are not found.
     *
     * @param environment the configurable environment
     * @return the resolved shell configuration
     */
    private ShellConfiguration resolveShellConfiguration(ConfigurableEnvironment environment) {
        try {
            AgentShellStarterProperties properties = Binder.get(environment)
                    .bind(SHELL_CONFIG_PREFIX, AgentShellStarterProperties.class)
                    .orElseGet(AgentShellStarterProperties::new);

            return new ShellConfiguration(properties);
        } catch (BindException e) {
            logger.warn("Failed to bind shell properties from '{}', using defaults: {}",
                    SHELL_CONFIG_PREFIX, e.getMessage());
            return new ShellConfiguration(new AgentShellStarterProperties());
        } catch (Exception e) {
            logger.error("Unexpected error while resolving shell configuration, using defaults", e);
            return new ShellConfiguration(new AgentShellStarterProperties());
        }
    }

    /**
     * Applies the shell configuration to the environment by adding a high-priority property source.
     *
     * @param environment the configurable environment
     * @param shellConfig the shell configuration to apply
     */
    private void applyShellConfiguration(ConfigurableEnvironment environment, ShellConfiguration shellConfig) {
        Map<String, Object> shellProperties = buildShellProperties(shellConfig);

        environment.getPropertySources().addFirst(
                new MapPropertySource(SHELL_PROPERTIES_SOURCE_NAME, shellProperties)
        );

        logger.debug("Added shell properties with {} entries", shellProperties.size());
    }

    /**
     * Builds the shell properties map from the configuration.
     *
     * <p>Sets the web application type to NONE to prevent web server startup when in shell mode,
     * ensuring the application operates as a command-line tool rather than a web service.
     *
     * @param shellConfig the shell configuration
     * @return map of property names to values
     */
    private Map<String, Object> buildShellProperties(ShellConfiguration shellConfig) {
        Map<String, Object> properties = new HashMap<>();

        // Configure application type for shell mode - prevents web server startup
        properties.put(WEB_APPLICATION_TYPE_PROPERTY, shellConfig.getWebApplicationType());

        // Configure Spring Shell behavior
        properties.put(SHELL_EXIT_ENABLED_PROPERTY, shellConfig.isExitCommandEnabled());
        properties.put(SHELL_QUIT_ENABLED_PROPERTY, shellConfig.isQuitCommandEnabled());
        properties.put(SHELL_INTERACTIVE_ENABLED_PROPERTY, shellConfig.isInteractiveMode());
        properties.put(SHELL_HISTORY_ENABLED_PROPERTY, shellConfig.isHistoryEnabled());

        return properties;
    }

    /**
     * Domain object representing shell configuration extracted from AgentShellStarterProperties.
     * This provides a clean abstraction over the raw properties and encapsulates shell-specific logic.
     */
    private static class ShellConfiguration {
        private final AgentShellStarterProperties properties;

        public ShellConfiguration(AgentShellStarterProperties properties) {
            this.properties = properties;
        }

        public String getWebApplicationType() {
            return properties.getWebApplicationType();
        }

        public boolean isExitCommandEnabled() {
            return properties.getCommand().isExitEnabled();
        }

        public boolean isQuitCommandEnabled() {
            return properties.getCommand().isQuitEnabled();
        }

        public boolean isInteractiveMode() {
            return properties.getInteractive().isEnabled();
        }

        public boolean isHistoryEnabled() {
            return properties.getInteractive().isHistoryEnabled();
        }
    }
}


================================================
FILE: embabel-agent-starters/embabel-agent-starter-shell/src/main/resources/META-INF/spring.factories
================================================
# Environment Post Processors
org.springframework.boot.env.EnvironmentPostProcessor=com.embabel.agent.starter.shell.spi.ShellEnvironmentPostProcessor


================================================
FILE: embabel-agent-starters/embabel-agent-starter-shell/src/test/java/com/embabel/agent/starter/shell/AgentShellStarterPropertiesTest.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.starter.shell;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class AgentShellStarterPropertiesTest {

    @Test
    void testDefaultValues() {
        AgentShellStarterProperties properties = new AgentShellStarterProperties();

        assertEquals("none", properties.getWebApplicationType());
        assertNotNull(properties.getCommand());
        assertNotNull(properties.getInteractive());

        // Command defaults - updated to match new defaults
        assertFalse(properties.getCommand().isExitEnabled());
        assertFalse(properties.getCommand().isQuitEnabled());

        // Interactive defaults
        assertTrue(properties.getInteractive().isEnabled());
        assertTrue(properties.getInteractive().isHistoryEnabled());
    }

    @Test
    void testSettersAndGetters() {
        AgentShellStarterProperties properties = new AgentShellStarterProperties();

        // Main properties
        properties.setWebApplicationType("servlet");
        assertEquals("servlet", properties.getWebApplicationType());

        properties.setWebApplicationType("reactive");
        assertEquals("reactive", properties.getWebApplicationType());

        // Command properties - can't set new Command object since it's final
        properties.getCommand().setExitEnabled(false);
        properties.getCommand().setQuitEnabled(false);

        assertFalse(properties.getCommand().isExitEnabled());
        assertFalse(properties.getCommand().isQuitEnabled());

        // Interactive properties - can't set new Interactive object since it's final
        properties.getInteractive().setEnabled(false);
        properties.getInteractive().setHistoryEnabled(false);

        assertFalse(properties.getInteractive().isEnabled());
        assertFalse(properties.getInteractive().isHistoryEnabled());
    }

    @Test
    void testCommandSettersAndGetters() {
        AgentShellStarterProperties.Command cmd = new AgentShellStarterProperties.Command();

        // Test setting to false (since default is now true)
        cmd.setExitEnabled(false);
        cmd.setQuitEnabled(false);

        assertFalse(cmd.isExitEnabled());
        assertFalse(cmd.isQuitEnabled());

        // Test setting back to true
        cmd.setExitEnabled(true);
        cmd.setQuitEnabled(true);

        assertTrue(cmd.isExitEnabled());
        assertTrue(cmd.isQuitEnabled());
    }

    @Test
    void testInteractiveSettersAndGetters() {
        AgentShellStarterProperties.Interactive interactive = new AgentShellStarterProperties.Interactive();

        interactive.setEnabled(false);
        interactive.setHistoryEnabled(false);

        assertFalse(interactive.isEnabled());
        assertFalse(interactive.isHistoryEnabled());

        interactive.setEnabled(true);
        interactive.setHistoryEnabled(true);

        assertTrue(interactive.isEnabled());
        assertTrue(interactive.isHistoryEnabled());
    }

    @Test
    void testWebApplicationTypeValidation() {
        AgentShellStarterProperties properties = new AgentShellStarterProperties();

        // Test valid values
        properties.setWebApplicationType("none");
        assertEquals("none", properties.getWebApplicationType());

        properties.setWebApplicationType("servlet");
        assertEquals("servlet", properties.getWebApplicationType());

        properties.setWebApplicationType("reactive");
        assertEquals("reactive", properties.getWebApplicationType());
    }

    @Test
    void testNullValues() {
        AgentShellStarterProperties properties = new AgentShellStarterProperties();

        // Test setting null webApplicationType
        properties.setWebApplicationType(null);
        assertNull(properties.getWebApplicationType());

        // Command and Interactive objects are final and cannot be set to null
        // They should always return non-null instances
        assertNotNull(properties.getCommand());
        assertNotNull(properties.getInteractive());
    }

    @Test
    void testNestedObjectsAreFinal() {
        AgentShellStarterProperties properties = new AgentShellStarterProperties();

        // Get references to nested objects
        AgentShellStarterProperties.Command command1 = properties.getCommand();
        AgentShellStarterProperties.Interactive interactive1 = properties.getInteractive();

        // Get references again
        AgentShellStarterProperties.Command command2 = properties.getCommand();
        AgentShellStarterProperties.Interactive interactive2 = properties.getInteractive();

        // Should be the same instances since they're final
        assertSame(command1, command2);
        assertSame(interactive1, interactive2);
    }
}


================================================
FILE: embabel-agent-starters/embabel-agent-starter-shell/src/test/java/com/embabel/agent/starter/shell/spi/ShellEnvironmentPostProcessorTest.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.starter.shell.spi;

import com.embabel.agent.starter.shell.AgentShellStarterProperties;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;
import ch.qos.logback.classic.Logger;
import ch.qos.logback.classic.Level;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;

import org.springframework.boot.context.properties.bind.BindResult;
import org.springframework.boot.context.properties.bind.Bindable;
import org.springframework.boot.context.properties.bind.Binder;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.env.MapPropertySource;
import org.springframework.core.env.MutablePropertySources;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
class ShellEnvironmentPostProcessorTest {

    @Mock
    private ConfigurableEnvironment environment;

    @Mock
    private SpringApplication application;

    @Mock
    private MutablePropertySources propertySources;

    private ShellEnvironmentPostProcessor processor;

    @BeforeEach
    void suppressLogging() {
        Logger logger = (Logger) LoggerFactory.getLogger(ShellEnvironmentPostProcessor.class);
        logger.setLevel(Level.OFF);
    }

    @Test
    void shouldContinueProcessingWhenNoEnableAgentShellAnnotation() {
        // Given
        processor = new ShellEnvironmentPostProcessor();
        Set<Object> sources = new HashSet<>();
        sources.add(String.class); // Not annotated class
        when(application.getAllSources()).thenReturn(sources);
        when(environment.getPropertySources()).thenReturn(propertySources);

        // When
        processor.postProcessEnvironment(environment, application);

        // Then
        verify(propertySources, atLeastOnce()).addFirst(any());
    }

    @Test
    void shouldNotSkipProcessingWhenSourcesIsEmpty() {
        // Given
        processor = new ShellEnvironmentPostProcessor();
        when(application.getAllSources()).thenReturn(Collections.emptySet());
        when(environment.getPropertySources()).thenReturn(propertySources);

        // When
        processor.postProcessEnvironment(environment, application);

        // Then
        verify(propertySources, atLeastOnce()).addFirst(any());
    }

    @Test
    void shouldNotSkipProcessingWhenSourcesIsNull() {
        // Given
        processor = new ShellEnvironmentPostProcessor();
        when(application.getAllSources()).thenReturn(null);
        when(environment.getPropertySources()).thenReturn(propertySources);

        // When
        processor.postProcessEnvironment(environment, application);

        // Then - should not throw exception and should skip processing
        verify(propertySources, atLeastOnce()).addFirst(any());
    }

    @Test
    void shouldProcessEnvironmentWhenEnableAgentShellAnnotationPresent() {
        // Given
        processor = new ShellEnvironmentPostProcessor();
        Set<Object> sources = new HashSet<>();
        sources.add(TestClass.class);
        when(application.getAllSources()).thenReturn(sources);
        when(environment.getPropertySources()).thenReturn(propertySources);

        AgentShellStarterProperties properties = createDefaultProperties();

        try (MockedStatic<Binder> binderMock = mockStatic(Binder.class)) {
            Binder binder = mock(Binder.class);
            BindResult<AgentShellStarterProperties> bindResult = mock(BindResult.class);

            binderMock.when(() -> Binder.get(environment)).thenReturn(binder);

            lenient().when(binder.bind(anyString(), any(Bindable.class))).thenReturn(bindResult);
            lenient().when(binder.bind(anyString(), eq(AgentShellStarterProperties.class))).thenReturn(bindResult);
            lenient().when(bindResult.isBound()).thenReturn(true);
            lenient().when(bindResult.get()).thenReturn(properties);
            lenient().when(bindResult.orElse(any())).thenReturn(properties);
            lenient().when(bindResult.orElseGet(any())).thenReturn(properties);

            // When
            processor.postProcessEnvironment(environment, application);

            // Then
            verify(propertySources).addFirst(any(MapPropertySource.class));
        }
    }

    @Test
    void shouldUseDefaultPropertiesWhenBindingFails() {
        // Given
        processor = new ShellEnvironmentPostProcessor();
        Set<Object> sources = new HashSet<>();
        sources.add(TestClass.class);
        when(application.getAllSources()).thenReturn(sources);
        when(environment.getPropertySources()).thenReturn(propertySources);

        AgentShellStarterProperties defaultProperties = createDefaultProperties();

        try (MockedStatic<Binder> binderMock = mockStatic(Binder.class)) {
            Binder binder = mock(Binder.class);
            BindResult<AgentShellStarterProperties> bindResult = mock(BindResult.class);

            binderMock.when(() -> Binder.get(environment)).thenReturn(binder);

            lenient().when(binder.bind(anyString(), any(Bindable.class))).thenReturn(bindResult);
            lenient().when(binder.bind(anyString(), eq(AgentShellStarterProperties.class))).thenReturn(bindResult);
            lenient().when(bindResult.isBound()).thenReturn(false);
            lenient().when(bindResult.orElse(any())).thenReturn(defaultProperties);
            lenient().when(bindResult.orElseGet(any())).thenReturn(defaultProperties);

            // When
            processor.postProcessEnvironment(environment, application);

            // Then
            verify(propertySources).addFirst(any(MapPropertySource.class));
        }
    }

    @Test
    void shouldUseDefaultPropertiesWhenBindExceptionIsThrown() {
        // Given
        processor = new ShellEnvironmentPostProcessor();
        Set<Object> sources = new HashSet<>();
        sources.add(TestClass.class);
        when(application.getAllSources()).thenReturn(sources);
        when(environment.getPropertySources()).thenReturn(propertySources);

        try (MockedStatic<Binder> binderMock = mockStatic(Binder.class)) {
            Binder binder = mock(Binder.class);

            binderMock.when(() -> Binder.get(environment)).thenReturn(binder);
            lenient().when(binder.bind(anyString(), any(Bindable.class)))
                    .thenThrow(new IllegalArgumentException("Invalid binding configuration"));
            lenient().when(binder.bind(anyString(), eq(AgentShellStarterProperties.class)))
                    .thenThrow(new IllegalArgumentException("Invalid binding configuration"));

            // When - should handle binding exceptions gracefully
            assertDoesNotThrow(() -> processor.postProcessEnvironment(environment, application));

            // Then - should still add default properties
            verify(propertySources).addFirst(any(MapPropertySource.class));
        }
    }

    @Test
    void shouldUseDefaultPropertiesWhenGeneralExceptionIsThrown() {
        // Given
        processor = new ShellEnvironmentPostProcessor();
        Set<Object> sources = new HashSet<>();
        sources.add(TestClass.class);
        when(application.getAllSources()).thenReturn(sources);
        when(environment.getPropertySources()).thenReturn(propertySources);

        try (MockedStatic<Binder> binderMock = mockStatic(Binder.class)) {
            Binder binder = mock(Binder.class);

            binderMock.when(() -> Binder.get(environment)).thenReturn(binder);
            lenient().when(binder.bind(anyString(), any(Bindable.class)))
                    .thenThrow(new IllegalStateException("Unexpected error"));
            lenient().when(binder.bind(anyString(), eq(AgentShellStarterProperties.class)))
                    .thenThrow(new IllegalStateException("Unexpected error"));

            // When - should handle general exceptions gracefully
            assertDoesNotThrow(() -> processor.postProcessEnvironment(environment, application));

            // Then - should still add default properties
            verify(propertySources).addFirst(any(MapPropertySource.class));
        }
    }

    @Test
    void shouldSetCorrectPropertyValuesFromBoundProperties() {
        // Given
        processor = new ShellEnvironmentPostProcessor();
        Set<Object> sources = new HashSet<>();
        sources.add(TestClass.class);
        when(application.getAllSources()).thenReturn(sources);
        when(environment.getPropertySources()).thenReturn(propertySources);

        AgentShellStarterProperties properties = new AgentShellStarterProperties();
        properties.setWebApplicationType("servlet");
        properties.getCommand().setExitEnabled(true);
        properties.getCommand().setQuitEnabled(true);
        properties.getInteractive().setEnabled(false);
        properties.getInteractive().setHistoryEnabled(false);

        try (MockedStatic<Binder> binderMock = mockStatic(Binder.class)) {
            Binder binder = mock(Binder.class);
            BindResult<AgentShellStarterProperties> bindResult = mock(BindResult.class);

            binderMock.when(() -> Binder.get(environment)).thenReturn(binder);

            lenient().when(binder.bind(anyString(), any(Bindable.class))).thenReturn(bindResult);
            lenient().when(binder.bind(anyString(), eq(AgentShellStarterProperties.class))).thenReturn(bindResult);
            lenient().when(bindResult.isBound()).thenReturn(true);
            lenient().when(bindResult.get()).thenReturn(properties);
            lenient().when(bindResult.orElse(any())).thenReturn(properties);
            lenient().when(bindResult.orElseGet(any())).thenReturn(properties);

            // When
            processor.postProcessEnvironment(environment, application);

            // Then
            ArgumentCaptor<MapPropertySource> captor = ArgumentCaptor.forClass(MapPropertySource.class);
            verify(propertySources).addFirst(captor.capture());

            MapPropertySource captured = captor.getValue();
            assertEquals("shellModeProperties", captured.getName());
            assertEquals("servlet", captured.getProperty("spring.main.web-application-type"));
            assertEquals(true, captured.getProperty("spring.shell.command.exit.enabled"));
            assertEquals(true, captured.getProperty("spring.shell.command.quit.enabled"));
            assertEquals(false, captured.getProperty("spring.shell.interactive.enabled"));
            assertEquals(false, captured.getProperty("spring.shell.history.enabled"));
        }
    }

    @Test
    void shouldSetCorrectPropertyValuesWithDefaultProperties() {
        // Given
        processor = new ShellEnvironmentPostProcessor();
        Set<Object> sources = new HashSet<>();
        sources.add(TestClass.class);
        when(application.getAllSources()).thenReturn(sources);
        when(environment.getPropertySources()).thenReturn(propertySources);

        AgentShellStarterProperties defaultProperties = createDefaultProperties();

        try (MockedStatic<Binder> binderMock = mockStatic(Binder.class)) {
            Binder binder = mock(Binder.class);
            BindResult<AgentShellStarterProperties> bindResult = mock(BindResult.class);

            binderMock.when(() -> Binder.get(environment)).thenReturn(binder);

            lenient().when(binder.bind(anyString(), any(Bindable.class))).thenReturn(bindResult);
            lenient().when(binder.bind(anyString(), eq(AgentShellStarterProperties.class))).thenReturn(bindResult);
            lenient().when(bindResult.isBound()).thenReturn(false);
            lenient().when(bindResult.orElse(any())).thenReturn(defaultProperties);
            lenient().when(bindResult.orElseGet(any())).thenReturn(defaultProperties);

            // When
            processor.postProcessEnvironment(environment, application);

            // Then
            ArgumentCaptor<MapPropertySource> captor = ArgumentCaptor.forClass(MapPropertySource.class);
            verify(propertySources).addFirst(captor.capture());

            MapPropertySource captured = captor.getValue();
            assertEquals("shellModeProperties", captured.getName());

            // Verify default values are set
            assertNotNull(captured.getProperty("spring.main.web-application-type"));
            assertNotNull(captured.getProperty("spring.shell.command.exit.enabled"));
            assertNotNull(captured.getProperty("spring.shell.command.quit.enabled"));
            assertNotNull(captured.getProperty("spring.shell.interactive.enabled"));
            assertNotNull(captured.getProperty("spring.shell.history.enabled"));
        }
    }

    @Test
    void shouldHandleNullWebApplicationType() {
        // Given
        processor = new ShellEnvironmentPostProcessor();
        Set<Object> sources = new HashSet<>();
        sources.add(TestClass.class);
        when(application.getAllSources()).thenReturn(sources);
        when(environment.getPropertySources()).thenReturn(propertySources);

        AgentShellStarterProperties properties = new AgentShellStarterProperties();
        properties.setWebApplicationType(null);

        try (MockedStatic<Binder> binderMock = mockStatic(Binder.class)) {
            Binder binder = mock(Binder.class);
            BindResult<AgentShellStarterProperties> bindResult = mock(BindResult.class);

            binderMock.when(() -> Binder.get(environment)).thenReturn(binder);

            lenient().when(binder.bind(anyString(), any(Bindable.class))).thenReturn(bindResult);
            lenient().when(binder.bind(anyString(), eq(AgentShellStarterProperties.class))).thenReturn(bindResult);
            lenient().when(bindResult.isBound()).thenReturn(true);
            lenient().when(bindResult.get()).thenReturn(properties);
            lenient().when(bindResult.orElse(any())).thenReturn(properties);
            lenient().when(bindResult.orElseGet(any())).thenReturn(properties);

            // When
            processor.postProcessEnvironment(environment, application);

            // Then - should not throw exception
            ArgumentCaptor<MapPropertySource> captor = ArgumentCaptor.forClass(MapPropertySource.class);
            verify(propertySources).addFirst(captor.capture());

            MapPropertySource captured = captor.getValue();
            assertNotNull(captured);
            // Should handle null gracefully by using the null value
            assertNull(captured.getProperty("spring.main.web-application-type"));
        }
    }

    @Test
    void shouldProcessMultipleSourcesWithSomeAnnotated() {
        // Given
        processor = new ShellEnvironmentPostProcessor();
        Set<Object> sources = new HashSet<>();
        sources.add(String.class); // Not annotated
        sources.add(TestClass.class); // Annotated
        sources.add(Integer.class); // Not annotated
        when(application.getAllSources()).thenReturn(sources);
        when(environment.getPropertySources()).thenReturn(propertySources);

        AgentShellStarterProperties properties = createDefaultProperties();

        try (MockedStatic<Binder> binderMock = mockStatic(Binder.class)) {
            Binder binder = mock(Binder.class);
            BindResult<AgentShellStarterProperties> bindResult = mock(BindResult.class);

            binderMock.when(() -> Binder.get(environment)).thenReturn(binder);

            lenient().when(binder.bind(anyString(), any(Bindable.class))).thenReturn(bindResult);
            lenient().when(binder.bind(anyString(), eq(AgentShellStarterProperties.class))).thenReturn(bindResult);
            lenient().when(bindResult.isBound()).thenReturn(true);
            lenient().when(bindResult.get()).thenReturn(properties);
            lenient().when(bindResult.orElse(any())).thenReturn(properties);
            lenient().when(bindResult.orElseGet(any())).thenReturn(properties);

            // When
            processor.postProcessEnvironment(environment, application);

            // Then - should still process because at least one class is annotated
            verify(propertySources).addFirst(any(MapPropertySource.class));
        }
    }

    @Test
    void shouldHaveCorrectOrder() {
        // Given
        processor = new ShellEnvironmentPostProcessor();

        // Then
        assertEquals(Integer.MIN_VALUE + 10, processor.getOrder());
    }

    @Test
    void shouldProcessEnvironmentWithMultipleAnnotatedClasses() {
        // Given
        processor = new ShellEnvironmentPostProcessor();
        Set<Object> sources = new HashSet<>();
        sources.add(TestClass.class);
        sources.add(AnotherTestClass.class);
        when(application.getAllSources()).thenReturn(sources);
        when(environment.getPropertySources()).thenReturn(propertySources);

        AgentShellStarterProperties properties = createDefaultProperties();

        try (MockedStatic<Binder> binderMock = mockStatic(Binder.class)) {
            Binder binder = mock(Binder.class);
            BindResult<AgentShellStarterProperties> bindResult = mock(BindResult.class);

            binderMock.when(() -> Binder.get(environment)).thenReturn(binder);

            lenient().when(binder.bind(anyString(), any(Bindable.class))).thenReturn(bindResult);
            lenient().when(binder.bind(anyString(), eq(AgentShellStarterProperties.class))).thenReturn(bindResult);
            lenient().when(bindResult.isBound()).thenReturn(true);
            lenient().when(bindResult.get()).thenReturn(properties);
            lenient().when(bindResult.orElse(any())).thenReturn(properties);
            lenient().when(bindResult.orElseGet(any())).thenReturn(properties);

            // When
            processor.postProcessEnvironment(environment, application);

            // Then
            verify(propertySources).addFirst(any(MapPropertySource.class));
        }
    }

    private AgentShellStarterProperties createDefaultProperties() {
        AgentShellStarterProperties properties = new AgentShellStarterProperties();
        properties.setWebApplicationType("none");
        properties.getCommand().setExitEnabled(false);
        properties.getCommand().setQuitEnabled(false);
        properties.getInteractive().setEnabled(true);
        properties.getInteractive().setHistoryEnabled(true);
        return properties;
    }

    // Test classes with the required annotation
    static class TestClass {
    }

    static class AnotherTestClass {
    }
}


================================================
FILE: embabel-agent-test-support/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-parent</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-test-support</artifactId>
    <packaging>pom</packaging>
    <name>Embabel Agent Test Support</name>
    <description>Embabel Agent Test Support for Agent API(s)</description>


    <modules>
        <module>embabel-agent-test</module>
        <module>embabel-agent-test-internal</module>
    </modules>

    <dependencies>
        <!-- Main Dependencies -->
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-api</artifactId>
        </dependency>

        <!-- Unit and Integration Testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
        </dependency>

        <dependency>
            <groupId>org.mockito</groupId>
            <artifactId>mockito-core</artifactId>
            <scope>compile</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.jetbrains.kotlin</groupId>
                <artifactId>kotlin-maven-plugin</artifactId>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>



================================================
FILE: embabel-agent-test-support/embabel-agent-test/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-test-support</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-test</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent Test</name>
    <description>Test Support Framework for Agent API(s)</description>

    

</project>



================================================
FILE: embabel-agent-test-support/embabel-agent-test/src/main/java/com/embabel/agent/testing/integration/EmbabelMockitoIntegrationTest.java
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.testing.integration;

import com.embabel.agent.core.AgentPlatform;
import com.embabel.agent.spi.LlmInteraction;
import com.embabel.agent.spi.LlmOperations;
import com.embabel.chat.Message;
import com.embabel.common.ai.model.ModelProvider;
import org.mockito.ArgumentCaptor;
import org.mockito.ArgumentMatcher;
import org.mockito.Mockito;
import org.mockito.stubbing.OngoingStubbing;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.TestPropertySource;
import org.springframework.test.context.bean.override.mockito.MockitoBean;

import java.util.List;
import java.util.function.Predicate;

import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * Base class for integration tests that use Mockito to mock LLM operations.
 * Provides convenient methods for stubbing and verifying LLM interactions.
 * Subclasses will be Spring Boot tests that start the AgentPlatform.
 * Prompt matching is done with normal lambdas rather than Mockito.
 */
@SpringBootTest
@TestPropertySource(properties = {
        "embabel.models.default-llm=test-model",
        "embabel.agent.verbosity.debug=true",
        "spring.shell.interactive.enabled=false",
        "spring.shell.noninteractive.enabled=false"
})
public class EmbabelMockitoIntegrationTest {

    @Autowired
    protected AgentPlatform agentPlatform;

    @MockitoBean
    private ModelProvider modelProvider;

    @MockitoBean
    protected LlmOperations llmOperations;

    // Stubbing methods
    protected <T> OngoingStubbing<T> whenCreateObject(Predicate<String> promptMatcher, Class<T> outputClass, Predicate<LlmInteraction> llmInteractionPredicate) {
        // Mock the lower level LLM operation to create an object
        // that will ultimately be called
        return when(llmOperations.createObject(argThat(m -> firstMessageContentSatisfiesMatcher(m, promptMatcher)), argThat(llmInteractionPredicate::test), eq(outputClass), any(), any()));
    }

    protected <T> OngoingStubbing<T> whenCreateObject(Predicate<String> promptMatcher, Class<T> outputClass) {
        return whenCreateObject(promptMatcher, outputClass, llmi -> true);
    }

    protected OngoingStubbing<String> whenGenerateText(Predicate<String> promptMatcher, Predicate<LlmInteraction> llmInteractionMatcher) {
        return when(llmOperations.createObject(argThat(m -> firstMessageContentSatisfiesMatcher(m, promptMatcher)),
                argThat(llmInteractionMatcher::test), eq(String.class), any(), any()));
    }

    protected OngoingStubbing<String> whenGenerateText(Predicate<String> promptMatcher) {
        return whenGenerateText(promptMatcher, llmi -> true);
    }

    // Verification methods
    protected <T> void verifyCreateObject(Predicate<String> promptMatcher, Class<T> outputClass, Predicate<LlmInteraction> llmInteractionMatcher) {
        verify(llmOperations).createObject(argThat(m -> firstMessageContentSatisfiesMatcher(m, promptMatcher)),
                argThat(llmInteractionMatcher::test), eq(outputClass), any(), any());
    }

    protected <T> void verifyCreateObject(Predicate<String> prompt, Class<T> outputClass) {
        verifyCreateObject(prompt, outputClass, llmi -> true);
    }

    protected void verifyGenerateText(Predicate<String> promptMatcher, Predicate<LlmInteraction> llmInteractionMatcher) {
        verify(llmOperations).createObject(argThat(m -> firstMessageContentSatisfiesMatcher(m, promptMatcher)), argThat(llmInteractionMatcher::test), eq(String.class), any(), any());
    }

    protected void verifyGenerateText(Predicate<String> promptMatcher) {
        verifyGenerateText(promptMatcher, llmi -> true);
    }

    // Verification methods with argument matchers
    protected <T> void verifyCreateObjectMatching(Predicate<String> promptMatcher, Class<T> outputClass, ArgumentMatcher<LlmInteraction> llmInteractionMatcher) {
        verify(llmOperations).createObject(argThat(m -> firstMessageContentSatisfiesMatcher(m, promptMatcher)), argThat(llmInteractionMatcher), eq(outputClass), any(), any());
    }

    protected <T> void verifyCreateObjectMatchingMessages(ArgumentMatcher<List<Message>> promptMatcher, Class<T> outputClass, ArgumentMatcher<LlmInteraction> llmInteractionMatcher) {
        verify(llmOperations).createObject(argThat(promptMatcher),
                argThat(llmInteractionMatcher),
                eq(outputClass), any(), any());
    }

    protected void verifyGenerateTextMatching(Predicate<String> promptMatcher) {
        verify(llmOperations).createObject(argThat(messages -> firstMessageContentSatisfiesMatcher(messages, promptMatcher)), any(), eq(String.class), any(), any());
    }

    protected void verifyGenerateTextMatching(Predicate<String> promptMatcher,
                                              LlmInteraction llmInteraction) {
        Mockito.verify(llmOperations).createObject(argThat(messages -> firstMessageContentSatisfiesMatcher(messages, promptMatcher)), eq(llmInteraction), eq(String.class), any(), any());
    }

    // Convenience verification methods
    protected void verifyNoInteractions() {
        Mockito.verifyNoInteractions(llmOperations);
    }

    protected void verifyNoMoreInteractions() {
        Mockito.verifyNoMoreInteractions(llmOperations);
    }

    // Argument captor helpers
    protected ArgumentCaptor<String> capturePrompt() {
        return ArgumentCaptor.forClass(String.class);
    }

    protected ArgumentCaptor<LlmInteraction> captureLlmInteraction() {
        return ArgumentCaptor.forClass(LlmInteraction.class);
    }

    protected <T> ArgumentCaptor<Class<T>> captureOutputClass() {
        return ArgumentCaptor.forClass(Class.class);
    }


    private boolean firstMessageContentSatisfiesMatcher(List<? extends Message> messages, Predicate<String> contentMatcher) {
        return messages != null && messages.size() == 1 && contentMatcher.test(messages.getFirst().getContent());
    }

}


================================================
FILE: embabel-agent-test-support/embabel-agent-test-internal/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-test-support</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-test-internal</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent Internal Test Framework</name>
    <description>Test Support Framework internal Modules</description>

    <dependencies>
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-test</artifactId>
        </dependency>
    </dependencies> 

</project>



================================================
FILE: embabel-agent-test-support/embabel-agent-test-internal/src/main/kotlin/com/embabel/agent/AgentTestApplication.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent
import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.context.properties.ConfigurationPropertiesScan
import org.springframework.boot.runApplication
import org.springframework.context.annotation.ComponentScan

@SpringBootApplication
@ConfigurationPropertiesScan(
    basePackages = [
        "com.embabel.agent",
        "com.embabel.example",
    ]
)
@ComponentScan(
    basePackages = [
        "com.embabel.agent",
        "com.embabel.example",
    ]
)
class AgentTestApplication {}



================================================
FILE: embabel-agent-test-support/embabel-agent-test-internal/src/main/kotlin/com/embabel/agent/test/domain/gardenOfEden.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.test.domain

data class GeneratedName(val name: String, val reason: String)

data class GeneratedNames(val names: List<GeneratedName>)

data class AllNames(val accepted: List<GeneratedName>, val rejected: List<GeneratedName>)

data class Garden(val name: String)

data class SpiPerson(val name: String)

data class WierdPerson(val name: String, val age: Int, val weirdness: String)

data class Return(
    val result: Result<*>,
    val capturedPrompt: String,
)



================================================
FILE: embabel-agent-test-support/embabel-agent-test-internal/src/main/kotlin/com/embabel/agent/test/domain/simplyMagic.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.test.domain

data class MagicVictim(
    val name: String,
)

data class Frog(
    val name: String,
)



================================================
FILE: embabel-agent-test-support/embabel-agent-test-internal/src/main/kotlin/com/embabel/agent/test/dsl/agentBuilderUtils.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.test.dsl

import com.embabel.agent.api.common.support.Branch
import com.embabel.agent.api.dsl.*
import com.embabel.agent.domain.io.UserInput
import com.embabel.agent.test.domain.*
import com.embabel.agent.test.type.Wumpus
import com.embabel.common.core.MobyNameGenerator

fun splitGarden() = agent("splitter", description = "splitter0") {

    transformation<UserInput, Garden> { Garden(it.input.content) }

    flow {
        split<Garden, Frog> {
            listOf(Frog("Kermit"), Frog("Freddo"))
        } andThenDo {
            SnakeMeal(it.objects.filterIsInstance<Frog>())
        }
    }

    goal(
        name = "snakeFed",
        description = "We are satisfied with generated names",
        satisfiedBy = SnakeMeal::class,
    )
}

fun userInputToFrogOrPersonBranch() = agent("brancher", description = "brancher0") {

    flow {
        branch<UserInput, SpiPerson, Frog> { Branch(SpiPerson(it.input.content)) }
    }

    goal(name = "namingDone", description = "We are satisfied with generated names", satisfiedBy = SpiPerson::class)
}

fun userInputToFrogChain() = agent("uitf", description = "Evil frogly wizard") {

    flow {
        chain<UserInput, SpiPerson, Frog>(
            { SpiPerson(it.input.content) },
            { Frog(it.input.name) },
        )
    }

    goal(name = "namingDone", description = "We are satisfied with generated names", satisfiedBy = Frog::class)
}

fun userInputToFrogAndThenDo() = agent("uitf", description = "Evil frogly wizard") {

    fun toSpiPerson(userInput: UserInput) = SpiPerson(userInput.content)

    flow {
        ::toSpiPerson andThenDo { Frog(it.input.name) }
    }

    goal(name = "namingDone", description = "We are satisfied with generated names", satisfiedBy = Frog::class)
}

fun userInputToFrogAndThen() = agent("uitf", description = "Evil frogly wizard") {

    fun toSpiPerson(userInput: UserInput) = SpiPerson(userInput.content)

    flow {
        ::toSpiPerson andThen { Frog(it.name) }
    }

    goal(name = "namingDone", description = "We are satisfied with generated names", satisfiedBy = Frog::class)
}

fun userInputToFrogAndThenAgain() = agent("uitf", description = "Evil frogly wizard") {

    fun toSpiPerson(userInput: UserInput) = SpiPerson(userInput.content)

    flow {
        ::toSpiPerson andThen { Frog(it.name) } andThen { Wumpus(it.name) }
    }

    goal(
        name = "namingDone", description = "We are satisfied with generated names",
        satisfiedBy = Wumpus::class
    )
}

fun simpleNamer(transformListener: () -> Unit = {}) =
    agent("Thing namer", description = "Name a thing, using internet research") {

        flow {
            aggregate<UserInput, GeneratedNames, AllNames>(
                transforms = listOf(
                    {
                        transformListener()
                        GeneratedNames(names = emptyList())
                    },
                    {
                        transformListener()
                        GeneratedNames(
                            names = listOf(
                                GeneratedName(
                                    "money.com",
                                    "Helps make money"
                                )
                            )
                        )
                    }),
                merge = { list, _ ->
                    AllNames(
                        accepted = list.flatMap { it.names }.distinctBy { it.name },
                        rejected = emptyList()
                    )
                },
            )
        }

        goal(name = "namingDone", description = "We are satisfied with generated names", satisfiedBy = AllNames::class)
    }


fun redoNamer() =
    agent(
        name = "Thing namer",
        description = "Name a thing, using internet research, repeating until we are happy"
    ) {

        flow {
            repeat<AllNames>(
                what = {
                    repeatableAggregate<UserInput, GeneratedNames, AllNames>(
                        startWith = AllNames(accepted = emptyList(), rejected = emptyList()),
                        transforms = listOf(
                            {
                                GeneratedNames(
                                    names = listOf(
                                        GeneratedName(
                                            MobyNameGenerator.generateName(),
                                            "Helps make money"
                                        )
                                    )
                                )
                            },
                            { GeneratedNames(names = listOf(GeneratedName("money.com", "Helps make money"))) }),
                        merge = { generatedNamesList ->
                            AllNames(
                                accepted = generatedNamesList.flatMap { it.names }.distinctBy { it.name },
                                rejected = emptyList()
                            )
                        },
                    )
                },
                until = { it, _ ->
                    it.accepted.size > 5
                })
        }

        goal(name = "namingDone", description = "We are satisfied with generated names", satisfiedBy = AllNames::class)
    }

data class Thing(val t: String)

fun nestingByName() = agent("nesting test", description = "Nesting test") {

    referencedAgentAction<UserInput, Thing>(agentName = "foobar")

    flow {
        aggregate<Thing, GeneratedNames, AllNames>(
            transforms = listOf(
                { GeneratedNames(names = emptyList()) },
                { GeneratedNames(names = listOf(GeneratedName("money.com", "Helps make money"))) }),
            merge = { generatedNamesList, _ ->
                AllNames(
                    accepted = generatedNamesList.flatMap { it.names }.distinctBy { it.name },
                    rejected = emptyList()
                )
            },
        )
    }

    goal(name = "namingDone", description = "We are satisfied with generated names", satisfiedBy = AllNames::class)
}

fun nestingByReference() = agent("nesting test", description = "Nesting test") {

    localAgentAction<UserInput, Thing>(
        agent(name = "foobar", description = "doesn't matter here") {
            transformation<UserInput, Thing>("foobar") {
                Thing(it.input.content)
            }
            goal("name", "description", satisfiedBy = Thing::class)
        })
    flow {
        aggregate<Thing, GeneratedNames, AllNames>(
            transforms = listOf(
                { GeneratedNames(names = emptyList()) },
                { GeneratedNames(names = listOf(GeneratedName("money.com", "Helps make money"))) }),
            merge = { generatedNamesList, _ ->
                AllNames(
                    accepted = generatedNamesList.flatMap { it.names }.distinctBy { it.name },
                    rejected = emptyList()
                )
            },
        )
    }

    goal(name = "namingDone", description = "We are satisfied with generated names", satisfiedBy = AllNames::class)
}

fun biAggregate() = agent("biAggregate", description = "Nesting test") {

    transformation<UserInput, Thing>("foo") {
        Thing(it.input.content)
    }

    flow {
        biAggregate<UserInput, Thing, GeneratedNames, AllNames>(
            transforms = listOf(
                { GeneratedNames(names = emptyList()) },
                { GeneratedNames(names = listOf(GeneratedName("money.com", "Helps make money"))) }),
            merge = { generatedNamesList ->
                AllNames(
                    accepted = generatedNamesList.flatMap { it.names }.distinctBy { it.name },
                    rejected = emptyList()
                )
            },
        )
    }

    goal(name = "namingDone", description = "We are satisfied with generated names", satisfiedBy = AllNames::class)
}



================================================
FILE: embabel-agent-test-support/embabel-agent-test-internal/src/main/kotlin/com/embabel/agent/test/dsl/dslAgents.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.test.dsl

import com.embabel.agent.api.dsl.agent
import com.embabel.agent.api.dsl.aggregate
import com.embabel.agent.domain.io.UserInput
import com.embabel.agent.test.domain.Frog
import com.embabel.agent.test.domain.MagicVictim


val EvilWizardAgent = agent("EvilWizard", description = "Turn a person into a frog") {

    transformation<UserInput, MagicVictim>(name = "thing") {
        MagicVictim(name = "Hamish")
    }

    promptedTransformer<MagicVictim, Frog>(name = "turn-into-frog") {
        "Turn the person named ${it.input.name} into a frog"

    }

    goal(name = "done", description = "done", satisfiedBy = Frog::class)
}

data class SnakeMeal(val frogs: List<Frog>)

fun evenMoreEvilWizard() = agent("EvenMoreEvilWizard", description = "Turn a person into a frog") {

    transformation<UserInput, MagicVictim>(name = "thing") {
        MagicVictim(name = "Hamish")
    }

    flow {
        aggregate<MagicVictim, Frog, SnakeMeal>(
            transforms = listOf({ Frog(it.input.name) }, { Frog("2") }, { Frog("3") }),
            merge = { frogs, _ -> SnakeMeal(frogs) },
        )
    }

    goal(name = "done", description = "done", satisfiedBy = SnakeMeal::class)
}



================================================
FILE: embabel-agent-test-support/embabel-agent-test-internal/src/main/kotlin/com/embabel/agent/test/models/OptionsConverterTestSupport.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.test.models

import com.embabel.common.ai.model.OptionsConverter
import org.junit.jupiter.api.Test
import org.springframework.ai.chat.prompt.ChatOptions

abstract class OptionsConverterTestSupport<O : ChatOptions>(
    protected val optionsConverter: OptionsConverter<O>
) {

    @Test
    fun `should preserve core values`() {
        checkOptionsConverterPreservesCoreValues(optionsConverter)
    }
}



================================================
FILE: embabel-agent-test-support/embabel-agent-test-internal/src/main/kotlin/com/embabel/agent/test/models/optionsConverterTestUtils.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.test.models

import com.embabel.common.ai.model.LlmOptions
import com.embabel.common.ai.model.OptionsConverter
import org.junit.jupiter.api.Assertions.assertEquals

fun checkOptionsConverterPreservesCoreValues(optionsConverter: OptionsConverter<*>) {
    val llmo = LlmOptions().withTemperature(temperature = 0.5).withTopK(10).withTopP(.2).withFrequencyPenalty(.2)
    val options = optionsConverter.convertOptions(llmo)
    assertEquals(llmo.temperature, options.temperature, "Should have preserved temperature")
//    assertEquals(llmo.topK, options.topK, "Should have preserved topK")
    assertEquals(llmo.topP, options.topP, "Should have preserved topP")
//    assertEquals(llmo.frequencyPenalty, options.frequencyPenalty, "Should have preserved frequencyPenalty")
}



================================================
FILE: embabel-agent-test-support/embabel-agent-test-internal/src/main/kotlin/com/embabel/agent/test/type/testTypes.kt
================================================
/*
 * Copyright 2024-2025 Embabel Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.embabel.agent.test.type

import com.embabel.agent.api.annotation.*
import com.embabel.agent.api.common.*
import com.embabel.agent.api.dsl.chain
import com.embabel.agent.api.dsl.runAgent
import com.embabel.agent.core.Goal
import com.embabel.agent.core.ProcessContext
import com.embabel.agent.core.hitl.ConfirmationRequest
import com.embabel.agent.domain.io.UserInput
import com.embabel.agent.test.domain.Frog
import com.embabel.agent.test.dsl.SnakeMeal
import com.embabel.agent.test.dsl.evenMoreEvilWizard
import com.embabel.common.ai.model.LlmOptions
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import org.springframework.ai.tool.annotation.Tool

data class PersonWithReverseTool(val name: String) {

    @Tool
    fun reverse() = name.reversed()

}

interface Organism {
}

open class Animal(
    val name: String,
) : Organism

class Dog(name: String) : Animal(name)


@AgentCapabilities
class NoMethods

@AgentCapabilities
class OneGoalOnly {

    val thing1 = Goal.createInstance(
        name = "thing1",
        description = "Thanks to Dr Seuss",
        type = PersonWithReverseTool::class.java,
    ).withValue(30.0)
}

@AgentCapabilities
class OneGoalOnlyWithRichMetadata {

    val thing1 = Goal.createInstance(
        name = "thing1",
        description = "This is a goal with rich metadata",
        type = PersonWithReverseTool::class.java,
        tags = setOf("foo", "bar"),
        examples = setOf("make me happy"),
    ).withValue(30.0)
}

@AgentCapabilities
class TwoGoalsOnly {

    val thing1 = Goal.createInstance(
        description = "Thanks to Dr Seuss",
        type = PersonWithReverseTool::class.java,
    )
    val thing2 = Goal.createInstance(
        description = "Thanks again to Dr Seuss",
        type = PersonWithReverseTool::class.java,
    )
}

@AgentCapabilities
class ActionGoal {

    @Action
    @AchievesGoal(description = "Creating a person")
    fun toPerson(userInput: UserInput): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

}

interface InterfaceWithNoDeser {
    val content: String
}

@AgentCapabilities
class InvalidActionNoDeserializationInInterfaceGoal {

    @Action
    @AchievesGoal(description = "Creating a weird thing")
    fun createWeirdThing(userInput: UserInput): InterfaceWithNoDeser {
        TODO()
    }

}

@JsonDeserialize(`as` = MyInterfaceWithDeser::class)
interface InterfaceWithDeser {
    val content: String
}

data class MyInterfaceWithDeser(
    override val content: String,
) : InterfaceWithDeser

@AgentCapabilities
class ValidActionWithDeserializationInInterfaceGoal {

    @Action
    @AchievesGoal(description = "Creating a weird thing")
    fun createWeirdThing(userInput: UserInput): InterfaceWithDeser {
        TODO()
    }

}

@AgentCapabilities
class TwoActionGoals {

    @Action
    @AchievesGoal(description = "Creating a person")
    fun toPerson(userInput: UserInput): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

    @Action
    @AchievesGoal(description = "Creating a frog")
    fun toFrog(person: PersonWithReverseTool): Frog {
        return Frog(person.name)
    }

}

@AgentCapabilities
class TwoActuallyNonConflictingActionGoalsWithSameOutput {

    @Action
    @AchievesGoal(description = "Creating a person")
    fun toPerson(userInput: UserInput): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

    @Action
    @AchievesGoal(description = "Also to person")
    fun alsoToPerson(person: PersonWithReverseTool): PersonWithReverseTool {
        return person
    }

}

@AgentCapabilities
class TwoConflictingActionGoals {

    @Action
    @AchievesGoal(description = "Creating a person")
    fun toPerson(userInput: UserInput): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

    @Action
    @AchievesGoal(description = "Also to person")
    fun alsoToPerson(userInput: UserInput): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

}

@AgentCapabilities
class NoConditions {

    // A goal makes it legal
    val g = Goal.createInstance(
        name = "thing1",
        description = "Thanks to Dr Seuss",
        type = PersonWithReverseTool::class.java,
    ).withValue(30.0)

}

@AgentCapabilities
class OneOperationContextConditionOnly {

    @Condition(cost = .5)
    fun condition1(operationContext: OperationContext): Boolean {
        return true
    }

}

@AgentCapabilities
class ConditionFromBlackboard {

    @Condition
    fun condition1(person: PersonWithReverseTool): Boolean {
        return person.name == "Rod"
    }

}

@AgentCapabilities
class CustomNameConditionFromBlackboard {

    @Condition(name = "condition1")
    fun `this is a weird name no one will see`(person: PersonWithReverseTool): Boolean {
        return person.name == "Rod"
    }

}

@AgentCapabilities
class ConditionsFromBlackboard {

    @Condition
    fun condition1(
        person: PersonWithReverseTool,
        frog: Frog,
    ): Boolean {
        return person.name == "Rod"
    }

}

@AgentCapabilities
class OneTransformerActionOnly {

    @Action(cost = 500.0)
    fun toPerson(userInput: UserInput): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

}

@AgentCapabilities
class OneTransformerActionWithNullableParameter {

    @Action(cost = 500.0)
    fun toPerson(
        userInput: UserInput,
        person: SnakeMeal?,
    ): PersonWithReverseTool {
        var content = userInput.content
        if (person != null) {
            content += " and tasty!"
        }
        return PersonWithReverseTool(content)
    }

}

internal data class InternalInput(val content: String)
internal data class InternalOutput(val content: String)

@Agent(description = "Package visible domain classes")
class InternalDomainClasses {

    @Action(cost = 500.0)
    internal fun oo(internalInput: InternalInput): InternalOutput {
        return InternalOutput(internalInput.content)
    }

}

@AgentCapabilities
class OneTransformerActionTakingPayloadOnly {

    @Action(cost = 500.0)
    fun toPerson(
        userInput: UserInput,
        payload: TransformationActionContext<UserInput, PersonWithReverseTool>,
    ): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

}

@AgentCapabilities
class OneTransformerActionTakingOperationPayload {

    @Action(cost = 500.0)
    fun toPerson(
        userInput: UserInput,
        payload: ActionContext,
    ): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

}

@AgentCapabilities
class OneTransformerActionReferencingConditionByName {

    @Action(pre = ["condition1"])
    fun toPerson(userInput: UserInput): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

}

@AgentCapabilities
class OneTransformerActionWithCustomToolGroupOnly {

    @Action(cost = 500.0, toolGroups = ["magic"])
    fun toPerson(userInput: UserInput): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

}

@Agent(description = "thing")
class OneTransformerActionTakingInterfaceWithCustomToolGroupOnly {

    @AchievesGoal(description = "Creating a frog")
    @Action(cost = 500.0, toolGroups = ["magic"])
    fun toPerson(person: PersonWithReverseTool): Frog {
        return Frog(person.name)
    }

}

@Agent(description = "thing")
class OneTransformerActionTakingInterfaceWithExpectationCustomToolGroupOnly {

    @AchievesGoal(description = "Creating a frog")
    @Action(cost = 500.0, toolGroups = ["magic"])
    fun toPerson(
        person: PersonWithReverseTool,
        context: OperationContext,
    ): Frog {
        val pr = context.promptRunner()
        return Frog(person.name)
    }

}

@Agent(description = "thing")
class OneTransformerActionTakingInterfaceWithExpectationCustomToolGroupRequirementOnly {

    @AchievesGoal(description = "Creating a frog")
    @Action(cost = 500.0, toolGroups = ["frogs"], toolGroupRequirements = [ToolGroup("magic")])
    fun toPerson(
        person: PersonWithReverseTool,
        context: OperationContext,
    ): Frog {
        val pr = context.promptRunner()
        return Frog(person.name)
    }

}

data class Task(
    val what: String,
)

@Agent(
    name = "myAgentWithCustomName",
    provider = "magic",
    version = "1.1.1",
    description = "one transformer action only",
)
class AgentWithCustomName {

    @Action(cost = 500.0)
    fun toPerson(
        userInput: UserInput,
        task: Task,
    ): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

}


@Agent(
    description = "one transformer action only",
)
class AgentWithOneTransformerActionWith2ArgsOnly {

    @Action(cost = 500.0)
    fun toPerson(
        userInput: UserInput,
        task: Task,
    ): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

}

@AgentCapabilities
class OneTransformerActionWith2ArgsAndCustomInputBindings {

    @Action
    fun toPerson(
        @RequireNameMatch userInput: UserInput,
        @RequireNameMatch task: Task,
    ): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

}

@AgentCapabilities
class OneTransformerActionWith2ArgsAndCustomOutputBinding {

    @Action(outputBinding = "person")
    fun toPerson(
        userInput: UserInput,
        task: Task,
    ): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

}

@AgentCapabilities
class OnePromptActionOnly(
) {

    val
    // Java style usage
            llm = LlmOptions.withModel("magical").withTemperature(1.7)

    @Action(cost = 500.0)
    fun toPersonWithPrompt(
        userInput: UserInput,
        context: OperationContext,
    ): PersonWithReverseTool {
        return context.ai().withLlm(llm).createObject("Generated prompt for ${userInput.content}")
    }

}

@AgentCapabilities
class AwaitableOne(
) {

    @Action(cost = 500.0)
    fun waitForPersonConfirmation(userInput: UserInput): PersonWithReverseTool {
        return waitFor(
            ConfirmationRequest(
                payload = PersonWithReverseTool(userInput.content),
                message = "Is this dude the right person?",
            )
        )
    }

}

@AgentCapabilities
class Combined {

    val planner = Goal.createInstance(
        description = "Create a person",
        type = PersonWithReverseTool::class.java,
    ).withValue(30.0)

    // Can reuse this or inject
    val magicalLlm =
        LlmOptions.withModel("magical").withTemperature(1.7)


    @Condition(cost = .5)
    fun condition1(processContext: ProcessContext): Boolean {
        return true
    }

    @Action
    fun toPerson(userInput: UserInput): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

    @Action(cost = 500.0)
    fun toPersonWithPrompt(
        userInput: UserInput,
        context: OperationContext,
    ): PersonWithReverseTool {
        return context.ai().withLlm(
            magicalLlm
        ).createObject("Generated prompt for ${userInput.content}")
    }

    @Tool
    fun weatherService(location: String) =
        "The weather in $location is ${listOf("sunny", "raining", "foggy").random()}"


}

@AgentCapabilities
class OnePromptActionWithToolOnly(
) {

    @Action(cost = 500.0)
    fun toPersonWithPrompt(
        userInput: UserInput,
        context: OperationContext,
    ): PersonWithReverseTool {
        return context.ai().withDefaultLlm() createObject
                "Generated prompt for ${userInput.content}"
    }

    @Tool
    fun thing(): String {
        return "foobar"
    }

}

@AgentCapabilities
class FromPersonUsesDomainObjectTools {

    @Action
    fun fromPerson(
        person: PersonWithReverseTool,
        context: OperationContext,
    ): UserInput {
        return context.ai().withDefaultLlm().createObject("Create a UserInput")
    }
}

@AgentCapabilities
class FromPersonUsesDomainObjectToolsViaContext {

    @Action
    fun fromPerson(
        person: PersonWithReverseTool,
        context: ActionContext,
    ): UserInput {
        return context.promptRunner().createObject("Create a UserInput")
    }
}

@AgentCapabilities
class FromPersonUsesObjectToolsViaUsing {

    @Action
    fun fromPerson(
        person: PersonWithReverseTool,
        context: ActionContext,
    ): UserInput {
        return context.promptRunner(toolObjects = listOf(ToolObject(FunnyTool()))).createObject("Create a UserInput")
    }
}

@AgentCapabilities
class FromPersonUsesObjectToolsViaContext {

    @Action
    fun fromPerson(
        person: PersonWithReverseTool,
        context: ActionContext,
    ): UserInput {
        return context.promptRunner(toolObjects = listOf(ToolObject(FunnyTool()))).createObject("Create a UserInput")
    }
}

class FunnyTool {
    @Tool
    fun thing(): String {
        return "foobar"
    }
}

@AgentCapabilities
class OneTransformerActionWith2Tools {

    @Action
    fun toPerson(
        @RequireNameMatch userInput: UserInput,
        @RequireNameMatch task: Task,
    ): PersonWithReverseTool {
        return PersonWithReverseTool(userInput.content)
    }

    @Tool
    fun toolWithoutArg(): String = "foo"

    @Tool
    fun toolWithArg(location: String) = "bar"

}

@AgentCapabilities
class ToolMethodsOnDomainObject {

    @Action
    fun toPerson(
        wumpty: Wumpus,
    ): PersonWithReverseTool {
        return PersonWithReverseTool(wumpty.name)
    }

    @Action
    fun toFrog(
        noTools: NoTools,
    ): Frog {
        return Frog("Kermit")
    }

}

class Wumpus(val name: String) {

    @Tool
    fun toolWithoutArg(): String = "The wumpus's name is $name"

    @Tool
    fun toolWithArg(location: String) = location
}

@AgentCapabilities
class ToolMethodsOnDomainObjects {

    @Action
    fun toFrog(
        wumpty: Wumpus,
        person: PersonWithReverseTool,
    ): Frog {
        return Frog(wumpty.name)
    }

}

data class NoTools(val x: Int)


@Agent(description = "define flow")
class DefineFlowTest {

    @Action
    fun toFrog(
        userInput: UserInput,
        context: TransformationActionContext<UserInput, PersonWithReverseTool>,
    ): Frog {
        return chain<UserInput, PersonWithReverseTool, Frog>(
            { PersonWithReverseTool(it.input.content) },
            { Frog(it.input.name) },
        ).asSubProcess(context)
    }

    @AchievesGoal(description = "Creating a person")
    @Action
    fun done(frog: Frog): PersonWithReverseTool {
        return PersonWithReverseTool(frog.name)
    }
}

@Agent(description = "local agent")
class LocalAgentTest {

    @Action
    fun toDeadPerson(
        userInput: UserInput,
        context: TransformationActionContext<UserInput, SnakeMeal>,
    ): SnakeMeal {
        return runAgent<UserInput, SnakeMeal>(evenMoreEvilWizard(), context)
    }

    @AchievesGoal(description = "Eating a person")
    @Action
    fun done(person: SnakeMeal): SnakeMeal {
        return person
    }
}

data class FrogOrDog(
    val frog: Frog? = null,
    val dog: Dog? = null,
) : SomeOf

@Agent(description = "thing")
class UsesFrogOrDogSomeOf {

    @Action
    fun frogOrDog(): FrogOrDog {
        return FrogOrDog(frog = Frog("Kermit"))
    }

    @AchievesGoal(description = "Creating a prince from a frog")
    @Action
    fun toPerson(frog: Frog): PersonWithReverseTool {
        return PersonWithReverseTool(frog.name)
    }

}



================================================
FILE: embabel-agent-ux/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.embabel.agent</groupId>
        <artifactId>embabel-agent-parent</artifactId>
        <version>0.2.0-SNAPSHOT</version>
    </parent>
    <artifactId>embabel-agent-ux</artifactId>
    <packaging>jar</packaging>
    <name>Embabel Agent UI UX</name>
    <description>Embabel Agent Web Components</description>

    <dependencies>
        <!-- Main Dependencies -->
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-api</artifactId>
        </dependency>
        <!-- Test Dependencies -->
        <dependency>
            <groupId>com.embabel.agent</groupId>
            <artifactId>embabel-agent-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.jetbrains.kotlin</groupId>
                <artifactId>kotlin-maven-plugin</artifactId>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
            </plugin>

        </plugins>
    </build>

</project>


================================================
FILE: embabel-agent-ux/src/main/kotlin/com/embabel/agent/discord/.gitkeep
================================================
ECHO is on.



================================================
FILE: embabel-agent-ux/src/main/resources/.gitkeep
================================================
ECHO is on.



================================================
FILE: embabel-agent-ux/src/test/kotlin/com/embabel/agent/discord/.gitkeep
================================================
ECHO is on.



================================================
FILE: embabel-agent-ux/src/test/resources/.gitkeep
================================================
ECHO is on.



================================================
FILE: .github/dco.yml
================================================
require:
  members: false


================================================
FILE: .github/scripts/dependabot-group-alerts.sh
================================================
#!/usr/bin/env bash
set -euo pipefail

: "${GITHUB_REPOSITORY:?GITHUB_REPOSITORY is not set}"

# Fetch alerts using GitHub CLI
gh api repos/"$GITHUB_REPOSITORY"/dependabot/alerts?state=open \
  --paginate \
  --jq '.' > alerts.json

# Group and format security alerts
cat alerts.json | jq -s '
  add
  | group_by([.dependency.package.name, .security_advisory.ghsa_id])
  | .[]
  | {
      key: "\(. | .[0].dependency.package.name) — \(. | .[0].security_advisory.ghsa_id)",
      paths: ([.[] | .dependency.manifest_path] | unique | sort),
      alerts: (
        [.[] | {
          severity: (.security_advisory.severity | ascii_downcase),
          summary: .security_advisory.summary,
          recommendation: (
            if (.security_advisory.recommendation != null and .security_advisory.recommendation != "") then
              .security_advisory.recommendation
            else
              "Upgrade \(.dependency.package.name) to a safe version (see advisory below)"
            end
          ),
          advisory_url: "https://github.com/advisories/\(.security_advisory.ghsa_id)"
        }]
        | unique
        | sort_by(
            .severity
            | if . == "critical" then 4
              elif . == "high" then 3
              elif . == "moderate" then 2
              elif . == "low" then 1
              else 0 end
          )
        | reverse
      )
    }
' | jq -r '
  . as $group |
  "\n🔐 \($group.key) (\($group.alerts | length) unique alerts)",
  "  Affected modules:",
  ($group.paths[] | "    - \(. )"),
  ($group.alerts[] |
    "  - Severity: \(.severity) | \(.summary)",
    "    ↪ Recommendation: \(.recommendation)",
    "    ↪ Advisory URL: \(.advisory_url)"
  )
'



================================================
FILE: .github/workflows/dependabot-insights.yml
================================================
name: Dependabot Insights

on:
  workflow_dispatch:  # Manual trigger only

permissions:
  contents: read
  security-events: read  # Required to access Dependabot alerts     

jobs:
  generate-insights:
    name: Generate Dependabot Insights
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4  # ✅ Official action, safe to use

      - name: Install GitHub CLI
        run: |
          sudo apt update
          sudo apt install -y gh
      
      - name: Run alert grouping script
        env:
          GH_TOKEN: ${{ secrets.DEPENDABOT_SECRET }}
        run: |
          bash .github/scripts/dependabot-group-alerts.sh




================================================
FILE: .github/workflows/deploy-docs.yml
================================================
# This workflow will build a Ascii Doctor project with Maven, 
# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

name: Publish Docs

on:
  workflow_dispatch:  # Enables manual triggering
    inputs:
      environment:
        description: 'Deploy Environment'
        required: true
        default: 'embabel-dev'
        type: choice
        options:
          - embabel-dev
          - embabel-sit
          - embabel-prod
      vm_instance:
        description: 'VM Instance Name'
        required: true
        default: 'embabel-webserver'
        type: string
      vm_zone:
        description: 'VM Zone'
        required: true
        default: 'us-east1-b'
        type: string
  
  # Automatic trigger on file changes
  push:
    branches:
      - main
    paths:
      - 'embabel-agent/embabel-agent-docs/**'
  
  # Also trigger on pull requests to docs
  pull_request:
    branches:
      - main
    paths:
      - 'embabel-agent/embabel-agent-docs/**'
  
env:
  PROJECT_ID: ${{ github.event.inputs.environment || 'embabel-dev' }}
  SERVICE_ACCOUNT: embabel-ci-build@embabel-dev.iam.gserviceaccount.com
  VM_INSTANCE: ${{ github.event.inputs.vm_instance || 'embabel-webserver' }}
  VM_ZONE: ${{ github.event.inputs.vm_zone || 'us-east1-b' }}

jobs:
  build:

    runs-on: ubuntu-latest

    # Set default working directory for all steps
    defaults:
      run:
        working-directory: ./embabel-agent-docs

    steps:
      - uses: actions/checkout@v4
      - name: Install Graphviz
        run: |
          sudo apt-get update
          sudo apt-get install -y graphviz
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: maven  
      - name: Build and analyze
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Needed to get PR information, if any
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: mvn package

      - name: Extract version from pom.xml
        id: get_version
        run: |
          VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "Extracted version: $VERSION"

      - name: Create deployment archive
        run: |
          echo "Creating deployment archive at $(date)"
          # Clean up any stale archive from previous runs
          rm -f docs-bundle.tar.gz
          cd target
          tar -czf ../docs-bundle.tar.gz generated-docs dokka-aggregate
          echo "Archive created at $(date), size: $(ls -lh ../docs-bundle.tar.gz | awk '{print $5}')"

      - name: Google Auth
        id: auth
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{secrets.GCP_SERVICE_ACCOUNT_CREDENTIALS}}
          service_account: embabel-ci-build@embabel-dev.iam.gserviceaccount.com
      
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Deploy archive to VM
        run: |
          echo "Starting deployment at $(date)"
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          echo "Deploying version: $VERSION"
          
          # Upload the single archive file
          gcloud compute scp docs-bundle.tar.gz \
            ${{ github.event.inputs.vm_instance || 'embabel-webserver' }}:~/ \
            --zone=${{ github.event.inputs.vm_zone || 'us-east1-b' }}
          
          echo "Archive uploaded at $(date)"
          
          # Extract and move files on the VM with versioned directories
          gcloud compute ssh ${{ github.event.inputs.vm_instance || 'embabel-webserver' }} \
            --zone=${{ github.event.inputs.vm_zone || 'us-east1-b' }} \
            --command="
              echo 'Starting extraction and deployment on VM at \$(date)' &&
              VERSION='$VERSION' &&
              echo 'Deploying version: $VERSION' &&
              sudo rm -rf /var/www/html/embabel-agent/guide/\$VERSION &&
              sudo rm -rf /var/www/html/embabel-agent/api-docs/\$VERSION &&
              sudo mkdir -p /var/www/html/embabel-agent/guide/\$VERSION &&
              sudo mkdir -p /var/www/html/embabel-agent/api-docs/\$VERSION &&
              cd /tmp &&
              sudo tar -xzf ~/docs-bundle.tar.gz &&
              sudo cp -r generated-docs/* /var/www/html/embabel-agent/guide/\$VERSION/ &&
              sudo cp -r dokka-aggregate/* /var/www/html/embabel-agent/api-docs/\$VERSION/ &&
              rm -f ~/docs-bundle.tar.gz &&
              sudo rm -rf /tmp/generated-docs /tmp/dokka-aggregate &&
              echo 'Deployment completed on VM at \$(date)'
            "
          
          echo "Deployment completed at $(date)"
          
          # Clean up local bundle
          rm -f docs-bundle.tar.gz

      - name: Verify deployment
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          gcloud compute ssh ${{ github.event.inputs.vm_instance || 'embabel-webserver' }} \
            --zone=${{ github.event.inputs.vm_zone || 'us-east1-b' }} \
            --command="
              echo 'Deployed version: $VERSION' &&
              echo 'Files in versioned guide directory:' &&
              sudo ls -la /var/www/html/embabel-agent/guide/$VERSION/ | head -10 &&
              echo 'Files in versioned api-docs directory:' &&
              sudo ls -la /var/www/html/embabel-agent/api-docs/$VERSION/ | head -10 &&
              echo 'Testing web access:' &&
              curl -I http://localhost/embabel-agent/guide/$VERSION/index.html || echo 'Versioned guide not responding'
            "



================================================
FILE: .github/workflows/deploy-snapshots.yml
================================================
# This workflow will build a Java / Kotlin project with Maven

name: Deploy Snapshots

on:
  workflow_dispatch:  # Enables manual triggering

jobs:
  build-and-deploy:

    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: maven
      - name: Configure Maven Settings
        uses: s4u/maven-settings-action@v2.8.0
        with:
          servers: ${{secrets.EMBABEL_ARTIFACTORY}}
      - name: Build and analyze
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} 
        
        run: mvn -U -DskipTests=true clean deploy



================================================
FILE: .github/workflows/maven.yml
================================================
# This workflow will build a Java / Kotlin project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-java-with-maven
# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.
name: Build
on:
  push:
  pull_request:
    types: [ opened, synchronize, reopened ]

jobs:
  build:
    runs-on: ${{ matrix.os }}
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository)
    
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
    
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: maven
      - name: Configure Testcontainers (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          echo "testcontainers.reuse.enable=true" > $env:USERPROFILE\.testcontainers.properties
      - name: Build and test
        env:
          SKIP_TESTCONTAINER_TESTS: true  # Do not run TestContainer Tests in Windows Matrix Build.
        run: mvn -U -B test verify
      - name: Linux-specific setup and SonarCloud analysis
        if: matrix.os == 'ubuntu-latest'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Needed to get PR information, if any
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          # Configure Testcontainers for Linux
          mkdir -p /home/runner
          echo "testcontainers.reuse.enable=true" > /home/runner/.testcontainers.properties
          
          # Run SonarCloud analysis
          mvn -P jacoco-code-coverage -B verify org.sonarsource.scanner.maven:sonar-maven-plugin:sonar -Dsonar.projectKey=embabel_embabel-agent
  
  build-fork: #for public forks
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name != github.repository
    
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: maven
      - name: Build and test
        run: |
          # Configure Testcontainers for Linux
          mkdir -p /home/runner
          echo "testcontainers.reuse.enable=true" > /home/runner/.testcontainers.properties
          # Build without Sonar Cloud
          mvn -U -B test verify


